//!FDSChartJS 10.23.0-edge.0
var FDSChartJS = (function (_$1,$$1) {
    'use strict';
    
    $$1 = 'default' in $$1 ? $$1['default'] : $$1;
    
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    
    
    
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    
    var isChartObject = function (obj) {
        if (!obj) {
            return false;
        }
        return (typeof obj.getObjectTypeName === 'function');
    };
    var isRootChart = function (obj) {
        if (!obj) {
            return false;
        }
        return obj.getObjectTypeName() === 'FDSChart';
    };
    var isPlot = function (obj) {
        if (!obj) {
            return false;
        }
        return obj.getObjectTypeName() === 'FDSPlot';
    };
    var isSeries = function (obj) {
        if (!obj) {
            return false;
        }
        return obj.getObjectTypeName() === 'FDSSeries';
    };
    var isDataSet = function (obj) {
        if (!obj) {
            return false;
        }
        return obj.getObjectTypeName() === 'FDSData';
    };
    var isAxis = function (obj) {
        if (!obj) {
            return false;
        }
        return obj.getObjectTypeName() === 'FDSAxis';
    };
    var isLegend = function (obj) {
        if (!obj) {
            return false;
        }
        return obj.getObjectTypeName() === 'FDSLegend';
    };
    
    /* tslint:disable:no-var-keyword */
    // 'const' at the global scope apparently sneaks its way into our output which then breaks things in IE10
    var DateTimeBinArray = [
        'NONE',
        'SECOND',
        'TWOSECOND',
        'FIVESECOND',
        'TENSECOND',
        'HALFMINUTE',
        'MINUTE',
        'TWOMINUTE',
        'FIVEMINUTE',
        'TENMINUTE',
        'HALFHOUR',
        'HOUR',
        'TWOHOUR',
        'SIXHOUR',
        'DAY',
        'WEEK',
        'MONTH',
        'QUARTER',
        'HALFY',
        'YEAR',
        'TWOY',
        'FIVEY',
        'TENY'
    ];
    var DrawStyleExported = {
        NONE: -1 /* NONE */,
        LINE: 0 /* LINE */,
        HLC: 2 /* HLC */,
        MARKER: 3 /* MARKER */,
        RANGEBAR: 4 /* RANGEBAR */,
        COLUMNS3D: 5 /* COLUMNS3D */,
        COLUMNS: 6 /* COLUMNS */,
        THIN: 7 /* THIN */,
        AREA: 9 /* AREA */,
        BARS3D: 11 /* BARS3D */,
        BARS: 12 /* BARS */,
        THINBARS: 13 /* THINBARS */,
        STEP: 14 /* STEP */,
        VERTICAL: 16 /* VERTICAL */,
        HORIZONTAL: 17 /* HORIZONTAL */,
        AREASTEP: 18 /* AREASTEP */,
        PIE: 19 /* PIE */,
        CSPLINE: 20 /* CSPLINE */,
        REGRESSION: 21 /* REGRESSION */,
        OHLC: 22 /* OHLC */,
        CANDLE: 23 /* CANDLE */,
        RECT: 27 /* RECT */,
        VERTRECT: 28 /* VERTRECT */,
        HORZRECT: 29 /* HORZRECT */,
        BUBBLE: 31 /* BUBBLE */,
        LINES: 32 /* LINES */,
        PTSLOPE: 33 /* PTSLOPE */,
        PIE3D: 36 /* PIE3D */,
        HLCROSS: 37 /* HLCROSS */,
        TREEMAP: 38 /* TREEMAP */,
        POINTFIGURE: 40 /* POINTFIGURE */,
        KMLMAP: 41 /* KMLMAP */,
        FIBRETRACEMENTS: 42 /* FIBRETRACEMENTS */,
        FIBARC: 43 /* FIBARC */,
        FIBFAN: 44 /* FIBFAN */,
        FIBTIMEZONES: 45 /* FIBTIMEZONES */,
        GANNFAN: 46 /* GANNFAN */,
        QUADRANTLINES: 47 /* QUADRANTLINES */,
        RAFFREGRESSION: 48 /* RAFFREGRESSION */,
        TIRONELEVELS: 49 /* TIRONELEVELS */,
        SPEED_RESISTANCE_LEVELS: 50 /* SPEED_RESISTANCE_LEVELS */,
        ZIGZAG: 51 /* ZIGZAG */,
        TRENDLINE: 53 /* TRENDLINE */,
        PRICE_CHANGE: 54 /* PRICE_CHANGE */,
        ELLIPSE: 55 /* ELLIPSE */,
        ARROW: 56 /* ARROW */,
        FIBPROJECTION: 57 /* FIBPROJECTION */,
        RELATIVE_AREA: 58 /* RELATIVE_AREA */,
        DRAGGABLE_MARKER: 59 /* DRAGGABLE_MARKER */,
        SURFACE: 60 /* SURFACE */,
        RANGECANDLE: 61 /* RANGECANDLE */,
        HISTOGRAM: 62 /* HISTOGRAM */,
        HISTOGRAM_AS_COLUMNS: 64 /* HISTOGRAM_AS_COLUMNS */,
    };
    var ObjectTypeExported = {
        FC_NULL: -1 /* FC_NULL */,
        FC_DATA: 1 /* FC_DATA */,
        FC_SERIES: 2 /* FC_SERIES */,
        FC_PLOT: 4 /* FC_PLOT */,
        FC_SCALE: 5 /* FC_SCALE */,
        FC_TEXT: 6 /* FC_TEXT */,
        FC_ROOT: 7 /* FC_ROOT */,
        FC_LEGEND: 8 /* FC_LEGEND */,
        FC_ANNOTATION: 9 /* FC_ANNOTATION */,
        FC_DATA_STYLE: 10 /* FC_DATA_STYLE */,
        FC_SERIES_STYLE: 11 /* FC_SERIES_STYLE */,
        FC_PLOT_STYLE: 13 /* FC_PLOT_STYLE */,
        FC_HEADING: 14 /* FC_HEADING */,
        FC_AXIS: 15 /* FC_AXIS */,
        FC_AXIS_STYLE: 16 /* FC_AXIS_STYLE */,
        FC_ROOT_STYLE: 17 /* FC_CHART_STYLE */,
    };
    var AddFlagsExported = {
        NO_FLAGS: 0 /* NO_FLAGS */,
        INT_DATA: 1 /* INT_DATA */,
        FLOAT_DATA: 2 /* FLOAT_DATA */,
        DATE_DATA: 3 /* DATE_DATA */,
        STRING_DATA: 4 /* STRING_DATA */,
        SINGLE_DATA: 5 /* SINGLE_DATA */,
        BYTE_DATA: 6 /* BYTE_DATA */,
        TIME_DATA: 7 /* TIME_DATA */,
        DATETIME_DATA: 8 /* DATETIME_DATA */,
        KML_DATA: 9 /* KML_DATA */,
    };
    var SetFlagsExported = {
        NONE: 0 /* NONE */,
        APP: 1 /* APP */,
        RESET: 2 /* RESET */,
        BATCH: 3 /* BATCH */,
        APPBATCH: 4 /* APPBATCH */,
        PROPERTY: 8 /* PROPERTY */,
        PROP_BATCH: 9 /* PROP_BATCH */,
        REMOVE_PROP: 10 /* REMOVE_PROP */,
        CLEAR_PROPERTIES: 11 /* CLEAR_PROPERTIES */,
    };
    var GetFlagsExported = {
        NONE: 0 /* NONE */,
        DEFAULT: 1 /* DEFAULT */,
        IF_DEFAULT: 2 /* IF_DEFAULT */,
        PROPERTY: 5 /* PROPERTY */,
    };
    var DeleteFlagsExported = {
        NONE: 0 /* NONE */,
        DELETE_WITH_CHILD: 1 /* DELETE_WITH_CHILD */,
    };
    var DrawingToolExported = {
        NONE: 0 /* NONE */,
        TRENDLINE: 1 /* TRENDLINE */,
        FIBARC: 2 /* FIBARC */,
        FIBFAN: 3 /* FIBFAN */,
        FIBRETRACEMENTS: 4 /* FIBRETRACEMENTS */,
        FIBTIMEZONES: 5 /* FIBTIMEZONES */,
        GANNFAN: 6 /* GANNFAN */,
        PRICECHANGE: 7 /* PRICECHANGE */,
        HORIZONTAL: 8 /* HORIZONTAL */,
        VERTICAL: 9 /* VERTICAL */,
        CIRCLE: 10 /* CIRCLE */,
        RECT: 11 /* RECT */,
        ARROW: 12 /* ARROW */,
        TEXTBOX: 13 /* TEXTBOX */,
        LINEARREGRESSION: 14 /* LINEARREGRESSION */,
        AVERAGE: 15 /* AVERAGE */,
        MEDIAN: 16 /* MEDIAN */,
        AVGSTDDEV: 17 /* AVGSTDDEV */,
        QUADRANTLINES: 18 /* QUADRANTLINES */,
        TIRONELEVELS: 19 /* TIRONELEVELS */,
        SERIESTEXTBOX: 20 /* SERIESTEXTBOX */,
        ZIGZAG: 21 /* ZIGZAG */,
        RAFFREGRESSION: 22 /* RAFFREGRESSION */,
        SPEEDRESISTANCE: 23 /* SPEEDRESISTANCE */,
        FIBPROJECTION: 24 /* FIBPROJECTION */,
        MARKER: 25 /* MARKER */,
        HARMONICMEAN: 26 /* HARMONICMEAN */,
    };
    
    var isHeadlessMode = (typeof (window) === 'undefined');
    function getDevicePixelRatio() {
        return (typeof devicePixelRatio !== 'undefined') ? devicePixelRatio : 1;
    }
    var scaleByDevicePixelRatio = typeof devicePixelRatio !== 'undefined' ?
        function (value) { return value * devicePixelRatio; } :
        function (value) { return value; };
    var scaleByDevicePixelRatioAndRound = typeof devicePixelRatio !== 'undefined' ?
        function (value) { return Math.round(value * devicePixelRatio); } :
        function (value) { return Math.round(value); };
    var scaleByDevicePixelRatioInverse = typeof devicePixelRatio !== 'undefined' ?
        function (value) { return value / devicePixelRatio; } :
        function (value) { return value; };
    // mostly used in Intraday Scale
    // the PC side keeps this on the axis but I think it makes more sense to keep it here
    var NumberOfDateBins = 23;
    var isFullPlotDrawStyle = function (ds) {
        var knownFullPlotDrawStyles = [
            19 /* PIE */,
            36 /* PIE3D */,
            38 /* TREEMAP */,
            41 /* KMLMAP */
        ];
        return _$1.includes(knownFullPlotDrawStyles, ds);
    };
    var bgDrawstyles = [
        3 /* MARKER */,
        4 /* RANGEBAR */,
        5 /* COLUMNS3D */,
        6 /* COLUMNS */,
        9 /* AREA */,
        11 /* BARS3D */,
        12 /* BARS */,
        18 /* AREASTEP */,
        19 /* PIE */,
        20 /* CSPLINE */,
        23 /* CANDLE */,
        27 /* RECT */,
        28 /* VERTRECT */,
        29 /* HORZRECT */,
        31 /* BUBBLE */,
        36 /* PIE3D */,
        38 /* TREEMAP */,
        41 /* KMLMAP */,
        55 /* ELLIPSE */,
        56 /* ARROW */,
        58 /* RELATIVE_AREA */,
        59 /* DRAGGABLE_MARKER */,
        60 /* SURFACE */,
        61 /* RANGECANDLE */
    ];
    function RMIBelongsToSMG(markerId, groupId) {
        return !(markerId % groupId);
    }
    var hitShapeNameToType = (function () {
        var m = {};
        m[0 /* NONE */] = -1 /* NONE */;
        m[1 /* DATAPOINTNS */] = 11 /* DATAPOINT_NS */;
        m[2 /* DATAPOINTWE */] = 12 /* DATAPOINT_WE */;
        m[3 /* DATAPOINT */] = 13 /* DATAPOINT */;
        m[4 /* DATAPOINTALTX */] = 17 /* DATAPOINT_ALTX */;
        m[5 /* SERIESHIT */] = 0 /* SERIES */;
        m[6 /* DATAPOINTLEFT */] = 14 /* DATAPOINT_LEFT */;
        m[7 /* DATAPOINTRIGHT */] = 15 /* DATAPOINT_RIGHT */;
        m[8 /* SERIESHITLEFTRIGHT */] = 16 /* SERIES_LEFT_RIGHT */;
        m[9 /* DATAPOINTN */] = 3 /* N */;
        m[10 /* DATAPOINTS */] = 4 /* S */;
        m[11 /* DATAPOINTE */] = 6 /* E */;
        m[12 /* DATAPOINTW */] = 5 /* W */;
        m[13 /* DATAPOINTNE */] = 9 /* NE */;
        m[14 /* DATAPOINTNW */] = 7 /* NW */;
        m[15 /* DATAPOINTSE */] = 10 /* SE */;
        m[16 /* DATAPOINTSW */] = 8 /* SW */;
        return function (name) { return m[name]; };
    })();
    var DrawingToolsLevels = (function () {
        var obj = {};
        obj[42 /* FIBRETRACEMENTS */] = [0.0, 0.236, 0.382, 0.5, 0.618, 0.764, 1.0, 1.618, 2.618, 4.236];
        obj[43 /* FIBARC */] = [0.236, 0.382, 0.5, 0.618, 0.764, 1.0, 1.618, 2.618, 4.236];
        obj[44 /* FIBFAN */] = [0.236, 0.382, 0.5, 0.618, 0.764, 1.0, 1.618, 2.618, 4.236];
        obj[46 /* GANNFAN */] = [-37.5, -30.0, -26.25, -18.75, 0.0, 18.75, 26.25, 30.0, 37.5];
        obj[47 /* QUADRANTLINES */] = [0.0, 0.25, 0.5, 0.75, 1.0];
        obj[49 /* TIRONELEVELS */] = [0.333, 0.5, 0.666];
        obj[50 /* SPEED_RESISTANCE_LEVELS */] = [0.333, 0.666];
        obj[57 /* FIBPROJECTION */] = [0.0, 0.236, 0.382, 0.5, 0.618, 0.764, 1.0, 1.618, 2.618, 4.236];
        return obj;
    })();
    // Cursor object used to reference different custom cursors in engine
    var Cursor = {
        TRENDLINE: 'crosshair',
        CROSSHAIRS: 'crosshair',
        FIBARC: 'DRAW_FIB_ARC',
        FIBFAN: 'DRAW_FIB_FAN',
        FIBRETRACEMENTS: 'DRAW_FIB_RETRACEMENTS',
        FIBTIMEZONES: 'DRAW_FIB_TIME',
        GANNFAN: 'DRAW_GANN_FAN',
        PRICECHANGE: 'DRAW_PRICE_CHANGE_TOOL',
        HORIZONTAL: 'DRAW_HORIZONTAL',
        VERTICAL: 'DRAW_VERTICAL',
        CIRCLE: 'DRAW_CIRCLE',
        RECT: 'DRAW_RECTANGLE',
        ARROW: 'DRAW_ARROW',
        TEXTBOX: 'DRAW_TEXTBOX',
        LINEARREGRESSION: 'DRAW_REGRESSION',
        AVERAGE: 'DRAW_AVG',
        MEDIAN: 'DRAW_MEDIAN',
        AVGSTDDEV: 'DRAW_AVG_STD_DEV',
        QUADRANTLINES: 'DRAW_QUADRANT_LINES',
        TIRONELEVELS: 'DRAW_TIRONE_LEVELS',
        SERIESTEXTBOX: 'DRAW_TEXTBOX',
        SIZENESW: 'nesw-resize',
        SIZENWSE: 'nwse-resize',
        SIZEWE: 'ew-resize',
        SIZENS: 'ns-resize',
        SIZEALL: 'move',
        DEFAULT: 'default',
        HAND: 'pointer',
        NOT_ALLOWED: 'not-allowed',
        ZOOM: 'ZOOM',
        SPEEDRESISTANCE: 'crosshair',
        FIBPROJECTION: 'crosshair',
        ZIGZAG: 'crosshair',
        RAFFREGRESSION: 'crosshair',
        MARKER: 'crosshair',
        HARMONICMEAN: 'DRAW_AVG',
    };
    var SystemCursors = [
        'alias',
        'all-scroll',
        'auto',
        'cell',
        'context-menu',
        'col-resize',
        'copy',
        'crosshair',
        'default',
        'e-resize',
        'ew-resize',
        'help',
        'move',
        'n-resize',
        'ne-resize',
        'nesw-resize',
        'ns-resize',
        'nw-resize',
        'nwse-resize',
        'no-drop',
        'none',
        'not-allowed',
        'pointer',
        'progress',
        'row-resize',
        's-resize',
        'se-resize',
        'sw-resize',
        'text',
        'vertical-text',
        'w-resize',
        'wait',
        'zoom-in',
        'zoom-out',
        'initial'
    ];
    // Map of Cursor object names to customImages cursor names
    var CursorImageNameMap = {
        DRAW_FIB_ARC: 'FIBONACCIARC',
        DRAW_FIB_FAN: 'FIBONACCIFAN',
        DRAW_FIB_RETRACEMENTS: 'FIBONACCIRETRACEMENTS',
        DRAW_FIB_TIME: 'FIBONACCITIME',
        DRAW_GANN_FAN: 'GANNFAN',
        DRAW_PRICE_CHANGE_TOOL: 'PRICECHANGE',
        DRAW_HORIZONTAL: 'HORIZONTAL',
        DRAW_VERTICAL: 'VERTICAL',
        DRAW_CIRCLE: 'CIRCLE',
        DRAW_RECTANGLE: 'RECTANGLE',
        DRAW_ARROW: 'ARROW',
        DRAW_TEXTBOX: 'TEXTBOX',
        DRAW_REGRESSION: 'REGRESSION',
        DRAW_AVG: 'AVERAGE',
        DRAW_MEDIAN: 'MEDIAN',
        DRAW_AVG_STD_DEV: 'AVERAGESTANDARDDEV',
        DRAW_QUADRANT_LINES: 'QUADRANT',
        DRAW_TIRONE_LEVELS: 'TIRONE'
    };
    var PHI = 1.61803398874989;
    var DRAWINGTOOL_HITSHAPE_LINE = 15;
    var DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER = 12;
    // defaults used by chart and axes
    var IntradayScaleRanges = [
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        1,
        14,
        120,
        425,
        Number.MAX_VALUE,
        17 * (365.25 / 4),
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        31 * 365.25 // TENY ( >= 31 years)
    ];
    var IntradayScaleMinorRanges = [
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        (1 / 24),
        (1 / 24) * 3,
        1,
        Number.MAX_VALUE,
        3,
        14,
        120,
        425,
        17 * (365.25 / 4),
        Number.MAX_VALUE,
        31 * 365.25,
        Number.MAX_VALUE,
        Number.MAX_VALUE,
        Number.MAX_VALUE // TENY
    ];
    var SERIES_COLOR_COUNT = 16;
    var CLICK_TIMEOUT_MS = 300;
    function GetDefaultMenuString(allowCopyAsObject, isSimpleZoomEnabled) {
        var defaultMenuString = '';
        if (isSimpleZoomEnabled) {
            defaultMenuString = defaultMenuString.concat('SYS_ZOOMBOX:Zoom...\nSYS_UNZOOM:Reset Zoom\n');
        }
        if (allowCopyAsObject) {
            defaultMenuString = defaultMenuString.concat('MENU:Copy as\nSYS_CLIPOBJECT:ActiveGraph Object\nENDMENU\n');
        }
        defaultMenuString = defaultMenuString.concat('MENU:Help\nSYS_ABOUT:About...\nENDMENU');
        return defaultMenuString;
    }
    function HEXtoRGB(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (result) {
            return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
        }
        else {
            console.warn("Invalid hex color: '" + hex + "'");
            return [0, 0, 0];
        }
    }
    function RGBtoCOLORREF(r, g, b) {
        return (b << 16) + (g << 8) + r;
    }
    /**
     * Converts a colorref + alpha pair into a css color string.
     *
     * @export
     * @param {number} colorref - BGR colorref integer
     * @param {number} alpha - alpha value in the range [0 - 255]
     * @returns
     */
    function COLORREFtoCSSColor(colorref, alpha) {
        var _a = COLORREFtoRGB(colorref), r = _a[0], g = _a[1], b = _a[2];
        if (alpha >= 255) {
            return "rgb(" + r + "," + g + "," + b + ")";
        }
        else {
            var opacity = Math.max(0, ~~alpha / 255);
            return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
        }
    }
    // Takes a win32 COLORREF and converts it to an HTML/CSS color string.
    function COLORREFtoHex(colorref) {
        return '#' + COLORREFtoRGB(colorref).map(toPaddedHex).join('');
        function toPaddedHex(c) {
            return (c < 16 ? '0' : '') + c.toString(16);
        }
    }
    function HEXtoCOLORREF(hex) {
        return RGBtoCOLORREF.apply(null, HEXtoRGB(hex));
    }
    // Takes a win32 COLORREF and converts it to a [r, g, b] tuple.
    function COLORREFtoRGB(colorref) {
        var r = colorref & 0x000000FF;
        var g = colorref >> 8 & 0x000000FF;
        var b = colorref >> 16 & 0x000000FF;
        return [r, g, b];
    }
    // some helpers
    function COLORREFtoHSL(colorref) {
        var _a = COLORREFtoRGB(colorref), r = _a[0], g = _a[1], b = _a[2];
        return RGBtoHSL(r / 255, g / 255, b / 255);
    }
    function HSLtoCOLORREF(h, s, l) {
        var _a = HSLtoRGB(h, s, l), r = _a[0], g = _a[1], b = _a[2];
        return RGBtoCOLORREF(r * 255, g * 255, b * 255);
    }
    // takes in RGB between 0 and 1, returns HSL between 0 and 1
    function RGBtoHSL(r, g, b) {
        var bMax = Math.max(r, g, b);
        var bMin = Math.min(r, g, b);
        // Luminosity calculation
        var s;
        var l = (bMax + bMin) / 2;
        if (bMax === bMin) {
            return [0, 0, l]; // achromatic
        }
        var d = bMax - bMin;
        if (l <= 0.5) {
            s = d / (bMax + bMin);
        }
        else {
            s = d / (2 - bMax - bMin);
        }
        var dR = (((bMax - r) / 6) + (d / 2)) / d;
        var dG = (((bMax - g) / 6) + (d / 2)) / d;
        var dB = (((bMax - b) / 6) + (d / 2)) / d;
        var h = 0;
        if (r === bMax) {
            h = dB - dG;
        }
        else if (g === bMax) {
            h = (1 / 3) + dR - dB;
        }
        else if (b === bMax) {
            h = (2 / 3) + dG - dR;
        }
        if (h < 0) {
            h = h + 1;
        }
        if (h > 1) {
            h = h - 1;
        }
        return [h, s, l];
    }
    // returns RGB color code for HSL color value
    function HSLtoRGB(h, s, l) {
        if (s === 0) {
            return [l, l, l];
        }
        var var_2 = (l < 0.5) ? (l * (1 + s)) : (l + s - s * l);
        var var_1 = 2 * l - var_2;
        var r = HueRGB(var_1, var_2, h + (1 / 3));
        var g = HueRGB(var_1, var_2, h);
        var b = HueRGB(var_1, var_2, h - (1 / 3));
        return [r, g, b];
    }
    // converts hue to RGB
    function HueRGB(v1, v2, vh) {
        if (vh < 0) {
            vh += 1;
        }
        if (vh > 1) {
            vh -= 1;
        }
        if ((6 * vh) < 1) {
            return (v1 + (v2 - v1) * 6 * vh);
        }
        if ((2 * vh) < 1) {
            return (v2);
        }
        if ((3 * vh) < 2) {
            return (v1 + (v2 - v1) * ((2 / 3) - vh) * 6);
        }
        return v1;
    }
    // Sanitizes the factor to ensure it is rounded and always within the range of the width.
    function factorHelper(factor, width) {
        if (factor < 0.0) {
            var ret = Math.round(width + (factor - 0.5));
            if (ret < 0) {
                return width;
            }
            return ret;
        }
        if (factor > 1.0) {
            var ret = Math.round(factor + 0.5);
            if (ret < width) {
                return ret;
            }
            return width;
        }
        return Math.round(factor * width + 0.5);
    }
    function DegToRad(deg) {
        return deg * Math.PI / 180;
    }
    function RadToDeg(rad) {
        return rad * 180 / Math.PI;
    }
    /**
     * This is a small value used for fuzzy comparisons or as a value for 'close enough'
     */
    var FDSFudge = 1.0e-5;
    var FDSNDCTolerance = 0.001;
    function FDSLog10(value, def) {
        if (def === void 0) { def = 1.0; }
        if (value <= 0.0) {
            value = def;
        }
        return (Math.log(value) / Math.log(10));
    }
    // Number of decimal digits of precision
    var MAX_PRECISION = 10;
    function roundToMaxPrecision(num) {
        // Yeah, this isn't great in terms of efficiency, but it works.
        return parseFloat(num.toPrecision(MAX_PRECISION));
    }
    function stringToBoolean(str) {
        return str.toLowerCase() === 'true';
    }
    // `ENABLE_DEBUG` will be set to `false` by the release-mode Closure compiler
    // pass. We have to put this in a JavaScript literal block in order for the
    // compiler to notice it.
    /** @define {boolean} */
    var ENABLE_DEBUG = true;
    // dealing with NaNs:
    var NAN = 0.0 - 1.0e20;
    var SURENAN = -1.0e19;
    function ISNAN(x) {
        return x <= SURENAN;
    }
    function NOTNAN(x) {
        return x > SURENAN;
    }
    function IsNA(x) {
        return x <= NAN;
    }
    function IsSomeNAN(val, type) {
        if (type === void 0) { type = typeof val; }
        switch (type) {
            case 'number':
                return IsNA(val) || ISNAN(val) || isNaN(val);
            case 'integer':
                return val <= -2147483647;
            case 'string':
                return val === '@NA';
            default:
                return false;
        }
    }
    function IsSomeInternalNAN(val, type) {
        if (type === void 0) { type = typeof val; }
        switch (type) {
            case 'number':
            case 'integer':
                return isNaN(val);
            case 'string':
                return val === '@NA';
            default:
                return false;
        }
    }
    
    // For generating div IDs to prevent naming collisions
    function MakeId() {
        return Math.random().toString(36).substring(7);
    }
    // fn to replace a string with escaped characters for use in xml files displayed as html
    // copied from c++ function of same name
    // @param str [String] the string to be cleaned
    // @return [String] the new cleaned string
    function cleanString(input) {
        if (typeof input === 'undefined' || input == null) {
            return '';
        }
        var str = input.toString();
        str = str.replace(/&/g, '&amp;'); // &
        str = str.replace(/\"/g, '&quot;'); // "
        str = str.replace(/\'/g, '&apos;'); // '
        str = str.replace(/</g, '&lt;'); // <
        str = str.replace(/>/g, '&gt;'); // >
        str = str.replace(/Â©/g, '&#169;'); // copyright
        str = str.replace(/â‚¬/g, '&#8364;'); // euro symbol
        str = str.replace(/Â¥/g, '&#165;'); // yen
        str = str.replace(/Â£/g, '&#163;'); // pound
        return str;
    }
    var timerFunc = (function () {
        if (typeof performance !== 'undefined' && _$1.isFunction(performance.now)) {
            return performance.now.bind(performance);
        }
        else {
            return Date.now.bind(Date);
        }
    })();
    // polyfill for bind not existing in phantom.
    // Source: https://github.com/gruntjs/grunt-contrib-jasmine/issues/107
    if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
            var target = this;
            var slice = [].slice;
            var Empty = function () {
            };
            if (typeof target !== 'function') {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            var args = slice.call(arguments, 1);
            var bound = function () {
                if (this instanceof bound) {
                    var result = target.apply(this, args.concat(slice.call(arguments)));
                    if (Object(result) === result) {
                        return result;
                    }
                    return this;
                }
                else {
                    return target.apply(that, args.concat(slice.call(arguments)));
                }
            };
            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty;
                Empty.prototype = null;
            }
            return bound;
        };
    }
    // fill for replacing requestAnimationFrame using timeouts if it doesn't exist.
    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
    // requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel
    // Under MIT license:
    // Copyright (c) Erik MÃ¶ller 2011
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.
    (function () {
        if (!isHeadlessMode) {
            var lastTime_1 = 0;
            var vendors = ['ms', 'moz', 'webkit', 'o'];
            for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
                window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
                    window[vendors[x] + 'CancelRequestAnimationFrame'];
            }
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = function (callback) {
                    var currTime = new Date().getTime();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime_1));
                    var id = window.setTimeout(function () {
                        callback(currTime + timeToCall);
                    }, timeToCall);
                    lastTime_1 = currTime + timeToCall;
                    return id;
                };
            }
            if (!window.cancelAnimationFrame) {
                window.cancelAnimationFrame = function (id) {
                    clearTimeout(id);
                };
            }
        }
    })();
    
    /**
     * Determine if two numbers are equal within a tolerance.
       * @paramx - The first number
       * @paramy - the second number
       * @param tolerance - how close the numbers must be to be considered equal
       * @return  true if the numbers are equal within the tolerance
       */
    function fuzzyEQ(x, y, tolerance) {
        if (tolerance === void 0) { tolerance = FDSFudge; }
        return y < (x + tolerance) && y > (x - tolerance);
    }
    /**
     * Determine if the first number is less-than or equal-to the second number within a tolerance
       * @param x - The first number
       * @param y - the second number
       * @param tolerance - how close the numbers must be to be considered equal
       * @return - true if the first number is less-than or equal-to the second number
       */
    function fuzzyLTE(x, y, tolerance) {
        if (tolerance === void 0) { tolerance = FDSFudge; }
        return x < (y + tolerance);
    }
    /**
     * Determine if the first number is less-than the second number within a tolerance
       * @param x - The first number
       * @param y - the second number
       * @param tolerance - how close the numbers must be to be considered equal
       * @return - true if the first number is less-than the second number
       */
    function fuzzyLT(x, y, tolerance) {
        if (tolerance === void 0) { tolerance = FDSFudge; }
        return x <= (y - tolerance);
    }
    /**
     * Determine if the first number is greater-than or equal-to the second number within a tolerance
       * @param x - The first number
       * @param y - the second number
       * @param tolerance - how close the numbers must be to be considered equal
       * @return - true if the first number is greater-than or equal-to the second number
       */
    function fuzzyGTE(x, y, tolerance) {
        if (tolerance === void 0) { tolerance = FDSFudge; }
        return x > (y - tolerance);
    }
    /**
     * Determine if the first number is greater-than the second number within a tolerance
       * @param x - The first number
       * @param y - the second number
       * @param tolerance - how close the numbers must be to be considered equal
       * @return - true if the first number is greater-than the second number
       */
    function fuzzyGT(x, y, tolerance) {
        if (tolerance === void 0) { tolerance = FDSFudge; }
        return x >= (y + tolerance);
    }
    /**
     * Clamps the given number to be within the provided upper and lower bounds.
       * @param {number} x - the number being clamped
       * @param {number} lower - the lower-bound for clamping
       * @param {number} upper - the upper-bound for clamping
       * @return {number} - returns the input value clamped to fall within the range [lower, upper]
       */
    function clamp(x, lower, upper) {
        if (fuzzyGT(x, lower)) {
            if (fuzzyLT(x, upper)) {
                return x;
            }
            else {
                return upper;
            }
        }
        else {
            return lower;
        }
    }
    /**
     * Checks if the given number is within the range [lower, upper] using a fuzzy tolerance at the boundaries
       * @param {number} x - the number being tested
       * @param {number} lower - the lower-bound for comparison
       * @param {number} upper - the upper-bound for comparison
       * @param {number} [tolerance=FDSFudge] - how close the numbers must be to the boundaries to be consider inside the
       *   range
       * @return {boolean} - returns true if the input value is within the range [lower, upper]
       */
    function isBounded(x, lower, upper, tolerance) {
        if (tolerance === void 0) { tolerance = FDSFudge; }
        return fuzzyLTE(x, upper, tolerance) && fuzzyGTE(x, lower, tolerance);
    }
    /**
     * Takes a number and makes it even by incrementing or decrementing based on the strategy requested.
       * @param {number} x - the input value
       * @param {boolean} [decrement=true] - if true, we will subtract 1 from odd number, otherwise, we add 1
       * @return {number} - returns the closest even number to the provided input.
       */
    function makeEven(x, decrement) {
        if (decrement === void 0) { decrement = true; }
        var incrOrDecr = decrement ? -1 : 1;
        if (x % 2 !== 0) {
            x += incrOrDecr;
        }
        return x;
    }
    /**
     * Calculates the multiple of a factor that is closest to nextNum and is less than or equal to it.
       * This works with both positive and negative numbers, including decimals.
       * @param {number} factor - the number for which we are finding a multiple.
       * @param {number} nextNum - the number that should be greater than or equal to the multiple we find.
       * @return {number} = The multiple of factor that is closest to nextNum and less than or equal to it.
       */
    function calculatePreviousMultiple(factor, nextNum) {
        return roundToMaxPrecision(nextNum - nextNum % factor);
    }
    /**
     * Calculates the multiple of a factor that is closest to prevNum and is greater than or equal to it.
       * This works with both positive and negative numbers, including decimals.
       * @param {number} factor - the number for which we are finding a multiple.
       * @param {number} prevNum - the number that should be less than or equal to the multiple we find.
       * @return {number} = The multiple of factor that is closest to prevNum and less than or equal to it.
       */
    function calculateNextMultiple(factor, prevNum) {
        if (fuzzyEQ(prevNum % factor, 0)) {
            return prevNum;
        }
        else {
            return roundToMaxPrecision(prevNum - prevNum % factor + factor);
        }
    }
    // FDSGraphics::polyinterp
    function polyinterp(a, n, x) {
        var sum$$1 = 0.0;
        for (var i = 0; i < n; i++) {
            sum$$1 += a[i] * Math.pow(x, i);
        }
        return sum$$1;
    }
    function meanBy(array, iteratee) {
        if (iteratee === void 0) { iteratee = _$1.identity; }
        return _$1.reduce(array, function (total, element) {
            return total + iteratee(element);
        }, 0) / array.length;
    }
    
    function smoothstep(x) {
        // Ken Perlin's version from https://en.wikipedia.org/wiki/Smoothstep
        return x * x * x * (x * (x * 6 - 15) + 10);
    }
    var TimedAnimator = /** @class */ (function () {
        function TimedAnimator(animationManager, duration) {
            this._startTime = timerFunc();
            this._duration = duration;
            this._endTime = this._startTime + duration;
            if (duration > 0) {
                this._percentComplete = 0;
            }
            else {
                this._percentComplete = 1;
            }
        }
        Object.defineProperty(TimedAnimator.prototype, "percentComplete", {
            get: function () { return this._percentComplete; },
            enumerable: true,
            configurable: true
        });
        TimedAnimator.prototype._updateTime = function (time) {
            if (this._percentComplete < 1) {
                var rawPercent = (time - this._startTime) / this._duration;
                this._percentComplete = clamp(smoothstep(rawPercent), 0, 1);
            }
        };
        TimedAnimator.prototype.forceCompletion = function () {
            this._percentComplete = 1;
        };
        TimedAnimator.prototype.isActive = function () {
            return this._percentComplete < 1;
        };
        return TimedAnimator;
    }());
    var AnimationManager = /** @class */ (function () {
        function AnimationManager(drawFunction) {
            this._animatorRegistrations = [];
            this._animToken = 0;
            this._isEnabled = true;
            this._drawFunction = drawFunction;
        }
        AnimationManager.prototype.canAnimate = function () {
            return !isHeadlessMode && this._isEnabled;
        };
        AnimationManager.prototype.reset = function () {
            if (this._animToken !== 0 && window && _$1.isFunction(window.cancelAnimationFrame)) {
                window.cancelAnimationFrame(this._animToken);
                this._animToken = 0;
            }
            this._animatorRegistrations.length = 0;
        };
        AnimationManager.prototype.removeAnimationsForObject = function (objectId) {
            _$1.remove(this._animatorRegistrations, { objectId: objectId });
        };
        AnimationManager.prototype.tryGetAnimator = function (objectId, animatorId, animatorCreator) {
            var registration = _$1.find(this._animatorRegistrations, { objectId: objectId, animatorId: animatorId });
            if (registration) {
                return registration.animator;
            }
            if (animatorCreator) {
                var animator = animatorCreator(this);
                this.registerAndBeginAnimation(objectId, animatorId, animator);
                return animator;
            }
            return undefined;
        };
        AnimationManager.prototype.registerAndBeginAnimation = function (objectId, animatorId, animator) {
            this._animatorRegistrations.push({ objectId: objectId, animatorId: animatorId, animator: animator });
            if (this.canAnimate()) {
                this._queueAnimationFrameIfNecessary();
            }
            else {
                animator.forceCompletion();
            }
        };
        AnimationManager.prototype.unregisterAnimator = function (objectId, animatorId) {
            _$1.remove(this._animatorRegistrations, { objectId: objectId, animatorId: animatorId });
        };
        AnimationManager.prototype.update = function () {
            if (isHeadlessMode) {
                return;
            }
            this._queueAnimationFrameIfNecessary();
        };
        AnimationManager.prototype.forceCompletion = function () {
            for (var _i = 0, _a = this._animatorRegistrations; _i < _a.length; _i++) {
                var animator = _a[_i].animator;
                if (animator.isActive()) {
                    this.forceCompletion();
                }
            }
        };
        AnimationManager.prototype.isAnimationInProgress = function () {
            return !isHeadlessMode && _$1.some(this._animatorRegistrations, function (reg) { return reg.animator.isActive(); });
        };
        AnimationManager.prototype._queueAnimationFrameIfNecessary = function () {
            if (this._animToken === 0 && this.isAnimationInProgress()) {
                this._animToken = window.requestAnimationFrame(this._animate.bind(this));
            }
        };
        AnimationManager.prototype._animate = function (time) {
            this._animToken = 0;
            var currentDrawRequirements = 0;
            var animatorsToRemove = [];
            for (var _i = 0, _a = this._animatorRegistrations; _i < _a.length; _i++) {
                var _b = _a[_i], objectId = _b.objectId, animatorId = _b.animatorId, animator = _b.animator;
                if (animator.isActive()) {
                    var results = animator.onTick(time);
                    if (results === -1 /* Unregister */) {
                        animatorsToRemove.push({ objectId: objectId, animatorId: animatorId });
                    }
                    if (results > currentDrawRequirements) {
                        currentDrawRequirements = results;
                    }
                }
            }
            for (var _c = 0, animatorsToRemove_1 = animatorsToRemove; _c < animatorsToRemove_1.length; _c++) {
                var _d = animatorsToRemove_1[_c], objectId = _d.objectId, animatorId = _d.animatorId;
                this.unregisterAnimator(objectId, animatorId);
            }
            if (currentDrawRequirements > 0 /* NoDrawNeeded */) {
                this._drawFunction();
            }
            this._queueAnimationFrameIfNecessary();
        };
        return AnimationManager;
    }());
    
    /**
     * A parent class for FDSPen/FDSBrush/FDSFont.
     * The main function of the base class is to encapsulate the shared functionality of pushHistory(), popHistory(), and
     * setAttr()
     */
    var BaseDrawingPrimitive = /** @class */ (function () {
        function BaseDrawingPrimitive() {
            this._history = [];
        }
        /**
         * Restores state by undoing values that were set in reverse order
         */
        BaseDrawingPrimitive.prototype.popHistory = function () {
            var last$$1 = this._history.pop();
            if (last$$1) {
                // playback state changes in reverse order.
                for (var i = last$$1.length - 1; i >= 0; i--) {
                    this[last$$1[i].prop] = last$$1[i].value;
                }
                return true;
            }
            return false;
        };
        /**
         * Creates a new snapshot for storing state changes
         */
        BaseDrawingPrimitive.prototype.pushHistory = function () {
            this._history.push([]);
        };
        /**
         * Set the object property to the new value and keep track of its previous value so it can be restored
         * @param prop - the object property to changes
         * @param newValue - The value to set
         */
        BaseDrawingPrimitive.prototype._setAttr = function (prop, newValue) {
            if (ENABLE_DEBUG) {
                console.assert(typeof this[prop] !== 'undefined', "Attribute '" + prop + "' is not defined.");
            }
            this._history[this._history.length - 1].push({ prop: prop, value: this[prop] });
            this[prop] = newValue;
            return true;
        };
        return BaseDrawingPrimitive;
    }());
    
    var forcePolyFill = false;
    var defaultState = Object.freeze({
        dashArray: [],
        isDashing: false,
        dashOverage: 0,
        isDashSegment: true,
        dashIndex: 0,
    });
    var canvasPrototype = typeof CanvasRenderingContext2D !== 'undefined' && CanvasRenderingContext2D.prototype;
    var ellipsePolyfill = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === void 0) { anticlockwise = false; }
        // Note, we need to call through prototype as these functions may have been overwritten
        // as part of the line-dash polyfill
        canvasPrototype.save.call(this);
        canvasPrototype.translate.call(this, x, y);
        canvasPrototype.rotate.call(this, rotation);
        canvasPrototype.scale.call(this, radiusX, radiusY);
        canvasPrototype.arc.call(this, 0, 0, 1, startAngle, endAngle, anticlockwise);
        canvasPrototype.restore.call(this);
    };
    var DeferredPath = /** @class */ (function () {
        function DeferredPath() {
            this._operations = [];
            this._startPos = undefined;
            this._lengthWhenPlayed = -1;
            this._lastPlayWasDashed = false;
        }
        DeferredPath.prototype.clone = function () {
            var cloned = new DeferredPath();
            cloned._operations = _$1.cloneDeep(this._operations);
            cloned._startPos = this._startPos;
            return cloned;
        };
        DeferredPath.prototype.playBackOnCanvas = function (ctx, dashToFunction) {
            var isDashed = dashToFunction !== undefined;
            if (this._lengthWhenPlayed === this._operations.length) {
                // If we have played back the operation list, we may be able to skip it
                if (isDashed === this._lastPlayWasDashed) {
                    return;
                }
            }
            this._lastPlayWasDashed = dashToFunction !== undefined;
            this._lengthWhenPlayed = this._operations.length;
            canvasPrototype.beginPath.call(ctx);
            var lastPos = undefined;
            for (var _i = 0, _a = this._operations; _i < _a.length; _i++) {
                var _b = _a[_i], fn = _b.fn, args = _b.args, pos = _b.pos;
                if (isDashed && lastPos) {
                    var lastX = lastPos.x, lastY = lastPos.y;
                    if (fn === canvasPrototype.lineTo) {
                        var x = args[0], y = args[1];
                        dashToFunction(lastX, lastY, x, y);
                    }
                    else if (fn === canvasPrototype.closePath && this._startPos) {
                        var _c = this._startPos, x = _c.x, y = _c.y;
                        dashToFunction(lastX, lastY, x, y);
                    }
                }
                else {
                    fn.apply(ctx, args);
                }
                if (pos) {
                    lastPos = pos;
                }
            }
        };
        DeferredPath.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
            var pos = { x: x, y: y };
            this._startPos = this._startPos || pos;
            this._operations.push({
                fn: canvasPrototype.arc,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.arcTo = function (x1, y1, x2, y2, radius) {
            var pos = { x: x1, y: y1 };
            this._operations.push({
                fn: canvasPrototype.arcTo,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            var pos = { x: x, y: y };
            this._operations.push({
                fn: canvasPrototype.bezierCurveTo,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.closePath = function () {
            var pos = this._startPos;
            this._operations.push({ fn: canvasPrototype.closePath, args: [], pos: pos });
        };
        DeferredPath.prototype.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
            var pos = { x: x, y: y };
            this._operations.push({
                fn: canvasPrototype.ellipse || ellipsePolyfill,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.lineTo = function (x, y) {
            var pos = { x: x, y: y };
            this._operations.push({
                fn: canvasPrototype.lineTo,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.moveTo = function (x, y) {
            var pos = { x: x, y: y };
            this._startPos = this._startPos || pos;
            this._operations.push({
                fn: canvasPrototype.moveTo,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            var pos = { x: x, y: y };
            this._operations.push({
                fn: canvasPrototype.quadraticCurveTo,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        DeferredPath.prototype.rect = function (x, y, w, h) {
            var pos = { x: x, y: y };
            this._startPos = this._startPos || pos;
            this._operations.push({
                fn: canvasPrototype.rect,
                args: Array.apply(null, arguments),
                pos: pos
            });
        };
        return DeferredPath;
    }());
    var CanvasDashImplementation = /** @class */ (function () {
        function CanvasDashImplementation(ctx) {
            var _this = this;
            this._currentState = __assign({}, defaultState);
            this._savedStack = [];
            this._ctx = ctx;
            CanvasDashImplementation._registerPathOverrides(this);
            ctx.setLineDash = function (pattern) { return _this._setLineDash(pattern); };
            ctx.getLineDash = function () { return _this._currentState.dashArray.slice(); };
            ctx.beginPath = function () { return _this._beginPath(); };
            ctx.clip = function () { return _this._clip(); };
            ctx.fill = function () { return _this._fill(); };
            ctx.stroke = function () { return _this._stroke(); };
            ctx.strokeRect = function (x, y, width, height) { return _this._strokeRect(x, y, width, height); };
            ctx.save = function () { return _this._save(); };
            ctx.restore = function () { return _this._restore(); };
        }
        CanvasDashImplementation.installPolyfill = function (ctx) {
            if (canvasPrototype) {
                new CanvasDashImplementation(ctx);
            }
            else {
                ctx.setLineDash = function () { };
                ctx.getLineDash = function () { return []; };
            }
        };
        CanvasDashImplementation._registerPathOverrides = function (that) {
            var functionsToOverride = [
                'arc',
                'arcTo',
                'bezier',
                'bezierCurveTo',
                'closePath',
                'ellipse',
                'lineTo',
                'moveTo',
                'quadraticCurveTo',
                'rect',
            ];
            var _loop_1 = function (fnName) {
                that._ctx[fnName] = function () {
                    if (!that._currentState.deferredPath) {
                        that._currentState.deferredPath = new DeferredPath();
                    }
                    var path = that._currentState.deferredPath;
                    path[fnName].apply(path, arguments);
                };
            };
            for (var _i = 0, functionsToOverride_1 = functionsToOverride; _i < functionsToOverride_1.length; _i++) {
                var fnName = functionsToOverride_1[_i];
                _loop_1(fnName);
            }
        };
        CanvasDashImplementation.prototype._setLineDash = function (pattern) {
            this._currentState.dashArray = pattern.slice();
            this._currentState.isDashing = pattern.length > 0;
        };
        CanvasDashImplementation.prototype._beginPath = function () {
            this._currentState.deferredPath = new DeferredPath();
        };
        CanvasDashImplementation.prototype._dashTo = function (lastX, lastY, x, y) {
            if (!this._currentState.isDashing) {
                canvasPrototype.lineTo.call(this._ctx, x, y);
                return;
            }
            var pattern = this._currentState.dashArray;
            // Empty pattern, don't render.
            if (pattern.length === 0) {
                canvasPrototype.moveTo.call(this._ctx, x, y);
                return;
            }
            var distance = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
            var start = this._currentState.dashOverage;
            this._currentState.dashOverage = 0;
            var angle = Math.atan2(y - lastY, x - lastX);
            var cosine = Math.cos(angle);
            var sine = Math.sin(angle);
            var len = 0;
            while (start < distance) {
                if ((start + len) > distance) {
                    this._currentState.dashOverage = (start + len) - distance;
                    start = distance;
                }
                else {
                    start += len;
                }
                var xl = start * cosine + lastX;
                var yl = start * sine + lastY;
                if (this._currentState.isDashSegment) {
                    canvasPrototype.lineTo.call(this._ctx, xl, yl);
                }
                else {
                    canvasPrototype.moveTo.call(this._ctx, xl, yl);
                }
                // if the segment went over the last point, continue drawing it in the next call to drawPolyline,
                // in other words, don't update this._dashIndex nor this._isDashSegment
                if (this._currentState.dashOverage === 0) {
                    this._currentState.isDashSegment = !this._currentState.isDashSegment;
                    this._currentState.dashIndex = (this._currentState.dashIndex + 1) % pattern.length;
                }
                // note, relies on boolean cascating to 1/0 for true/false
                len = pattern[this._currentState.dashIndex];
            }
        };
        CanvasDashImplementation.prototype._stroke = function () {
            this._currentState.dashIndex = 0;
            this._currentState.dashOverage = 0;
            this._currentState.isDashSegment = true;
            var path = this._currentState.deferredPath;
            if (path && this._ctx.fillStyle !== 'transparent') {
                var dashFn = this._currentState.isDashing ? this._dashTo.bind(this) : undefined;
                path.playBackOnCanvas(this._ctx, dashFn);
                canvasPrototype.stroke.call(this._ctx);
            }
        };
        CanvasDashImplementation.prototype._clip = function () {
            var path = this._currentState.deferredPath;
            if (path) {
                path.playBackOnCanvas(this._ctx);
                canvasPrototype.clip.call(this._ctx);
            }
        };
        CanvasDashImplementation.prototype._fill = function () {
            var path = this._currentState.deferredPath;
            if (path && this._ctx.fillStyle !== 'transparent') {
                path.playBackOnCanvas(this._ctx);
                canvasPrototype.fill.call(this._ctx);
            }
        };
        CanvasDashImplementation.prototype._strokeRect = function (x, y, width, height) {
            if (!this._currentState.isDashing) {
                canvasPrototype.strokeRect.call(this._ctx, x, y, width, height);
            }
            else {
                var offset = (this._ctx.lineWidth % 2 !== 0) ? 0.5 : 0;
                var x1 = x;
                var y1 = y;
                var x2 = x + width;
                var y2 = y + height;
                var ctx = this._ctx;
                ctx.beginPath();
                // top
                ctx.moveTo(x1 - offset, y1);
                ctx.lineTo(x2 - offset, y1);
                // right
                ctx.moveTo(x2, y1 - offset);
                ctx.lineTo(x2, y2 - offset);
                // bottom
                ctx.moveTo(x2 - offset, y2);
                ctx.lineTo(x1 - offset, y2);
                // left
                ctx.moveTo(x1, y2 - offset);
                ctx.lineTo(x1, y1 - offset);
                ctx.stroke();
            }
        };
        CanvasDashImplementation.prototype._save = function () {
            canvasPrototype.save.call(this._ctx);
            this._savedStack.push(this._currentState);
            this._currentState = __assign({}, this._currentState);
            if (this._currentState.deferredPath) {
                this._currentState.deferredPath = this._currentState.deferredPath.clone();
            }
        };
        CanvasDashImplementation.prototype._restore = function () {
            canvasPrototype.restore.call(this._ctx);
            if (this._savedStack.length > 0) {
                this._currentState = this._savedStack.pop();
            }
            else {
                this._currentState = __assign({}, defaultState);
            }
        };
        return CanvasDashImplementation;
    }());
    function polyFillCanvasContext(ctx) {
        // If CanvasRenderingContext2D doesn't exist (such as in unit tests), don't polyfill
        if (forcePolyFill || !_$1.isFunction(ctx.ellipse)) {
            if (canvasPrototype) {
                ctx.ellipse = ellipsePolyfill;
            }
            else {
                ctx.ellipse = function () { };
            }
        }
        if (forcePolyFill || !_$1.isFunction(ctx.setLineDash)) {
            // If we don't have a real canvas implementation, skip it
            if (canvasPrototype) {
                CanvasDashImplementation.installPolyfill(ctx);
            }
        }
        return ctx;
    }
    
    function getLinkStyle(theme) {
        if (theme === 2 /* CARBON */) {
            return {
                default: {
                    fontColor: "#26C9FF",
                    underline: false,
                    fontWeight: '',
                },
                hover: {
                    fontColor: "#00AEEF",
                    underline: true,
                    fontWeight: '',
                }
            };
        }
        else {
            return {
                default: {
                    fontColor: "#00AEEF",
                    underline: false,
                    fontWeight: '',
                },
                hover: {
                    fontColor: "#26C9FF",
                    underline: true,
                    fontWeight: '',
                }
            };
        }
    }
    function renderUnderlineForBlock(ctx, rect, color) {
        // Scale the width of the underline with the line height.
        var lineWidth = Math.max(1, Math.round(rect.getHeight() / 12));
        var aliasOffset = (lineWidth % 2) === 1 ? 0.5 : 0;
        var y = ~~rect.y2 - aliasOffset;
        ctx.setPenStrokeStyle(color, scaleByDevicePixelRatio(lineWidth), []);
        ctx.beginPath();
        ctx.moveTo(~~rect.x1, y);
        ctx.lineTo(~~rect.x2, y);
        ctx.stroke();
    }
    var RichTextLink = /** @class */ (function () {
        function RichTextLink(eventData) {
            this.textBlocks = [];
            this.eventData = eventData;
            this.isDisplayingHovered = false;
        }
        RichTextLink.prototype.isMouseOver = function (point) {
            return _$1.some(this.textBlocks, function (block) { return block.rect.hit(point); });
        };
        RichTextLink.prototype.render = function (ctx, style) {
            var myStyle = this.isDisplayingHovered ? style.hover : style.default;
            var font;
            var fontBaselineOffset = 0;
            for (var _i = 0, _a = this.textBlocks; _i < _a.length; _i++) {
                var block = _a[_i];
                if (block.font !== font) {
                    font = block.font;
                    fontBaselineOffset = font.getBaselineOffset();
                    ctx.setFont(font);
                    ctx.setFontFillStyle(myStyle.fontColor);
                }
                ctx.fillText(block.text, block.rect.x1, block.rect.y1 + fontBaselineOffset);
                if (myStyle.underline) {
                    renderUnderlineForBlock(ctx, block.rect, myStyle.fontColor);
                }
            }
        };
        return RichTextLink;
    }());
    var RichTextLinkContainer = /** @class */ (function () {
        function RichTextLinkContainer() {
            this._links = {};
        }
        RichTextLinkContainer.prototype.getLinkInfoAsJson = function () {
            var output = [];
            for (var _i = 0, _a = Object.keys(this._links); _i < _a.length; _i++) {
                var layerName = _a[_i];
                for (var _b = 0, _c = this._links[layerName]; _b < _c.length; _b++) {
                    var link = _c[_b];
                    var textBlocks = _$1.map(link.textBlocks, function (tb) { return ({
                        rect: { x1: tb.rect.x1, y1: tb.rect.y1, x2: tb.rect.x2, y2: tb.rect.y2 },
                        text: tb.text,
                    }); });
                    output.push({ textBlocks: textBlocks, type: link.eventData.type, data: link.eventData.data });
                }
            }
            return output;
        };
        RichTextLinkContainer.prototype.addLinkForLayer = function (link, layerName) {
            if (!layerName) {
                console.warn('Rich-text links are unsupported on an un-named canvas');
                return;
            }
            if (this._links[layerName] === undefined) {
                this._links[layerName] = [];
            }
            this._links[layerName].push(link);
        };
        RichTextLinkContainer.prototype.clearLinksFromLayer = function (layerName) {
            if (!layerName) {
                return;
            }
            this._links[layerName] = [];
        };
        RichTextLinkContainer.prototype.isEmpty = function () {
            return _$1.every(this._links, function (linkArray) { return linkArray.length === 0; });
        };
        RichTextLinkContainer.prototype.resetHoverStates = function (point) {
            var allLinks = _$1.flatten(_$1.toArray(this._links));
            var hoverChanged = false;
            for (var _i = 0, allLinks_1 = allLinks; _i < allLinks_1.length; _i++) {
                var link = allLinks_1[_i];
                if (link.isDisplayingHovered) {
                    hoverChanged = true;
                    link.isDisplayingHovered = false;
                }
            }
            return hoverChanged;
        };
        RichTextLinkContainer.prototype.updateHoverStates = function (point) {
            var hoverChanged = false;
            var allLinks = _$1.flatten(_$1.toArray(this._links));
            for (var _i = 0, allLinks_2 = allLinks; _i < allLinks_2.length; _i++) {
                var link = allLinks_2[_i];
                var isMouseOver = link.isMouseOver(point);
                if (isMouseOver !== link.isDisplayingHovered) {
                    hoverChanged = true;
                }
                link.isDisplayingHovered = isMouseOver;
            }
            return hoverChanged;
        };
        RichTextLinkContainer.prototype.hitTest = function (pick$$1, point) {
            var allLinks = _$1.flatten(_$1.toArray(this._links));
            // Reverse iteration to respect the z-order
            for (var i = allLinks.length - 1; i >= 0; i--) {
                var link = allLinks[i];
                if (link.isMouseOver(point)) {
                    pick$$1.cursor = link.eventData.cursor || 'pointer';
                    var _a = link.eventData, type = _a.type, data = _a.data;
                    if (type === 'event') {
                        var action = "<Action type=\"FireEvent\"><EventData>" + data + "</EventData></Action>";
                        pick$$1.setAccessLClickAction("<ActionList>" + action + "</ActionList>");
                    }
                    else if (type === 'href') {
                        var action = "<Action type=\"Navigate\"><HRef>" + data + "</HRef></Action>";
                        pick$$1.setAccessLClickAction("<ActionList>" + action + "</ActionList>");
                    }
                    else if (type === 'action') {
                        pick$$1.setAccessLClickAction(data);
                    }
                    return true;
                }
            }
            return false;
        };
        RichTextLinkContainer.prototype.drawToBuffer = function (ctx, theme) {
            ctx.save();
            var style = getLinkStyle(theme);
            var allLinks = _$1.flatten(_$1.toArray(this._links));
            for (var _i = 0, allLinks_3 = allLinks; _i < allLinks_3.length; _i++) {
                var link = allLinks_3[_i];
                link.render(ctx, style);
            }
            ctx.restore();
        };
        return RichTextLinkContainer;
    }());
    
    var BaseLayerManager = /** @class */ (function () {
        function BaseLayerManager(container, layerConstructor, initializer) {
            this.linkContainer = new RichTextLinkContainer();
            this._minSizeScaleFactor = { x: 1, y: 1 };
            this._container = container;
            if (initializer) {
                initializer(this);
            }
            this.main = layerConstructor(this, 'main');
            this.overlay = layerConstructor(this, 'overlay');
            this.ui = layerConstructor(this, 'ui');
        }
        BaseLayerManager.prototype.scaleForMinimumSize = function (widthScale, heightScale) {
            function scaleContext(ctx) {
                ctx.scale(widthScale, heightScale);
            }
            this._minSizeScaleFactor.x *= widthScale;
            this._minSizeScaleFactor.y *= heightScale;
            scaleContext(this.main.context);
            scaleContext(this.overlay.context);
            scaleContext(this.ui.context);
            if (this._links) {
                scaleContext(this._links.context);
            }
        };
        BaseLayerManager.prototype.unscaleForMinimumSize = function (widthScale, heightScale) {
            this.scaleForMinimumSize(1 / widthScale, 1 / heightScale);
        };
        BaseLayerManager.prototype.renderRichTextLinks = function (theme) {
            if (this._links) {
                var linkContext = this._links.context;
                linkContext.clear();
                this.linkContainer.drawToBuffer(linkContext, theme);
            }
        };
        BaseLayerManager.prototype.resize = function (width, height) {
            for (var _i = 0, _a = [this.main, this.overlay, this.ui, this._links]; _i < _a.length; _i++) {
                var layer = _a[_i];
                if (layer) {
                    layer.resize(width, height);
                }
            }
        };
        BaseLayerManager.prototype.show = function () {
            this.main.show();
            this.overlay.show();
            this.ui.show();
            if (this._links) {
                this._links.show();
            }
        };
        BaseLayerManager.prototype.hide = function () {
            this.main.hide();
            this.overlay.hide();
            this.ui.hide();
            if (this._links) {
                this._links.hide();
            }
        };
        BaseLayerManager.prototype.destroy = function () {
            this.main.destroy();
            this.overlay.destroy();
            this.ui.destroy();
            if (this._links) {
                this._links.destroy();
            }
        };
        return BaseLayerManager;
    }());
    function getPixelAlignedFunctor(_a) {
        var isVertical = _a.isVertical;
        if (isVertical) {
            return function (ctx, _a) {
                var pt1 = _a.pt1, pt2 = _a.pt2;
                return ctx.appendVerticalLineToPath(pt1.y, pt2.y, pt1.x);
            };
        }
        else {
            return function (ctx, _a) {
                var pt1 = _a.pt1, pt2 = _a.pt2;
                return ctx.appendHorizontalLineToPath(pt1.x, pt2.x, pt1.y);
            };
        }
    }
    var ValidRenderingModes = ['svg', 'canvas', 'none'];
    
    var FillStyleType;
    (function (FillStyleType) {
        FillStyleType[FillStyleType["NONE"] = 0] = "NONE";
        FillStyleType[FillStyleType["BRUSH"] = 1] = "BRUSH";
        FillStyleType[FillStyleType["FONT"] = 2] = "FONT";
    })(FillStyleType || (FillStyleType = {}));
    var CanvasLayerManager = /** @class */ (function (_super) {
        __extends(CanvasLayerManager, _super);
        function CanvasLayerManager(container) {
            return _super.call(this, container, function (manager, layerName) { return new CanvasLayer(manager, container, layerName); }) || this;
        }
        CanvasLayerManager.prototype.createLayer = function (width, height) {
            return new CanvasLayer(this, width, height);
        };
        CanvasLayerManager.prototype.renderRichTextLinks = function (theme) {
            var layers = [this.main, this.overlay, this.ui];
            this.createOrDestroyLinkLayerIfNeeded(layers);
            _super.prototype.renderRichTextLinks.call(this, theme);
        };
        CanvasLayerManager.prototype.createOrDestroyLinkLayerIfNeeded = function (layers) {
            if (this._links && this.linkContainer.isEmpty()) {
                this._links.destroy();
                this._links = undefined;
            }
            else if (!this._links && !this.linkContainer.isEmpty()) {
                this._links = new CanvasLayer(this, this._container, 'links');
                this._links.resize(this.main.canvas.width, this.main.canvas.height);
                this._links.context.scale(this._minSizeScaleFactor.x, this._minSizeScaleFactor.y);
            }
        };
        CanvasLayerManager.prototype.flattenLayersToCanvas = function (includeUI) {
            var mergedLayer = new CanvasLayer(this, this.main.getWidth(), this.main.getHeight());
            var layers = [this.main, this.overlay];
            if (includeUI) {
                layers.push(this.ui);
            }
            if (this._links) {
                layers.push(this._links);
            }
            for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
                var layer = layers_1[_i];
                mergedLayer.context.drawLayer(layer);
            }
            return mergedLayer.canvas;
        };
        CanvasLayerManager.prototype.flattenLayersToCanvasAsync = function (includeUI) {
            var deferred = $$1.Deferred();
            var canvas = this.flattenLayersToCanvas(includeUI);
            deferred.resolve(canvas);
            return deferred.promise();
        };
        return CanvasLayerManager;
    }(BaseLayerManager));
    var CanvasLayer = /** @class */ (function () {
        function CanvasLayer(layerManager, containerOrWidth, nameOrHeight) {
            this.layerManager = layerManager;
            var canvas = document.createElement('canvas');
            this.canvas = canvas;
            if (_$1.isNumber(containerOrWidth) && _$1.isNumber(nameOrHeight)) {
                var width = containerOrWidth;
                var height = nameOrHeight;
                this.resize(width, height);
            }
            else {
                this._container = containerOrWidth;
                this.name = nameOrHeight;
            }
            if (this._container) {
                canvas.style.position = 'absolute';
                canvas.style.left = canvas.style.top = '0px';
                // Disabling pointer events here for consistency with the svg rendering context
                this.canvas.style.pointerEvents = 'none';
                this._container.appendChild(canvas);
            }
            this.context = new CanvasContext(this, canvas.getContext('2d'));
        }
        CanvasLayer.prototype.getWidth = function () {
            return this.canvas.width;
        };
        CanvasLayer.prototype.getHeight = function () {
            return this.canvas.height;
        };
        CanvasLayer.createHatchCanvas = function (fgColor) {
            // Currently we only support one type of hatch.
            var patternDim = 8;
            // Set up the canvas
            var canvas = document.createElement('canvas');
            canvas.width = patternDim;
            canvas.height = patternDim;
            var ctx = canvas.getContext('2d');
            // Manually write to the imageData array that we generate on the canvas.
            var _a = COLORREFtoRGB(fgColor), r = _a[0], g = _a[1], b = _a[2];
            var imageData = ctx.createImageData(patternDim, patternDim);
            var i = 0;
            var k = 0;
            // This starts with the top-left pixel, then moves back one pixel modulo
            // the dimensions of the pattern, moving forward by the stride.
            while (i < imageData.data.length) {
                var j = 4 * (i + (i - k) % patternDim);
                imageData.data[j + 0] = r;
                imageData.data[j + 1] = g;
                imageData.data[j + 2] = b;
                imageData.data[j + 3] = 255;
                i += patternDim;
                k += 1;
            }
            // Write the image data back to the canvas's context
            ctx.putImageData(imageData, 0, 0);
            return canvas;
        };
        CanvasLayer.prototype.setStyle = function (styleOptions) {
            _$1.assign(this.canvas.style, styleOptions);
        };
        CanvasLayer.prototype.resize = function (width, height) {
            var _a = this, canvas = _a.canvas, _container = _a._container;
            canvas.width = width;
            canvas.height = height;
            if (_container) {
                canvas.style.width = scaleByDevicePixelRatioInverse(width) + 'px';
                canvas.style.height = scaleByDevicePixelRatioInverse(height) + 'px';
            }
        };
        CanvasLayer.prototype.hide = function () {
            this.canvas.style.display = 'none';
        };
        CanvasLayer.prototype.show = function () {
            this.canvas.style.display = '';
        };
        CanvasLayer.prototype.destroy = function () {
            if (this._container) {
                this._container.removeChild(this.canvas);
            }
        };
        CanvasLayer.prototype.addRichTextLink = function (link) {
            this.layerManager.linkContainer.addLinkForLayer(link, this.name);
        };
        CanvasLayer.prototype.clearRichTextLinks = function () {
            this.layerManager.linkContainer.clearLinksFromLayer(this.name);
        };
        return CanvasLayer;
    }());
    var CanvasContext = /** @class */ (function () {
        function CanvasContext(layer, ctx) {
            this.layer = layer;
            this._fillStyleType = FillStyleType.NONE;
            this._saveStack = [];
            this._ctx = polyFillCanvasContext(ctx);
        }
        Object.defineProperty(CanvasContext.prototype, "globalCompositeOperation", {
            // To be removed
            get: function () {
                return this._ctx.globalCompositeOperation;
            },
            set: function (value) {
                this._ctx.globalCompositeOperation = value;
            },
            enumerable: true,
            configurable: true
        });
        CanvasContext.prototype.getCanvasCtx = function () {
            return this._ctx;
        };
        CanvasContext.prototype._setFillStyleType = function (type) {
            if (type !== this._fillStyleType) {
                if (type === FillStyleType.BRUSH) {
                    this._ctx.fillStyle = this._brushFillStyle;
                }
                else if (type === FillStyleType.FONT) {
                    this._ctx.fillStyle = this._fontFillStyle;
                }
                this._fillStyleType = type;
            }
            else {
                // Eventually we can remove this branch, but not safe yet.
                if (type === FillStyleType.BRUSH) {
                    this._ctx.fillStyle = this._brushFillStyle;
                }
                else if (type === FillStyleType.FONT) {
                    this._ctx.fillStyle = this._fontFillStyle;
                }
            }
        };
        CanvasContext.prototype.setFont = function (font) {
            var prop = font.toPropertyObject();
            this._ctx.font = prop.font;
            this.setFontFillStyle(prop.fillStyle);
        };
        CanvasContext.prototype.setFontFillStyle = function (style) {
            this._fontFillStyle = style;
            if (this._fillStyleType === FillStyleType.FONT) {
                this._ctx.fillStyle = this._fontFillStyle;
            }
        };
        CanvasContext.prototype.setPen = function (pen) {
            pen.closePolyline();
            var props = pen.toPropertyObject();
            this._ctx.lineWidth = props.lineWidth;
            this._ctx.strokeStyle = props.strokeStyle;
            this._ctx.lineCap = props.lineCap;
            this._ctx.miterLimit = 4;
            this._ctx.setLineDash(pen.getDashArray());
            this._aliasOffset = (props.lineWidth % 2 === 0) ? 0 : 0.5;
        };
        CanvasContext.prototype.setBrush = function (brush, rect) {
            var fillStyle = brush.toPropertyObject(this, rect).fillStyle;
            var canvasStyle;
            if (fillStyle.brushType === 'none') {
                canvasStyle = 'transparent';
            }
            else if (fillStyle.brushType === 'solid') {
                canvasStyle = COLORREFtoCSSColor(fillStyle.color, fillStyle.alpha);
            }
            else if (fillStyle.brushType === 'linearGradient') {
                canvasStyle = this._createLinearGradient(fillStyle.x1, fillStyle.y1, fillStyle.x2, fillStyle.y2, fillStyle.stops);
            }
            else if (fillStyle.brushType === 'radialGradient') {
                canvasStyle = this._createRadialGradient(fillStyle.x1, fillStyle.y1, fillStyle.r1, fillStyle.x2, fillStyle.y2, fillStyle.r2, fillStyle.stops);
            }
            else if (fillStyle.brushType === 'pattern') {
                canvasStyle = this._createHatchPattern(brush.color);
            }
            else {
                throw new Error('Unexpected brush style');
            }
            this.setBrushFillStyle(canvasStyle);
        };
        CanvasContext.prototype.setBrushFillStyle = function (style) {
            this._brushFillStyle = style;
            if (this._fillStyleType === FillStyleType.BRUSH) {
                this._ctx.fillStyle = this._brushFillStyle;
            }
        };
        CanvasContext.prototype.setPenStrokeStyle = function (style, width, dashArray) {
            this._ctx.strokeStyle = style;
            this._ctx.lineWidth = width;
            this._ctx.setLineDash(dashArray);
            this._aliasOffset = (width % 2) === 0 ? 0 : 0.5;
        };
        CanvasContext.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
            this._ctx.arc.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            this._ctx.bezierCurveTo.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.closePath = function () {
            this._ctx.closePath();
        };
        CanvasContext.prototype.ellipse = function (x, y, radiusX, radiusY) {
            if (radiusY === void 0) { radiusY = radiusX; }
            this._ctx.ellipse(x, y, radiusX, radiusY, 0, 0, 2 * Math.PI);
        };
        CanvasContext.prototype.lineTo = function (x, y) {
            this._ctx.lineTo.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.moveTo = function (x, y) {
            this._ctx.moveTo.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            this._ctx.quadraticCurveTo.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.rect = function (x, y, w, h) {
            this._ctx.rect.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.beginPath = function () {
            this._ctx.beginPath();
        };
        CanvasContext.prototype.clear = function () {
            this.layer.clearRichTextLinks();
            this._ctx.save();
            // We temporarily reset the scaling on the rendering context so that clearRect clears the whole canvas.
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this.layer.getWidth(), this.layer.getHeight());
            this._ctx.restore();
        };
        CanvasContext.prototype.clearRect = function (x, y, w, h) {
            this._ctx.clearRect.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.clip = function (fillRule) {
            this._ctx.clip.apply(this._ctx, arguments);
        };
        CanvasContext.prototype._createLinearGradient = function (x1, y1, x2, y2, stops) {
            var gradient = this._ctx.createLinearGradient(x1, y1, x2, y2);
            for (var _i = 0, stops_1 = stops; _i < stops_1.length; _i++) {
                var _a = stops_1[_i], offset = _a.offset, color = _a.color, alpha = _a.alpha;
                gradient.addColorStop(offset, COLORREFtoCSSColor(color, alpha));
            }
            return gradient;
        };
        CanvasContext.prototype._createRadialGradient = function (x1, y1, r1, x2, y2, r2, stops) {
            var gradient = this._ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);
            for (var _i = 0, stops_2 = stops; _i < stops_2.length; _i++) {
                var _a = stops_2[_i], offset = _a.offset, color = _a.color, alpha = _a.alpha;
                gradient.addColorStop(offset, COLORREFtoCSSColor(color, alpha));
            }
            return gradient;
        };
        CanvasContext.prototype._createHatchPattern = function (fgColor) {
            var canvas = CanvasLayer.createHatchCanvas(fgColor);
            return this._ctx.createPattern(canvas, 'repeat');
        };
        CanvasContext.prototype.fill = function (fillRule) {
            this._setFillStyleType(FillStyleType.BRUSH);
            this._ctx.fill.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.fillRect = function (x, y, w, h) {
            this._setFillStyleType(FillStyleType.BRUSH);
            this._ctx.fillRect.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.fillText = function (text, x, y, maxWidth) {
            this._setFillStyleType(FillStyleType.FONT);
            this._ctx.fillText.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.legacyFillText = function (text, x, y, alignment) {
            this._setFillStyleType(FillStyleType.FONT);
            // Capture current value
            var oldAlign = this._ctx.textAlign;
            this._ctx.textAlign = alignment;
            this._ctx.fillText(text, x, y);
            // restore previous values.
            this._ctx.textAlign = oldAlign;
        };
        CanvasContext.prototype.measureTextWidth = function (text) {
            var result = this._ctx.measureText(text);
            return Math.ceil(result.width);
        };
        CanvasContext.prototype.restore = function () {
            this._ctx.restore();
            var prev = this._saveStack.pop();
            if (prev) {
                this._aliasOffset = prev.aliasOffset;
                this._brushFillStyle = prev.brushFillStyle;
                this._fontFillStyle = prev.fontFillStyle;
                this._fillStyleType = prev.fillStyleType;
            }
        };
        CanvasContext.prototype.rotate = function (angle) {
            this._ctx.rotate.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.save = function () {
            this._ctx.save();
            this._saveStack.push({
                aliasOffset: this._aliasOffset,
                brushFillStyle: this._brushFillStyle,
                fontFillStyle: this._fontFillStyle,
                fillStyleType: this._fillStyleType,
            });
        };
        CanvasContext.prototype.scale = function (x, y) {
            this._ctx.scale.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.stroke = function () {
            this._ctx.stroke();
        };
        CanvasContext.prototype.strokeRect = function (x, y, w, h) {
            this._ctx.strokeRect.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.strokeRectAligned = function (x, y, w, h) {
            this.strokeRect(~~x + this._aliasOffset, ~~y + this._aliasOffset, ~~w, ~~h);
        };
        CanvasContext.prototype.strokeRectInternalAligned = function (x, y, w, h) {
            var lineWidth = this._ctx.lineWidth;
            var halfStroke = ~~(lineWidth / 2);
            this.strokeRectAligned(~~x + halfStroke, ~~y + halfStroke, ~~w - lineWidth, ~~h - lineWidth);
        };
        CanvasContext.prototype.appendHorizontalLineToPath = function (x1, x2, y) {
            var offsetY = ~~y + this._aliasOffset;
            this.moveTo(~~x1, offsetY);
            this.lineTo(~~x2, offsetY);
        };
        CanvasContext.prototype.appendVerticalLineToPath = function (y1, y2, x) {
            var offsetX = ~~x + this._aliasOffset;
            this.moveTo(offsetX, ~~y1);
            this.lineTo(offsetX, ~~y2);
        };
        CanvasContext.prototype.translate = function (x, y) {
            this._ctx.translate.apply(this._ctx, arguments);
        };
        CanvasContext.prototype.drawImage = function (image, offsetX, offsetY, width, height, alpha) {
            if (alpha === void 0) { alpha = 1; }
            if (alpha < 1) {
                this._ctx.globalAlpha = alpha;
            }
            this._ctx.drawImage(image, offsetX, offsetY, width, height);
            if (alpha < 1) {
                this._ctx.globalAlpha = 1;
            }
        };
        CanvasContext.prototype.drawLayer = function (layer, offsetX, offsetY) {
            if (offsetX === void 0) { offsetX = 0; }
            if (offsetY === void 0) { offsetY = 0; }
            if (layer instanceof CanvasLayer) {
                this._ctx.drawImage(layer.canvas, offsetX, offsetY);
            }
            else {
                console.error('Error: Attempting to draw a non-canvas layer onto a canvas');
            }
        };
        CanvasContext.prototype.drawLines = function (points, isClosed) {
            if (isClosed === void 0) { isClosed = false; }
            if (points.length < 2) {
                return;
            }
            this._ctx.beginPath();
            this._ctx.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                var _a = points[i], x = _a.x, y = _a.y;
                this._ctx.lineTo(x, y);
            }
            if (isClosed) {
                this._ctx.closePath();
            }
            this._ctx.stroke();
        };
        return CanvasContext;
    }());
    
    function sanitizeBrushStyle(style) {
        if (style > 4 || style < 0 || style === 3 /* pattern */) {
            if (ENABLE_DEBUG) {
                console.warn("BrushStyle value '" + style + "' is out of range or unsupported.");
            }
            return 0 /* SOLID */; // For compatability reasons unknown defaults to solid instead of null.
        }
        else {
            return style;
        }
    }
    /**
     * Consolidates a bunch of properties about drawing fills and
     * provides facilities for reading/writing those properties
     * from chart attributes
     */
    var FDSBrush = /** @class */ (function (_super) {
        __extends(FDSBrush, _super);
        /**
         * Constructs a new FDSBrush object.
         * @constructor
         */
        function FDSBrush() {
            var _this = _super.call(this) || this;
            _this._init();
            return _this;
        }
        FDSBrush.prototype.setAttr = function (prop, newValue) {
            if (prop === 'gradientColor') {
                _super.prototype._setAttr.call(this, 'gradientColorDefault', (newValue == null));
            }
            else if (prop === 'gradientAlpha') {
                _super.prototype._setAttr.call(this, 'gradientAlphaDefault', (newValue == null));
            }
            return _super.prototype._setAttr.call(this, prop, newValue);
        };
        /** Initialize the brush to default values. */
        FDSBrush.prototype._init = function () {
            this.gradientAngle = 0;
            this.gradientStyle = 0 /* NONE */;
            this.gradientColor = 0 /* BLACK */;
            this.gradientAlpha = this.alpha = 255;
            this.color = 0 /* BLACK */;
            this.style = 1 /* NULL */;
            this.gradientFactor = 1;
            this.gradientOffsetX = 0;
            this.gradientOffsetY = 0;
            this.imageDSName = '';
            this.gradientColorDefault = this.gradientAlphaDefault = true;
            this._lightDirection = null;
        };
        /** @returns a copy of this brush */
        FDSBrush.prototype.copy = function () {
            return _$1.assign(new FDSBrush(), this);
        };
        /**
         * Copy the other brush's attributes if ours are defaulted
         * @param otherBrush - The brush to inherit values from
         * @param attrSet - The attribute set to pull values from
         * @param attrBase - The base name to use as a prefix. `attrBase+'Color'`, etc.
         */
        FDSBrush.prototype.inheritFromOtherBrush = function (otherBrush, attrSet, attrBase) {
            var _this = this;
            // Simple wrapper function to reduce code-duplication.
            // technically this might have been simpler, if the wrapper also inlined `this[param] = otherBrush[param]`
            // But that sort of pattern would prevent us from minifying parameters as aggressively.
            var ifDefault = function (attrSuffix, func) {
                if (attrSet.isDefault(attrBase + attrSuffix)) {
                    func();
                }
            };
            ifDefault('Style', function () { return _this.style = otherBrush.style; });
            ifDefault('Color', function () { return _this.color = otherBrush.color; });
            ifDefault('Alpha', function () { return _this.alpha = otherBrush.alpha; });
            ifDefault('GradientColor', function () {
                _this.gradientColorDefault = otherBrush.gradientColorDefault;
                _this.gradientColor = otherBrush.gradientColor;
            });
            ifDefault('GradientAngle', function () { return _this.gradientAngle = otherBrush.gradientAngle; });
            ifDefault('GradientStyle', function () { return _this.gradientStyle = otherBrush.gradientStyle; });
            ifDefault('GradientAlpha', function () {
                _this.gradientAlphaDefault = otherBrush.gradientAlphaDefault;
                _this.gradientAlpha = otherBrush.gradientAlpha;
            });
            ifDefault('GradientFactor', function () { return _this.gradientFactor = otherBrush.gradientFactor; });
            ifDefault('RadialGradientOffsetX', function () { return _this.gradientOffsetX = otherBrush.gradientOffsetX; });
            ifDefault('RadialGradientOffsetY', function () { return _this.gradientOffsetY = otherBrush.gradientOffsetY; });
            ifDefault('ImageName', function () { return _this.imageDSName = otherBrush.imageDSName; });
        };
        /**
         * Writes the default attributes for this brush into the default map
         * @param attrSet - The `AttributeSet` where the the brush's attributes will reside.
         * @param attrBase - The prefix used for this brush's attributes 'SeriesBG', 'CanvasBG', etc.
         * @param parentAttrBase - The prefix for the chart-level brush to inherit from.
         */
        FDSBrush.prototype.writeToAttrSet = function (attrSet, attrBase, parentAttrBase) {
            if (!attrSet) {
                return;
            }
            var set = attrSet.getDefaultSetter(attrBase, parentAttrBase);
            set('Style', this.style);
            set('Color', this.color);
            set('Alpha', this.alpha);
            set('GradientColor', this.gradientColor);
            set('GradientAngle', this.gradientAngle);
            set('GradientStyle', this.gradientStyle);
            set('GradientAlpha', this.gradientAlpha);
            set('GradientFactor', this.gradientFactor);
            set('RadialGradientOffsetX', this.gradientOffsetX);
            set('RadialGradientOffsetY', this.gradientOffsetY);
            set('ImageName', this.imageDSName);
        };
        /**
         * Read the brush's values from the attribute map
         * @param attrSet - The attribute set to pull the values from
         * @param attrBase - The name of the brush object
         */
        FDSBrush.prototype.constructFromAttributes = function (attrSet, attrBase) {
            if (!attrSet) {
                return;
            }
            // reset to the default values so that short-circuiting below yiels sane values.
            this._init();
            /**
             * Gets an attribute from the attribute set and provides additional
             * debug validation to verify that the value is defined.
             * @param attrSuffix - The string to append to attrBase
             * @param transform - If provided, this transform will be applied before returning.
             */
            function get$$1(attrSuffix, transform) {
                var value = attrSet.get(attrBase + attrSuffix);
                if (ENABLE_DEBUG) {
                    console.assert(value !== undefined, attrBase + attrSuffix + ' returned undefined');
                }
                return transform ? transform(value) : value;
            }
            this.color = get$$1('Color');
            this.alpha = get$$1('Alpha');
            this.style = sanitizeBrushStyle(get$$1('Style'));
            if (this.style !== 1 /* NULL */ && this.style !== 2 /* HATCHED */) {
                // The below attributes are only needed if the brush has a fill.
                this.gradientStyle = get$$1('GradientStyle');
                if (this.style === 4 /* STEPPED */ || this.gradientStyle !== 0 /* NONE */) {
                    // Similarly, gradient attributes are only needed if we have a gradient style
                    this.gradientColorDefault = attrSet.isInheritedDefault(attrBase + 'GradientColor');
                    this.gradientAlphaDefault = attrSet.isInheritedDefault(attrBase + 'GradientAlpha');
                    this.gradientColor = get$$1('GradientColor');
                    this.gradientAlpha = get$$1('GradientAlpha');
                    this.gradientAngle = get$$1('GradientAngle');
                    this.gradientFactor = get$$1('GradientFactor');
                    if (this.gradientStyle === 4 /* RADIAL */) {
                        // And radial gradient offsets are only needed if we are set to the radial gradient style
                        this.gradientOffsetX = get$$1('RadialGradientOffsetX');
                        this.gradientOffsetY = get$$1('RadialGradientOffsetY');
                    }
                }
            }
            this.imageDSName = get$$1('ImageName');
        };
        /**
         * A helper function to fetch the shared gradient info for linear and radial gradients
         * Reduces duplication between toCSSStyle() and toStyle().
         * @param width - the width of the `ClientRect` or `Rectangle`
         * @param height - the height of the `ClientRect` or `Rectangle`
         */
        FDSBrush.prototype._getGradientInfo = function (width, height) {
            var gradientAlpha = this.gradientAlphaDefault ? this.alpha : this.gradientAlpha;
            var gradientColor = this.gradientColorDefault ? this.color : this.gradientColor;
            var offsetX = this.gradientOffsetX;
            var offsetY = this.gradientOffsetY;
            if (Math.abs(offsetX) < 1) {
                offsetX *= width / 2;
            }
            if (Math.abs(offsetY) < 1) {
                offsetY *= height / 2;
            }
            return {
                color1: gradientColor,
                alpha1: gradientAlpha,
                color2: this.color,
                alpha2: this.alpha,
                offsetX: offsetX,
                offsetY: offsetY
            };
        };
        /**
         * Converts the `FDSBrush` object into a CSS style string so that we can style divs like slider handles
         * using the same attributes as a brush drawn on the canvas.
         * @param rect - the `ClientRect` of the `HTMLElement`
         */
        FDSBrush.prototype.toCSSStyle = function (rect) {
            // this is for divs, so the rect should be a clientRect, not an FDS Rectangle
            if (this.style === 1 /* NULL */) {
                return 'transparent';
            }
            if (this.gradientStyle !== 0 /* NONE */) {
                var _a = this._getGradientInfo(rect.width, rect.height), color1 = _a.color1, alpha1 = _a.alpha1, color2 = _a.color2, alpha2 = _a.alpha2, offsetX = _a.offsetX, offsetY = _a.offsetY;
                var hexColor1 = COLORREFtoCSSColor(color1, alpha1);
                var hexColor2 = COLORREFtoCSSColor(color2, alpha2);
                switch (this.gradientStyle) {
                    case 4 /* RADIAL */:
                        var posString = '';
                        if (rect.width !== 0 && rect.height !== 0) {
                            var xPct = (rect.width / 2 + offsetX) * 100 / rect.width;
                            var yPct = (rect.height / 2 + offsetY) * 100 / rect.height;
                            posString = xPct + "% " + yPct + "%,";
                        }
                        return "-radial-gradient(" + posString + "circle," + hexColor1 + "," + hexColor2 + ")";
                    default:
                        var rval = '-linear-gradient(';
                        switch (this.gradientAngle) {
                            case 90:
                                rval += 'bottom, ';
                                break;
                            case 180:
                                rval += 'right, ';
                                break;
                            case 270:
                                rval += 'top, ';
                                break;
                            default:
                                rval += 'left, ';
                        }
                        switch (this.gradientStyle) {
                            case 2 /* FULL_IO */:
                                rval += hexColor2 + ", " + hexColor1 + " 50%, " + hexColor2;
                                break;
                            case 3 /* FULL_OI */:
                                rval += hexColor1 + ", " + hexColor2 + " 50%, " + hexColor1;
                                break;
                            default:// GradientStyle.HALF
                                rval += hexColor1 + ", " + hexColor2;
                        }
                        rval += ')';
                        return rval;
                }
            }
            else if (this.style === 2 /* HATCHED */) {
                // Create a hatch pattern
                var fillCanvas = CanvasLayer.createHatchCanvas(this.color);
                return "url(" + fillCanvas.toDataURL('image/png') + ")";
            }
            else {
                return COLORREFtoCSSColor(this.color, this.alpha);
            }
        };
        /**
         * Convert the brush into an HTML5 canvas fillStyle for the brush
         * @param ctx - the chart rendering context
         * @param rect - The rect used for scaling and positioning the gradient.
         */
        FDSBrush.prototype._toStyle = function (ctx, rect) {
            // This used to also be dependent on if 'this.gradientStyle is GradientStyle.NONE' but it
            // appears the PC- side just goes transparent regardless if @style is BrushStyle.NULL.
            if (this.style === 1 /* NULL */) {
                return { brushType: 'none' };
            }
            if (this._lightDirection != null && rect != null) {
                return this._getBubble3dGradientInfo(rect, this._lightDirection);
            }
            if (this.gradientStyle !== 0 /* NONE */ && rect) {
                var _a = this._getGradientInfo(rect.getWidth(), rect.getHeight()), color1 = _a.color1, alpha1 = _a.alpha1, color2 = _a.color2, alpha2 = _a.alpha2, offsetX = _a.offsetX, offsetY = _a.offsetY;
                if (this.gradientStyle === 4 /* RADIAL */) {
                    var center = rect.centerPoint();
                    // make sure the radius can reach from the offset center to the edge of the rect
                    var radius = Math.max(rect.getWidth(), rect.getHeight()) + Math.max(offsetX, offsetY);
                    return {
                        brushType: 'radialGradient',
                        x1: center.x + offsetX,
                        y1: center.y + offsetY,
                        r1: 0,
                        x2: center.x,
                        y2: center.y,
                        r2: radius,
                        stops: [
                            { offset: 0, color: color2, alpha: alpha2 },
                            { offset: 0.5, color: color1, alpha: alpha1 }
                        ]
                    };
                }
                else {
                    // The PC chart doesn't even support gradients with non-square angles,
                    // so we won't either. Zero degrees is actually east (visually), not
                    // north.
                    var x1 = void 0;
                    var x2 = void 0;
                    var y1 = void 0;
                    var y2 = void 0;
                    var len = void 0;
                    switch (this.gradientAngle) {
                        case 90:
                            x1 = x2 = rect.x1;
                            len = (rect.y2 - rect.y1) * this.gradientFactor;
                            y1 = rect.y1;
                            y2 = rect.y1 + len;
                            break;
                        case 180:
                            len = (rect.x2 - rect.x1) * this.gradientFactor;
                            x1 = rect.x1;
                            x2 = rect.x1 + len;
                            y1 = y2 = rect.y1;
                            break;
                        case 270:
                            x1 = x2 = rect.x1;
                            len = (rect.y2 - rect.y1) * this.gradientFactor;
                            y1 = rect.y2;
                            y2 = rect.y2 - len;
                            break;
                        default:
                            len = (rect.x2 - rect.x1) * this.gradientFactor;
                            x1 = rect.x2;
                            x2 = rect.x2 - len;
                            y1 = y2 = rect.y1;
                    }
                    var stops = void 0;
                    switch (this.gradientStyle) {
                        case 2 /* FULL_IO */:
                            stops = [
                                { offset: 0.0, color: color2, alpha: alpha2 },
                                { offset: 0.5, color: color1, alpha: alpha1 },
                                { offset: 1.0, color: color2, alpha: alpha2 },
                            ];
                            break;
                        case 3 /* FULL_OI */:
                            stops = [
                                { offset: 0.0, color: color1, alpha: alpha1 },
                                { offset: 0.5, color: color2, alpha: alpha2 },
                                { offset: 1.0, color: color1, alpha: alpha1 },
                            ];
                            break;
                        default:// GradientStyle.HALF
                            stops = [
                                { offset: 0.0, color: color2, alpha: alpha2 },
                                { offset: 1.0, color: color1, alpha: alpha1 },
                            ];
                    }
                    return {
                        brushType: 'linearGradient',
                        x1: x1, y1: y1,
                        x2: x2, y2: y2,
                        stops: stops
                    };
                }
            }
            else if (this.style === 2 /* HATCHED */) {
                return { brushType: 'pattern' };
            }
            else {
                return { brushType: 'solid', color: this.color, alpha: this.alpha };
            }
        };
        FDSBrush.prototype.setBubble3dMode = function (lightDirection) {
            this._lightDirection = lightDirection;
        };
        FDSBrush.prototype._getBubble3dGradientInfo = function (rect, lightDirection) {
            var center = rect.centerPoint();
            var radius = Math.min(rect.getWidth(), rect.getHeight());
            var offsetY = 0;
            var offsetX = 0;
            var offsetAmt = 0.15 * radius; // 15% is a good amount to shift the lightshine by
            switch (lightDirection) {
                case 0 /* TOP */:
                    offsetY = -offsetAmt;
                    break;
                case 1 /* BOTTOM */:
                    offsetY = offsetAmt;
                    break;
                case 2 /* LEFT */:
                    offsetX = -offsetAmt;
                    break;
                case 3 /* RIGHT */:
                    offsetX = offsetAmt;
                    break;
                case 4 /* TOP_LEFT */:
                    offsetX = -offsetAmt;
                    offsetY = -offsetAmt;
                    break;
                case 5 /* TOP_RIGHT */:
                    offsetX = offsetAmt;
                    offsetY = -offsetAmt;
                    break;
                case 6 /* BOTTOM_LEFT */:
                    offsetX = -offsetAmt;
                    offsetY = offsetAmt;
                    break;
                case 7 /* BOTTOM_RIGHT */:
                    offsetX = offsetAmt;
                    offsetY = offsetAmt;
                    break;
            }
            var _a = COLORREFtoRGB(this.color), r1 = _a[0], g1 = _a[1], b1 = _a[2];
            var alpha = this.alpha / 255;
            return {
                brushType: 'radialGradient',
                x1: center.x + offsetX,
                y1: center.y + offsetY,
                r1: 0,
                x2: center.x,
                y2: center.y,
                r2: radius,
                stops: [
                    { offset: 0, color: 16777215 /* WHITE */, alpha: this.alpha },
                    { offset: 0.4, color: this.color, alpha: this.alpha },
                    { offset: 0.9, color: 0 /* BLACK */, alpha: this.alpha },
                ]
            };
        };
        FDSBrush.prototype.toPropertyObject = function (ctx, rect) {
            return {
                fillStyle: this._toStyle(ctx, rect)
            };
        };
        /**
         * sets the canvas draw propertiesto match this brush's properties
         * @param ctx - the chart rendering context
         * @param rect? - If provided, this rectangle is used for scaling and positioning gradients
         */
        FDSBrush.prototype.setOnCanvas = function (ctx, rect) {
            ctx.setBrush(this, rect);
        };
        return FDSBrush;
    }(BaseDrawingPrimitive));
    
    function sanitizePenStyle(style) {
        if (style > 5 || style < 0) {
            if (ENABLE_DEBUG) {
                console.warn("PenStyle value '" + style + "' is out of range or unsupported.");
            }
            return 5 /* NULL */;
        }
        else {
            return style;
        }
    }
    /**
     * Consolidates a bunch of properties about drawing outlines / lines
     * And provides facilities for reading/writing those properties
     * from chart attributes
     */
    var FDSPen = /** @class */ (function () {
        /**
         * Create a new pen object.
         * @constructor
         */
        function FDSPen(options) {
            this.width = 1.0;
            this.color = 0;
            this.style = 0 /* SOLID */;
            this.dashFactor = 1.0;
            this.lineCap = 'round';
            // used for dashed line drawing
            this._hasStartedPolyline = false;
            _$1.assign(this, options);
        }
        FDSPen.prototype.with = function (options) {
            return new FDSPen(_$1.defaults(options, this));
        };
        FDSPen.prototype.equals = function (other) {
            // Short circuit if the references are equal
            return this === other || (this.width === other.width &&
                this.color === other.color &&
                this.style === other.style &&
                this.dashFactor === other.dashFactor &&
                this.lineCap === other.lineCap);
        };
        /**
         * Copy the other pen's attributes if ours are defaulted
         * @param otherPen - The pen to inherit values from
         * @param attrSet - The attribute set to pull values from
         * @param attrBase - The base name to use as a prefix. `attrBase+'Color'`, etc.
         */
        FDSPen.prototype.inheritFromOtherPen = function (otherPen, attrSet, attrBase) {
            // Simple wrapper function to reduce code-duplication.
            // technically this might have been simpler, if the wrapper also inlined `this[param] = otherPen[param]`
            // But that sort of pattern would prevent us from minifying parameters as aggressively.
            var ifDefault = function (attrSuffix, func) {
                if (attrSet.isDefault(attrBase + attrSuffix)) {
                    func();
                }
            };
            var options = {};
            ifDefault('Width', function () { return options.width = otherPen.width; });
            ifDefault('Color', function () { return options.color = otherPen.color; });
            ifDefault('Style', function () { return options.style = otherPen.style; });
            ifDefault('DashFactor', function () { return options.dashFactor = otherPen.dashFactor; });
            ifDefault('LineCap', function () { return options.lineCap = otherPen.lineCap; });
            return this.with(options);
        };
        /**
         * Writes the default attributes for this pen into the default map
         * @param attrSet - The `AttributeSet` where the the pen's attributes will reside.
         * @param attrBase - The prefix used for this pen's attributes 'SeriesFG', 'SeriesOutline', etc.
         * @param parentAttrBase - The prefix for the chart-level pen to inherit from.
         */
        FDSPen.prototype.writeToAttrSet = function (attrSet, attrBase, parentAttrBase) {
            // Get a setter-functor that so we don't need to duplicate the concatenating of base and parent attribute names.
            var setDefault = attrSet.getDefaultSetter(attrBase, parentAttrBase);
            setDefault('Width', this.width);
            setDefault('Color', this.color);
            setDefault('Style', this.style);
            setDefault('DashFactor', this.dashFactor);
            setDefault('LineCap', this.lineCap);
        };
        /**
         * Read the pen's values from the attribute map
         * @param attrSet - The attribute set to pull the values from
         * @param attrBase - The name of the pen object
         */
        FDSPen.constructFromAttributes = function (attrSet, attrBase) {
            /**
             * Gets an attribute from the attribute set and provides additional
             * debug validation to verify that the value is defined.
             * @param attrSuffix - The string to append to attrBase
             * @param transform - If provided, this transform will be applied before returning.
             */
            function get$$1(attrSuffix, transform) {
                var value = attrSet.get(attrBase + attrSuffix);
                if (ENABLE_DEBUG) {
                    console.assert(value !== undefined, attrBase + attrSuffix + ' returned undefined');
                }
                return transform ? transform(value) : value;
            }
            var options = {};
            options.style = sanitizePenStyle(get$$1('Style'));
            if (options.style !== 5 /* NULL */) {
                options.width = get$$1('Width');
                options.color = get$$1('Color');
                options.lineCap = get$$1('LineCap', function (cap) { return cap.toLowerCase(); });
                if (options.style !== 0 /* SOLID */) {
                    options.dashFactor = get$$1('DashFactor');
                }
            }
            return new FDSPen(options);
        };
        /**
         * With the HTML5 Canvas, the pixel center is located at `[0.5, 0.5]`. Consequently,
         * when drawing a horizontal line from `[0, 0]` to `[10, 0]`, the line will be drawn
         * spanning the pixel boundary instead of filling the pixel.
         *
         * This is particularly problematic for odd-width lines. A one pixel black line, for example,
         * will draw itself with half-a-pixel of black on either side of the boundary. Due to
         * anti-aliasing, this will manifest itself as a 2px wide gray line instead of a 1px wide black line.
         *
         * To accomodate for this and provide crisp line rendering, we need to accomodate for line width
         * (and device pixel ratio) and return an offset of either 0 or 0.5 pixels depending on what is needed.
         * @return {number} - 0 or 0.5 pixels.
         */
        FDSPen.prototype.getAliasOffset = function () {
            if (this.style === 5 /* NULL */) {
                return 0;
            }
            // If the actual (after applying devicePixelRatio) line width is even, we
            // don't want to add a half-pixel to our drawing coordinate, since it'll
            // make the line anti-aliased (when we really want it to be aliased). If
            // the width is odd, however, we *do* want to add that half-pixel.
            if (this._getDeviceLineWidth() % 2 !== 0) {
                // A specified width of zero actually means to draw as a single-pixel
                // line regardless of `devicePixelRatio`, so we need to offset it by
                // a half-pixel
                return 0.5;
            }
            else {
                // odd width lines draw on half-pixel boundaries
                return 0;
            }
        };
        FDSPen.prototype._getDeviceLineWidth = function () {
            return this.width === 0 ? 1 : scaleByDevicePixelRatioAndRound(this.width);
        };
        /**
         * Converts the pen's data into a more directly consumed format for rendering.
         */
        FDSPen.prototype.toPropertyObject = function () {
            // save the color too, sometimes we want this even when the pen is null
            var color = COLORREFtoHex(this.color);
            var width = this._getDeviceLineWidth();
            return {
                lineWidth: width,
                strokeStyle: this.style === 5 /* NULL */ ? 'transparent' : color,
                willDrawStroke: this.style !== 5 /* NULL */,
                aliasOffset: this.getAliasOffset(),
                color: color,
                lineCap: width > 2 ? this.lineCap : 'butt'
            };
        };
        /**
         * Converts the dash style into an array with alternating line and gap lengths.
         */
        FDSPen.prototype.getDashArray = function () {
            // the length of the spaces is increased by the width of the line
            // this is because each cap is (lineWidth / 2), and there are two caps per gap
            var lineWidth = this._getDeviceLineWidth();
            var shouldAdjustSpaces = (this.lineCap === 'round' || this.lineCap === 'square');
            // Since negative values and zero would be bad here. A minimum value of 0.25
            // results in a dot size of one pixel, so that seems like a good place to clamp.
            var safeDashFactor = Math.max(this.dashFactor, 0.25);
            // Figure out how big the different components of a dashed/dotted line should be
            var space = (5 + (shouldAdjustSpaces ? lineWidth : 0)) * safeDashFactor;
            var dot = 4 * safeDashFactor;
            var dash = 10 * safeDashFactor;
            switch (this.style) {
                case 2 /* DOT */:
                    return [dot, space];
                case 1 /* DASH */:
                    return [dash, space];
                case 3 /* DASHDOT */:
                    return [dash, space, dot, space];
                case 4 /* DASHDOTDOT */:
                    return [dash, space, dot, space, dot, space];
                default:
                    return [];
            }
        };
        /**
         * Draws a line segment between two points with support for line-dash styles.
         * Note: Up until recently, browsers didn't support native line-dash styles in the HTML5 Canvas.
         * This is our own implementation used selectively in places where we expect to have dashed lines.
         * @param ctx {ChartRenderingContext} - The chart rendering context.
         * @param p1 - the first point of the line segment
         * @param p2 - the first point of the line segment
         */
        FDSPen.prototype._drawLineInternal = function (ctx, p1, p2) {
            if (!(isFinite(p1.x) && isFinite(p1.y) && isFinite(p2.x) && isFinite(p2.y))) {
                if (ENABLE_DEBUG) {
                    console.log('FDSPen::drawLineInternal - Trying to draw to infinite point, bailing.');
                }
                return;
            }
            if (!this._hasStartedPolyline) {
                ctx.moveTo(p1.x, p1.y);
                this._hasStartedPolyline = true;
            }
            ctx.lineTo(p2.x, p2.y);
        };
        /**
         * For solid lines, this function ultimately just calls moveTo/lineTo on the canvas context to create a line segment
         * as part of the current path. For dashed line styles, this will call moveTo/lineTo repeatedly to manually draw the
         * line dashes
         * @param ctx - the chart rendering context
         * @param p1 - the first point of the line segment
         * @param p2 - the first point of the line segment
         */
        FDSPen.prototype.drawPolyline = function (ctx, p1, p2) {
            this._drawLineInternal(ctx, p1, p2);
        };
        /**
         * Signals the end of the polyline. This resets internal state for line dashing such as the dash offset
         * and whether or not we are currently in a dash or in a gap.
         */
        FDSPen.prototype.closePolyline = function () {
            this._hasStartedPolyline = false;
        };
        /**
         * sets the canvas draw propertiesto match this pen's properties
         * @param ctx - the chart rendering context
         */
        FDSPen.prototype.setOnCanvas = function (ctx, unused) {
            ctx.setPen(this);
        };
        /**
         * Instructs the canvas context to use the pen's stroke color as the fill color as well.
         * @param ctx - the chart rendering context
         */
        FDSPen.prototype.useAsFill = function (ctx) {
            var penColoredBrush = new FDSBrush();
            penColoredBrush.color = this.color;
            penColoredBrush.style = 0 /* SOLID */;
            ctx.setBrush(penColoredBrush);
        };
        return FDSPen;
    }());
    
    /**
     * An extremely basic helper class for holding 2D and 3D points
     */
    var Point = /** @class */ (function () {
        /**
         * @constructor
         * @param x - the x coordinate
         * @param y - the y coordinate
         */
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        /**
         * creates a new point at the origin
         */
        Point.zero = function () {
            return new Point(0, 0);
        };
        /**
         * Adds another `Point` or a number as an offset, and return a new `Point` at that offset.
         * @param p - If of type `Point`, vector addition is performed. If of type `number`, scalar addition is performed.
         * @return a new point, offset by the value passed in.
         */
        Point.prototype.add = function (p) {
            var newPt = this.copy();
            if (p instanceof Point) {
                newPt.x += p.x;
                newPt.y += p.y;
            }
            else {
                newPt.x += p;
                newPt.y += p;
            }
            return newPt;
        };
        /**
         * Adds another `Point` or a number as an offset, and return a new `Point` at that offset.
         * @param p - If of type `Point`, vector subtraction is performed. If of type `number`, scalar subtraction is
         *   performed.
         * @return a new point, offset by the value passed in.
         */
        Point.prototype.subtract = function (p) {
            var newPt = this.copy();
            if (p instanceof Point) {
                newPt.x -= p.x;
                newPt.y -= p.y;
            }
            else {
                newPt.x -= p;
                newPt.y -= p;
            }
            return newPt;
        };
        /**
         * @return a formatted string for debugging purposes
         */
        Point.prototype.toString = function () {
            return this.x + ", " + this.y;
        };
        /**
         * Determines if two `Point` objects are equal
         */
        Point.prototype.isEqual = function (other) {
            return this.x === other.x && this.y === other.y;
        };
        /**
         * rounds the components of this `Point` to the nearest integer, and returns the new `Point`.
         * @return a new `Point` with integral components.
         */
        Point.prototype.roundToInt = function () {
            return new Point(Math.round(this.x), Math.round(this.y));
        };
        /**
         * @return a copy of this `Point`
         */
        Point.prototype.copy = function () {
            return new Point(this.x, this.y);
        };
        return Point;
    }());
    
    /**
     * Base class for hit shapes
     *
     * @abstract
     * @class FDSShape
     */
    var FDSShape = /** @class */ (function () {
        function FDSShape() {
            /**
             * the index of the datapoint associated with the hit shape
             */
            this.index = 0;
            /**
             * Alternate index used for interactive annotations / drawing tools
             */
            this.altIndex = 0;
            /**
             * The name of the hit shape
             */
            this.name = 'Shape';
            /**
             * Tooltip override text
             */
            this.hoverText = '';
        }
        /**
         * Helper to determine if a shape is inside an x range
         * @param xMin - minimum endpoint of the x range
         * @param xMax - maximum endpoint of the x range
         * @param minX - minimum endpoint of the shape in the x direction
         * @param maxX - maximum endpoint of the shape in the x direction
         * @return s hether or not the shape is inside the range
         */
        FDSShape.prototype._inXRangeHelper = function (xMin, xMax, minX, maxX) {
            return (xMin <= minX && minX <= xMax) || (xMin <= maxX && maxX <= xMax) || (minX <= xMin && xMax <= maxX);
        };
        /**
         * Given this shape and a rectangle that is overlapping it, provide a shift for the
         * rectangle in either the positive or negative y direction to avoid the overlap.
         *
         * @param x1 - the x-coordinate of the first corner of the rectangle
         * @param y1 - the y-coordinate of the first corner of the rectangle
         * @param x2 - the x-coordinate of the second corner of the rectangle
         * @param y2 - the x-coordinate of the second corner of the rectangle
         * @param moveUp - whether the shift should be upwards (negative Y)
         * @returns the amount to shift in the given direction in pixels
         */
        FDSShape.prototype.getAvoidanceOffset = function (x1, y1, x2, y2, moveUp) {
            return 0;
        };
        /**
         * The distance of the {x,y} point from the centroid of the hit shape
         *
         * @param x - the x-coordinate being tested
         * @param y - the y-coordinate being tested
         * @returns the distance
         */
        FDSShape.prototype.distancesFromCentroid = function (x, y) {
            return new Point(0, 0);
        };
        // Draws over the hitshape to make debugging easier
        FDSShape.prototype.shadeShape = function (ctx) {
            var brush = new FDSBrush();
            brush.alpha = 100;
            brush.color = 16711935;
            brush.style = 0 /* SOLID */;
            ctx.setBrush(brush);
        };
        return FDSShape;
    }());
    function isShapeAnnotRectangle(shape) {
        return shape.name === 'AnnotRectangle';
    }
    
    var Range = /** @class */ (function () {
        /**
         * Constructs a range given values
         */
        function Range(start, end) {
            this.start = start;
            this.end = end;
            if (this.start > this.end) {
                _a = [this.end, this.start], this.start = _a[0], this.end = _a[1];
            }
            this.size = this.end - this.start;
            var _a;
        }
        Range.fromRectangle = function (rect, dimension) {
            if (dimension === 1 /* X */) {
                return new Range(rect.x1, rect.x2);
            }
            else {
                return new Range(rect.y1, rect.y2);
            }
        };
        /**
         * Compares two ranges and returns the overlap information.
         *
         * @param {Range} A The first range
         * @param {Range} B The second range
         */
        Range.CheckForOverlap = function (A, B) {
            if (A.start > A.end) {
                A = new Range(A.end, A.start);
            }
            if (B.start > B.end) {
                B = new Range(B.end, B.start);
            }
            if (A.start < B.start) {
                if (A.end < B.end) {
                    if (A.end <= B.start) {
                        /*  A---A          */
                        /*          B---B  */
                        /*  A          */
                        /*      B---B  */
                        /*  A---A      */
                        /*          B  */
                        /*  A      */
                        /*      B  */
                        /*  A---A      */
                        /*      B---B  */
                        return 0 /* CLEAR_START */;
                    }
                    else {
                        /*  A---A    */
                        /*    B---B  */
                        return 1 /* OVERLAP_START */;
                    }
                }
                else if (A.end === B.end) {
                    /*  A-----A    */
                    /*    B---B    */
                    /*  A---A  */
                    /*      B  */
                    return 1 /* OVERLAP_START */;
                }
                else {
                    /*  A-------A  */
                    /*    B---B    */
                    /*  A-----A  */
                    /*     B     */
                    return 2 /* AROUND */;
                }
            }
            else if (A.start === B.start) {
                if (A.end < B.end) {
                    /*  A---A    */
                    /*  B-----B  */
                    /*  A      */
                    /*  B---B  */
                    return 4 /* INSIDE */;
                }
                else if (A.end === B.end) {
                    /*  A---A  */
                    /*  B---B  */
                    /*  A  */
                    /*  B  */
                    return 3 /* EQUAL */;
                }
                else {
                    /*  A-----A  */
                    /*  B---B    */
                    /*  A---A  */
                    /*  B      */
                    return 5 /* OVERLAP_END */;
                }
            }
            else {
                if (A.end <= B.end) {
                    /*    A---A    */
                    /*  B-------B  */
                    /*    A    */
                    /*  B---B  */
                    /*    A---A  */
                    /*  B-----B  */
                    /*      A  */
                    /*  B---B  */
                    return 4 /* INSIDE */;
                }
                else {
                    if (A.start < B.end) {
                        /*    A---A  */
                        /*  B---B    */
                        return 5 /* OVERLAP_END */;
                    }
                    else {
                        /*      A---A  */
                        /*  B---B      */
                        /*      A  */
                        /*  B      */
                        /*      A---A  */
                        /*  B          */
                        /*          A  */
                        /*  B---B      */
                        /*          A---A  */
                        /*  B---B          */
                        return 6 /* CLEAR_END */;
                    }
                }
            }
        };
        return Range;
    }());
    
    /**
     * A rectangle defined by its upper-left and lower-right coordiantes.
     * Useful for boundaries and hit testing.
     */
    var Rectangle = /** @class */ (function () {
        /**
         * Constructs a rectangle given optional coordinates
         * @constructor
         * @param x1 - the first x coordinate
         * @param y1 - the first y coordinate
         * @param x2 - the second x coordinate
         * @param y2 - the second y coordinate
         */
        function Rectangle(x1, y1, x2, y2) {
            if (x1 === void 0) { x1 = 0; }
            if (y1 === void 0) { y1 = 0; }
            if (x2 === void 0) { x2 = 0; }
            if (y2 === void 0) { y2 = 0; }
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
            if (this.x1 > this.x2) {
                _a = [this.x2, this.x1], this.x1 = _a[0], this.x2 = _a[1];
            }
            if (this.y1 > this.y2) {
                _b = [this.y2, this.y1], this.y1 = _b[0], this.y2 = _b[1];
            }
            var _a, _b;
        }
        Object.defineProperty(Rectangle.prototype, "x", {
            get: function () {
                return this.x1;
            },
            set: function (newX) {
                var width = this.width;
                this.x1 = newX;
                this.x2 = newX + width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "y", {
            get: function () {
                return this.y1;
            },
            set: function (newY) {
                var height = this.height;
                this.y1 = newY;
                this.y2 = newY + height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "width", {
            get: function () {
                return Math.max(this.x1, this.x2) - Math.min(this.x1, this.x2);
            },
            set: function (newWidth) {
                this.x2 = this.x1 + newWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Rectangle.prototype, "height", {
            get: function () {
                return Math.max(this.y1, this.y2) - Math.min(this.y1, this.y2);
            },
            set: function (newHeight) {
                this.y2 = this.y1 + newHeight;
            },
            enumerable: true,
            configurable: true
        });
        Rectangle.constructFromIRectangle = function (rect) {
            return new Rectangle(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height);
        };
        Rectangle.constructFromPositionWidthAndHeight = function (_a, width, height) {
            var x = _a.x, y = _a.y;
            return new Rectangle(x, y, x + width, y + height);
        };
        /**
         * Resets the rectangle's coordinates
         * @param x1 - the first x coordinate
         * @param y1 - the first y coordinate
         * @param x2 - the second x coordinate
         * @param y2 - the second y coordinate
         */
        Rectangle.prototype.setRect = function (x1, y1, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
            return this;
        };
        /**
         * Scales each of the rectangle's coordinates.
         * @param widthScaleFactor - the factor by which to scale the rectangle's x coordiates
         * @param heightScaleFactor - the factor by which to scale the rectangle's y coordiates
         */
        Rectangle.prototype.scaleRect = function (widthScaleFactor, heightScaleFactor) {
            this.x1 *= widthScaleFactor;
            this.x2 *= widthScaleFactor;
            this.y1 *= heightScaleFactor;
            this.y2 *= heightScaleFactor;
        };
        /**
         * sets all coordinates to 0, resulting in an empty rectangle (width and height are zero).
         * @return 'this' for chaining.
         */
        Rectangle.prototype.setRectEmpty = function () {
            this.x1 = this.y1 = this.x2 = this.y2 = 0;
            return this;
        };
        /**
         * Gets the width of the rectangle
         * @return the width of the rectangle
         */
        Rectangle.prototype.getWidth = function () {
            return Math.abs(this.x2 - this.x1);
        };
        /**
         * Gets the height of the rectangle
         * @return the height of the rectangle
         */
        Rectangle.prototype.getHeight = function () {
            return Math.abs(this.y2 - this.y1);
        };
        /**
         * Performs hit testing on the rectangle given a point
         * @param point - The point being tested
         */
        Rectangle.prototype.hit = function (point) {
            var halfPixelTolerance = 0.5;
            return isBounded(point.x, this.x1, this.x2, halfPixelTolerance) &&
                isBounded(point.y, this.y1, this.y2, halfPixelTolerance);
        };
        /**
         * Given a value in 'Non-Device Coordinate' space, convert to pixels
         * @param value - The value to be converted
         * @param dimension - Which dimension the conversion is happening in X or Y.
         */
        Rectangle.prototype.fromNDC = function (value, dimension) {
            if (dimension === 1 /* X */) {
                return value * this.getWidth();
            }
            else {
                // y == 0 is defined as the bottom left in the chart, so we need to flip the y-axis
                return (1 - value) * this.getHeight();
            }
        };
        /**
         * Offset the coordinates of this rectangle by the specified `x` and `y` coordinates
         */
        Rectangle.prototype.offsetRect = function (x, y) {
            this.x1 += x;
            this.x2 += x;
            this.y1 += y;
            this.y2 += y;
        };
        /**
         * Converts `value` from pixel space to 'non-device coordinate' space
         * @param value - The value to convert in pixels
         * @param dimension - Which dimension the conversion is happening in (X or Y)
         */
        Rectangle.prototype.toRectNDC = function (value, dimension) {
            if (dimension === 1 /* X */) {
                return value / this.getWidth();
            }
            else {
                return value / this.getHeight();
            }
        };
        /**
         * Converts `value` from global pixel space to local 'non-device coordinate' space
         * @param value - The value to convert in pixels
         * @param dimension - Which dimension the conversion is happening in (X or Y)
         */
        Rectangle.prototype.globalPixelsToRectNdc = function (value, dim) {
            if (dim === 1 /* X */) {
                return this.getWidth() <= 0 ? 0 : (value - this.x1) / this.getWidth();
            }
            else {
                return this.getHeight() <= 0 ? 0 : (value - this.y1) / this.getHeight();
            }
        };
        /**
         * This function takes a value in 'non-device coordinate' space, transforms to pixel space
         * @param value - A value in 'non-device coordinate' space.
         * @param dimension - The dimension the conversion is happening in (X or Y)
         * @param penProps - the pen property object
         */
        Rectangle.prototype.rectNdcToGlobalPixels = function (value, dimension) {
            if (dimension === 1 /* X */) {
                return Math.round(this.x1 + value * this.getWidth());
            }
            else {
                return Math.round(this.y1 + (1 - value) * this.getHeight());
            }
        };
        /**
         * Copy initialization from another rectangle.
         * @param rect the rectangle we are copying
         */
        Rectangle.prototype.constructFromRect = function (rect) {
            this.x1 = rect.x1;
            this.y1 = rect.y1;
            this.x2 = rect.x2;
            this.y2 = rect.y2;
        };
        /**
         * clones the current Rectangle and returns a
         * @return a copy of `this`
         */
        Rectangle.prototype.copy = function () {
            return new Rectangle(this.x1, this.y1, this.x2, this.y2);
        };
        /**
         * gets the center point
         * @return the center `Point`
         */
        Rectangle.prototype.centerPoint = function () {
            return (new Point((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2));
        };
        /**
         * Given an array of points, return the bounding rectangle
         * @param pts - an array of points {x,y}
         */
        Rectangle.constructBoundingBoxFromPts = function (pts) {
            var minX = Number.POSITIVE_INFINITY;
            var maxX = Number.NEGATIVE_INFINITY;
            var minY = Number.POSITIVE_INFINITY;
            var maxY = Number.NEGATIVE_INFINITY;
            for (var _i = 0, pts_1 = pts; _i < pts_1.length; _i++) {
                var pt = pts_1[_i];
                if (pt.x < minX) {
                    minX = pt.x;
                }
                if (pt.x > maxX) {
                    maxX = pt.x;
                }
                if (pt.y < minY) {
                    minY = pt.y;
                }
                if (pt.y > maxY) {
                    maxY = pt.y;
                }
            }
            return new Rectangle(minX, minY, maxX, maxY);
        };
        Rectangle.prototype.fill = function (ctx) {
            ctx.fillRect(~~this.x, ~~this.y, ~~this.width, ~~this.height);
        };
        Rectangle.prototype.stroke = function (ctx) {
            ctx.strokeRectAligned(~~this.x, ~~this.y, ~~this.width, ~~this.height);
        };
        Rectangle.prototype.strokeInternal = function (ctx) {
            // TODO: use proper width instead of 1
            ctx.strokeRectInternalAligned(~~this.x, ~~this.y, ~~this.width, ~~this.height);
        };
        Rectangle.prototype.clampValueToBounds = function (value, dimension) {
            var min$$1 = (dimension === 1 /* X */) ? this.x : this.y;
            var max$$1 = (dimension === 1 /* X */) ? this.width : this.height;
            return clamp(value, min$$1, max$$1);
        };
        Rectangle.doRectanglesIntersect = function (rect, compareRect, aliasOffset) {
            if (aliasOffset === void 0) { aliasOffset = 0; }
            if (rect === compareRect) {
                return false;
            }
            var rectX1 = (~~rect.x) + aliasOffset;
            var rectX2 = rectX1 + (~~rect.width);
            var rectY1 = (~~rect.y) + aliasOffset;
            var rectY2 = rectY1 + (~~rect.height);
            var compareRectX1 = (~~compareRect.x) + aliasOffset;
            var compareRectX2 = compareRectX1 + (~~compareRect.width);
            var compareRectY1 = (~~compareRect.y) + aliasOffset;
            var compareRectY2 = compareRectY1 + (~~compareRect.height);
            return !(rectX1 >= compareRectX2 || compareRectX1 >= rectX2 || rectY1 >= compareRectY2 || compareRectY1 >= rectY2);
        };
        /**
         * Calculates the axis-aligned bounding box / minimum bounding rectangle
         * from a collection of rectangles
         */
        Rectangle.AABB = function (rectangles) {
            return new Rectangle(_$1.min(rectangles.map(function (r) { return r.x; })), _$1.min(rectangles.map(function (r) { return r.y; })), _$1.max(rectangles.map(function (r) { return r.x + r.width; })), _$1.max(rectangles.map(function (r) { return r.y + r.height; })));
        };
        Rectangle.calcRectangleUnionArea = function (rectA, rectB) {
            var union = Rectangle.AABB([rectA, rectB]);
            return union.width * union.height;
        };
        Rectangle.getRectangleOverlap = function (rectA, rectB) {
            var widthA = new Range(rectA.x, rectA.x + rectA.width);
            var widthB = new Range(rectB.x, rectB.x + rectB.width);
            var heightA = new Range(rectA.y, rectA.y + rectA.height);
            var heightB = new Range(rectB.y, rectB.y + rectB.height);
            return {
                xOverlap: Range.CheckForOverlap(widthA, widthB),
                yOverlap: Range.CheckForOverlap(heightA, heightB)
            };
        };
        return Rectangle;
    }());
    
    /**
     * Class for the rectangle hitshape
     *
     * @class FDSRectangleHitShape
     * @extends FDSShape
     */
    var FDSRectangleHitShape = /** @class */ (function (_super) {
        __extends(FDSRectangleHitShape, _super);
        /**
         * Actual constructor implementation of the above overloads
         */
        function FDSRectangleHitShape(x, y, width, height) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            var _this = _super.call(this) || this;
            _this.name = 'FDSRectangleHitShape';
            if (typeof x === 'number') {
                _this.x = x;
                _this.y = y;
                _this.width = width;
                _this.height = height;
            }
            else if (x instanceof Rectangle) {
                var rect = x;
                _this.x = Math.min(rect.x1, rect.x2);
                _this.y = Math.min(rect.y1, rect.y2);
                _this.width = Math.abs(rect.x1 - rect.x2);
                _this.height = Math.abs(rect.y1 - rect.y2);
            }
            else if (x instanceof FDSRectangleHitShape) {
                // we've been handed an FDSRectangleHitShape to copy
                var shape = x;
                _this.x = shape.x;
                _this.y = shape.y;
                _this.width = shape.width;
                _this.height = shape.height;
            }
            else {
                return _this;
            }
            return _this;
        }
        /**
         * test for whether a point (or other shape) is inside this rectangle
         *
         * @param x - the x-coordinate of the point (or shape) being tested
         * @param y - the x-coordinate of the point (or shape) being tested
         * @param shape - the type of shape being tested- point, vertical line, or horizontal line. Defaults to point.
         * @returns whether the point (or shape) is inside the rectangle
         */
        FDSRectangleHitShape.prototype.onHitTest = function (x, y, shape) {
            if (shape === void 0) { shape = 0 /* POINT */; }
            switch (shape) {
                case 0 /* POINT */:
                    if (x < this.x || y < this.y || x > (this.x + this.width) || y > (this.y + this.height)) {
                        return false;
                    }
                    return true;
                case 2 /* HLINE */:
                    if (y < this.y || y > (this.y + this.height)) {
                        return false;
                    }
                    return true;
                case 1 /* VLINE */:
                    if (x < this.x || x > (this.x + this.width)) {
                        return false;
                    }
                    return true;
                default:
                    return false;
            }
        };
        /**
         * Check whether another rectangle intersects this one, given two corners
         *
         * @param x1 - the x-coordinate of the first corner
         * @param y1 - the y-coordinate of the first corner
         * @param x2 - the x-coordinate of the second corner
         * @param y2 - the y-coordinate of the second corner
         * @returns true if the rectangles overlap
         */
        FDSRectangleHitShape.prototype.hitTest = function (x1, y1, x2, y2) {
            // normalize rectangle
            if (x2 < x1) {
                _a = [x2, x1], x1 = _a[0], x2 = _a[1];
            }
            if (y2 < y1) {
                _b = [y2, y1], y1 = _b[0], y2 = _b[1];
            }
            return !(this.x >= x2 || (this.x + this.width) <= x1 ||
                this.y >= y2 || (this.y + this.height) <= y1);
            var _a, _b;
        };
        /**
         * Given this rectangle and another rectangle that is overlapping it, provide
         * a shift for the other rectangle in either the positive or negative y direction
         * to avoid the overlap.
         *
         * @param x1 - the x-coordinate of the first corner
         * @param y1 - the y-coordinate of the first corner
         * @param x2 - the x-coordinate of the second corner
         * @param y2 - the y-coordinate of the second corner
         * @param moveUp - whether the shift should be upwards (negative Y)
         * @returns the amount to shift in the given direction in pixels
         */
        FDSRectangleHitShape.prototype.getAvoidanceOffset = function (x1, y1, x2, y2, moveUp) {
            if (moveUp) {
                return Math.min(-1, -Math.abs(Math.min(y1, y2) - (this.y + this.height)));
            }
            else {
                return Math.max(1, Math.abs(Math.max(y1, y2) - this.y));
            }
        };
        /**
         * The distance of a point from the center of this rectangle
         *
         * @param x - the x-coordinate of the point being compared
         * @param y - the y-coordinate of the point being compared
         * @returns the x and y distances
         */
        FDSRectangleHitShape.prototype.distancesFromCentroid = function (x, y) {
            var centroidx = this.x + (this.width / 2.0);
            var centroidy = this.y + (this.height / 2.0);
            return new Point(x - Math.round(centroidx), Math.round(centroidy) - y);
        };
        FDSRectangleHitShape.prototype.shadeShape = function (ctx) {
            ctx.save();
            _super.prototype.shadeShape.call(this, ctx);
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.restore();
        };
        return FDSRectangleHitShape;
    }(FDSShape));
    
    var PlotDragManager = /** @class */ (function () {
        function PlotDragManager(container, chart, theme) {
            if (theme === void 0) { theme = 1 /* QUARTZ */; }
            this._translateTransition = 0.2;
            this._scaleTransition = 0.2;
            this._supportedDragDirection = 1 /* Vertical */;
            this._origLeft = 0;
            this._origTop = 0;
            this._currLeft = 0;
            this._currTop = 0;
            this._transitioning = false;
            this._selectedOffsetX = 0;
            this._selectedOffsetY = 0;
            var QuartzDragTheme = {
                placeholderMargin: 0,
                placeholderBackground: '#E8F4F9',
                placeholderBorderColor: '#6FB7FF',
                placeholderBorderStyle: 'none',
                placeholderBorderWidth: 1,
                backdropColor: '#E8F4F9',
                gripperBackground: '#C8C8C8',
                shadowColor: 'rgba(0, 0, 0, 0.4)'
            };
            var CarbonDragTheme = {
                placeholderMargin: 0,
                placeholderBackground: '#355373',
                placeholderBorderColor: '#003366',
                placeholderBorderStyle: 'none',
                placeholderBorderWidth: 1,
                backdropColor: '#355373',
                gripperBackground: '#C8C8C8',
                shadowColor: 'rgba(0, 0, 0, 0.5)'
            };
            this._container = container;
            this._chart = chart;
            this._theme = theme === 2 /* CARBON */ ? CarbonDragTheme : QuartzDragTheme;
            this.chartTheme = theme;
            this._dragItems = this._setupDivs(this._createElementsFromPlots(container, chart));
            this._selected = null;
            this._setupDragData();
            this._touchMoveEvent = this._onTouchMove.bind(this);
            this._touchEndEvent = this._onTouchEnd.bind(this);
            this._mouseMoveEvent = this._onMouseMove.bind(this);
            this._mouseUpEvent = this._onMouseUp.bind(this);
            this._dropTransitionFinishedEvent = this._dropTransitionFinished.bind(this);
        }
        PlotDragManager.isPlotDragManagerNeeded = function (chart) {
            if (csstransform == null || csstransition == null) {
                return false;
            }
            var dragEnabledCount = _$1.filter(chart.chartPlotList, function (plot) { return plot.plotDragEnabled; }).length;
            return dragEnabledCount > 1;
        };
        PlotDragManager.prototype._reset = function () {
            if (this._container) {
                if (this._backdrop) {
                    if (this._selected) {
                        this._dropSelected();
                    }
                    if (this._transitioning) {
                        // We need to be sure not to redraw on reset.
                        // Not only is it ineffient to do so, but we can find
                        // ourselves in an infinite redraw situation if we
                        // are resetting in response to a draw event.
                        this._dropTransitionFinished(null, { draw: false });
                    }
                    this._container.removeChild(this._backdrop);
                    this._backdrop = null;
                    this._placeholder = null;
                }
            }
        };
        PlotDragManager.prototype.resetFromChart = function () {
            if (this._container && this._plotsHaveChanged()) {
                this._reset();
                this._dragItems = this._setupDivs(this._createElementsFromPlots(this._container, this._chart));
                this._setupDragData();
            }
        };
        PlotDragManager.prototype.clear = function () {
            this._reset();
            this._chart = null;
            this._container = null;
            this._backdrop = null;
            this._dragItems = null;
        };
        PlotDragManager.prototype._plotsHaveChanged = function () {
            if (this._transitioning) {
                return false;
            }
            if (this._chart.chartPlotList.length !== this._dragItems.length) {
                return true;
            }
            for (var _i = 0, _a = this._dragItems; _i < _a.length; _i++) {
                var div = _a[_i];
                var dragData = div.dragData;
                var plot = div.plot;
                // Check if the plot object itself changed.
                if (plot !== this._chart.getObject(plot.id)) {
                    return true;
                }
                // If the drag enabled flag changed, we also need to update things
                if (plot.plotDragEnabled !== dragData.dragEnabled) {
                    return true;
                }
                // Lastly, check if the pixel location of the plot has changed.
                var rect = this._getRectFromPlot(plot, this._chart.chartSubRect);
                if (!_$1.eq(rect, dragData.rect)) {
                    return true;
                }
            }
            return false;
        };
        PlotDragManager.prototype._createElementsFromPlots = function (container, chart) {
            var divs = [];
            var backdropRect = chart.chartSubRect;
            this._backdrop = document.createElement('div');
            this._backdrop.className = 'plotdrag-container';
            this._backdrop.style.position = 'absolute';
            this._backdrop.style.overflow = 'hidden';
            // The divs that we create here need to be scaled since they are created above the chart and plots.
            var minSizeManager = chart.minimumSizeManager;
            var scaledBackDropRect = minSizeManager.scaleRectangle(backdropRect);
            this._backdrop.style.left = scaleByDevicePixelRatioInverse(scaledBackDropRect.x1) + 'px';
            this._backdrop.style.top = scaleByDevicePixelRatioInverse(scaledBackDropRect.y1) + 'px';
            this._backdrop.style.width = scaleByDevicePixelRatioInverse(scaledBackDropRect.getWidth()) + 'px';
            this._backdrop.style.height = scaleByDevicePixelRatioInverse(scaledBackDropRect.getHeight()) + 'px';
            this._backdrop.style.background = this._theme.backdropColor;
            this._backdrop.style.pointerEvents = 'none';
            this._backdrop.style.zIndex = '2';
            this._backdrop.tabIndex = -1;
            container.appendChild(this._backdrop);
            for (var _i = 0, _a = chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                var plotCanvasHolder = document.createElement('div');
                plotCanvasHolder.style.position = 'absolute';
                this._backdrop.appendChild(plotCanvasHolder);
                var rect = minSizeManager.scaleRectangle(this._getRectFromPlot(plot, backdropRect));
                plotCanvasHolder.style.left = rect.x1 + 'px';
                plotCanvasHolder.style.top = rect.y1 + 'px';
                plotCanvasHolder.style.width = rect.getWidth() + 'px';
                plotCanvasHolder.style.height = rect.getHeight() + 'px';
                plotCanvasHolder.tabIndex = -1;
                var plotCanvas = document.createElement('canvas');
                plotCanvas.width = scaleByDevicePixelRatio(plotCanvasHolder.offsetWidth);
                plotCanvas.height = scaleByDevicePixelRatio(plotCanvasHolder.offsetHeight);
                plotCanvas.style.width = '100%';
                plotCanvas.style.height = '100%';
                plotCanvas.style.position = 'absolute';
                plotCanvasHolder.appendChild(plotCanvas);
                divs.push({ div: plotCanvasHolder, plot: plot });
            }
            return divs;
        };
        PlotDragManager.prototype._getRectFromPlot = function (plot, backdropRect) {
            var _a = plot.getXYFactors(), minXFactor = _a.minXFactor, minYFactor = _a.minYFactor, maxXFactor = _a.maxXFactor, maxYFactor = _a.maxYFactor;
            return Rectangle.constructFromPositionWidthAndHeight({
                x: ~~(scaleByDevicePixelRatioInverse(minXFactor - backdropRect.x1)),
                y: ~~(scaleByDevicePixelRatioInverse(minYFactor - backdropRect.y1)),
            }, ~~(scaleByDevicePixelRatioInverse(maxXFactor - minXFactor)), ~~(scaleByDevicePixelRatioInverse(maxYFactor - minYFactor)));
        };
        PlotDragManager.prototype._updateRectsFromPlots = function () {
            if (this._chart == null) {
                return;
            }
            var backdropRect = this._chart.chartSubRect;
            var canvas = this._chart.mergeCanvas(false);
            for (var _i = 0, _a = this._dragItems; _i < _a.length; _i++) {
                var _b = _a[_i], div = _b.div, dragData = _b.dragData, plot = _b.plot;
                dragData.rect = this._getRectFromPlot(plot, backdropRect);
                // The drag data rect is not scaled, so we'll scale whenever we do something based on it here.
                var minSizeManager = this._chart.minimumSizeManager;
                var scaledRect = minSizeManager.scaleRectangle(dragData.rect);
                div.style[csstransform] = "translate(" + scaledRect.x1 + "px, " + scaledRect.y1 + "px)";
                div.style.width = scaledRect.getWidth() + "px";
                div.style.height = scaledRect.getHeight() + "px";
                var imageWidth = ~~(scaleByDevicePixelRatio(scaledRect.getWidth()));
                var imageHeight = ~~(scaleByDevicePixelRatio(scaledRect.getHeight()));
                var plotCanvas = div.children[0].children[0];
                plotCanvas.width = imageWidth;
                plotCanvas.height = imageHeight;
                var ctx = plotCanvas.getContext('2d');
                ctx.drawImage(canvas, minSizeManager.scaleWidth(scaleByDevicePixelRatio(dragData.rect.x1) + backdropRect.x1), minSizeManager.scaleHeight(scaleByDevicePixelRatio(dragData.rect.y1) + backdropRect.y1), imageWidth, imageHeight, 0, 0, imageWidth, imageHeight);
            }
        };
        PlotDragManager.prototype._setupDivs = function (elems) {
            if (this._backdrop) {
                this._backdrop.style.background = '';
            }
            var divs = [];
            for (var _i = 0, elems_1 = elems; _i < elems_1.length; _i++) {
                var _a = elems_1[_i], div = _a.div, plot = _a.plot;
                var translateDiv = document.createElement('div');
                var dragData = new DragData(translateDiv, div);
                translateDiv.style[csstransform] = "translate(" + div.style.left + ", " + div.style.top + ")";
                translateDiv.style.top = '0px';
                translateDiv.style.left = '0px';
                translateDiv.style.width = div.style.width;
                translateDiv.style.height = div.style.height;
                translateDiv.style.position = 'absolute';
                translateDiv.tabIndex = -1;
                var container = div.parentNode;
                this._backdrop.removeChild(div);
                this._backdrop.appendChild(translateDiv);
                translateDiv.appendChild(div);
                div.style.position = 'absolute';
                div.style.top = '0px';
                div.style.left = '0px';
                div.style.width = '100%';
                div.style.height = '100%';
                if (this._backdrop) {
                    div.children[0].style.display = 'none';
                }
                div.style[csstransition] = this._scaleTransition + "s ease-in-out";
                div.style[csstransform] = 'scale(1.0)';
                var touchPadding = typeof window.ontouchstart === 'undefined' ? 0 : 20;
                var grabberDiv = document.createElement('div');
                var grabberOpts = {
                    width: 20 + touchPadding * 2,
                    height: 32 + touchPadding * 2,
                    relativeLeft: 1,
                    relativeTop: 0.5,
                    marginLeft: -(20 + touchPadding),
                    marginTop: -(16 + touchPadding),
                };
                grabberDiv.innerHTML = "<div style='width: " + grabberOpts.width + "px;\n                                             height: " + grabberOpts.height + "px;\n                                             position: relative;\n                                             left: " + grabberOpts.relativeLeft * 100 + "%;\n                                             top: " + grabberOpts.relativeTop * 100 + "%;\n                                             margin-top: " + grabberOpts.marginTop + "px;\n                                             margin-left: " + grabberOpts.marginLeft + "px;\n                                             pointer-events: auto'>\n                                    <svg opacity='1' style='width:20px; height:32px; left: " + touchPadding + "px; top:" + touchPadding + "px; position:absolute; cursor: ns-resize'>\n                                       <rect x='05' y='05' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='11' y='05' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='05' y='11' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='11' y='11' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='05' y='17' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='11' y='17' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='05' y='23' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                       <rect x='11' y='23' style='fill: " + this._theme.gripperBackground + ";' width='4' height='4'></rect>\n                                    </svg>\n                                 </div>";
                this._cachePlotGrabberPixelPoint(plot.id, dragData, grabberOpts);
                grabberDiv.children[0].children[0].addEventListener('mousedown', this._onMouseDown.bind(this), true);
                if (typeof window.ontouchstart !== 'undefined') {
                    grabberDiv.children[0].addEventListener('touchstart', this._ontouchStart.bind(this), true);
                }
                div.appendChild(grabberDiv.children[0]);
                divs.push({ div: translateDiv, plot: plot, dragData: dragData });
            }
            return divs;
        };
        PlotDragManager.prototype._cachePlotGrabberPixelPoint = function (plotId, dragData, grabberOptions) {
            var dragRect = dragData.rect;
            var x1 = dragRect.x1 + dragRect.getWidth() * grabberOptions.relativeLeft + grabberOptions.marginLeft;
            var x2 = x1 + grabberOptions.width;
            var y1 = dragRect.y1 + dragRect.getHeight() * grabberOptions.relativeTop + grabberOptions.marginTop;
            var y2 = y1 + grabberOptions.height;
            var x = ~~scaleByDevicePixelRatio((x1 + x2) / 2);
            var y = ~~scaleByDevicePixelRatio((y1 + y2) / 2);
            this._chart.plotGrabberPixelPoints[plotId] = { x: x, y: y };
        };
        PlotDragManager.prototype._getDragItemFromDiv = function (element) {
            return _$1.find(this._dragItems, function (item) { return item.div === element; });
        };
        PlotDragManager.prototype._getDragItemFromTouchTarget = function (target) {
            return this._getDragItemFromDiv(target.parentNode.parentNode);
        };
        PlotDragManager.prototype._getDragItemFromMouseTarget = function (target) {
            return this._getDragItemFromDiv(target.parentNode.parentNode.parentNode);
        };
        PlotDragManager.prototype._getTouchTargetFromDiv = function (div) {
            return div.children[0].children[1];
        };
        PlotDragManager.prototype._getMouseTargetFromDiv = function (div) {
            return this._getTouchTargetFromDiv(div).children[0];
        };
        PlotDragManager.prototype._testDragSupported = function (direction) {
            return (this._supportedDragDirection & direction) !== 0;
        };
        PlotDragManager.prototype._setupDragData = function () {
            for (var _i = 0, _a = this._dragItems; _i < _a.length; _i++) {
                var _b = _a[_i], divA = _b.div, dataA = _b.dragData, plotA = _b.plot;
                dataA.reset();
                if (plotA.plotDragEnabled) {
                    dataA.dragEnabled = true;
                    for (var _c = 0, _d = this._dragItems; _c < _d.length; _c++) {
                        var _e = _d[_c], divB = _e.div, dataB = _e.dragData, plotB = _e.plot;
                        if (divA === divB || !plotB.plotDragEnabled) {
                            continue;
                        }
                        if (this._testDragSupported(1 /* Vertical */) && isVerticallyAdjacentTo(dataA.rect, dataB.rect)) {
                            dataA.lattitude |= 1 /* Vertical */;
                            this._getMouseTargetFromDiv(divA).style.cursor = 'ns-resize';
                            if (isAbove(dataA.rect, dataB.rect)) {
                                dataA.below.push(dataB);
                            }
                            else {
                                dataA.above.push(dataB);
                            }
                        }
                        if (this._testDragSupported(2 /* Horizontal */) &&
                            isHorizontallyAdjacentTo(dataA.rect, dataB.rect)) {
                            dataA.lattitude |= 2 /* Horizontal */;
                            this._getMouseTargetFromDiv(divA).style.cursor = 'ew-resize';
                            if (isLeftOf(dataA.rect, dataB.rect)) {
                                dataA.right.push(dataB);
                            }
                            else {
                                dataA.left.push(dataB);
                            }
                        }
                    }
                }
                var grabber = divA.children[0].children[1];
                if (dataA.lattitude === 0 /* None */) {
                    grabber.style.display = 'none';
                }
            }
        };
        PlotDragManager.prototype._swapIfNeeded = function (currentRect, comparator, selectedData, neighbors) {
            var changed = false;
            for (var _i = 0, neighbors_1 = neighbors; _i < neighbors_1.length; _i++) {
                var otherData = neighbors_1[_i];
                if (comparator(currentRect, otherData.rect)) {
                    DragData.swap(selectedData, otherData);
                    // Data rects are not scaled, so we scale it here when we transform the div.
                    var scaledOtherLeft = this._chart.minimumSizeManager.scaleWidth(otherData.rect.x1);
                    var scaledOtherTop = this._chart.minimumSizeManager.scaleHeight(otherData.rect.y1);
                    otherData.div.style[csstransform] = "translate(" + scaledOtherLeft + "px, " + scaledOtherTop + "px)";
                    this._origLeft = selectedData.rect.x1;
                    this._origTop = selectedData.rect.y1;
                    changed = true;
                }
            }
            return changed;
        };
        PlotDragManager.prototype._updatePositions = function () {
            if (this._selected == null) {
                return false;
            }
            var changed = false;
            var otherData = null;
            var selectedData = this._selected.dragData;
            var currentRect = Rectangle.constructFromPositionWidthAndHeight({ x: this._currLeft, y: this._currTop }, selectedData.rect.getWidth(), selectedData.rect.getHeight());
            if ((selectedData.lattitude & 1 /* Vertical */) !== 0) {
                changed = this._swapIfNeeded(currentRect, isAbove, selectedData, selectedData.above) || changed;
                changed = this._swapIfNeeded(currentRect, isBelow, selectedData, selectedData.below) || changed;
            }
            if ((selectedData.lattitude & 2 /* Horizontal */) !== 0) {
                changed = this._swapIfNeeded(currentRect, isLeftOf, selectedData, selectedData.left) || changed;
                changed = this._swapIfNeeded(currentRect, isRightOf, selectedData, selectedData.right) || changed;
            }
            if (changed) {
                // origLeft and origTop are unscaled, so we scale them here.
                var scaledOrigLeft = this._chart.minimumSizeManager.scaleWidth(this._origLeft);
                var scaledOrigTop = this._chart.minimumSizeManager.scaleHeight(this._origTop);
                this._placeholder.style[csstransform] = "translate(" + scaledOrigLeft + "px, " + scaledOrigTop + "px)";
                this._setupDragData();
            }
            return changed;
        };
        PlotDragManager.prototype.isDragging = function () {
            return this._selected && !this._transitioning;
        };
        PlotDragManager.prototype.isActive = function () {
            return this._selected || this._transitioning;
        };
        PlotDragManager.prototype._dropSelected = function () {
            if (this._selected == null) {
                return;
            }
            var div = this._selected.div;
            div.children[0].style[csstransform] = 'scale(1.0)';
            div.children[0].style.boxShadow = '';
            div.style[csstransition] = this._translateTransition + "s ease-in-out";
            var scaledPosition = this._chart.minimumSizeManager.scalePoint({ x: this._origLeft, y: this._origTop });
            div.style[csstransform] = "translate(" + scaledPosition.x + "px, " + scaledPosition.y + "px)";
            div.addEventListener('transitionend', this._dropTransitionFinishedEvent, false);
            this._transitionTimeOut = window.setTimeout(this._dropTransitionFinishedEvent, Math.max(this._translateTransition, this._scaleTransition) * 1000 + 50);
            this._plotDropEventData = this._buildDropData();
            this._chart.fireNonLocationEvent('PlotDropBegin', this._plotDropEventData);
            this._transitioning = true;
        };
        PlotDragManager.prototype._buildDropData = function () {
            var data = {
                draw: true,
                setAttributes: true,
                plots: {}
            };
            var backdropRect = this._chart.chartSubRect;
            var height = scaleByDevicePixelRatioInverse(backdropRect.y2 - backdropRect.y1);
            var width = scaleByDevicePixelRatioInverse(backdropRect.x2 - backdropRect.x1);
            for (var _i = 0, _a = this._dragItems; _i < _a.length; _i++) {
                var div = _a[_i];
                var rect = div.dragData.rect;
                var plot = div.plot;
                if (plot) {
                    var minYFactor = 1.0 - (rect.y2 / height);
                    var maxYFactor = 1.0 - (rect.y1 / height);
                    var minXFactor = rect.x1 / width;
                    var maxXFactor = rect.x2 / width;
                    data.plots[plot.id] = {
                        minYFactor: (minYFactor > 1) ? ~~minYFactor : minYFactor,
                        maxYFactor: (maxYFactor > 1) ? ~~maxYFactor : maxYFactor,
                        minXFactor: (minXFactor > 1) ? ~~minXFactor : minXFactor,
                        maxXFactor: (maxXFactor > 1) ? ~~maxXFactor : maxXFactor,
                    };
                }
            }
            return data;
        };
        PlotDragManager.prototype._dropTransitionFinished = function (event, options) {
            var _this = this;
            if (options === void 0) { options = { draw: true }; }
            if (this._chart && this._transitioning) {
                this._chart.postDrawHooks.push(function () {
                    if (_this._backdrop) {
                        _this._backdrop.style.background = '';
                    }
                    if (_this._placeholder) {
                        _this._backdrop.removeChild(_this._placeholder);
                        _this._placeholder = null;
                    }
                    _this._transitioning = false;
                    if (_this._dragItems) {
                        for (var _i = 0, _a = _this._dragItems; _i < _a.length; _i++) {
                            var item = _a[_i];
                            item.div.children[0].children[0].style.display = 'none';
                        }
                    }
                    if (_this._chart) {
                        _this._chart.suppressAllInteraction = false;
                        _this._chart.setUIVisibility(true);
                    }
                    _this._selected = null;
                    _this._plotDropEventData = null;
                });
                this._chart.plotResizeManager.setSlidersDirty();
                if (this._plotDropEventData.setAttributes) {
                    for (var _i = 0, _a = this._dragItems; _i < _a.length; _i++) {
                        var plot = _a[_i].plot;
                        if (plot) {
                            var factors = this._plotDropEventData.plots[plot.id];
                            if (factors) {
                                plot.attributeSet.setAt('minXFactor', 'user', factors.minXFactor);
                                plot.attributeSet.setAt('maxXFactor', 'user', factors.maxXFactor);
                                plot.attributeSet.setAt('minYFactor', 'user', factors.minYFactor);
                                plot.attributeSet.setAt('maxYFactor', 'user', factors.maxYFactor);
                            }
                        }
                    }
                }
                // remove the transitionend event so that it doesn't get called a second time until our postDrawHook runs.
                // we don't set the `this.transition` flag to false until after that runs to make sure that chart drawing
                // isn't suppressed.
                this._selected.div.removeEventListener('transitionend', this._dropTransitionFinishedEvent, false);
                clearTimeout(this._transitionTimeOut);
                this._transitionTimeOut = null;
                this._chart.fireNonLocationEvent('PlotDropEnd', this._plotDropEventData);
                if (this._plotDropEventData.draw && options.draw) {
                    this._chart.invalidate();
                }
            }
        };
        PlotDragManager.prototype._ontouchStart = function (event) {
            if (this._transitioning || this._activeTouch) {
                return;
            }
            this._activeTouch = event.changedTouches[0];
            if (this._beginDrag(event, this._getDragItemFromTouchTarget(event.currentTarget), this._activeTouch.clientX, this._activeTouch.clientY)) {
                // Listen for touchend and touchmove
                window.addEventListener('touchcancel', this._touchEndEvent, true);
                window.addEventListener('touchend', this._touchEndEvent, true);
                window.addEventListener('touchmove', this._touchMoveEvent, true);
            }
        };
        PlotDragManager.prototype._prepareForDrag = function () {
            for (var _i = 0, _a = this._dragItems; _i < _a.length; _i++) {
                var div = _a[_i].div;
                div.style.zIndex = '1';
                div.style[csstransition] = this._translateTransition + "s ease-in-out";
                if (this._backdrop) {
                    var child = div.children[0];
                    child.children[0].style.display = '';
                    child.style[csstransition] = this._scaleTransition + "s ease-in-out";
                }
            }
            this._chart.setUIVisibility(false);
            this._updateRectsFromPlots();
        };
        PlotDragManager.prototype._beginDrag = function (event, element, clientX, clientY) {
            this._dropSelected();
            this._prepareForDrag();
            if (this._chart) {
                this._chart.suppressAllInteraction = true;
            }
            if (this._backdrop) {
                this._backdrop.style.background = this._theme.backdropColor;
            }
            var data = element.dragData;
            this._selected = element;
            var selectedDiv = this._selected.div;
            selectedDiv.style[csstransition] = '';
            selectedDiv.style.zIndex = '2';
            var padding = this._chart.plotDragScalePadding * 2; // Padding is on both sides, so we double it
            var scaleFactor = 1 - padding / Math.max(data.rect.getWidth(), data.rect.getHeight());
            selectedDiv.children[0].style[csstransform] = "scale(" + scaleFactor + ")";
            if (padding !== 0) {
                var shadow_offset = Math.min(Math.floor(padding / 8), 5); // capping the maximum shadow size we don't want
                // giant shadows with large padding.
                var shadow_spread = shadow_offset;
                var shadow_blur = shadow_offset * 4;
                selectedDiv.children[0].style.boxShadow
                    = shadow_offset + "px " + shadow_offset + "px " + shadow_blur + "px " + shadow_spread + "px " + this._theme.shadowColor;
            }
            else {
                selectedDiv.style.borderStyle = 'solid';
                selectedDiv.style.borderWidth = this._theme.placeholderBorderWidth + 'px';
                selectedDiv.style.borderColor = this._theme.placeholderBorderColor;
            }
            this._origTop = this._currTop = data.rect.y1;
            this._origLeft = this._currLeft = data.rect.x1;
            // origLeft and origTop are unscaled, so we scale them here.
            this._selectedOffsetX = clientX - this._chart.minimumSizeManager.scaleWidth(this._origLeft);
            this._selectedOffsetY = clientY - this._chart.minimumSizeManager.scaleHeight(this._origTop);
            this._placeholder = document.createElement('div');
            this._placeholder.style.marginLeft = this._placeholder.style.marginTop = this._theme.placeholderMargin + 'px';
            this._placeholder.style.width = selectedDiv.offsetWidth - (this._theme.placeholderMargin * 2) + 'px';
            this._placeholder.style.height = selectedDiv.offsetHeight - (this._theme.placeholderMargin * 2) + 'px';
            this._placeholder.style[csstransition] = this._translateTransition * 0.5 + "s ease-in-out";
            this._placeholder.style[csstransform] = "translate(" + this._origLeft + "px, " + this._origTop + "px)";
            this._placeholder.style.zIndex = '0';
            this._placeholder.style.borderStyle = this._theme.placeholderBorderStyle;
            this._placeholder.style.background = this._theme.placeholderBackground;
            this._placeholder.style.borderColor = this._theme.placeholderBorderColor;
            this._placeholder.style.borderWidth = this._theme.placeholderBorderWidth + 'px';
            this._placeholder.tabIndex = -1;
            this._backdrop.appendChild(this._placeholder);
            this._setupDragData();
            this._chart.fireNonLocationEvent('PlotDragBegin', { selectedPlot: element.plot.id });
            event.preventDefault();
            event.stopImmediatePropagation();
            return true;
        };
        PlotDragManager.prototype._createDragMask = function () {
            var dragMask = document.createElement('div');
            dragMask.style.position = 'fixed';
            dragMask.style.left = '0px';
            dragMask.style.top = '0px';
            dragMask.style.width = '100%';
            dragMask.style.height = '100%';
            dragMask.style.cursor = 'ns-resize';
            document.body.appendChild(dragMask);
            this._dragMask = dragMask;
        };
        PlotDragManager.prototype._onMouseDown = function (event) {
            if (this._transitioning) {
                return;
            }
            if (event instanceof MouseEvent) {
                if (event.button === 0) {
                    if (this._beginDrag(event, this._getDragItemFromMouseTarget(event.currentTarget), event.clientX, event.clientY)) {
                        this._createDragMask();
                        this._container.style.cursor = 'ns-resize';
                        window.addEventListener('mouseup', this._mouseUpEvent, true);
                        window.addEventListener('mousemove', this._mouseMoveEvent, true);
                    }
                }
            }
        };
        PlotDragManager.prototype._onTouchEnd = function (event) {
            if (this._transitioning) {
                return;
            }
            if (this._getTrackedTouch(event.changedTouches)) {
                window.removeEventListener('touchend', this._touchEndEvent, true);
                window.removeEventListener('touchcancel', this._touchEndEvent, true);
                window.removeEventListener('touchmove', this._touchMoveEvent, true);
                this._dragMask = null;
                this._activeTouch = null;
                this._dropSelected();
                event.preventDefault();
                event.stopPropagation();
            }
        };
        PlotDragManager.prototype._onMouseUp = function (event) {
            if (this._transitioning) {
                return;
            }
            if (event instanceof MouseEvent) {
                if (event.button !== 0) {
                    return;
                }
                window.removeEventListener('mouseup', this._mouseUpEvent, true);
                window.removeEventListener('mousemove', this._mouseMoveEvent, true);
                this._container.style.cursor = 'default';
                document.body.removeChild(this._dragMask);
                this._dragMask = null;
                this._dropSelected();
                event.preventDefault();
                event.stopPropagation();
            }
        };
        PlotDragManager.prototype._onMouseMove = function (event) {
            if (this._transitioning) {
                return;
            }
            if (event instanceof MouseEvent && this._selected) {
                this._doDrag(event, event.clientX, event.clientY);
            }
        };
        PlotDragManager.prototype._getTrackedTouch = function (touches) {
            if (this._activeTouch) {
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < touches.length; i++) {
                    var touch = touches[i];
                    if (touch.identifier === this._activeTouch.identifier) {
                        return touch;
                    }
                }
            }
            return null;
        };
        PlotDragManager.prototype._doDrag = function (event, clientX, clientY) {
            var _a = this._selected, lattitude = _a.dragData.lattitude, _b = _a.div, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
            if ((lattitude & 1 /* Vertical */) !== 0) {
                this._currTop = Math.min(this._backdrop.offsetHeight - offsetHeight, Math.max(0, (clientY - this._selectedOffsetY)));
                this._currTop = this._chart.minimumSizeManager.unscaleHeight(this._currTop);
            }
            else {
                this._currTop = this._origTop;
            }
            if ((lattitude & 2 /* Horizontal */) !== 0) {
                this._currLeft = Math.min(this._backdrop.offsetWidth - offsetWidth, Math.max(0, (clientX - this._selectedOffsetX)));
                this._currTop = this._chart.minimumSizeManager.unscaleWidth(this._currLeft);
            }
            else {
                this._currLeft = this._origLeft;
            }
            // currLeft and currop are unscaled, so we scale them here.
            var scaledCurrTop = this._chart.minimumSizeManager.scaleHeight(this._currTop);
            var scaledCurrLeft = this._chart.minimumSizeManager.scaleWidth(this._currLeft);
            this._selected.div.style[csstransform] = "translate(" + scaledCurrLeft + "px, " + scaledCurrTop + "px)";
            this._updatePositions();
            event.preventDefault();
            event.stopPropagation();
        };
        PlotDragManager.prototype._onTouchMove = function (event) {
            if (this._transitioning) {
                return;
            }
            if (this._selected) {
                var touch = this._getTrackedTouch(event.changedTouches);
                if (touch) {
                    this._doDrag(event, touch.clientX, touch.clientY);
                }
            }
        };
        return PlotDragManager;
    }());
    var DragData = /** @class */ (function () {
        function DragData(div, elem) {
            this.above = [];
            this.below = [];
            this.left = [];
            this.right = [];
            this.lattitude = 0 /* None */;
            var offsetLeft = elem.offsetLeft, offsetTop = elem.offsetTop, offsetWidth = elem.offsetWidth, offsetHeight = elem.offsetHeight;
            this.rect = Rectangle.constructFromPositionWidthAndHeight({ x: offsetLeft, y: offsetTop }, offsetWidth, offsetHeight);
            this.div = div;
        }
        DragData.prototype.reset = function () {
            this.above = [];
            this.below = [];
            this.left = [];
            this.right = [];
            this.lattitude = 0 /* None */;
            this.dragEnabled = false;
        };
        DragData.swap = function (d1, d2) {
            if (d1.rect.y1 < d2.rect.y1) {
                d2.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d2.rect.x, y: d1.rect.y1 }, d2.rect.getWidth(), d2.rect.getHeight());
                d1.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d1.rect.x1, y: d1.rect.y1 + d2.rect.getHeight() }, d1.rect.getWidth(), d1.rect.getHeight());
            }
            else if (d2.rect.y1 < d1.rect.y1) {
                d1.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d1.rect.x1, y: d2.rect.y1 }, d1.rect.getWidth(), d1.rect.getHeight());
                d2.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d2.rect.x1, y: d2.rect.y1 + d1.rect.getHeight() }, d2.rect.getWidth(), d2.rect.getHeight());
            }
            if (d1.rect.x1 < d2.rect.x1) {
                d2.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d1.rect.x1, y: d2.rect.y1 }, d2.rect.getWidth(), d2.rect.getHeight());
                d1.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d1.rect.x1 + d2.rect.getWidth(), y: d1.rect.y1 }, d1.rect.getWidth(), d1.rect.getHeight());
            }
            else if (d2.rect.x1 < d1.rect.x1) {
                d1.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d2.rect.x1, y: d1.rect.y1 }, d1.rect.getWidth(), d1.rect.getHeight());
                d2.rect = Rectangle.constructFromPositionWidthAndHeight({ x: d2.rect.x1 + d1.rect.getWidth(), y: d2.rect.y1 }, d2.rect.getWidth(), d2.rect.getHeight());
            }
        };
        return DragData;
    }());
    function isAbove(testRect, referenceRect) {
        return testRect.y1 < referenceRect.centerPoint().y;
    }
    function isBelow(testRect, referenceRect) {
        return testRect.y2 > referenceRect.centerPoint().y;
    }
    function isVerticallyAdjacentTo(testRect, referenceRect, checkExactMatch) {
        if (checkExactMatch === void 0) { checkExactMatch = true; }
        var a1 = Math.round(testRect.y1);
        var b1 = Math.round(testRect.y2);
        var c1 = Math.round(testRect.x1);
        var d1 = Math.round(testRect.x2);
        var a2 = Math.round(referenceRect.y1);
        var b2 = Math.round(referenceRect.y2);
        var c2 = Math.round(referenceRect.x1);
        var d2 = Math.round(referenceRect.x2);
        var exact = (c2 === c1 && d2 === d1);
        var touching = (c2 < d1 && d2 > c1) && !checkExactMatch;
        // We let there be a tiny bit of leeway between the top and bottom, to avoid errors due to rounding.
        return (fuzzyEQ(a1, b2, 5) || fuzzyEQ(a2, b1, 5) && (exact || touching));
    }
    function isLeftOf(testRect, referenceRect) {
        return testRect.x1 < referenceRect.centerPoint().x;
    }
    function isRightOf(testRect, referenceRect) {
        return testRect.x2 > referenceRect.centerPoint().x;
    }
    function isHorizontallyAdjacentTo(testRect, referenceRect, checkExactMatch) {
        if (checkExactMatch === void 0) { checkExactMatch = true; }
        var a1 = Math.round(testRect.x1);
        var b1 = Math.round(testRect.x2);
        var c1 = Math.round(testRect.y1);
        var d1 = Math.round(testRect.y2);
        var a2 = Math.round(referenceRect.x1);
        var b2 = Math.round(referenceRect.x2);
        var c2 = Math.round(referenceRect.y1);
        var d2 = Math.round(referenceRect.y2);
        var exact = (c2 === c1 && d2 === d1);
        var touching = (c2 < d1 && d2 > c1) && !checkExactMatch;
        return fuzzyEQ(a1, b2, 5) || fuzzyEQ(a2, b1, 5) && (exact || touching);
    }
    var getsupportedprop = function (proparray) {
        var rootStyle = typeof document !== 'undefined' && document.documentElement && document.documentElement.style;
        if (rootStyle) {
            for (var _i = 0, proparray_1 = proparray; _i < proparray_1.length; _i++) {
                var prop = proparray_1[_i];
                if (prop in rootStyle) {
                    return prop;
                }
            }
        }
        return undefined;
    };
    var csstransform = getsupportedprop([
        'transform',
        'MozTransform',
        'WebkitTransform',
        'msTransform',
        'OTransform'
    ]);
    var csstransition = getsupportedprop([
        'transition',
        'MozTransition',
        'WebkitTransition',
        'msTransition',
        'OTransition'
    ]);
    
    var AutoPositioner = /** @class */ (function () {
        function AutoPositioner(plotRenderManager) {
            this.plotRenderManager = plotRenderManager;
        }
        return AutoPositioner;
    }());
    
    var AutoPositionerLinearFallback = /** @class */ (function (_super) {
        __extends(AutoPositionerLinearFallback, _super);
        function AutoPositionerLinearFallback(plotRenderManager) {
            return _super.call(this, plotRenderManager) || this;
        }
        AutoPositionerLinearFallback.prototype.calcAutoPositionOffset = function (rect, placedRects, boundaryRect, options) {
            var offset = { x: 0, y: 0 };
            if (options.dimension === 1 /* X */) {
                var leftStart = rect.x;
                var leftEnd = this.plotRenderManager.plot.plotRect.x1;
                var rightStart = rect.x + 1;
                var rightEnd = this.plotRenderManager.plot.plotRect.x2 - rect.width;
                offset.x = this._calcOverlapMinimizingOffsetWithinRange(rect, placedRects, leftStart, leftEnd, rightStart, rightEnd, options);
            }
            else {
                var topStart = rect.y;
                var topEnd = this.plotRenderManager.plot.plotRect.y1;
                var botStart = rect.y + 1;
                var botEnd = this.plotRenderManager.plot.plotRect.y2 - rect.height;
                offset.y = this._calcOverlapMinimizingOffsetWithinRange(rect, placedRects, topStart, topEnd, botStart, botEnd, options);
            }
            return { isSuccess: true, offset: offset };
        };
        /**
         * Given start and end positions, test every point and return the one that produces the least overlap.
         */
        AutoPositionerLinearFallback.prototype._calcOverlapMinimizingOffsetWithinRange = function (rect, placedRects, topOrLeftStart, topOrLeftEnd, botOrRightStart, botOrRightEnd, options) {
            var _this = this;
            var bestOverlap = Infinity;
            var dimensionIsX = options.dimension === 1;
            var bestPosition = (dimensionIsX) ? rect.x : rect.y;
            var testRect = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            var setupTestRect = function (i) {
                if (dimensionIsX) {
                    testRect.x = i;
                }
                else {
                    testRect.y = i;
                }
            };
            var findBestPosition = function (start, end, comparator, incDec) {
                for (var i = start; comparator(i, end); i = incDec(i)) {
                    setupTestRect(i);
                    var currOverlap = _this._calcAggregateOverlap(testRect, placedRects, options);
                    if (currOverlap < bestOverlap) {
                        bestOverlap = currOverlap;
                        bestPosition = i;
                    }
                    if (bestOverlap === 0) {
                        return;
                    }
                }
            };
            findBestPosition(topOrLeftStart, topOrLeftEnd, _$1.gt, function (i) { return i - 1; });
            if (bestOverlap !== 0 && (topOrLeftEnd !== botOrRightStart && botOrRightEnd !== topOrLeftStart)) {
                findBestPosition(botOrRightStart, botOrRightEnd, _$1.lt, function (i) { return i + 1; });
            }
            if (bestOverlap !== Infinity) {
                // If we found a better overlap along the way than the default position, use it
                return (dimensionIsX) ? bestPosition - rect.x : bestPosition - rect.y;
            }
            else {
                return 0;
            }
        };
        AutoPositionerLinearFallback.prototype._calcAggregateOverlap = function (rect, placedRects, options) {
            var aggregateOverlap = 0;
            if (options.shouldAvoidSeries) {
                var seriesPenalty = (rect.width * 2) * (rect.height * 2);
                for (var _i = 0, _a = this.plotRenderManager.plotSeries; _i < _a.length; _i++) {
                    var series = _a[_i];
                    for (var _b = 0, _c = series.hitVector; _b < _c.length; _b++) {
                        var shape = _c[_b];
                        if (shape.hitTest(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height)) {
                            aggregateOverlap = aggregateOverlap + seriesPenalty;
                        }
                    }
                }
            }
            // Figure out the aggregate overlap factor of this candidate rectangle against all rectangles that are already placed
            for (var _d = 0, placedRects_1 = placedRects; _d < placedRects_1.length; _d++) {
                var compareRect = placedRects_1[_d];
                if (Rectangle.doRectanglesIntersect(rect, compareRect, options.aliasOffset)) {
                    var maxUnionArea = (rect.width + compareRect.width) * (rect.height + compareRect.height);
                    var actualUnionArea = Rectangle.calcRectangleUnionArea(rect, compareRect);
                    aggregateOverlap += (maxUnionArea - actualUnionArea);
                }
            }
            return aggregateOverlap;
        };
        return AutoPositionerLinearFallback;
    }(AutoPositioner));
    
    var AutoPositionerFibonacciFallback = /** @class */ (function (_super) {
        __extends(AutoPositionerFibonacciFallback, _super);
        function AutoPositionerFibonacciFallback(plotRenderManager) {
            return _super.call(this, plotRenderManager) || this;
        }
        /**
         * Try positions created using the Fibonacci sequence and use the position that produces minimum overlap.
         */
        AutoPositionerFibonacciFallback.prototype.calcAutoPositionOffset = function (rect, placedRects, boundaryRect, options) {
            var isDimensionX = options.dimension === 1;
            var candidateSteps = [];
            var a = 0;
            var b = 1;
            var i = isDimensionX ? rect.x : rect.y;
            var limit = isDimensionX ? boundaryRect.x : boundaryRect.y;
            // Create a list of possible positions based on the Fibonacci sequence, moving in the negative direction.
            while (i > limit) {
                candidateSteps.push(i);
                _a = [b, a + b], a = _a[0], b = _a[1];
                i -= b;
            }
            a = 0;
            b = 1;
            i = isDimensionX ? rect.x - 1 : rect.y - 1;
            var length = isDimensionX ? rect.width : rect.height;
            // Create a list of possible positions based on the Fibonacci sequence, moving in the positive direction.
            limit = isDimensionX ? (boundaryRect.x + boundaryRect.width) : (boundaryRect.y + boundaryRect.height);
            while (i + length < limit) {
                candidateSteps.push(i);
                _b = [b, a + b], a = _b[0], b = _b[1];
                i += b;
            }
            if (candidateSteps.length !== 0) {
                var offsetX = 0;
                var offsetY = 0;
                if (isDimensionX) {
                    offsetX = this._calcOverlapMinimizingOffsetFromSteps(rect, placedRects, candidateSteps, options);
                }
                else {
                    offsetY = this._calcOverlapMinimizingOffsetFromSteps(rect, placedRects, candidateSteps, options);
                }
                return { isSuccess: true, offset: { x: offsetX, y: offsetY } };
            }
            return { isSuccess: false, offset: { x: 0, y: 0 } };
            var _a, _b;
        };
        /**
         * Use an incoming vector to find an approximate fit, and then optimize the approximate
         * fit with the linear mechanism
         */
        AutoPositionerFibonacciFallback.prototype._calcOverlapMinimizingOffsetFromSteps = function (rect, placedRects, candidateSteps, options) {
            if (candidateSteps.length === 0) {
                return 0;
            }
            var bestOverlap = Infinity;
            var bestPrevPos;
            var prevPos;
            var bestPos;
            var isDimensionX = options.dimension === 1;
            var startPos = bestPrevPos = prevPos = bestPos = (isDimensionX) ? rect.x : rect.y;
            var testRect = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            // Find an approximate range based on this list of values we were given.
            for (var _i = 0, candidateSteps_1 = candidateSteps; _i < candidateSteps_1.length; _i++) {
                var step = candidateSteps_1[_i];
                if (step === startPos) {
                    // Our offset has reversed direction, so reset the stored values and continue to the next step.
                    prevPos = bestPrevPos = step;
                    continue;
                }
                var oldOverlap = bestOverlap;
                if (isDimensionX) {
                    testRect.x = step;
                }
                else {
                    testRect.y = step;
                }
                var currOverlap = this._calcAggregateOverlap(testRect, placedRects, options);
                if (currOverlap < bestOverlap) {
                    bestOverlap = currOverlap;
                    bestPos = step;
                    bestPrevPos = prevPos;
                }
                if (bestOverlap === 0) {
                    break;
                }
                prevPos = step;
            }
            // Go through every possible position in the range we found and get the overlap minimizing position.
            return this._calcOverlapMinimizingOffsetWithinRange(rect, placedRects, bestPrevPos, bestPos, bestPrevPos, bestPos, options);
        };
        return AutoPositionerFibonacciFallback;
    }(AutoPositionerLinearFallback));
    
    var AutoPositionerOptions = /** @class */ (function () {
        function AutoPositionerOptions(dimension, shouldAvoidSeries, direction, aliasOffset) {
            if (direction === void 0) { direction = 0 /* POSITIVE */; }
            if (aliasOffset === void 0) { aliasOffset = 0; }
            this.dimension = dimension;
            this.direction = direction;
            this.shouldAvoidSeries = shouldAvoidSeries;
            this.aliasOffset = aliasOffset;
        }
        AutoPositionerOptions.prototype.createOptionsWithReverseDirection = function () {
            var reverseDirection = (this.direction === 0 /* POSITIVE */) ? 1 /* NEGATIVE */ : 0;
            return new AutoPositionerOptions(this.dimension, this.shouldAvoidSeries, reverseDirection, this.aliasOffset);
        };
        return AutoPositionerOptions;
    }());
    
    var AutoPositionerOverlapEliminating = /** @class */ (function (_super) {
        __extends(AutoPositionerOverlapEliminating, _super);
        function AutoPositionerOverlapEliminating(plotRenderManager) {
            return _super.call(this, plotRenderManager) || this;
        }
        AutoPositionerOverlapEliminating.prototype.calcAutoPositionOffset = function (rect, placedRects, boundaryRect, options) {
            var offsetResult = this.calcAutoPositionOffsetInOneDirection(rect, placedRects, boundaryRect, options);
            // Try the opposite direction.
            var optionsWithReverseDirection = options.createOptionsWithReverseDirection();
            var reverseOffsetResult = this.calcAutoPositionOffsetInOneDirection(rect, placedRects, boundaryRect, optionsWithReverseDirection);
            var dimensionIsX = options.dimension === 1;
            var offsetCompareVal = Math.abs(dimensionIsX ? offsetResult.offset.x : offsetResult.offset.y);
            var reverseOffsetCompareVal = Math.abs(dimensionIsX ? reverseOffsetResult.offset.x : reverseOffsetResult.offset.y);
            if (offsetResult.isSuccess && reverseOffsetResult.isSuccess) {
                return (offsetCompareVal < reverseOffsetCompareVal) ? offsetResult : reverseOffsetResult;
            }
            else if (offsetResult.isSuccess) {
                return offsetResult;
            }
            else if (reverseOffsetResult.isSuccess) {
                return reverseOffsetResult;
            }
            return { isSuccess: false, offset: { x: 0, y: 0 } };
        };
        /**
         * Computes an offset for a rectangle that eliminates collisions with the rectangles in a given list. This
         * offset will be in the single given dimension and direction.
         */
        AutoPositionerOverlapEliminating.prototype.calcAutoPositionOffsetInOneDirection = function (rect, placedRects, boundaryRect, options) {
            // First, check if there are any collisions in the first place.
            var testOffset = this._calcNextOverlapEliminatingOffset(rect, placedRects, options);
            if (testOffset.x === 0 && testOffset.y === 0) {
                return { isSuccess: true, offset: { x: 0, y: 0 } };
            }
            var candidate = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            var appliedOffset = { x: 0, y: 0 };
            var isBoundaryBroken = false;
            while (testOffset.x !== 0 || testOffset.y !== 0) {
                appliedOffset.x += testOffset.x;
                appliedOffset.y += testOffset.y;
                candidate.x += testOffset.x;
                candidate.y += testOffset.y;
                isBoundaryBroken = candidate.x < boundaryRect.x || candidate.x + candidate.width > boundaryRect.x + boundaryRect.width
                    || candidate.y < boundaryRect.y || candidate.y + candidate.height > boundaryRect.y + boundaryRect.height;
                if (isBoundaryBroken) {
                    break;
                }
                testOffset = this._calcNextOverlapEliminatingOffset(candidate, placedRects, options);
            }
            if (testOffset.x !== 0 || testOffset.y !== 0) {
                return { isSuccess: false, offset: { x: 0, y: 0 } };
            }
            else {
                return { isSuccess: true, offset: appliedOffset };
            }
        };
        /**
          * Test a rect against a list of rects as well as the series hitshapes. If a collision is found,
          * return the offset that would elimate the collision.
          */
        AutoPositionerOverlapEliminating.prototype._calcNextOverlapEliminatingOffset = function (rect, placedRects, options) {
            if (placedRects.length <= 0 && !options.shouldAvoidSeries) {
                return { x: 0, y: 0 };
            }
            var offset = { x: 0, y: 0 };
            if (options.shouldAvoidSeries && options.dimension === 2 /* Y */) {
                // Currently, checking against series hitshapes is only implemented for the y dimension.
                offset.y = this._calcNextOverlapEliminatingOffsetAgainstSeriesList(rect, options);
            }
            if (offset.x === 0 && offset.y === 0) {
                offset = this._calcNextOverlapEliminatingOffsetAgainstPlacedRects(rect, placedRects, options);
            }
            return offset;
        };
        /**
         * Test a rect against the series hitshapes. If a collision is found, return the offset that would elimate the collision.
         * Currently, this function will only return an offset for the y-dimension.
         */
        AutoPositionerOverlapEliminating.prototype._calcNextOverlapEliminatingOffsetAgainstSeriesList = function (rect, options) {
            for (var _i = 0, _a = this.plotRenderManager.plotSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.isAnnotation) {
                    continue;
                }
                var effectiveDrawStyle = series.getEffectiveDrawStyle();
                if (effectiveDrawStyle === 19 /* PIE */ || effectiveDrawStyle === 36 /* PIE3D */) {
                    continue;
                }
                for (var _b = 0, _c = series.hitVector; _b < _c.length; _b++) {
                    var shape = _c[_b];
                    if (!shape.hitTest(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height)) {
                        continue;
                    }
                    var shiftInPositiveDirection = (options.direction === 0 /* POSITIVE */);
                    var shift = shape.getAvoidanceOffset(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, shiftInPositiveDirection);
                    if (shift !== 0) {
                        return shift;
                    }
                }
            }
            return 0;
        };
        AutoPositionerOverlapEliminating.prototype._calcNextOverlapEliminatingOffsetAgainstPlacedRects = function (rect, placedRects, options) {
            for (var _i = 0, placedRects_1 = placedRects; _i < placedRects_1.length; _i++) {
                var placedRect = placedRects_1[_i];
                if (Rectangle.doRectanglesIntersect(rect, placedRect, options.aliasOffset)) {
                    return this._calcOverlapEliminatingOffsetAgainstPlacedRect(rect, placedRect, options);
                }
            }
            return { x: 0, y: 0 };
        };
        AutoPositionerOverlapEliminating.prototype._calcOverlapEliminatingOffsetAgainstPlacedRect = function (rect, compareRect, options) {
            var offset = { x: 0, y: 0 };
            if (options.dimension === 1 /* X */) {
                if (options.direction === 0 /* POSITIVE */) {
                    offset.x = (compareRect.x + compareRect.width) - rect.x;
                }
                else {
                    offset.x = (compareRect.x - (rect.x + rect.width));
                }
            }
            else {
                // We use the word positive here to refer to moving a marker upwards on the plot.
                // Because we are dealing with pixels, we move up as the y-value decreases. As a result,
                // we return a negative value if providePositiveOffset is true and vice versa.
                if (options.direction === 0 /* POSITIVE */) {
                    offset.y = compareRect.y - (rect.y + rect.height);
                }
                else {
                    offset.y = (compareRect.y + compareRect.height) - rect.y;
                }
            }
            return offset;
        };
        return AutoPositionerOverlapEliminating;
    }(AutoPositioner));
    
    var BatchedLineRenderer = /** @class */ (function () {
        function BatchedLineRenderer(ctx) {
            this._currentPen = undefined;
            this._needsStroke = false;
            this._ctx = ctx;
            this._ctx.beginPath();
        }
        BatchedLineRenderer.prototype.setPen = function (newPen) {
            if (!this._currentPen || !newPen.equals(this._currentPen)) {
                // Draw the path with the existing pen before switching it
                this.finishDrawing();
                // Start a new path and setup the new pen
                this._ctx.beginPath();
                this._currentPen = newPen;
                this._ctx.setPen(newPen);
            }
        };
        BatchedLineRenderer.prototype.appendHorizontalLineToPath = function (x1, x2, y) {
            this._ctx.appendHorizontalLineToPath(x1, x2, y);
            this._needsStroke = true;
        };
        BatchedLineRenderer.prototype.appendVerticalLineToPath = function (y1, y2, x) {
            this._ctx.appendVerticalLineToPath(y1, y2, x);
            this._needsStroke = true;
        };
        BatchedLineRenderer.prototype.appendLineGroup = function (lineGroup) {
            if (lineGroup.lines.length === 0) {
                return;
            }
            this.setPen(lineGroup.pen);
            if (lineGroup.isVertical) {
                for (var _i = 0, _a = lineGroup.lines; _i < _a.length; _i++) {
                    var _b = _a[_i], _c = _b.range, start = _c.start, end = _c.end, position = _b.position;
                    this.appendVerticalLineToPath(start, end, position);
                }
            }
            else {
                for (var _d = 0, _e = lineGroup.lines; _d < _e.length; _d++) {
                    var _f = _e[_d], _g = _f.range, start = _g.start, end = _g.end, position = _f.position;
                    this.appendHorizontalLineToPath(start, end, position);
                }
            }
        };
        BatchedLineRenderer.prototype.finishDrawing = function () {
            if (this._needsStroke) {
                this._ctx.stroke();
                this._needsStroke = false;
                this._ctx.beginPath();
            }
        };
        return BatchedLineRenderer;
    }());
    function renderAxisLines(ctx, plot, axesToDraw) {
        var xAxes = getAxesForDimension(axesToDraw, 1 /* X */);
        var yAxes = getAxesForDimension(axesToDraw, 2 /* Y */);
        var lineRenderer = new BatchedLineRenderer(ctx);
        for (var _i = 0, xAxes_1 = xAxes; _i < xAxes_1.length; _i++) {
            var axis = xAxes_1[_i];
            axis.drawAlternatingBackground(ctx);
        }
        // Grid lines must be drawn underneath all other axis parts, so we draw all of the gridlines
        // together in one big batch before drawing the rest of the axis parts one axis at a time.
        renderAllGridLines(lineRenderer, xAxes, yAxes);
        for (var _a = 0, axesToDraw_1 = axesToDraw; _a < axesToDraw_1.length; _a++) {
            var _b = axesToDraw_1[_a], axis = _b.axis, alternateAxisRect = _b.alternateAxisRect, primaryAxisRect = _b.primaryAxisRect;
            lineRenderer.appendLineGroup(axis.getAxisLines(alternateAxisRect, primaryAxisRect));
            lineRenderer.appendLineGroup(axis.getTickLines(alternateAxisRect, primaryAxisRect));
        }
        lineRenderer.finishDrawing();
        for (var _c = 0, axesToDraw_2 = axesToDraw; _c < axesToDraw_2.length; _c++) {
            var _d = axesToDraw_2[_c], axis = _d.axis, alternateAxisRect = _d.alternateAxisRect, primaryAxisRect = _d.primaryAxisRect;
            // TODO: convert the rest of the rendering to remove this function
            axis.drawToBuffer(ctx, alternateAxisRect, primaryAxisRect);
        }
    }
    function renderReferenceLines(ctx, plot) {
        var lineRenderer = new BatchedLineRenderer(ctx);
        for (var _i = 0, _a = plot.axes; _i < _a.length; _i++) {
            var axis = _a[_i];
            lineRenderer.appendLineGroup(axis.getReferenceLine());
        }
        lineRenderer.finishDrawing();
    }
    function getAxesForDimension(entries, dimension) {
        return entries.reduce(function (result, entry) {
            if (entry.axis.dimension === dimension) {
                result.push(entry.axis);
            }
            return result;
        }, []);
    }
    function renderAllGridLines(lineRenderer, xAxes, yAxes) {
        var xGridLines = _$1.flatten(_$1.map(xAxes, function (axis) { return axis.getGridLines(); }));
        var yGridLines = _$1.flatten(_$1.map(yAxes, function (axis) { return axis.getGridLines(); }));
        for (var _i = 0, xGridLines_1 = xGridLines; _i < xGridLines_1.length; _i++) {
            var lineGroup = xGridLines_1[_i];
            lineRenderer.appendLineGroup(lineGroup);
        }
        for (var _a = 0, yGridLines_1 = yGridLines; _a < yGridLines_1.length; _a++) {
            var lineGroup = yGridLines_1[_a];
            lineRenderer.appendLineGroup(lineGroup);
        }
    }
    
    var BaseRenderCache = /** @class */ (function () {
        function BaseRenderCache(parent) {
            this.parent = parent;
            this.valid = true;
            this.prevLength = -1;
        }
        BaseRenderCache.prototype.setInvalidated = function () {
            this.valid = false;
        };
        return BaseRenderCache;
    }());
    
    var isStackable = function (drawStyle) {
        return isHorizonalBarType(drawStyle) || isVerticalBarType(drawStyle) || drawStyle === 9 /* AREA */;
    };
    var isHorizonalBarType = function (drawStyle) {
        return _$1.includes([12 /* BARS */, 11 /* BARS3D */, 13 /* THINBARS */], drawStyle);
    };
    var isHorizontalBinnedDrawStyle = function (drawStyle) {
        return isHorizonalBarType(drawStyle);
    };
    var isVerticalBarType = function (drawStyle) {
        return _$1.includes([6 /* COLUMNS */, 5 /* COLUMNS3D */, 7 /* THIN */], drawStyle);
    };
    var isVerticalBinnedDrawStyle = function (drawStyle) {
        return _$1.includes([23 /* CANDLE */, 22 /* OHLC */, 37 /* HLCROSS */, 2 /* HLC */], drawStyle) ||
            isVerticalBarType(drawStyle);
    };
    var isBarType = function (drawStyle) {
        return isVerticalBarType(drawStyle) || isHorizonalBarType(drawStyle) || drawStyle === 4 /* RANGEBAR */ ||
            drawStyle === 61 /* RANGECANDLE */;
    };
    
    var ConditionalParser = (function () {
        var parser = { trace: function trace() { },
            yy: {},
            symbols_: { "error": 2, "program": 3, "expList": 4, "EOF": 5, "expression": 6, "exp": 7, "TEXT": 8, "brackets": 9, "parens": 10, ":": 11, "[": 12, "]": 13, "(": 14, ")": 15, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 5: "EOF", 8: "TEXT", 11: ":", 12: "[", 13: "]", 14: "(", 15: ")" },
            productions_: [0, [3, 2], [4, 2], [4, 0], [6, 1], [6, 1], [7, 4], [9, 2], [9, 3], [10, 2], [10, 3], [10, 3]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        this.$ = [];
                        return $$[$0 - 1];
                        break;
                    case 2:
                        this.$.push($$[$0]);
                        break;
                    case 3:
                        this.$ = [];
                        break;
                    case 4:
                        this.$ = $$[$0];
                        break;
                    case 5:
                        this.$ = $$[$0];
                        break;
                    case 6:
                        this.$ = { condition: $$[$0 - 3], trueBranch: $$[$0 - 2], falseBranch: $$[$0] };
                        break;
                    case 7:
                        this.$ = "";
                        break;
                    case 8:
                        this.$ = $$[$0 - 1];
                        break;
                    case 9:
                        this.$ = "";
                        break;
                    case 10:
                        this.$ = $$[$0 - 1];
                        break;
                    case 11:
                        this.$ = $$[$0 - 1];
                        break;
                }
            },
            table: [{ 3: 1, 4: 2, 5: [2, 3], 8: [2, 3], 12: [2, 3] }, { 1: [3] }, { 5: [1, 3], 6: 4, 7: 5, 8: [1, 6], 9: 7, 12: [1, 8] }, { 1: [2, 1] }, { 5: [2, 2], 8: [2, 2], 12: [2, 2] }, { 5: [2, 4], 8: [2, 4], 12: [2, 4] }, { 5: [2, 5], 8: [2, 5], 12: [2, 5] }, { 10: 9, 14: [1, 10] }, { 8: [1, 12], 13: [1, 11] }, { 11: [1, 13] }, { 7: 16, 8: [1, 15], 9: 7, 12: [1, 8], 15: [1, 14] }, { 14: [2, 7] }, { 13: [1, 17] }, { 10: 18, 14: [1, 10] }, { 5: [2, 9], 8: [2, 9], 11: [2, 9], 12: [2, 9], 15: [2, 9] }, { 15: [1, 19] }, { 15: [1, 20] }, { 14: [2, 8] }, { 5: [2, 6], 8: [2, 6], 12: [2, 6], 15: [2, 6] }, { 5: [2, 10], 8: [2, 10], 11: [2, 10], 12: [2, 10], 15: [2, 10] }, { 5: [2, 11], 8: [2, 11], 11: [2, 11], 12: [2, 11], 15: [2, 11] }],
            defaultActions: { 3: [2, 1], 11: [2, 7], 17: [2, 8] },
            parseError: function parseError(str, hash) {
                throw new Error(str);
            },
            parse: function parse(input) {
                var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                this.lexer.setInput(input);
                this.lexer.yy = this.yy;
                this.yy.lexer = this.lexer;
                this.yy.parser = this;
                if (typeof this.lexer.yylloc == "undefined")
                    this.lexer.yylloc = {};
                var yyloc = this.lexer.yylloc;
                lstack.push(yyloc);
                var ranges = this.lexer.options && this.lexer.options.ranges;
                if (typeof this.yy.parseError === "function")
                    this.parseError = this.yy.parseError;
                function lex() {
                    var token;
                    token = self.lexer.lex() || 1;
                    if (typeof token !== "number") {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                }
                var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    }
                    else {
                        if (symbol === null || typeof symbol == "undefined") {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === "undefined" || !action.length || !action[0]) {
                        var errStr = "";
                        if (!recovering) {
                            expected = [];
                            for (p in table[state])
                                if (this.terminals_[p] && p > 2) {
                                    expected.push("'" + this.terminals_[p] + "'");
                                }
                            if (this.lexer.showPosition) {
                                errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                            }
                            else {
                                errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                            }
                            this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                        }
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0)
                                    recovering--;
                            }
                            else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                            if (ranges) {
                                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                            }
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            }
        };
        /* Jison generated lexer */
        var lexer = (function () {
            var lexer = ({ EOF: 1,
                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    }
                    else {
                        throw new Error(str);
                    }
                },
                setInput: function (input) {
                    this._input = input;
                    this._more = this._less = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                    if (this.options.ranges)
                        this.yylloc.range = [0, 0];
                    this.offset = 0;
                    return this;
                },
                input: function () {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    }
                    else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges)
                        this.yylloc.range[1]++;
                    this._input = this._input.slice(1);
                    return ch;
                },
                unput: function (ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);
                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);
                    if (lines.length - 1)
                        this.yylineno -= lines.length - 1;
                    var r = this.yylloc.range;
                    this.yylloc = { first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ?
                            (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length :
                            this.yylloc.first_column - len
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    return this;
                },
                more: function () {
                    this._more = true;
                    return this;
                },
                less: function (n) {
                    this.unput(this.match.slice(n));
                },
                pastInput: function () {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },
                upcomingInput: function () {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },
                showPosition: function () {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },
                next: function () {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input)
                        this.done = true;
                    var token, match, tempMatch, index, col, lines;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (!this.options.flex)
                                break;
                        }
                    }
                    if (match) {
                        lines = match[0].match(/(?:\r\n?|\n).*/g);
                        if (lines)
                            this.yylineno += lines.length;
                        this.yylloc = { first_line: this.yylloc.last_line,
                            last_line: this.yylineno + 1,
                            first_column: this.yylloc.last_column,
                            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                        this.yytext += match[0];
                        this.match += match[0];
                        this.matches = match;
                        this.yyleng = this.yytext.length;
                        if (this.options.ranges) {
                            this.yylloc.range = [this.offset, this.offset += this.yyleng];
                        }
                        this._more = false;
                        this._input = this._input.slice(match[0].length);
                        this.matched += match[0];
                        token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                        if (this.done && this._input)
                            this.done = false;
                        if (token)
                            return token;
                        else
                            return;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    }
                    else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                    }
                },
                lex: function lex() {
                    var r = this.next();
                    if (typeof r !== 'undefined') {
                        return r;
                    }
                    else {
                        return this.lex();
                    }
                },
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },
                popState: function popState() {
                    return this.conditionStack.pop();
                },
                _currentRules: function _currentRules() {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                },
                topState: function () {
                    return this.conditionStack[this.conditionStack.length - 2];
                },
                pushState: function begin(condition) {
                    this.begin(condition);
                } });
            lexer.options = {};
            lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:/* skip whitespace  */ 
                        break;
                    case 1:
                        this.begin('inbracket');
                        return 12;
                        break;
                    case 2:
                        this.popState();
                        this.begin('preparen');
                        return 13;
                        break;
                    case 3:
                        this.popState();
                        this.begin('inparen1');
                        return 14;
                        break;
                    case 4:
                        this.popState();
                        this.begin('inparen2');
                        return 14;
                        break;
                    case 5:
                        this.popState();
                        this.begin('btwparen');
                        return 15;
                        break;
                    case 6:
                        this.popState();
                        return 15;
                        break;
                    case 7:
                        return 11;
                        break;
                    case 8:
                        return 8;
                        break;
                    case 9:
                        return 8;
                        break;
                    case 10:
                        return 8;
                        break;
                    case 11:
                        return 'NUMBER';
                        break;
                    case 12:
                        return 5;
                        break;
                }
            };
            lexer.rules = [/^(?:\s+)/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\()/, /^(?:\))/, /^(?:\))/, /^(?::)/, /^(?:[^\[]+)/, /^(?:[^\[)]+)/, /^(?:[^\]]+)/, /^(?:[0-9]+(\.[0-9]*)?)/, /^(?:$)/];
            lexer.conditions = { "btwparen": { "rules": [0, 4, 7, 12], "inclusive": true }, "preparen": { "rules": [0, 3, 12], "inclusive": true }, "inbracket": { "rules": [0, 2, 10, 11, 12], "inclusive": true }, "inparen2": { "rules": [0, 1, 6, 9, 12], "inclusive": true }, "inparen1": { "rules": [0, 1, 5, 9, 12], "inclusive": true }, "INITIAL": { "rules": [0, 1, 8, 12], "inclusive": true } };
            return lexer;
        })();
        parser.lexer = lexer;
        function Parser() { this.yy = {}; this.parse = parser.parse; } // Otherwise we fail type checking
        Parser.prototype = parser;
        parser.Parser = Parser;
        return new Parser;
    })();
    function setup() {
        return ConditionalParser;
    }
    
    var FDSDate = /** @class */ (function () {
        function FDSDate(weekType, clockType) {
            if (weekType === void 0) { weekType = 0 /* FIVE_DAY */; }
            if (clockType === void 0) { clockType = 1 /* CT_12_HOUR */; }
            this.adjustUp = this.adjustUp.bind(this);
            this.adjust = this.adjust.bind(this);
            this.weekType = weekType;
            this.clockType = clockType;
        }
        FDSDate.prototype.setWeekType = function (weekType) {
            return this.weekType = weekType;
        };
        FDSDate.prototype.lookupDateBin = function (frequency) {
            if (FDSDate._freqToEnum[frequency] == null) {
                return 0 /* NONE */;
            }
            else {
                return FDSDate._freqToEnum[frequency];
            }
        };
        FDSDate.prototype.lookupTimeBin = function (frequency) {
            var dateBin = this.lookupDateBin(frequency);
            switch (dateBin) {
                case 11 /* HOUR */:
                    return 10000;
                case 10 /* HALFHOUR */:
                    return 3000;
                case 6 /* MINUTE */:
                    return 100;
                case 5 /* HALFMINUTE */:
                    return 30;
                case 1 /* SECOND */:
                    return 0;
                default:
                    var ret = parseInt(frequency);
                    return isNaN(ret) ? 0 : ret;
            }
        };
        FDSDate.prototype.adjustTime = function (day, seconds) {
            var daySeconds = this.nSeconds(0, day); // TODO
            return this.getPackedTimeSeconds(daySeconds + seconds); // TODO
        };
        FDSDate.prototype.julianToNumeric = function (jdate) {
            var _a = FDSDate.getDate(jdate), y = _a[0], m = _a[1], d = _a[2];
            return y * 10000 + m * 100 + d;
        };
        FDSDate.prototype.numericToJulian = function (ndate) {
            var y = ~~(ndate / 10000);
            var m = (~~(ndate / 100)) % 100;
            var d = ndate % 100;
            return FDSDate.getJulian(y, m, d);
        };
        FDSDate.dateMath = function (jdate, nYears, nMonths, nDays) {
            // Special case the nop case. This is more common than you'd think because of sub-day time offsets.
            if (nYears === 0 && nMonths === 0 && nDays === 0) {
                return jdate;
            }
            // temporarily get rid of time info which messes up the getDate / getJulian conversion
            var datepart = ~~jdate;
            var timepart = jdate - datepart;
            var _a = FDSDate.getDate(datepart), yy = _a[0], mm = _a[1], dd = _a[2];
            yy += nYears;
            yy += ~~(nMonths / 12);
            mm += nMonths % 12;
            if (mm < 1) {
                yy--;
                mm += 12;
            }
            else if (mm > 12) {
                yy++;
                mm -= 12;
            }
            var end = FDSDate.getEndOfMonth(yy, mm);
            dd = dd < end ? dd : end;
            dd += nDays;
            return FDSDate.getJulian(yy, mm, dd) + timepart;
        };
        FDSDate.getJulian = function (y, m, d) {
            'using asm';
            // The basic algorithm is explained here: http://www.math.ubc.ca/~cass/jd.pdf
            // Ensure input args are integers
            y = ~~y;
            m = ~~m;
            d = ~~d;
            // February having a variable number of days is the source of lots of headaches.
            // As a result, we are shifting the start of the year to be March 1st instead of January 1st
            // This places February 28th/29th in a place where we are able to more easily ignore it.
            if (m < 3) {
                m += 12;
                y--;
            }
            // Leap-years are defined using the somewhat confusing rule:
            // A year is a leap year if it is:
            //   divisible by 4,
            //   but not divisible by 100,
            //   unless its also divisible by 400
            // using these rules, we can identify the number of leapdays since the year 0 easily enough
            var leapDays = ~~(y / 4) - ~~(y / 100) + ~~(y / 400);
            var daysForYear = ~~(365 * y) + leapDays;
            // The number of days contributed by the month value is somewhat complicated.
            // The formula `f(m) = floor(30.6 * (m+1))` is used as the basis. It can be seen by subtracting from previous
            // values of m that this formula produces the correct pattern of 31's and 30's to line up with the number of days
            // in the month (excluding feb) Fortunately, as described above, we center our calculation around March 1st
            // instead, weren't we smart? :) Because of that, we want this formula to at zero for m=3 to represent number of
            // days since March 1st. To do that, we subtract a constant `floor(30.6*(3+1)) = 122`
            var daysForMonth = ~~(30.6 * (m + 1)) - 122;
            var epochOffset = 693900;
            return ~~(d + daysForMonth + daysForYear - epochOffset);
        };
        FDSDate.prototype.compress = function (jdate, adjFunc) {
            if (adjFunc === void 0) { adjFunc = this.adjust; }
            jdate = adjFunc(jdate);
            if (this.weekType === 0 /* FIVE_DAY */) {
                jdate = (~~(jdate / 7)) * 5 + jdate % 7 - 2;
            }
            return jdate;
        };
        FDSDate.prototype.decompress = function (jdate) {
            var whole = ~~jdate;
            var dec = jdate - whole;
            jdate = whole;
            if (this.weekType === 0 /* FIVE_DAY */) {
                jdate = (~~(jdate / 5)) * 7 + jdate % 5 + 2;
            }
            return jdate + dec;
        };
        FDSDate.prototype.compressUp = function (jdate) {
            return this.compress(jdate, this.adjustUp);
        };
        FDSDate.prototype.compressIntraDay = function (day) {
            return (~~(day / 10000)) * 3600 + (~~(day / 100)) % 100 * 60 + day % 100;
        };
        FDSDate.prototype.getPackedTime = function (h, m, s) {
            return h * 10000 + m * 100 + s;
        };
        FDSDate.prototype.getPackedTimeSeconds = function (seconds) {
            return (~~(seconds / 3600)) * 10000 + (~~((seconds % 3600) / 60)) * 100 + seconds % 60;
        };
        FDSDate.getDayOfWeek = function (jdate) {
            return jdate % 7;
        };
        FDSDate.isWeekend = function (jdate) {
            return (FDSDate.getDayOfWeek(jdate)) < 2;
        };
        FDSDate.isLeapYear = function (y) {
            return ((y % 4 === 0) && !(y % 100 === 0)) || (y % 400 === 0);
        };
        FDSDate.prototype.adjustUp = function (jdate) {
            if (this.weekType === 0 /* FIVE_DAY */) {
                switch (FDSDate.getDayOfWeek(jdate)) {
                    case 0:
                        return jdate + 2;
                    case 1:
                        return jdate + 1;
                }
            }
            return jdate;
        };
        FDSDate.prototype.adjust = function (jdate) {
            if (this.weekType === 0 /* FIVE_DAY */) {
                switch (FDSDate.getDayOfWeek(jdate)) {
                    case 0:
                        return jdate - 1;
                    case 1:
                        return jdate - 2;
                }
            }
            return jdate;
        };
        // Returns [yy, mm, dd]
        FDSDate.getDate = function (jdate) {
            // Apologies on the terrible variable names, they were inherited from the PC side code.
            jdate = ~~jdate;
            if (!jdate) {
                return [0, 0, 0];
            }
            // Rebase to our calculation to remove our epoch
            var epochOffset = 693900;
            var Z = jdate + epochOffset;
            // This portion is taking our julian date and trying to adjust for leap years
            // to get us closer to the actual year.
            var G = Z - 0.25;
            var A = ~~(G / 36524.25);
            var B = A - ~~(A / 4.0);
            // Success, we have a year.
            var yy = ~~((B + G) / 365.25);
            // Now that we have a year, we can plug that back in to deduce what month we are currently in
            var C = B + Z - ~~(365.25 * yy);
            var mm = ~~((5.0 * C + 456.0) / 153.0);
            // And now that we have a month, we can figure out the number of days since the start of month.
            var dd = ~~(C - ~~((153.0 * mm - 457.0) / 5.0));
            // The above date math figures out what the values of mm are from a range 3-14 instead of 1-12
            // because of this, we may need to roll-over to the following year and renormalize the month
            // (see `getJulian` for more info on why things are centered on March).
            if (mm > 12) {
                yy++;
                mm -= 12;
            }
            return [yy, mm, dd];
        };
        FDSDate.prototype.getDay = function (jdate) {
            var _a = FDSDate.getDate(jdate), dd = _a[2];
            return dd;
        };
        FDSDate.getEndOfMonth = function (year, month) {
            switch (month) {
                case 1:
                case 3:
                case 5:
                case 7:
                case 8:
                case 10:
                case 12:
                    return 31;
                case 4:
                case 6:
                case 9:
                case 11:
                    return 30;
                case 2:
                    if (this.isLeapYear(year)) {
                        return 29;
                    }
                    else {
                        return 28;
                    }
                default:
                    return 30;
            }
        };
        FDSDate.prototype.getMonth = function (jdate) {
            var _a = FDSDate.getDate(jdate), m = _a[1];
            return m;
        };
        // returns [month, jstart, jend]
        FDSDate.prototype.getMonthRange = function (jdate) {
            var _a = FDSDate.getDate(jdate), yy = _a[0], mm = _a[1];
            var jstart = this.adjustUp(FDSDate.getJulian(yy, mm, 1));
            var jend = this.adjust(FDSDate.getJulian(yy, mm, FDSDate.getEndOfMonth(yy, mm)));
            return [mm, jstart, jend];
        };
        FDSDate.prototype.getYear = function (jdate) {
            var _a = FDSDate.getDate(jdate), y = _a[0];
            return y;
        };
        // returns [year, jstart, jend]
        FDSDate.prototype.getYearRange = function (jdate, jref) {
            if (jref === void 0) { jref = 0; }
            var month = this.getMonth(jref);
            month = month > 0 ? 12 - month : 0;
            jdate = FDSDate.dateMath(jdate, 0, month, 0);
            var _a = FDSDate.getDate(jdate), year = _a[0];
            var jstart = this.adjustUp(FDSDate.getJulian(year, 1, 1));
            var jend = this.adjust(FDSDate.getJulian(year, 12, 31));
            return [year, jstart, jend];
        };
        // returns [nyear, jstart, jend]
        FDSDate.prototype.getNYear = function (jdate, n) {
            var _a = FDSDate.getDate(jdate), year = _a[0];
            var nblocks = ~~(year / n);
            var jstart = this.adjustUp(FDSDate.getJulian(nblocks * n, 1, 1));
            var jend = this.adjust(FDSDate.getJulian((nblocks + 1) * n - 1, 12, 31));
            return [year, jstart, jend];
        };
        FDSDate.prototype.getWeek = function (jdate) {
            return (~~(jdate / 7)) - (~~(FDSDate.getJulian(this.getYear(jdate), 1, 1) / 7));
        };
        // returns [week, jstart, jend]
        FDSDate.prototype.getWeekRange = function (jdate) {
            var temp = ~~(jdate / 7);
            var jstart = temp * 7;
            var jend = this.adjust(jstart + 6);
            jstart = this.adjustUp(jstart);
            return [temp - (~~(FDSDate.getJulian(this.getYear(jdate), 1, 1) / 7)), jstart, jend];
        };
        FDSDate.prototype.getQuarter = function (jdate) {
            var temp = 1;
            var _a = FDSDate.getDate(jdate), m = _a[1];
            temp += ~~((m - 1) / 3);
            return temp;
        };
        // returns [quarter, jstart, jend]
        FDSDate.prototype.getQuarterRange = function (jdate, jref) {
            if (jref === void 0) { jref = 0; }
            var month = this.getMonth(jref) % 3;
            month = month > 0 ? 3 - month : 0;
            jdate = FDSDate.dateMath(jdate, 0, month, 0);
            var quarter = this.getQuarter(jdate);
            var year = this.getYear(jdate);
            var jstart;
            var jend;
            switch (quarter) {
                case 1:
                    jstart = this.adjustUp(FDSDate.getJulian(year, 1, 1));
                    jend = this.adjust(FDSDate.getJulian(year, 3, 31));
                    break;
                case 2:
                    jstart = this.adjustUp(FDSDate.getJulian(year, 4, 1));
                    jend = this.adjust(FDSDate.getJulian(year, 6, 30));
                    break;
                case 3:
                    jstart = this.adjustUp(FDSDate.getJulian(year, 7, 1));
                    jend = this.adjust(FDSDate.getJulian(year, 9, 30));
                    break;
                case 4:
                    jstart = this.adjustUp(FDSDate.getJulian(year, 10, 1));
                    jend = this.adjust(FDSDate.getJulian(year, 12, 31));
                    break;
            }
            return [quarter, jstart, jend];
        };
        FDSDate.prototype.getHalfYear = function (jdate) {
            var temp = 1;
            var _a = FDSDate.getDate(jdate), m = _a[1];
            temp += ~~((m - 1) / 6);
            return temp;
        };
        // returns [halfyear, jstart, jend]
        FDSDate.prototype.getHalfYearRange = function (jdate, jref) {
            var month = 0;
            if (jref != null) {
                month = (this.getMonth(jref)) % 3;
                month = month > 0 ? 3 - month : 0;
            }
            jdate = FDSDate.dateMath(jdate, 0, month, 0);
            var half = this.getHalfYear(jdate);
            var year = this.getYear(jdate);
            var jstart;
            var jend;
            switch (half) {
                case 1:
                    jstart = this.adjustUp(FDSDate.getJulian(year, 1, 1));
                    jend = this.adjustUp(FDSDate.getJulian(year, 6, 30));
                    break;
                case 2:
                    jstart = this.adjustUp(FDSDate.getJulian(year, 7, 1));
                    jend = this.adjust(FDSDate.getJulian(year, 12, 31));
                    break;
            }
            return [half, jstart, jend];
        };
        FDSDate.prototype.getStringMonth = function (monthNum) {
            if (0 <= monthNum && monthNum < FDSDate._months.length) {
                return FDSDate._months[monthNum];
            }
            else {
                return FDSDate._months[0];
            }
        };
        FDSDate.prototype.getStringDay = function (dayNum) {
            if (0 <= dayNum && dayNum < FDSDate._days.length) {
                return FDSDate._days[dayNum];
            }
            else {
                return FDSDate._days[0];
            }
        };
        FDSDate.prototype.getStringEnding = function (endingNum) {
            if (0 <= endingNum && endingNum < FDSDate._endings.length) {
                return FDSDate._endings[endingNum];
            }
            else {
                return FDSDate._endings[0];
            }
        };
        FDSDate.prototype.nYears = function (min$$1, max$$1) {
            return this.getYear(max$$1) - this.getYear(min$$1);
        };
        FDSDate.prototype.nHalfYears = function (min$$1, max$$1) {
            return 2 * this.nYears(min$$1, max$$1) - this.getHalfYear(min$$1) + this.getHalfYear(max$$1);
        };
        FDSDate.prototype.nQuarters = function (min$$1, max$$1) {
            return 4 * this.nYears(min$$1, max$$1) - this.getQuarter(min$$1) + this.getQuarter(max$$1);
        };
        FDSDate.prototype.nMonths = function (min$$1, max$$1) {
            return 12 * this.nYears(min$$1, max$$1) - this.getMonth(min$$1) + this.getMonth(max$$1);
        };
        FDSDate.prototype.nWeeks = function (min$$1, max$$1) {
            return 53 * this.nYears(min$$1, max$$1) - this.getWeek(min$$1) + this.getWeek(max$$1);
        };
        FDSDate.prototype.nDays = function (min$$1, max$$1) {
            return max$$1 - min$$1;
        };
        FDSDate.prototype.nCompressedDays = function (min$$1, max$$1) {
            return (this.compress(max$$1)) - (this.compress(min$$1));
        };
        FDSDate.prototype.nHours = function (dstart, dend) {
            return (this.getHour(dend)) - (this.getHour(dstart));
        };
        FDSDate.prototype.nMinutes = function (dstart, dend) {
            return 60 * (this.nHours(dstart, dend)) + (this.getMinute(dend)) - (this.getMinute(dstart));
        };
        FDSDate.prototype.nSeconds = function (dstart, dend) {
            return 60 * (this.nMinutes(dstart, dend)) + (this.getSecond(dend)) - (this.getSecond(dstart));
        };
        FDSDate.prototype.nQHours = function (min$$1, max$$1) {
            return 4 * (this.nHours(min$$1, max$$1)) - (this.getQHour(min$$1)) + (this.getQHour(max$$1));
        };
        FDSDate.prototype.nQMinutes = function (min$$1, max$$1) {
            return 4 * (this.nMinutes(min$$1, max$$1)) - (this.getQMinute(min$$1)) + (this.getQMinute(max$$1));
        };
        FDSDate.prototype.getHour = function (day) {
            if (day === 240000) {
                return 24;
            }
            else {
                return (~~(day / 10000)) % 24;
            }
        };
        FDSDate.prototype.getMinute = function (day) {
            return ((~~(day / 100)) % 100) % 60;
        };
        FDSDate.prototype.getSecond = function (day) {
            return (day % 100) % 60;
        };
        // returns [hour, minute, second]
        FDSDate.prototype.getTime = function (day) {
            return [(this.getHour(day)), (this.getMinute(day)), (this.getSecond(day))];
        };
        // returns [hour, start, end]
        FDSDate.prototype.getHourRange = function (day) {
            var hour = this.getHour(day);
            return [hour, (this.getPackedTime(hour, 0, 0)), (this.getPackedTime(hour, 59, 59))];
        };
        // returns [minute, start, edn]
        FDSDate.prototype.getMinuteRange = function (day) {
            var hour = this.getHour(day);
            var minute = this.getMinute(day);
            return [minute, (this.getPackedTime(hour, minute, 0)), (this.getPackedTime(hour, minute, 59))];
        };
        FDSDate.prototype.getQMinute = function (day) {
            var second = this.getSecond(day);
            if (second < 15) {
                return 1;
            }
            else if (second < 30) {
                return 2;
            }
            else if (second < 45) {
                return 3;
            }
            return 4;
        };
        // returns [day, start, end]
        FDSDate.prototype.getQMinuteRange = function (day) {
            var hour = this.getHour(day);
            var minute = this.getMinute(day);
            var qm = this.getQMinute(day);
            var startSecond = 0;
            var endSecond = 14;
            switch (qm) {
                case 2:
                    startSecond = 15;
                    endSecond = 29;
                    break;
                case 3:
                    startSecond = 30;
                    endSecond = 44;
                    break;
                case 4:
                    startSecond = 45;
                    endSecond = 59;
                    break;
            }
            return [qm, (this.getPackedTime(hour, minute, startSecond)), (this.getPackedTime(hour, minute, endSecond))];
        };
        FDSDate.prototype.getQHour = function (day) {
            var minute = this.getMinute(day);
            if (minute < 15) {
                return 1;
            }
            if (minute < 30) {
                return 2;
            }
            if (minute < 45) {
                return 3;
            }
            return 4;
        };
        // Returns [qhour, start, end]
        FDSDate.prototype.getQHourRange = function (day) {
            var hour = this.getHour(day);
            var qhour = this.getQHour(day);
            var startMinute = 0;
            var endMinute = 14;
            switch (qhour) {
                case 2:
                    startMinute = 15;
                    endMinute = 29;
                    break;
                case 3:
                    startMinute = 30;
                    endMinute = 44;
                    break;
                case 4:
                    startMinute = 45;
                    endMinute = 59;
                    break;
            }
            return [qhour, (this.getPackedTime(hour, startMinute, 0)), (this.getPackedTime(hour, endMinute, 59))];
        };
        FDSDate.prototype.getTimeBin = function (day, bin) {
            var daySeconds = this.nSeconds(0, day);
            var binSeconds = this.nSeconds(0, bin);
            return ~~(daySeconds / (binSeconds > 0 ? binSeconds : 1));
        };
        // returns [bin, start, end]
        FDSDate.prototype.getTimeBinRange = function (day, bin) {
            var ret = this.getTimeBin(day, bin);
            var binSeconds = this.nSeconds(0, bin);
            if (binSeconds === 0) {
                return [ret, this.getPackedTimeSeconds(ret), this.getPackedTimeSeconds(ret)];
            }
            else {
                return [
                    ret,
                    this.getPackedTimeSeconds(ret * binSeconds),
                    this.getPackedTimeSeconds(ret * binSeconds + binSeconds - 1)
                ];
            }
        };
        FDSDate.prototype.nTimeBins = function (bin, dstart, dend) {
            return (this.getTimeBin(dend, bin)) - (this.getTimeBin(dstart, bin));
        };
        FDSDate.prototype.mapToSimpleBin = function (dateBin) {
            switch (dateBin) {
                case 15 /* WEEK */:
                    return 15 /* WEEK */;
                case 16 /* MONTH */:
                    return 16 /* MONTH */;
                case 17 /* QUARTER */:
                    return 17 /* QUARTER */;
                case 18 /* HALFY */:
                    return 18 /* HALFY */;
                case 19 /* YEAR */:
                    return 19 /* YEAR */;
                case 22 /* TENY */:
                    return 22 /* TENY */;
                case 21 /* FIVEY */:
                    return 21 /* FIVEY */;
                case 20 /* TWOY */:
                    return 20 /* TWOY */;
                default:
                    return 14 /* DAY */;
            }
        };
        // returns [item, start, end]
        FDSDate.prototype.getCalendarRange = function (dateBin, jdate) {
            switch (dateBin) {
                case 15 /* WEEK */:
                    return this.getWeekRange(jdate);
                case 16 /* MONTH */:
                    return this.getMonthRange(jdate);
                case 17 /* QUARTER */:
                    return this.getQuarterRange(jdate);
                case 18 /* HALFY */:
                    return this.getHalfYearRange(jdate);
                case 19 /* YEAR */:
                    return this.getYearRange(jdate);
                case 22 /* TENY */:
                    return this.getNYear(jdate, 10);
                case 20 /* TWOY */:
                    return this.getNYear(jdate, 2);
                case 21 /* FIVEY */:
                    return this.getNYear(jdate, 5);
                default:
                    return [jdate, jdate, jdate];
            }
        };
        FDSDate.prototype.numericToPercentage = function (ntime) {
            // This division SHOULD ACTUALLY be floating-point.
            return (this.compressIntraDay(ntime)) / 86400.0;
        };
        FDSDate.prototype.percentageToNumeric = function (ntime) {
            return this.getPackedTimeSeconds(~~((ntime * 86400) + 0.5));
        };
        FDSDate.prototype.filterTime = function (day) {
            return this.getPackedTime(this.getHour(day), this.getMinute(day), this.getSecond(day));
        };
        FDSDate._days = [
            'Saturday',
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday'
        ];
        FDSDate._months = [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ];
        FDSDate._endings = [
            'st',
            'nd',
            'rd',
            'th'
        ];
        FDSDate._freqToEnum = {
            'Y': 19 /* YEAR */,
            'Q': 17 /* QUARTER */,
            'D': 14 /* DAY */,
            'CQ': 17 /* QUARTER */,
            'FQ': 17 /* QUARTER */,
            'AQ': 17 /* QUARTER */,
            'QTD': 17 /* QUARTER */,
            'FQTD': 17 /* QUARTER */,
            'CQTD': 17 /* QUARTER */,
            'HY': 18 /* HALFY */,
            'FY': 19 /* YEAR */,
            'AY': 19 /* YEAR */,
            'CY': 19 /* YEAR */,
            '2Y': 20 /* TWOY */,
            '5Y': 21 /* FIVEY */,
            '10Y': 22 /* TENY */,
            'YTD': 19 /* YEAR */,
            'CYTD': 19 /* YEAR */,
            'FYTD': 19 /* YEAR */,
            'M': 16 /* MONTH */,
            'AM': 16 /* MONTH */,
            'MTD': 16 /* MONTH */,
            'W': 15 /* WEEK */,
            'AW': 15 /* WEEK */,
            'WTD': 15 /* WEEK */,
            'TH': 11 /* HOUR */,
            'TM': 6 /* MINUTE */,
            'THH': 10 /* HALFHOUR */,
            'THM': 5 /* HALFMINUTE */,
            'TS': 1 /* SECOND */,
            'S': 1 /* SECOND */,
            'NONE': 0 /* NONE */
        };
        return FDSDate;
    }());
    
    var parser = setup();
    var FormatDesc = /** @class */ (function () {
        function FormatDesc() {
            this._init();
        }
        FormatDesc.prototype._init = function () {
            this.sign = false;
            this.parens = false;
            this.capE = true;
            this.decimal = false;
            this.comma = false;
            this.percent = false;
            this.preDecimal = -1;
            this.decimals = 0;
            this.denominator = 0;
            this.type = 0 /* DEFAULT */;
            this.locale = 0 /* WESTERN */;
        };
        return FormatDesc;
    }());
    var FormatParser = /** @class */ (function () {
        function FormatParser() {
        }
        FormatParser._padToTwo = function (value) {
            return (value < 10 ? '0' : '') + value;
        };
        FormatParser._formatValue = function (value, formatDesc) {
            var absVal = Math.abs(value);
            if (!formatDesc.decimal) {
                return absVal.toFixed() + '.';
            }
            else if (formatDesc.decimals >= 0) {
                return absVal.toFixed(formatDesc.decimals);
            }
            else {
                return absVal.toString();
            }
        };
        FormatParser.prototype._printGeneral = function (value, formatDesc) {
            var decValue = FormatParser._formatValue(value, formatDesc);
            var decPosition = decValue.indexOf('.');
            var isEuro = formatDesc.locale === 1;
            var floatingPoint = false;
            if (formatDesc.decimals < 0) {
                floatingPoint = true;
            }
            if (formatDesc.decimals < 0) {
                formatDesc.decimals = decValue.length;
            }
            var decPart = decPosition === -1 ? '' : decValue.substring(decPosition + 1, decValue.length);
            if (!floatingPoint && decPart.length < formatDesc.decimals) {
                for (var i = 0; i < formatDesc.decimals - decPart.length; i++) {
                    decPart += '0';
                }
            }
            if (decPart.length > formatDesc.decimals) {
                decPart = decPart.substr(0, formatDesc.decimals);
            }
            var start = 0;
            var commaEnd = decPosition >= 0 ? decPosition : decValue.length;
            var intPart;
            if (formatDesc.comma && commaEnd > 3) {
                intPart = '';
                for (var i = commaEnd; i >= start; i -= 3) {
                    intPart = (decValue.substr(Math.max(start, i - 3), Math.min(3, i - start))) + intPart;
                    if (i - 3 > 0) {
                        intPart = (isEuro ? '.' : ',') + intPart;
                    }
                }
            }
            else {
                if (decPosition < 0) {
                    decPosition = decValue.length;
                }
                intPart = decValue.substr(start, (decPosition - start));
            }
            if (intPart === '0' && formatDesc.preDecimal === 0) {
                intPart = '';
            }
            var preDecimal = '';
            if (intPart.length < formatDesc.preDecimal) {
                for (var i = intPart.length; i < formatDesc.preDecimal; i++) {
                    preDecimal += '0';
                }
            }
            var out = '';
            if (value < 0) {
                out += formatDesc.parens ? '(' : '-';
            }
            else if (formatDesc.sign && value > 0) {
                out += '+';
            }
            if (formatDesc.preDecimal > 0) {
                out += preDecimal;
            }
            out += intPart;
            if (decPart !== '') {
                out += isEuro ? ',' : '.';
                out += decPart;
            }
            if (formatDesc.percent) {
                out += '%';
            }
            if (value < 0 && formatDesc.parens) {
                out += ')';
            }
            return out;
        };
        FormatParser.prototype._printExp = function (value, formatDesc) {
            return '';
        };
        FormatParser.prototype._printFract = function (value, formatDesc) {
            return '';
        };
        FormatParser._handleEscaping = function (regex, match) {
            // find the next quote not preceeded by a backslash
            if (match.input != null && match.index != null) {
                var quoteMatch = /[^\\]"/.exec(match.input.substr(match.index));
                if (quoteMatch) {
                    var nextQuote = match.index + quoteMatch.index + quoteMatch[0].length;
                    regex.lastIndex = nextQuote; // fast-forward the regex past the end of the last quote
                    return match.input.substr(match.index + 1, nextQuote - match.index - 2).replace(/\\"/g, '"');
                }
            }
            return '"';
        };
        FormatParser.prototype.buildTimeFormatString = function (formatString) {
            var cfs = new CompiledFormatString(FormatValueContextTime);
            var timeRe = /"|\\"|h{1,2}|H{1,2}|m{1,2}|M{1,2}|s{1,2}|S{1,2}|am|AM/g;
            var lastIndex = 0;
            var match;
            while (match = timeRe.exec(formatString)) {
                if (match.index != null && match.index !== lastIndex) {
                    // some string before this didn't capture
                    cfs.push(formatString.substr(lastIndex, (match.index - lastIndex)));
                }
                // Handle formatting tokens
                switch (match[0]) {
                    case '\\"':
                        cfs.push('"');
                        break;
                    case '"':
                        cfs.push(FormatParser._handleEscaping(timeRe, match));
                        break;
                    case 'h':
                        cfs.push(function (ctx) {
                            var hour = ctx.hour % 12;
                            if (hour === 0) {
                                hour = 12;
                            }
                            return hour.toFixed(0);
                        });
                        break;
                    case 'hh':
                        cfs.push(function (ctx) {
                            var hour = ctx.hour % 12;
                            if (hour === 0) {
                                hour = 12;
                            }
                            return FormatParser._padToTwo(hour);
                        });
                        break;
                    case 'H':
                        cfs.push(function (ctx) {
                            return ctx.hour.toFixed(0);
                        });
                        break;
                    case 'HH':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.hour);
                        });
                        break;
                    case 'm':
                    case 'M':
                        cfs.push(function (ctx) {
                            return ctx.minute.toFixed(0);
                        });
                        break;
                    case 'mm':
                    case 'MM':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.minute);
                        });
                        break;
                    case 's':
                    case 'S':
                        cfs.push(function (ctx) {
                            return ctx.second.toFixed(0);
                        });
                        break;
                    case 'ss':
                    case 'SS':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.second);
                        });
                        break;
                    case 'am':
                        cfs.push(function (ctx) {
                            return ctx.am ? 'am' : 'pm';
                        });
                        break;
                    case 'AM':
                        cfs.push(function (ctx) {
                            return ctx.am ? 'AM' : 'PM';
                        });
                        break;
                }
                lastIndex = timeRe.lastIndex;
            }
            if (lastIndex < formatString.length) {
                cfs.push(formatString.substr(lastIndex));
            }
            return cfs;
        };
        FormatParser.prototype.buildDateFormatString = function (formatString) {
            var cfs = new CompiledFormatString(FormatValueContextDate);
            var dateRe = /("|\\"|d{1,2}|D{1,4}|m{1,2}|M{1,4}|q{1,4}|Q{1,4}|e{1,3}|E{1,3}|y{1,4}|Y{1,4})/g;
            var lastIndex = 0;
            var match;
            var _loop_1 = function () {
                if (match.index != null && match.index !== lastIndex) {
                    cfs.push(formatString.substr(lastIndex, match.index - lastIndex));
                }
                switch (match[0]) {
                    case '\\"':
                        cfs.push('"');
                        break;
                    case '"':
                        cfs.push(FormatParser._handleEscaping(dateRe, match));
                        break;
                    case 'd':
                        cfs.push(function (ctx) {
                            return ctx.day.toFixed(0);
                        });
                        break;
                    case 'dd':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.day);
                        });
                        break;
                    case 'D':
                    case 'DD':
                    case 'DDD':
                        cfs.push((function (matchLen) { return function (ctx) {
                            return ctx.date.getStringDay((FDSDate.getDayOfWeek(ctx.value))).substring(0, matchLen);
                        }; })(match[0].length));
                        break;
                    case 'DDDD':
                        cfs.push(function (ctx) {
                            return ctx.date.getStringDay((FDSDate.getDayOfWeek(ctx.value)));
                        });
                        break;
                    case 'm':
                        cfs.push(function (ctx) {
                            return ctx.month.toFixed(0);
                        });
                        break;
                    case 'mm':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.month);
                        });
                        break;
                    case 'M':
                    case 'MM':
                    case 'MMM':
                        cfs.push((function (matchLen) { return function (ctx) {
                            return ctx.date.getStringMonth(ctx.month - 1).substring(0, matchLen);
                        }; })(match[0].length));
                        break;
                    case 'MMMM':
                        cfs.push(function (ctx) {
                            return ctx.date.getStringMonth(ctx.month - 1);
                        });
                        break;
                    case 'q':
                    case 'qq':
                    case 'qqq':
                    case 'qqqq':
                        var prefix_1 = ['', 'Q', 'Qtr ', 'Quarter '];
                        cfs.push((function (matchLen) { return function (ctx) {
                            return prefix_1[matchLen - 1] + ctx.date.getQuarter(ctx.value);
                        }; })(match[0].length));
                        break;
                    case 'Q':
                    case 'QQ':
                    case 'QQQ':
                    case 'QQQQ':
                        var suffix_1 = ['', ' Q', ' Qtr', ' Quarter'];
                        cfs.push((function (matchLen) { return function (ctx) {
                            return ctx.date.getQuarter(ctx.value) + ctx.date.getStringEnding(ctx.date.getQuarter(ctx.value) - 1) +
                                suffix_1[matchLen - 1];
                        }; })(match[0].length));
                        break;
                    case 'e':
                    case 'ee':
                    case 'eee':
                        prefix_1 = ['', 'H', 'Half '];
                        cfs.push((function (matchLen) { return function (ctx) {
                            return prefix_1[matchLen - 1] + (ctx.date.getHalfYear(ctx.value));
                        }; })(match[0].length));
                        break;
                    case 'E':
                    case 'EE':
                    case 'EEE':
                        suffix_1 = ['', ' H', ' Half'];
                        cfs.push((function (matchLen) { return function (ctx) {
                            return ctx.date.getHalfYear(ctx.value) +
                                ctx.date.getStringEnding(ctx.date.getHalfYear(ctx.value) - 1) + suffix_1[matchLen - 1];
                        }; })(match[0].length));
                        break;
                    case 'y':
                    case 'Y':
                    case 'yy':
                    case 'YY':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo((ctx.year % 100));
                        });
                        break;
                    case 'yyy':
                    case 'YYY':
                    case 'yyyy':
                    case 'YYYY':
                        cfs.push(function (ctx) {
                            return ctx.year.toFixed(0);
                        });
                        break;
                }
                (lastIndex = dateRe.lastIndex);
            };
            while (match = dateRe.exec(formatString)) {
                _loop_1();
            }
            if (lastIndex < formatString.length) {
                cfs.push(formatString.substr(lastIndex));
            }
            return cfs;
        };
        FormatParser.prototype.buildDateTimeFormatString = function (formatString) {
            var cfs = new CompiledFormatString(FormatValueContextDateTime);
            var dateTimeRe = /("|\\"|c|[Dd]{1,6}|[Ww]{1,2}|[Mm]{1,4}|[Qq]{1,4}|[Ee]{1,3}|[Yy]{1,4}|[Hh]{1,2}|[Nn]{1,2}|[Ss]{1,2}|ttttt|a\/?m|A\/?M)/g;
            var lastIndex = 0;
            var match;
            var _loop_2 = function () {
                if (match.index != null && match.index !== lastIndex) {
                    cfs.push(formatString.substr(lastIndex, match.index - lastIndex));
                }
                switch (match[0]) {
                    case '\\"':
                        cfs.push('"');
                        break;
                    case '"':
                        cfs.push(FormatParser._handleEscaping(dateTimeRe, match));
                        break;
                    case 'c':
                        cfs.push(function (ctx) {
                            var ret = '';
                            if (ctx.year !== 0 && ctx.month !== 0 && ctx.day !== 0) {
                                ret = ctx.month.toFixed(0) + "/" + ctx.day.toFixed(0) + "/" + FormatParser._padToTwo(ctx.year % 100);
                                if (ctx.hour !== 0 && ctx.minute !== 0 && ctx.second !== 0) {
                                    ret += ' ';
                                }
                            }
                            if (ctx.hour !== 0 && ctx.minute !== 0 && ctx.second !== 0) {
                                ret
                                    += ctx.amhour.toFixed(0) + ":" + FormatParser._padToTwo(ctx.minute) + ":" + FormatParser._padToTwo(ctx.second) + " " + (ctx.am ?
                                        'AM' :
                                        'PM');
                            }
                            return ret;
                        });
                        break;
                    case 'd':
                        cfs.push(function (ctx) {
                            return ctx.day.toFixed(0);
                        });
                        break;
                    case 'dd':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.day);
                        });
                        break;
                    case 'D':
                    case 'DD':
                    case 'DDD':
                    case 'ddd':
                        cfs.push((function (matchLen) {
                            return function (ctx) {
                                return ctx.date.getStringDay(FDSDate.getDayOfWeek(ctx.ymd)).substring(0, matchLen);
                            };
                        })(match[0].length));
                        break;
                    case 'dddd':
                    case 'DDDD':
                        cfs.push(function (ctx) {
                            return ctx.date.getStringDay((FDSDate.getDayOfWeek(ctx.ymd)));
                        });
                        break;
                    case 'ddddd':
                    case 'DDDDD':
                        cfs.push(function (ctx) {
                            return ctx.month.toFixed(0) + "/" + ctx.day.toFixed(0) + "/" + FormatParser._padToTwo(ctx.year % 100);
                        });
                        break;
                    case 'dddddd':
                    case 'DDDDDD':
                        cfs.push(function (ctx) {
                            return ctx.date.getStringMonth((ctx.month - 1)) + " " + FormatParser._padToTwo(ctx.day) + ", " + ctx.year;
                        });
                        break;
                    case 'w':
                    case 'W':
                        cfs.push(function (ctx) {
                            return FDSDate.getDayOfWeek(ctx.ymd).toFixed(0);
                        });
                        break;
                    case 'ww':
                    case 'WW':
                        cfs.push(function (ctx) {
                            return ctx.date.getWeek(ctx.ymd).toFixed(0);
                        });
                        break;
                    case 'm':
                        cfs.push(function (ctx) {
                            return ctx.month.toFixed(0);
                        });
                        break;
                    case 'mm':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.month);
                        });
                        break;
                    case 'M':
                    case 'MM':
                    case 'MMM':
                        cfs.push((function (matchLen) {
                            return function (ctx) {
                                return ctx.date.getStringMonth(ctx.month - 1).substring(0, matchLen);
                            };
                        })(match[0].length));
                        break;
                    case 'MMMM':
                        cfs.push(function (ctx) {
                            return ctx.date.getStringMonth(ctx.month - 1);
                        });
                        break;
                    case 'q':
                    case 'qq':
                    case 'qqq':
                    case 'qqqq':
                        var prefix_2 = ['', 'Q', 'Qtr ', 'Quarter '];
                        cfs.push((function (matchLen) {
                            return function (ctx) {
                                return prefix_2[matchLen - 1] + (ctx.date.getQuarter(ctx.ymd));
                            };
                        })(match[0].length));
                        break;
                    case 'Q':
                    case 'QQ':
                    case 'QQQ':
                    case 'QQQQ':
                        var suffix_2 = ['', ' Q', ' Qtr', ' Quarter'];
                        cfs.push((function (matchLen) {
                            return function (ctx) {
                                return (ctx.date.getQuarter(ctx.ymd)) +
                                    (ctx.date.getStringEnding((ctx.date.getQuarter(ctx.ymd)) - 1)) + suffix_2[matchLen - 1];
                            };
                        })(match[0].length));
                        break;
                    case 'e':
                    case 'ee':
                    case 'eee':
                        prefix_2 = ['', 'H', 'Half '];
                        cfs.push((function (matchLen) {
                            return function (ctx) {
                                return prefix_2[matchLen - 1] + (ctx.date.getHalfYear(ctx.ymd));
                            };
                        })(match[0].length));
                        break;
                    case 'E':
                    case 'EE':
                    case 'EEE':
                        suffix_2 = ['', ' H', ' Half'];
                        cfs.push((function (matchLen) {
                            return function (ctx) {
                                return (ctx.date.getHalfYear(ctx.ymd)) +
                                    (ctx.date.getStringEnding((ctx.date.getHalfYear(ctx.ymd)) - 1)) + suffix_2[matchLen - 1];
                            };
                        })(match[0].length));
                        break;
                    case 'y':
                    case 'Y':
                        cfs.push(function (ctx) {
                            return ((ctx.year - 1900) % 366 + 1).toFixed();
                        });
                        break;
                    case 'yy':
                    case 'YY':
                        cfs.push(function (ctx) {
                            return FormatParser._padToTwo(ctx.year % 100);
                        });
                        break;
                    case 'yyy':
                    case 'YYY':
                    case 'yyyy':
                    case 'YYYY':
                        cfs.push(function (ctx) {
                            return ctx.year.toFixed();
                        });
                        break;
                    case 'h':
                    case 'hh':
                        cfs.push((function (clipLen) {
                            return function (ctx) {
                                return ctx.padOrFixed(ctx.amhour, clipLen);
                            };
                        })(match[0].length === 2));
                        break;
                    case 'H':
                    case 'HH':
                        cfs.push((function (clipLen) {
                            return function (ctx) {
                                return ctx.padOrFixed(ctx.hour, clipLen);
                            };
                        })(match[0].length === 2));
                        break;
                    case 'n':
                    case 'N':
                    case 'nn':
                    case 'NN':
                        cfs.push((function (clipLen) {
                            return function (ctx) {
                                return ctx.padOrFixed(ctx.minute, clipLen);
                            };
                        })(match[0].length === 2));
                        break;
                    case 's':
                    case 'S':
                    case 'ss':
                    case 'SS':
                        cfs.push((function (clipLen) {
                            return function (ctx) {
                                return ctx.padOrFixed(ctx.second, clipLen);
                            };
                        })(match[0].length === 2));
                        break;
                    case 'ttttt':
                        cfs.push(function (ctx) {
                            return ctx.amhour + ":" + FormatParser._padToTwo(ctx.minute) + ":" + FormatParser._padToTwo(ctx.second) + " " + (ctx.am ?
                                'A.M.' :
                                'P.M.');
                        });
                        break;
                    case 'am':
                        cfs.push(function (ctx) {
                            return ctx.am ? 'am' : 'pm';
                        });
                        break;
                    case 'AM':
                        cfs.push(function (ctx) {
                            return ctx.am ? 'AM' : 'PM';
                        });
                        break;
                }
                lastIndex = dateTimeRe.lastIndex;
            };
            while (match = dateTimeRe.exec(formatString)) {
                _loop_2();
            }
            if (lastIndex < formatString.length) {
                cfs.push(formatString.substr(lastIndex));
            }
            return cfs;
        };
        FormatParser.prototype.buildNumberFormatString = function (formatString, padLength) {
            var _this = this;
            if (padLength === void 0) { padLength = -1; }
            var cfs = new CompiledFormatString(FormatValueContextNumber);
            // This function basically allows us to dispatch to member functions from
            // FormatParser inside a CompiledFormatString closure.
            var dispatchTypedPrintFunction = function (typeSpecifier, value, formatDesc, _padLength, plain) {
                if (_padLength === void 0) { _padLength = -1; }
                if (plain === void 0) { plain = false; }
                // If we want to print with out any fancy stuff (parens, or what have you, we should
                // clobber whatever format descriptor already exists. Only used in the case where we are padding
                // and we need to determine the length to pad to.
                if (plain === true) {
                    formatDesc = new FormatDesc();
                }
                switch (typeSpecifier) {
                    case 'G':
                        formatDesc.type = 4 /* GENERAL */;
                        formatDesc.decimals = _padLength;
                        formatDesc.decimal = true;
                        formatDesc.comma = true;
                        return _this._printGeneral(value, formatDesc);
                    case 'E':
                        formatDesc.type = 5 /* EXP */;
                        return _this._printExp(value, formatDesc);
                    case 'I':
                        formatDesc.decimal = false;
                        formatDesc.decimals = 0;
                        formatDesc.type = 8 /* INT */;
                        return _this._printGeneral(value, formatDesc);
                    case 'F':
                        formatDesc.decimal = true;
                        formatDesc.type = 7 /* FIXED */;
                        return _this._printGeneral(value, formatDesc);
                    case '/':
                        formatDesc.type = 6 /* FRACT */;
                        return _this._printFract(value, formatDesc);
                }
                return '';
            };
            var numberFormatRe = /"|\\"|#((?:,|\d*\.?\d+|\d+\.?\d*|\+|~|\(|%)*)([GEIFgeif\/])/g;
            var operatorRe = /(,|\d*\.?\d+|\d+\.?\d*|\+|~|\(|%)/g;
            var lastIndex = 0;
            // if the format string doesn't contain any real formatting, push
            // empty string to cfs so it doesn't think that it is empty down below
            if (!numberFormatRe.test(formatString) && formatString !== '') {
                cfs.push('');
            }
            numberFormatRe.lastIndex = 0;
            var match;
            while (match = numberFormatRe.exec(formatString)) {
                // IIFE needed to capture formatdDesc correctly
                lastIndex = (function () {
                    var formatDesc = new FormatDesc();
                    // Handle the chunks of the string that aren't formatting operators
                    if (match.index != null && match.index !== lastIndex) {
                        cfs.push(formatString.substr(lastIndex, match.index - lastIndex));
                    }
                    if (match[0] === '\\"') {
                        cfs.push('"');
                    }
                    else if (match[0] === '"') {
                        cfs.push(FormatParser._handleEscaping(numberFormatRe, match));
                    }
                    else {
                        // At this point, we have the match group containing the formatting
                        // operators, so now we get to handle that individually
                        var typeSpecifier_1 = match[match.length - 1].toUpperCase();
                        if (match[1] != null) {
                            var subMatch = void 0;
                            while (subMatch = operatorRe.exec(match[1])) {
                                switch (subMatch[0]) {
                                    case ',':
                                        formatDesc.comma = true;
                                        break;
                                    case '+':
                                        formatDesc.sign = true;
                                        break;
                                    case '~':
                                        formatDesc.locale = 1 /* EUROPEAN */;
                                        break;
                                    case '(':
                                        formatDesc.parens = true;
                                        break;
                                    case '%':
                                        formatDesc.percent = true;
                                        break;
                                    default:
                                        // This handles decimal specifications
                                        var _a = subMatch[0].split('.'), predec = _a[0], postdec = _a[1];
                                        // pad 1 digit pre-decimal if nothing is specified
                                        formatDesc.preDecimal = predec ? Number(predec) : 1;
                                        formatDesc.decimals = postdec ? Number(postdec) : 0;
                                        formatDesc.decimal = postdec ? true : false;
                                }
                            }
                        }
                        cfs.push(function (ctx, _padLength, plain) {
                            return dispatchTypedPrintFunction(typeSpecifier_1, ctx.value, formatDesc, _padLength, plain);
                        });
                    }
                    return numberFormatRe.lastIndex;
                })();
            }
            if (cfs.formatStringEmpty()) {
                var formatDesc_1 = new FormatDesc();
                cfs.push(function (ctx, _padLength) {
                    formatDesc_1.type = 4 /* GENERAL */;
                    return dispatchTypedPrintFunction('G', ctx.value, formatDesc_1, _padLength);
                });
            }
            cfs.push(formatString.substr(lastIndex, formatString.length));
            return cfs;
        };
        FormatParser.prototype.parseConditionalFormatAndApply = function (formatString, valueOrArray) {
            // return if the string is just whitespace or if either input is undefined
            if (formatString === undefined || valueOrArray === undefined || formatString.match(/[^\s]/) === null) {
                return _$1.isArray(valueOrArray) ? [formatString] : formatString;
            }
            var list = this.parseConditionalFormat(formatString);
            return this._applyParsedList(list, valueOrArray);
        };
        FormatParser.prototype.applyParsedList = function (list, valueOrArray) {
            return this._applyParsedList(list, valueOrArray);
        };
        FormatParser.prototype._applyParsedListToArray = function (list, inputs) {
            if (list === null || list.length === 0) {
                return inputs.map(function (v) { return v.toString(); });
            }
            var outputs = [];
            var foundCond = false;
            for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
                var rawInput = inputs_1[_i];
                var result = '';
                for (var _a = 0, list_1 = list; _a < list_1.length; _a++) {
                    var item = list_1[_a];
                    // for now just combine everything
                    result = result + this._walkConditionTree(item, rawInput);
                }
                outputs.push(result);
            }
            return outputs;
        };
        FormatParser.prototype._applyParsedList = function (list, inputs) {
            if (_$1.isArray(inputs)) {
                return this._applyParsedListToArray(list, inputs);
            }
            else {
                return this._applyParsedListToArray(list, [inputs])[0];
            }
        };
        FormatParser.prototype.getAllFormatsFromParsedList = function (list) {
            if (list.length === 0) {
                return [''];
            }
            var first$$1 = list[0];
            if (typeof first$$1 === 'string') {
                return [first$$1];
            }
            var output = [];
            this._getAllFormatsHelper(first$$1, output);
            return output;
        };
        FormatParser.prototype._getAllFormatsHelper = function (node, output) {
            if (typeof node.falseBranch === 'string') {
                output.push(node.falseBranch);
            }
            else {
                this._getAllFormatsHelper(node.falseBranch, output);
            }
            if (typeof node.trueBranch === 'string') {
                output.push(node.trueBranch);
            }
            else {
                this._getAllFormatsHelper(node.trueBranch, output);
            }
        };
        // takes in condition tree and a single input, returns a single output
        FormatParser.prototype._walkConditionTree = function (root, rawInput) {
            if (root === null) {
                return rawInput.toString();
            }
            var node = root;
            while (typeof node !== 'string') {
                var input = void 0;
                if (typeof rawInput === 'number') {
                    input = rawInput;
                }
                else {
                    input = parseFloat(rawInput);
                    if (input === undefined) {
                        return rawInput.toString();
                    }
                }
                var cond = this._parseCond(node.condition, input);
                if (cond) {
                    node = node.trueBranch;
                }
                else {
                    node = node.falseBranch;
                }
            }
            // At this point, we know that node is a leaf-node string
            return node;
        };
        // function to parse a conditional phrase ('<5', '>=100', etc)
        FormatParser.prototype._parseCond = function (condition, input) {
            var first$$1 = condition.substr(0, 1);
            var firsttwo = condition.substr(0, 2);
            var num;
            // figure out what comparison string we're looking at
            if (firsttwo === '<=' || firsttwo === '>=') {
                num = 2;
            }
            else if (first$$1 === '<' || first$$1 === '>' || first$$1 === '=') {
                num = 1;
            }
            else {
                return false;
            }
            // make sure the value we're comparing against is actually a valid number
            var value = parseFloat(condition.substr(num, condition.length - num));
            if (value === undefined) {
                return false;
            }
            // compare the input and value based on the comparison string
            var comp = num === 1 ? first$$1 : firsttwo;
            switch (comp) {
                case '<':
                    return input < value;
                case '>':
                    return input > value;
                case '>=':
                    return input >= value;
                case '<=':
                    return input <= value;
                case '=':
                    return input === value;
                default:
                    return false;
            }
        };
        // takes a format string and parses it into a parse tree
        FormatParser.prototype.parseConditionalFormat = function (formatString) {
            try {
                return parser.parse(formatString);
            }
            catch (err) {
                if (ENABLE_DEBUG) {
                    console.error(err.toString());
                }
                return [];
            }
        };
        return FormatParser;
    }());
    var FormatValueContext = /** @class */ (function () {
        function FormatValueContext(value) {
            this.value = value;
        }
        return FormatValueContext;
    }());
    var FormatValueContextTime = /** @class */ (function (_super) {
        __extends(FormatValueContextTime, _super);
        function FormatValueContextTime(value) {
            var _this = _super.call(this, value) || this;
            var date = new FDSDate();
            _a = date.getTime(value), _this.hour = _a[0], _this.minute = _a[1], _this.second = _a[2];
            _this.am = _this.hour < 12 ? true : false;
            return _this;
            var _a;
        }
        return FormatValueContextTime;
    }(FormatValueContext));
    var FormatValueContextDate = /** @class */ (function (_super) {
        __extends(FormatValueContextDate, _super);
        function FormatValueContextDate(value) {
            var _this = _super.call(this, value) || this;
            _this.date = new FDSDate();
            _a = FDSDate.getDate(_this.value), _this.year = _a[0], _this.month = _a[1], _this.day = _a[2];
            return _this;
            var _a;
        }
        return FormatValueContextDate;
    }(FormatValueContext));
    var FormatValueContextDateTime = /** @class */ (function (_super) {
        __extends(FormatValueContextDateTime, _super);
        function FormatValueContextDateTime(value) {
            var _this = _super.call(this, value) || this;
            _this.date = new FDSDate();
            _this.ymd = ~~_this.value;
            _this.hms = _this.date.percentageToNumeric((_this.value - _this.ymd));
            _a = FDSDate.getDate(_this.ymd), _this.year = _a[0], _this.month = _a[1], _this.day = _a[2];
            _b = _this.date.getTime(_this.hms), _this.hour = _b[0], _this.minute = _b[1], _this.second = _b[2];
            _this.amhour = _this.hour % 12;
            if (_this.amhour === 0) {
                _this.amhour = 12;
            }
            _this.am = _this.hour < 12 ? true : false;
            return _this;
            var _a, _b;
        }
        FormatValueContextDateTime.prototype.padOrFixed = function (value, pad) {
            return pad ? FormatParser._padToTwo(value) : value.toFixed(0);
        };
        return FormatValueContextDateTime;
    }(FormatValueContext));
    var FormatValueContextNumber = /** @class */ (function (_super) {
        __extends(FormatValueContextNumber, _super);
        function FormatValueContextNumber(value) {
            return _super.call(this, value) || this;
        }
        return FormatValueContextNumber;
    }(FormatValueContext));
    var CompiledFormatString = /** @class */ (function () {
        function CompiledFormatString(_ctxConstructor) {
            this._ctxConstructor = _ctxConstructor;
            this._formatChunks = [];
        }
        CompiledFormatString.prototype.push = function (chunk) {
            this._formatChunks.push(chunk);
        };
        CompiledFormatString.prototype.formatStringEmpty = function () {
            return this._formatChunks.length === 0;
        };
        CompiledFormatString.prototype.fromValue = function (value, padToLength, plain) {
            if (padToLength === void 0) { padToLength = -1; }
            if (plain === void 0) { plain = false; }
            // Don't bother with setup if we're empty
            if (this.formatStringEmpty()) {
                return '';
            }
            // Setup the value context
            var valueContext = new this._ctxConstructor(value);
            var ret = '';
            var chunks = this._formatChunks;
            for (var _i = 0, chunks_1 = chunks; _i < chunks_1.length; _i++) {
                var chunk = chunks_1[_i];
                if (chunk instanceof Function) {
                    ret += chunk(valueContext, padToLength, plain);
                }
                else if (plain !== true) {
                    ret += chunk;
                }
            }
            return ret;
        };
        return CompiledFormatString;
    }());
    
    var FDSLocaleSettings = /** @class */ (function () {
        function FDSLocaleSettings() {
            this.timeFormat = 0 /* USE_AM_PM */;
            this.shortDateFormatOrder = 0 /* MDY */;
            this.dateSeparator = '/';
            this.decimalSeparator = '.';
            this.timeSeparator = ':';
        }
        FDSLocaleSettings.prototype.getDefaultTimeFormatString = function (timeFreq) {
            var amString;
            var hour;
            if (this.timeFormat === 1 /* USE_24_HR */) {
                amString = '';
                hour = 'H';
            }
            else {
                amString = 'am';
                hour = 'h';
            }
            if (timeFreq >= 10000) {
                return hour + ' ' + amString;
            }
            else if (timeFreq >= 100) {
                return "" + hour + this.timeSeparator + "mm " + amString;
            }
            else {
                return "" + hour + this.timeSeparator + "mm" + this.timeSeparator + "ss " + amString;
            }
        };
        FDSLocaleSettings.prototype.getDefaultDateFormatString = function (dateFreq) {
            switch (dateFreq) {
                case 14 /* DAY */:
                case 15 /* WEEK */:
                    switch (this.shortDateFormatOrder) {
                        case 1 /* DMY */:
                            return "d" + this.dateSeparator + "m";
                        default:
                            return "m" + this.dateSeparator + "d";
                    }
                case 16 /* MONTH */:
                    return 'MMM';
                case 17 /* QUARTER */:
                    switch (this.shortDateFormatOrder) {
                        case 1 /* DMY */:
                        case 0 /* MDY */:
                            return "m" + this.dateSeparator + "yy";
                        default:
                            return "yy" + this.dateSeparator + "m";
                    }
                case 19 /* YEAR */:
                case 20 /* TWOY */:
                case 21 /* FIVEY */:
                case 22 /* TENY */:
                    return "'yy";
                default:
                    switch (this.shortDateFormatOrder) {
                        case 1 /* DMY */:
                            return "d" + this.dateSeparator + "m" + this.dateSeparator + "yyyy";
                        case 2 /* YMD */:
                            return "yyyy" + this.dateSeparator + "m" + this.dateSeparator + "d";
                        default:
                            return "m" + this.dateSeparator + "d" + this.dateSeparator + "yyyy";
                    }
            }
        };
        FDSLocaleSettings.prototype.getDefaultDateTimeFormatString = function (dateTimeFreq, timeBin, needTime) {
            var amString = 'am';
            var hour = 'h';
            if (this.timeFormat === 1 /* USE_24_HR */) {
                amString = '';
                hour = 'H';
            }
            var formatString;
            switch (dateTimeFreq) {
                case 1 /* SECOND */:
                    return 's';
                case 5 /* HALFMINUTE */:
                case 6 /* MINUTE */:
                    return "n" + this.timeSeparator + "ss";
                case 10 /* HALFHOUR */:
                case 11 /* HOUR */:
                    return "" + hour + this.timeSeparator + "nn" + this.timeSeparator + "ss " + amString;
                case 15 /* WEEK */:
                    switch (this.shortDateFormatOrder) {
                        case 0 /* MDY */:
                        case 2 /* YMD */:
                            return "m" + this.dateSeparator + "d";
                        default:
                            return "d" + this.dateSeparator + "m";
                    }
                case 16 /* MONTH */:
                    return 'MMM';
                case 17 /* QUARTER */:
                    switch (this.shortDateFormatOrder) {
                        case 2 /* YMD */:
                            return "yy" + this.dateSeparator + "m";
                        default:
                            return "m" + this.dateSeparator + "yy";
                    }
                case 19 /* YEAR */:
                case 20 /* TWOY */:
                case 21 /* FIVEY */:
                case 22 /* TENY */:
                    return "'yy";
                default:
                    if (dateTimeFreq === 14 /* DAY */) {
                        // don't return from this switch, we may need to add the time portion if its needed.
                        switch (this.shortDateFormatOrder) {
                            case 2 /* YMD */:
                            case 0 /* MDY */:
                                formatString = "m" + this.dateSeparator + "d";
                                break;
                            default:
                                formatString = "d" + this.dateSeparator + "m";
                                break;
                        }
                    }
                    if (timeBin >= 30000) {
                        switch (this.shortDateFormatOrder) {
                            case 2 /* YMD */:
                            case 0 /* MDY */:
                                return "m" + this.dateSeparator + "d " + hour + " " + amString;
                            default:
                                return "d" + this.dateSeparator + "m " + hour + " " + amString;
                        }
                    }
                    else if (timeBin >= 10000) {
                        return hour + " " + amString;
                    }
                    else if (timeBin > 0) {
                        return "" + hour + this.timeSeparator + "nn " + amString;
                    }
            }
            if (formatString === undefined) {
                switch (this.shortDateFormatOrder) {
                    case 1 /* DMY */:
                        formatString = "d" + this.dateSeparator + "m" + this.dateSeparator + "yyyy";
                        break;
                    case 2 /* YMD */:
                        formatString = "yyyy" + this.dateSeparator + "m" + this.dateSeparator + "d";
                        break;
                    default:
                        formatString = "m" + this.dateSeparator + "d" + this.dateSeparator + "yyyy";
                }
                if (needTime) {
                    formatString += " " + hour + this.timeSeparator + "nn" + this.timeSeparator + "ss " + amString;
                }
            }
            return formatString;
        };
        return FDSLocaleSettings;
    }());
    var FDSFormat = /** @class */ (function () {
        function FDSFormat() {
            this.sNAN = '@NA';
            this.formatParser = new FormatParser();
            this.locale = new FDSLocaleSettings();
        }
        FDSFormat.prototype.formatAsType = function (value, dataType) {
            if (_$1.isString(value)) {
                return this.formatAsString(value);
            }
            else {
                switch (dataType) {
                    case 'INT':
                    case 'INTEGER':
                    case 'FLOAT':
                        return this.formatAsNumber(value);
                        break;
                    case 'DATE':
                        return this.formatAsDate(value);
                        break;
                    case 'TIME':
                        return this.formatAsTime(value);
                        break;
                    case 'DATETIME':
                        return this.formatAsDateTime(value);
                        break;
                    case 'STRING':
                        return this.formatAsString(value);
                        break;
                }
            }
            console.warn("Unexpected data type: '" + dataType + "'");
            return '';
        };
        FDSFormat.prototype.formatAsString = function (value) {
            // Empty string concatenation ensures result is of the expected type
            return value ? value.toString() : '';
        };
        FDSFormat.prototype.formatAsNumber = function (value, padToLength, plain) {
            if (padToLength === void 0) { padToLength = -1; }
            if (plain === void 0) { plain = false; }
            if (isNaN(value)) {
                return this.sNAN;
            }
            value = roundToMaxPrecision(value);
            return this._compiledFormatString.fromValue(value, padToLength, plain);
        };
        FDSFormat.prototype.formatAsDate = function (value) {
            if (isNaN(value)) {
                return this.sNAN;
            }
            return this._compiledFormatString.fromValue(value);
        };
        FDSFormat.prototype.formatAsTime = function (value) {
            if (isNaN(value)) {
                return this.sNAN;
            }
            return this._compiledFormatString.fromValue(value);
        };
        FDSFormat.prototype.formatAsDateTime = function (value) {
            if (isNaN(value)) {
                return this.sNAN;
            }
            return this._compiledFormatString.fromValue(value);
        };
        FDSFormat.prototype.setNumberFormat = function (format) {
            this._compiledFormatString = this.formatParser.buildNumberFormatString(format);
        };
        FDSFormat.prototype.setDateFormat = function (format, dateFreq) {
            if (dateFreq === void 0) { dateFreq = 0 /* NONE */; }
            if (!format) {
                format = this.locale.getDefaultDateFormatString(dateFreq);
            }
            this._compiledFormatString = this.formatParser.buildDateFormatString(format);
        };
        FDSFormat.prototype.setTimeFormat = function (format, timeFreq) {
            if (timeFreq === void 0) { timeFreq = 0; }
            if (!format) {
                format = this.locale.getDefaultTimeFormatString(timeFreq);
            }
            this._compiledFormatString = this.formatParser.buildTimeFormatString(format);
        };
        FDSFormat.prototype.setDateTimeFormat = function (format, dateTimeFreq, timeBin, needTime) {
            if (dateTimeFreq === void 0) { dateTimeFreq = 0 /* NONE */; }
            if (timeBin === void 0) { timeBin = 0; }
            if (needTime === void 0) { needTime = true; }
            if (!format) {
                format = this.locale.getDefaultDateTimeFormatString(dateTimeFreq, timeBin, needTime);
            }
            this._compiledFormatString = this.formatParser.buildDateTimeFormatString(format);
        };
        return FDSFormat;
    }());
    
    var defaultFonts = ['arial', 'courier new', 'georgia', 'lucida grande', 'tahoma', 'times new roman', 'geneva', 'sans-serif'];
    var FontCacheBase = /** @class */ (function () {
        function FontCacheBase() {
        }
        FontCacheBase.clear = function () {
            for (var _i = 0, _a = _$1.keys(this._map); _i < _a.length; _i++) {
                var family = _a[_i];
                this._map[family] = {};
            }
        };
        FontCacheBase.getOrCreateValue = function (fontFamily, fontHeight, calcValueFunc) {
            var family = this._map[fontFamily];
            if (family) {
                var value_1 = family[fontHeight];
                if (value_1 !== undefined) {
                    return scaleByDevicePixelRatioAndRound(value_1);
                }
            }
            else {
                family = this._map[fontFamily] = {};
            }
            // Calculate and cache the metric.
            var value = calcValueFunc();
            // The value goes into the map unscaled
            family[fontHeight] = value;
            // but then we need to return the scaled value just like above.
            return scaleByDevicePixelRatioAndRound(value);
        };
        FontCacheBase._map = {};
        return FontCacheBase;
    }());
    /**
     * FontHeightMap contains a pre-computed cache of font heights for chrome.
     * These font heights are needed because the canvas does not provide a way to measure
     * text heights, and they are expensive to calculate manually. The map may be augmented at runtime
     * if `fontName`s or `fontSize`s outside of the precalculated range are required.
     */
    var FontHeightMap = /** @class */ (function (_super) {
        __extends(FontHeightMap, _super);
        function FontHeightMap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FontHeightMap.getHeight = function (ctx, fontFamily, fontHeight) {
            return _super.getOrCreateValue.call(this, fontFamily, fontHeight, function () { return Math.ceil(scaleByDevicePixelRatioInverse(ctx.measureTextWidth('m') * 1.4)); });
        };
        FontHeightMap._map = {
            'arial': {
                '1': 2,
                '2': 2,
                '3': 4,
                '4': 5,
                '5': 6,
                '6': 6,
                '7': 7,
                '8': 10,
                '9': 12,
                '10': 13,
                '11': 14,
                '12': 15,
                '13': 16,
                '14': 16,
                '15': 17,
                '16': 18,
                '17': 19,
                '18': 21,
                '19': 22,
                '20': 23,
                '21': 24,
                '22': 25,
                '23': 26,
                '24': 27,
                '25': 28,
                '26': 31,
                '27': 32,
                '28': 32,
                '29': 33,
                '30': 35,
                '31': 35,
                '32': 36,
                '33': 38,
                '34': 39,
                '35': 40,
                '36': 41,
                '37': 42,
                '38': 43,
                '39': 44,
                '40': 45,
                '41': 47,
                '42': 47,
                '43': 49,
                '44': 50,
                '45': 50,
                '46': 52,
                '47': 53,
                '48': 55
            },
            'courier new': {
                '1': 3,
                '2': 3,
                '3': 3,
                '4': 4,
                '5': 6,
                '6': 7,
                '7': 8,
                '8': 8,
                '9': 12,
                '10': 12,
                '11': 14,
                '12': 15,
                '13': 16,
                '14': 17,
                '15': 17,
                '16': 18,
                '17': 20,
                '18': 20,
                '19': 21,
                '20': 22,
                '21': 23,
                '22': 24,
                '23': 25,
                '24': 27,
                '25': 29,
                '26': 29,
                '27': 30,
                '28': 31,
                '29': 32,
                '30': 33,
                '31': 33,
                '32': 36,
                '33': 36,
                '34': 37,
                '35': 39,
                '36': 39,
                '37': 39,
                '38': 40,
                '39': 42,
                '40': 42,
                '41': 44,
                '42': 45,
                '43': 46,
                '44': 47,
                '45': 47,
                '46': 49,
                '47': 50,
                '48': 50
            },
            'georgia': {
                '1': 2,
                '2': 2,
                '3': 4,
                '4': 5,
                '5': 6,
                '6': 7,
                '7': 8,
                '8': 9,
                '9': 12,
                '10': 13,
                '11': 14,
                '12': 15,
                '13': 16,
                '14': 17,
                '15': 18,
                '16': 18,
                '17': 20,
                '18': 21,
                '19': 23,
                '20': 24,
                '21': 25,
                '22': 27,
                '23': 27,
                '24': 29,
                '25': 30,
                '26': 30,
                '27': 31,
                '28': 32,
                '29': 34,
                '30': 35,
                '31': 36,
                '32': 38,
                '33': 38,
                '34': 39,
                '35': 41,
                '36': 41,
                '37': 43,
                '38': 43,
                '39': 45,
                '40': 46,
                '41': 47,
                '42': 48,
                '43': 49,
                '44': 51,
                '45': 51,
                '46': 53,
                '47': 54,
                '48': 56
            },
            'lucida grande': {
                '1': 2,
                '2': 2,
                '3': 4,
                '4': 5,
                '5': 5,
                '6': 6,
                '7': 8,
                '8': 10,
                '9': 12,
                '10': 12,
                '11': 14,
                '12': 15,
                '13': 15,
                '14': 16,
                '15': 17,
                '16': 19,
                '17': 19,
                '18': 20,
                '19': 21,
                '20': 22,
                '21': 23,
                '22': 25,
                '23': 26,
                '24': 27,
                '25': 29,
                '26': 29,
                '27': 31,
                '28': 33,
                '29': 33,
                '30': 34,
                '31': 35,
                '32': 36,
                '33': 37,
                '34': 39,
                '35': 40,
                '36': 41,
                '37': 42,
                '38': 43,
                '39': 43,
                '40': 46,
                '41': 47,
                '42': 48,
                '43': 49,
                '44': 51,
                '45': 52,
                '46': 53,
                '47': 53,
                '48': 55
            },
            'tahoma': {
                '1': 2,
                '2': 2,
                '3': 4,
                '4': 5,
                '5': 6,
                '6': 7,
                '7': 8,
                '8': 10,
                '9': 11,
                '10': 12,
                '11': 13,
                '12': 14,
                '13': 16,
                '14': 17,
                '15': 18,
                '16': 19,
                '17': 21,
                '18': 22,
                '19': 23,
                '20': 24,
                '21': 25,
                '22': 27,
                '23': 28,
                '24': 29,
                '25': 30,
                '26': 31,
                '27': 33,
                '28': 34,
                '29': 35,
                '30': 36,
                '31': 37,
                '32': 39,
                '33': 40,
                '34': 41,
                '35': 42,
                '36': 43,
                '37': 45,
                '38': 46,
                '39': 47,
                '40': 48,
                '41': 49,
                '42': 51,
                '43': 52,
                '44': 53,
                '45': 54,
                '46': 56,
                '47': 57,
                '48': 58
            },
            'times new roman': {
                '1': 2,
                '2': 2,
                '3': 4,
                '4': 5,
                '5': 5,
                '6': 6,
                '7': 8,
                '8': 10,
                '9': 12,
                '10': 12,
                '11': 14,
                '12': 15,
                '13': 15,
                '14': 16,
                '15': 17,
                '16': 19,
                '17': 19,
                '18': 20,
                '19': 21,
                '20': 22,
                '21': 23,
                '22': 25,
                '23': 26,
                '24': 27,
                '25': 29,
                '26': 29,
                '27': 31,
                '28': 33,
                '29': 33,
                '30': 34,
                '31': 35,
                '32': 36,
                '33': 37,
                '34': 39,
                '35': 40,
                '36': 41,
                '37': 42,
                '38': 43,
                '39': 43,
                '40': 46,
                '41': 47,
                '42': 48,
                '43': 49,
                '44': 51,
                '45': 52,
                '46': 53,
                '47': 53,
                '48': 55
            },
            'geneva': {
                '1': 2,
                '2': 2,
                '3': 4,
                '4': 5,
                '5': 5,
                '6': 6,
                '7': 8,
                '8': 10,
                '9': 12,
                '10': 12,
                '11': 14,
                '12': 15,
                '13': 15,
                '14': 16,
                '15': 17,
                '16': 19,
                '17': 19,
                '18': 20,
                '19': 21,
                '20': 22,
                '21': 23,
                '22': 25,
                '23': 26,
                '24': 27,
                '25': 29,
                '26': 29,
                '27': 31,
                '28': 33,
                '29': 33,
                '30': 34,
                '31': 35,
                '32': 36,
                '33': 37,
                '34': 39,
                '35': 40,
                '36': 41,
                '37': 42,
                '38': 43,
                '39': 43,
                '40': 46,
                '41': 47,
                '42': 48,
                '43': 49,
                '44': 51,
                '45': 52,
                '46': 53,
                '47': 53,
                '48': 55
            }
        };
        return FontHeightMap;
    }(FontCacheBase));
    /**
     * used for generating the default map in case we want to update values or add fonts
     */
    
    /**
     * Calculate the offset between top and alphabetic offsets by aligning
     * a 1px tall image with the baseline of some text, and measuring the
     * offsets calculated by the browser / DOM.
     */
    function calculateFontBaselineOffset(cssFont) {
        // Things need to be placed on the DOM for measurement to work
        // We don't have easy access here to the chart's div
        // So instead we create a temporary one and place it on the body.
        var container = document.createElement('div');
        container.style.cssText = 'position: absolute; top: 0px; left: 0px; display: inline';
        document.body.appendChild(container);
        var parent = document.createElement('div');
        var image = document.createElement('img');
        image.width = 42;
        image.height = 1; // only the height matters
        image.style.verticalAlign = 'baseline';
        parent.style.font = cssFont;
        parent.appendChild(document.createTextNode('TheQuickBrownFox!'));
        parent.appendChild(image);
        container.appendChild(parent);
        // getting css equivalent of ctx.measureText()
        image.style.display = 'none';
        parent.style.display = 'inline';
        var measureHeight = parent.offsetHeight;
        var measureWidth = parent.offsetWidth;
        // making sure super-wide text stays in-bounds
        image.style.display = 'inline';
        var forceWidth = (measureWidth + image.offsetWidth) * 1.5; // 50% larger arbitrarily
        // capturing the "top"
        var margin = 50;
        parent.style.cssText = "font: " + cssFont + "; margin: " + margin + "px 0; display: block; width: " + forceWidth + "px";
        var baselineOffset = image.offsetTop - (margin - 1);
        // Cleanup and remove the div from the DOM.
        document.body.removeChild(container);
        return baselineOffset;
    }
    /**
     * FontBaselineMap contains a pre-computed cache of offsets from the alphabetic to the top baseline.
     * These offsets are needed because the canvas does not provide a way to measure
     * text metrics, and they are expensive to calculate manually. The map may be augmented at runtime
     * if `fontName`s or `fontSize`s outside of the precalculated range are required.
     */
    var FontBaselineMap = /** @class */ (function (_super) {
        __extends(FontBaselineMap, _super);
        function FontBaselineMap() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FontBaselineMap.getBaseline = function (fontFamily, fontHeight) {
            return _super.getOrCreateValue.call(this, fontFamily, fontHeight, function () { return calculateFontBaselineOffset(fontHeight + "px " + fontFamily); });
        };
        FontBaselineMap._map = {
            'arial': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 5,
                '7': 6,
                '8': 7,
                '9': 8,
                '10': 9,
                '11': 10,
                '12': 11,
                '13': 12,
                '14': 13,
                '15': 14,
                '16': 14,
                '17': 15,
                '18': 16,
                '19': 17,
                '20': 18,
                '21': 19,
                '22': 20,
                '23': 21,
                '24': 22,
                '25': 23,
                '26': 24,
                '27': 24,
                '28': 25,
                '29': 26,
                '30': 27,
                '31': 28,
                '32': 29,
                '33': 30,
                '34': 31,
                '35': 32,
                '36': 33,
                '37': 33,
                '38': 34,
                '39': 35,
                '40': 36,
                '41': 37,
                '42': 38,
                '43': 39,
                '44': 40,
                '45': 41,
                '46': 43,
                '47': 44,
                '48': 44
            },
            'courier new': {
                '1': 1,
                '2': 2,
                '3': 2,
                '4': 3,
                '5': 4,
                '6': 5,
                '7': 6,
                '8': 7,
                '9': 7,
                '10': 8,
                '11': 9,
                '12': 10,
                '13': 11,
                '14': 12,
                '15': 12,
                '16': 13,
                '17': 14,
                '18': 15,
                '19': 16,
                '20': 17,
                '21': 17,
                '22': 18,
                '23': 19,
                '24': 20,
                '25': 21,
                '26': 22,
                '27': 22,
                '28': 23,
                '29': 24,
                '30': 25,
                '31': 26,
                '32': 27,
                '33': 27,
                '34': 28,
                '35': 29,
                '36': 30,
                '37': 31,
                '38': 32,
                '39': 32,
                '40': 33,
                '41': 34,
                '42': 35,
                '43': 36,
                '44': 37,
                '45': 37,
                '46': 38,
                '47': 39,
                '48': 40
            },
            'georgia': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 6,
                '7': 6,
                '8': 7,
                '9': 8,
                '10': 9,
                '11': 10,
                '12': 11,
                '13': 12,
                '14': 13,
                '15': 14,
                '16': 15,
                '17': 16,
                '18': 17,
                '19': 17,
                '20': 18,
                '21': 19,
                '22': 20,
                '23': 21,
                '24': 22,
                '25': 23,
                '26': 24,
                '27': 25,
                '28': 26,
                '29': 27,
                '30': 28,
                '31': 28,
                '32': 29,
                '33': 30,
                '34': 31,
                '35': 32,
                '36': 33,
                '37': 34,
                '38': 35,
                '39': 36,
                '40': 37,
                '41': 38,
                '42': 39,
                '43': 39,
                '44': 40,
                '45': 41,
                '46': 42,
                '47': 43,
                '48': 44
            },
            'lucida grande': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 4,
                '6': 5,
                '7': 6,
                '8': 7,
                '9': 8,
                '10': 9,
                '11': 10,
                '12': 11,
                '13': 12,
                '14': 12,
                '15': 13,
                '16': 14,
                '17': 15,
                '18': 16,
                '19': 17,
                '20': 18,
                '21': 19,
                '22': 20,
                '23': 20,
                '24': 21,
                '25': 22,
                '26': 23,
                '27': 24,
                '28': 25,
                '29': 26,
                '30': 27,
                '31': 28,
                '32': 29,
                '33': 29,
                '34': 30,
                '35': 31,
                '36': 33,
                '37': 34,
                '38': 35,
                '39': 36,
                '40': 37,
                '41': 38,
                '42': 38,
                '43': 39,
                '44': 40,
                '45': 41,
                '46': 42,
                '47': 43,
                '48': 44
            },
            'tahoma': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 6,
                '7': 7,
                '8': 8,
                '9': 9,
                '10': 10,
                '11': 11,
                '12': 12,
                '13': 13,
                '14': 14,
                '15': 15,
                '16': 16,
                '17': 17,
                '18': 18,
                '19': 19,
                '20': 20,
                '21': 21,
                '22': 22,
                '23': 23,
                '24': 24,
                '25': 25,
                '26': 26,
                '27': 27,
                '28': 28,
                '29': 29,
                '30': 30,
                '31': 31,
                '32': 32,
                '33': 33,
                '34': 34,
                '35': 35,
                '36': 36,
                '37': 37,
                '38': 38,
                '39': 39,
                '40': 40,
                '41': 41,
                '42': 42,
                '43': 43,
                '44': 44,
                '45': 45,
                '46': 46,
                '47': 47,
                '48': 48
            },
            'times new roman': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 4,
                '6': 5,
                '7': 6,
                '8': 7,
                '9': 8,
                '10': 9,
                '11': 10,
                '12': 11,
                '13': 12,
                '14': 12,
                '15': 13,
                '16': 14,
                '17': 15,
                '18': 16,
                '19': 17,
                '20': 18,
                '21': 19,
                '22': 20,
                '23': 20,
                '24': 21,
                '25': 22,
                '26': 23,
                '27': 24,
                '28': 25,
                '29': 26,
                '30': 27,
                '31': 28,
                '32': 29,
                '33': 29,
                '34': 30,
                '35': 31,
                '36': 33,
                '37': 34,
                '38': 35,
                '39': 36,
                '40': 37,
                '41': 38,
                '42': 38,
                '43': 39,
                '44': 40,
                '45': 41,
                '46': 42,
                '47': 43,
                '48': 44
            },
            'geneva': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 4,
                '6': 5,
                '7': 6,
                '8': 7,
                '9': 8,
                '10': 9,
                '11': 10,
                '12': 11,
                '13': 12,
                '14': 12,
                '15': 13,
                '16': 14,
                '17': 15,
                '18': 16,
                '19': 17,
                '20': 18,
                '21': 19,
                '22': 20,
                '23': 20,
                '24': 21,
                '25': 22,
                '26': 23,
                '27': 24,
                '28': 25,
                '29': 26,
                '30': 27,
                '31': 28,
                '32': 29,
                '33': 29,
                '34': 30,
                '35': 31,
                '36': 33,
                '37': 34,
                '38': 35,
                '39': 36,
                '40': 37,
                '41': 38,
                '42': 38,
                '43': 39,
                '44': 40,
                '45': 41,
                '46': 42,
                '47': 43,
                '48': 44
            },
            'sans-serif': {
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 5,
                '7': 6,
                '8': 7,
                '9': 8,
                '10': 9,
                '11': 10,
                '12': 11,
                '13': 12,
                '14': 13,
                '15': 14,
                '16': 14,
                '17': 15,
                '18': 16,
                '19': 17,
                '20': 18,
                '21': 19,
                '22': 20,
                '23': 21,
                '24': 22,
                '25': 23,
                '26': 24,
                '27': 24,
                '28': 25,
                '29': 26,
                '30': 27,
                '31': 28,
                '32': 29,
                '33': 30,
                '34': 31,
                '35': 32,
                '36': 33,
                '37': 33,
                '38': 34,
                '39': 35,
                '40': 36,
                '41': 37,
                '42': 38,
                '43': 39,
                '44': 40,
                '45': 41,
                '46': 43,
                '47': 44,
                '48': 44
            }
        };
        return FontBaselineMap;
    }(FontCacheBase));
    
    /**
     * Consolidates a bunch of properties about drawing text and
     * provides facilities for reading/writing those properties
     * from chart attributes
     */
    var FDSFont = /** @class */ (function () {
        /**
         * Constructs a new FDSFont object.
         * @constructor
         */
        function FDSFont(options) {
            /** The color to draw the text */
            this.color = 0 /* BLACK */;
            /** The font's point-size */
            this.height = 12;
            /** An integer representing the font weight (boldness). For historic reasons, these values line up with GDI's */
            this.weight = 400 /* NORMAL */; // FW_NORMAL from WinGDI.h... we'll deal with this later
            /** Whether to draw italicized */
            this.italic = false;
            /** Whether to draw underlined */
            this.underline = false;
            /** The font family */
            this.family = 'Arial';
            /** A font's `widthHint` is the point (in pixels) at which word-wrapping will trigger. */
            this._widthHint = 75;
            /** Whether to draw text aligned to the left, right, or center of the destination rectangle. */
            this.alignment = 0 /* LEFT */;
            /** The Font's transparency when drawn. */
            this.alpha = 255;
            /** A font's escapement is the rotation angle in radians */
            this.escapement = 0;
            /** if set to true, text rendering will truncate at the widthHint and append the value of `truncateString` */
            this.truncate = -1 /* DEFAULT */;
            /** this string is used when `truncate` is enabled to indicate that the text has been truncated at the `widthHint` */
            this.truncateString = '...';
            _$1.assign(this, this._sanitizeWidthHint(options));
        }
        Object.defineProperty(FDSFont.prototype, "widthHint", {
            get: function () {
                return scaleByDevicePixelRatio(this._widthHint);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get's the font family name and optionally applies a series of font fallbacks.
         * This is available so that applications such as the ChartImageService can  specify
         * a fallback for missing fonts like 'Arial' based on fonts that are known to be installed.
         *
         * @param fontName - the base font name to lookup font fallbacks for
         */
        FDSFont.addFontFallbackToFamily = function (fontName) {
            if (FDSFont.fontFallbackMap) {
                var fallbackArr = FDSFont.fontFallbackMap[fontName.toLowerCase()];
                if (fallbackArr) {
                    return fontName + ", " + fallbackArr.join(', ');
                }
            }
            return fontName;
        };
        FDSFont.prototype.with = function (options) {
            return new FDSFont(_$1.defaults(this._sanitizeWidthHint(options), this));
        };
        FDSFont.prototype._sanitizeWidthHint = function (options) {
            if (options && 'widthHint' in options) {
                options['_widthHint'] = options.widthHint;
                delete options.widthHint;
            }
            return options;
        };
        /**
         * Writes the default attributes for this font into the default map
         * @param attrSet - The `AttributeSet` where the the font's attributes will reside.
         * @param attrBase - The prefix used for this font's attributes 'SeriesValueFont', 'SeriesQuickLabelFont', etc.
         * @param parentAttrBase - The prefix for the chart-level font to inherit from.
         */
        FDSFont.prototype.writeToAttrSet = function (attrSet, attrBase, parentAttrBase, inheritAll) {
            if (inheritAll === void 0) { inheritAll = false; }
            // Some of the font attributes are not inherited, even if parentAttrBase is specified.
            // We create a special defaultSetter just for this case
            var setNoBase = attrSet.getDefaultSetter(attrBase);
            // If parentAttrBase is null, call setNoBase instead
            var set = (parentAttrBase == null) ? setNoBase : attrSet.getDefaultSetter(attrBase, parentAttrBase);
            set('Family', this.family);
            set('Color', this.color);
            set('Height', this.height);
            set('Weight', this.weight);
            set('Italic', this.italic);
            set('Underline', this.underline);
            set('Truncate', this.truncate === 1 /* TRUNCATE */);
            set('TruncateString', this.truncateString);
            // Deliberately not inheriting these from base attributes
            // unless inheritAll is explicitly passed as true.
            // For example, axis fonts inherit all attributes from XFont, YFont, etc.
            var restrictedSet = inheritAll ? set : setNoBase;
            restrictedSet('WidthHint', this._widthHint);
            restrictedSet('Alignment', this.alignment);
            restrictedSet('Escapement', RadToDeg(this.escapement) * 10);
        };
        /**
         * Read the font's values from the attribute map
         * @param attrSet - The attribute set to pull the values from
         * @param attrBase - The name of the font object
         */
        FDSFont.constructFromAttributes = function (attrSet, attrBase) {
            /**
             * Gets an attribute from the attribute set and provides additional
             * debug validation to verify that the value is defined.
             * @param attrSuffix - The string to append to attrBase
             * @param transform - If provided, this transform will be applied before returning.
             */
            function get$$1(attrSuffix, transform) {
                var value = attrSet.get(attrBase + attrSuffix);
                if (ENABLE_DEBUG) {
                    console.assert(value !== undefined, attrBase + attrSuffix + ' returned undefined');
                }
                return transform ? transform(value) : value;
            }
            var options = {};
            options.family = get$$1('Family');
            options.color = get$$1('Color');
            options.height = get$$1('Height');
            options.weight = get$$1('Weight');
            options.italic = get$$1('Italic');
            options.underline = get$$1('Underline');
            options.widthHint = get$$1('WidthHint');
            options.alignment = get$$1('Alignment');
            options.escapement = get$$1('Escapement', function (value) { return DegToRad(value / 10); });
            if (attrSet.isInheritedDefault(attrBase + 'Truncate')) {
                options.truncate = -1 /* DEFAULT */;
            }
            else {
                if (get$$1('Truncate')) {
                    options.truncate = 1 /* TRUNCATE */;
                    // Maximum of 5 characters for TruncateString
                    options.truncateString = get$$1('TruncateString', function (str) { return str.length > 5 ? str.slice(0, 5) : str; });
                }
                else {
                    options.truncate = 0 /* NONE */;
                }
            }
            return new FDSFont(options);
        };
        /**
         * Copy the other font's attributes if ours are defaulted
         * @param otherPen - The font to inherit values from
         * @param attrSet - The attribute set to pull values from
         * @param attrBase - The base name to use as a prefix. `attrBase+'Family'`, etc.
         */
        FDSFont.prototype.inheritFromOtherFont = function (otherFont, attrSet, attrBase) {
            // Simple wrapper function to reduce code-duplication.
            // technically this might have been simpler, if the wrapper also inlined `this[param] = otherPen[param]`
            // But that sort of pattern would prevent us from minifying parameters as aggressively.
            var ifDefault = function (attrSuffix, func) {
                if (attrSet.isDefault(attrBase + attrSuffix)) {
                    func();
                }
            };
            var options = {};
            ifDefault('Family', function () { return options.family = otherFont.family; });
            ifDefault('Color', function () { return options.color = otherFont.color; });
            ifDefault('Height', function () { return options.height = otherFont.height; });
            ifDefault('Weight', function () { return options.weight = otherFont.weight; });
            ifDefault('Italic', function () { return options.italic = otherFont.italic; });
            ifDefault('Underline', function () { return options.underline = otherFont.underline; });
            ifDefault('WidthHint', function () { return options.widthHint = otherFont._widthHint; });
            ifDefault('Alignment', function () { return options.alignment = otherFont.alignment; });
            ifDefault('Escapement', function () { return options.escapement = otherFont.escapement; });
            ifDefault('Truncate', function () { return options.truncate = otherFont.truncate; });
            ifDefault('TruncateString', function () { return options.truncateString = otherFont.truncateString; });
            return this.with(options);
        };
        /**
         * Converts the weight number into a css font weight string.
         * < 400 => 'lighter'
         * < 700 => 'normal'
         * >= 700 => 'bold'
         * @param weight - the weight number to convert.
         */
        FDSFont.convertFontWeightToCSS = function (weight) {
            // Technically > 700 should be considered "bolder" but apparently canvas doesn't support that
            // and it just defaults to bold. The problem there, is that SVG does support 'bolder' and
            // then our font measurements don't line up.
            if (weight < 400) {
                return 'lighter';
            }
            else if (weight < 700) {
                return 'normal';
            }
            else {
                return 'bold';
            }
        };
        /**
         * Convert font properties into a format that can be more directly consumed by canvas
         */
        FDSFont.prototype.toPropertyObject = function () {
            var cssWeight = FDSFont.convertFontWeightToCSS(this.weight);
            var cssItalic = this.italic ? 'italic' : '';
            var fillStyle = COLORREFtoCSSColor(this.color, this.alpha);
            var family = FDSFont.addFontFallbackToFamily(this.family);
            return {
                font: cssItalic + " " + cssWeight + " " + this.getHeight() + "px " + family,
                family: family,
                italic: cssItalic,
                weight: cssWeight,
                height: this.getHeight(),
                fillStyle: fillStyle,
            };
        };
        /**
         * Convert the font object into equivalent CSS style properties.
         */
        FDSFont.prototype.toCSSStyle = function () {
            var transform = "rotate(" + this.escapement + "rad)";
            var origin = '50% 51%';
            return {
                fontFamily: FDSFont.addFontFallbackToFamily(this.family),
                color: COLORREFtoCSSColor(this.color, this.alpha),
                fontSize: this.height + 'px',
                fontWeight: FDSFont.convertFontWeightToCSS(this.weight),
                transform: transform,
                webkitTransform: transform,
                transformOrigin: origin,
                webkitTransformOrigin: origin,
                background: undefined,
                textAlign: undefined,
                verticalAlign: undefined
            };
        };
        /**
         * Get the height of font, scaled by device pixel ratio.
         * The `canvas` doesn't provide a method to get the font height, so this is largely
         * a sequence of guesses. We use a cache of pre-computed font-heights from the
         * FontHeightMap, however, these values are specific to Chrome and will cause problems
         * in IE, etc.
         */
        FDSFont.prototype.getHeight = function (ctx) {
            if (!ctx) {
                return scaleByDevicePixelRatio(this.height);
            }
            else {
                // There is a precomputed map of font heights for several common fonts and heights
                // in globals.coffee, but if it doesn't exist in that map, it will fall back
                // to the terrible hack outlined below:
                // This is a hack to get the actual height of the text, based on a
                // solution promulgated here: http://stackoverflow.com/q/1134586/1135363#1135363
                var familyName = FDSFont.addFontFallbackToFamily(this.family).toLowerCase();
                return FontHeightMap.getHeight(ctx, familyName, this.height);
            }
        };
        FDSFont.prototype.getBaselineOffset = function () {
            var familyName = FDSFont.addFontFallbackToFamily(this.family).toLowerCase();
            return FontBaselineMap.getBaseline(familyName, this.height);
        };
        /**
         * Compares two fonts value-wise and returns true if they are deemed equal.
         */
        FDSFont.prototype.equals = function (fontObj) {
            if (!fontObj) {
                return false;
            }
            return this.color === fontObj.color &&
                this.height === fontObj.height &&
                this.weight === fontObj.weight &&
                this.italic === fontObj.italic &&
                this.underline === fontObj.underline &&
                this.family === fontObj.family;
        };
        /**
         * sets the canvas draw properties to match this font's properties
         * @param ctx - the chart rendering context
         */
        FDSFont.prototype.setOnCanvas = function (ctx, unused) {
            ctx.setFont(this);
        };
        return FDSFont;
    }());
    
    var FDSPropertyParser = (function () {
        var o = function (k, v, o, l) { for (o = o || {}, l = k.length; l--; o[k[l]] = v)
            ; return o; }, $V0 = [2, 2], $V1 = [1, 5], $V2 = [1, 8], $V3 = [5, 8, 11, 21], $V4 = [1, 16], $V5 = [1, 11], $V6 = [2, 18], $V7 = [1, 20], $V8 = [2, 17], $V9 = [8, 11, 14], $Va = [14, 19], $Vb = [5, 8, 11, 14, 19, 21];
        var parser = { trace: function trace() { },
            yy: {},
            symbols_: { "error": 2, "program": 3, "expression_list": 4, "EOF": 5, "expression_list_1": 6, "block": 7, "WORDS": 8, "property_tag": 9, "incomplete_property_tag": 10, "<": 11, "FDSIDENTIFIER": 12, "argument_list": 13, ">": 14, "prop_identifier": 15, "inner_expression_list": 16, "argument_list_1": 17, "argument_group": 18, "IDENTIFIER": 19, "=\"": 20, "\"": 21, "=": 22, "$accept": 0, "$end": 1 },
            terminals_: { 2: "error", 5: "EOF", 8: "WORDS", 11: "<", 12: "FDSIDENTIFIER", 14: ">", 19: "IDENTIFIER", 20: "=\"", 21: "\"", 22: "=" },
            productions_: [0, [3, 2], [4, 0], [4, 1], [6, 1], [6, 2], [7, 1], [7, 1], [7, 1], [10, 2], [9, 4], [9, 3], [9, 3], [16, 1], [16, 2], [16, 2], [16, 2], [15, 1], [15, 0], [13, 0], [13, 1], [17, 1], [17, 2], [18, 4], [18, 3]],
            performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
                /* this == yyval */
                var $0 = $$.length - 1;
                switch (yystate) {
                    case 1:
                        //console.log($$[$0-1]);
                        return $$[$0 - 1];
                        break;
                    case 2:
                        this.$ = [];
                        break;
                    case 4:
                        this.$ = [$$[$0]];
                        break;
                    case 5:
                        this.$ = $$[$0 - 1];
                        this.$.push($$[$0]);
                        break;
                    case 6:
                        //console.log('p2: block of words...');
                        this.$ = $$[$0];
                        break;
                    case 7:
                        //console.log('p2: property tag...');
                        this.$ = $$[$0];
                        break;
                    case 8:
                        //console.log('p2: got incomplete tag...');
                        this.$ = $$[$0];
                        break;
                    case 9:
                        this.$ = '<' + $$[$0];
                        break;
                    case 10:
                        //console.log('p2: identifier with args');
                        if (typeof yy.PropertyTagObject != 'undefined') {
                            this.$ = new yy.PropertyTagObject(yy.PropertySet, $$[$0 - 2], $$[$0 - 1]);
                        }
                        else {
                            this.$ = { id: $$[$0 - 2], args: $$[$0 - 1] };
                        }
                        break;
                    case 11:
                        //console.log('p2: prop identifier');
                        if (typeof yy.PropertyTagObject != 'undefined') {
                            this.$ = new yy.PropertyTagObject(yy.PropertySet, $$[$0 - 1], {});
                        }
                        else {
                            this.$ = { id: $$[$0 - 1], args: {} };
                        }
                        break;
                    case 12:
                        //console.log('p2: inner expression list');
                        if (typeof yy.PropertyTagObject != 'undefined') {
                            this.$ = new yy.PropertyTagObject(yy.PropertySet, $$[$0 - 1], {});
                        }
                        else {
                            this.$ = { id: $$[$0 - 1], args: {} };
                        }
                        break;
                    case 13:
                        //console.log('p2: inner property_tag');
                        this.$ = [$$[$0]];
                        break;
                    case 14:
                        //console.log('p2: inner words and property_tag');
                        this.$ = [$$[$0 - 1], $$[$0]];
                        break;
                    case 15:
                        //console.log('p2: inner expression list and property_tag');
                        this.$ = $$[$0 - 1];
                        this.$.push($$[$0]);
                        break;
                    case 16:
                        //console.log('p2: inner expression list and words');
                        this.$ = $$[$0 - 1];
                        this.$.push($$[$0]);
                        break;
                    case 17:
                        this.$ = $$[$0];
                        break;
                    case 18:
                        this.$ = "";
                        break;
                    case 19:
                        this.$ = {};
                        break;
                    case 21:
                        //console.log('p2: got argument group');
                        this.$ = {};
                        this.$[$$[$0][0].toUpperCase()] = $$[$0][1];
                        break;
                    case 22:
                        //console.log('p2: got multiple args');
                        this.$ = $$[$0 - 1];
                        this.$[$$[$0][0].toUpperCase()] = $$[$0][1];
                        break;
                    case 23:
                        this.$ = [$$[$0 - 3], $$[$0 - 1]];
                        break;
                    case 24:
                        this.$ = [$$[$0 - 2], $$[$0]];
                        break;
                }
            },
            table: [{ 3: 1, 4: 2, 5: $V0, 6: 3, 7: 4, 8: $V1, 9: 6, 10: 7, 11: $V2 }, { 1: [3] }, { 5: [1, 9] }, o([5, 21], [2, 3], { 9: 6, 10: 7, 7: 10, 8: $V1, 11: $V2 }), o($V3, [2, 4]), o($V3, [2, 6]), o($V3, [2, 7]), o($V3, [2, 8]), { 8: [1, 14], 9: 15, 11: $V4, 12: $V5, 14: $V6, 15: 12, 16: 13 }, { 1: [2, 1] }, o($V3, [2, 5]), { 13: 17, 14: [2, 19], 17: 18, 18: 19, 19: $V7 }, { 14: [1, 21] }, { 8: [1, 24], 9: 23, 11: $V4, 14: [1, 22] }, o([5, 8, 21], [2, 9], { 9: 25, 11: $V4, 14: $V8 }), o($V9, [2, 13]), { 8: [1, 26], 9: 15, 11: $V4, 12: $V5, 14: $V6, 15: 12, 16: 13 }, { 14: [1, 27] }, { 14: [2, 20], 18: 28, 19: $V7 }, o($Va, [2, 21]), { 20: [1, 29], 22: [1, 30] }, o($Vb, [2, 11]), o($Vb, [2, 12]), o($V9, [2, 15]), o($V9, [2, 16]), o($V9, [2, 14]), { 9: 25, 11: $V4, 14: $V8 }, o($Vb, [2, 10]), o($Va, [2, 22]), { 4: 31, 6: 3, 7: 4, 8: $V1, 9: 6, 10: 7, 11: $V2, 21: $V0 }, { 9: 32, 11: $V4 }, { 21: [1, 33] }, o($Va, [2, 24]), o($Va, [2, 23])],
            defaultActions: { 9: [2, 1] },
            parseError: function parseError(str, hash) {
                if (hash.recoverable) {
                    this.trace(str);
                }
                else {
                    throw new Error(str);
                }
            },
            parse: function parse(input) {
                var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                var lexer = Object.create(this.lexer);
                var sharedState = { yy: {} };
                for (var k in this.yy) {
                    if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                        sharedState.yy[k] = this.yy[k];
                    }
                }
                lexer.setInput(input, sharedState.yy);
                sharedState.yy.lexer = lexer;
                sharedState.yy.parser = this;
                if (typeof lexer.yylloc == 'undefined') {
                    lexer.yylloc = {};
                }
                var yyloc = lexer.yylloc;
                lstack.push(yyloc);
                var ranges = lexer.options && lexer.options.ranges;
                if (typeof sharedState.yy.parseError === 'function') {
                    this.parseError = sharedState.yy.parseError;
                }
                else {
                    this.parseError = Object.getPrototypeOf(this).parseError;
                }
                var lex = function () {
                    var token;
                    token = lexer.lex() || EOF;
                    if (typeof token !== 'number') {
                        token = self.symbols_[token] || token;
                    }
                    return token;
                };
                var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                while (true) {
                    state = stack[stack.length - 1];
                    if (this.defaultActions[state]) {
                        action = this.defaultActions[state];
                    }
                    else {
                        if (symbol === null || typeof symbol == 'undefined') {
                            symbol = lex();
                        }
                        action = table[state] && table[state][symbol];
                    }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                        var errStr = '';
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push('\'' + this.terminals_[p] + '\'');
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                        }
                        else {
                            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected
                        });
                    }
                    if (action[0] instanceof Array && action.length > 1) {
                        throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
                    }
                    switch (action[0]) {
                        case 1:
                            stack.push(symbol);
                            vstack.push(lexer.yytext);
                            lstack.push(lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = lexer.yyleng;
                                yytext = lexer.yytext;
                                yylineno = lexer.yylineno;
                                yyloc = lexer.yylloc;
                                if (recovering > 0) {
                                    recovering--;
                                }
                            }
                            else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;
                        case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [
                                    lstack[lstack.length - (len || 1)].range[0],
                                    lstack[lstack.length - 1].range[1]
                                ];
                            }
                            r = this.performAction.apply(yyval, [
                                yytext,
                                yyleng,
                                yylineno,
                                sharedState.yy,
                                action[1],
                                vstack,
                                lstack
                            ]);
                            if (typeof r !== 'undefined') {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;
                        case 3:
                            return true;
                    }
                }
                return true;
            } };
        /* generated by jison-lex 0.3.4 */
        var lexer = (function () {
            var lexer = ({
                EOF: 1,
                parseError: function parseError(str, hash) {
                    if (this.yy.parser) {
                        this.yy.parser.parseError(str, hash);
                    }
                    else {
                        throw new Error(str);
                    }
                },
                // resets the lexer, sets new input
                setInput: function (input, yy) {
                    this.yy = yy || this.yy || {};
                    this._input = input;
                    this._more = this._backtrack = this.done = false;
                    this.yylineno = this.yyleng = 0;
                    this.yytext = this.matched = this.match = '';
                    this.conditionStack = ['INITIAL'];
                    this.yylloc = {
                        first_line: 1,
                        first_column: 0,
                        last_line: 1,
                        last_column: 0
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [0, 0];
                    }
                    this.offset = 0;
                    return this;
                },
                // consumes and returns one char from the input
                input: function () {
                    var ch = this._input[0];
                    this.yytext += ch;
                    this.yyleng++;
                    this.offset++;
                    this.match += ch;
                    this.matched += ch;
                    var lines = ch.match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno++;
                        this.yylloc.last_line++;
                    }
                    else {
                        this.yylloc.last_column++;
                    }
                    if (this.options.ranges) {
                        this.yylloc.range[1]++;
                    }
                    this._input = this._input.slice(1);
                    return ch;
                },
                // unshifts one char (or a string) into the input
                unput: function (ch) {
                    var len = ch.length;
                    var lines = ch.split(/(?:\r\n?|\n)/g);
                    this._input = ch + this._input;
                    this.yytext = this.yytext.substr(0, this.yytext.length - len);
                    //this.yyleng -= len;
                    this.offset -= len;
                    var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                    this.match = this.match.substr(0, this.match.length - 1);
                    this.matched = this.matched.substr(0, this.matched.length - 1);
                    if (lines.length - 1) {
                        this.yylineno -= lines.length - 1;
                    }
                    var r = this.yylloc.range;
                    this.yylloc = {
                        first_line: this.yylloc.first_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.first_column,
                        last_column: lines ?
                            (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                                + oldLines[oldLines.length - lines.length].length - lines[0].length :
                            this.yylloc.first_column - len
                    };
                    if (this.options.ranges) {
                        this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                    }
                    this.yyleng = this.yytext.length;
                    return this;
                },
                // When called from action, caches matched text and appends it on next action
                more: function () {
                    this._more = true;
                    return this;
                },
                // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
                reject: function () {
                    if (this.options.backtrack_lexer) {
                        this._backtrack = true;
                    }
                    else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                    return this;
                },
                // retain first n characters of the match
                less: function (n) {
                    this.unput(this.match.slice(n));
                },
                // displays already matched input, i.e. for error messages
                pastInput: function () {
                    var past = this.matched.substr(0, this.matched.length - this.match.length);
                    return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                },
                // displays upcoming input, i.e. for error messages
                upcomingInput: function () {
                    var next = this.match;
                    if (next.length < 20) {
                        next += this._input.substr(0, 20 - next.length);
                    }
                    return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                },
                // displays the character position where the lexing error occurred, i.e. for error messages
                showPosition: function () {
                    var pre = this.pastInput();
                    var c = new Array(pre.length + 1).join("-");
                    return pre + this.upcomingInput() + "\n" + c + "^";
                },
                // test the lexed token: return FALSE when not a match, otherwise return token
                test_match: function (match, indexed_rule) {
                    var token, lines, backup;
                    if (this.options.backtrack_lexer) {
                        // save context
                        backup = {
                            yylineno: this.yylineno,
                            yylloc: {
                                first_line: this.yylloc.first_line,
                                last_line: this.last_line,
                                first_column: this.yylloc.first_column,
                                last_column: this.yylloc.last_column
                            },
                            yytext: this.yytext,
                            match: this.match,
                            matches: this.matches,
                            matched: this.matched,
                            yyleng: this.yyleng,
                            offset: this.offset,
                            _more: this._more,
                            _input: this._input,
                            yy: this.yy,
                            conditionStack: this.conditionStack.slice(0),
                            done: this.done
                        };
                        if (this.options.ranges) {
                            backup.yylloc.range = this.yylloc.range.slice(0);
                        }
                    }
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) {
                        this.yylineno += lines.length;
                    }
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ?
                            lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                            this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._backtrack = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) {
                        this.done = false;
                    }
                    if (token) {
                        return token;
                    }
                    else if (this._backtrack) {
                        // recover context
                        for (var k in backup) {
                            this[k] = backup[k];
                        }
                        return false; // rule action called reject() implying the next rule should be tested instead.
                    }
                    return false;
                },
                // return next match in input
                next: function () {
                    if (this.done) {
                        return this.EOF;
                    }
                    if (!this._input) {
                        this.done = true;
                    }
                    var token, match, tempMatch, index;
                    if (!this._more) {
                        this.yytext = '';
                        this.match = '';
                    }
                    var rules = this._currentRules();
                    for (var i = 0; i < rules.length; i++) {
                        tempMatch = this._input.match(this.rules[rules[i]]);
                        if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                            match = tempMatch;
                            index = i;
                            if (this.options.backtrack_lexer) {
                                token = this.test_match(tempMatch, rules[i]);
                                if (token !== false) {
                                    return token;
                                }
                                else if (this._backtrack) {
                                    match = false;
                                    continue; // rule action called reject() implying a rule MISmatch.
                                }
                                else {
                                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                    return false;
                                }
                            }
                            else if (!this.options.flex) {
                                break;
                            }
                        }
                    }
                    if (match) {
                        token = this.test_match(match, rules[index]);
                        if (token !== false) {
                            return token;
                        }
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                    if (this._input === "") {
                        return this.EOF;
                    }
                    else {
                        return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                            text: "",
                            token: null,
                            line: this.yylineno
                        });
                    }
                },
                // return next match that has a token
                lex: function lex() {
                    var r = this.next();
                    if (r) {
                        return r;
                    }
                    else {
                        return this.lex();
                    }
                },
                // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
                begin: function begin(condition) {
                    this.conditionStack.push(condition);
                },
                // pop the previously active lexer condition state off the condition stack
                popState: function popState() {
                    var n = this.conditionStack.length - 1;
                    if (n > 0) {
                        return this.conditionStack.pop();
                    }
                    else {
                        return this.conditionStack[0];
                    }
                },
                // produce the lexer rule set which is active for the currently active lexer condition state
                _currentRules: function _currentRules() {
                    if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    }
                    else {
                        return this.conditions["INITIAL"].rules;
                    }
                },
                // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
                topState: function topState(n) {
                    n = this.conditionStack.length - 1 - Math.abs(n || 0);
                    if (n >= 0) {
                        return this.conditionStack[n];
                    }
                    else {
                        return "INITIAL";
                    }
                },
                // alias for begin(condition)
                pushState: function pushState(condition) {
                    this.begin(condition);
                },
                // return the number of states currently on the stack
                stateStackSize: function stateStackSize() {
                    return this.conditionStack.length;
                },
                options: {},
                performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    var YYSTATE = YY_START;
                    switch ($avoiding_name_collisions) {
                        case 0:
                            //console.log('spaaaaaace0');
                            /*       ignore          */
                            break;
                        case 1:
                            var lastlastcond = this.conditionStack[this.conditionStack.length - 1];
                            this.popState();
                            var lastcond = this.conditionStack[this.conditionStack.length - 1];
                            if (lastcond === "openbracket" && lastlastcond != "openbracket") {
                                this.popState();
                                //console.log('popping more...');
                            }
                            //console.log('close bracket');
                            return '>';
                            break;
                        case 2:
                            this.begin('openbracketopenquote');
                            //console.log('equal');
                            return '="';
                            break;
                        case 3:
                            this.begin('openbracket');
                            //console.log('beginning open bracket inner?...');
                            return 22;
                            break;
                        case 4:
                            //console.log('spaaaaaace');
                            /*       ignore          */
                            break;
                        case 5:
                            this.begin('openbracket');
                            //console.log('beginning open bracket...');
                            return 11;
                            break;
                        case 6:
                            this.popState();
                            //console.log('openbracketopenquote');
                            return 21;
                            break;
                        case 7:
                            this.begin('argparse');
                            //console.log('fdsidentifier');
                            return 12;
                            break;
                        case 8:
                            //console.log('identifier');
                            return 19;
                            break;
                        case 9:
                            //console.log('init');
                            return 8;
                            break;
                        case 10:
                            //console.log('openbracket');
                            return 8;
                            break;
                        case 11:
                            //console.log('openbracketopenquote1');
                            return 8;
                            break;
                        case 12:
                            //console.log('EOF');
                            return 'EOF';
                            break;
                    }
                },
                rules: [/^(?:\s+)/, /^(?:>)/, /^(?:=")/, /^(?:=)/, /^(?:\s+)/, /^(?:<)/, /^(?:")/, /^(?:FDSSpan|FDSProperty|FDSIf|FDSMath\b)/, /^(?:\/?[A-Za-z0-9_@]+)/, /^(?:([^<])+)/, /^(?:([^<>])+)/, /^(?:(\\"|\\<|[^"<])+)/, /^(?:$)/],
                conditions: { "argparse": { "rules": [0, 1, 2, 3, 5, 8, 12], "inclusive": true }, "openbracketopenquote": { "rules": [5, 6, 11, 12], "inclusive": true }, "openbracket": { "rules": [1, 4, 5, 7, 10, 12], "inclusive": true }, "INITIAL": { "rules": [5, 9, 12], "inclusive": true } }
            });
            return lexer;
        })();
        parser.lexer = lexer;
        function Parser() {
            this.yy = {};
        }
        Parser.prototype = parser;
        parser.Parser = Parser;
        return new Parser;
    })();
    function setup$1() {
        return FDSPropertyParser;
    }
    
    var parser$1 = setup$1();
    var FDSSpanTag = /** @class */ (function () {
        function FDSSpanTag(args, valueContext) {
            for (var _i = 0, _a = args.getKeys(); _i < _a.length; _i++) {
                var key = _a[_i];
                this[key] = args.getArg(key, valueContext);
            }
        }
        return FDSSpanTag;
    }());
    var FDSCloseSpanTag = /** @class */ (function () {
        function FDSCloseSpanTag() {
        }
        return FDSCloseSpanTag;
    }());
    /**
     * Takes an array of mixed types and flattens any adjacent string in the array.
     * Numbers are converted to strings in the process. But everything else is preserved.
     * For example:
     *   `[10, 'Hello ', ' ', 'World', 20, '!']`
     *   =>
     *   `['10Hello World20!']`
     *
     * and
     *
     *   `[{FONTCOLOR: "red"}, 'Hello ', ' ', 'World', {closeTag: true}, '!']`
     *   =>
     *   `[{FONTCOLOR: "red"}, 'Hello World', {closeTag: true}, '!']`
     *
     * @param array - the array to flatten.
     */
    function simplifyStringsInArray(array) {
        var ret = [];
        var curStr = '';
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var val = array_1[_i];
            if (_$1.isString(val)) {
                curStr += val;
            }
            else if (_$1.isNumber(val)) {
                curStr += val.toString();
            }
            else {
                if (curStr !== '') {
                    ret.push(curStr);
                    curStr = '';
                }
                ret.push(val);
            }
        }
        if (curStr !== '') {
            ret.push(curStr);
        }
        return ret;
    }
    var RichTextString = /** @class */ (function () {
        function RichTextString(data, adoptArray) {
            if (adoptArray === void 0) { adoptArray = false; }
            if (_$1.isString(data)) {
                this.data = [data];
            }
            else if (_$1.isArray(data)) {
                this.data = adoptArray ? data : simplifyStringsInArray(data);
            }
            else {
                this.data = [];
            }
        }
        RichTextString.join = function () {
            var strings = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                strings[_i] = arguments[_i];
            }
            return new RichTextString(_$1.flatten(strings.map(function (str) {
                return _$1.isString(str) ? [str] :
                    !_$1.isUndefined(str) ? str.data :
                        [];
            })));
        };
        RichTextString.prototype.isEmpty = function () {
            return !this.data || this.data.length === 0 || (this.data.length === 1 && this.data[0] === '');
        };
        RichTextString.prototype.concat = function (str) {
            var newStrArgs;
            var lastOfCurr = _$1.last(this.data);
            var firstOfNext = _$1.isString(str) ? str : _$1.head(str.data);
            if (_$1.isString(lastOfCurr) && _$1.isString(firstOfNext)) {
                var firstOfCurr = _$1.take(this.data, this.data.length - 1);
                var restOfNext = _$1.isString(str) ? [] : _$1.tail(str.data);
                newStrArgs = firstOfCurr.concat(lastOfCurr + firstOfNext).concat(restOfNext);
            }
            else {
                newStrArgs = this.data.concat(_$1.isString(str) ? [str] : str.data);
            }
            return new RichTextString(newStrArgs, true);
        };
        RichTextString.prototype.toString = function () {
            return this.data ? this.data.filter(_$1.isString).join('') : '';
        };
        RichTextString.Empty = new RichTextString();
        return RichTextString;
    }());
    var PropertyArgs = /** @class */ (function () {
        function PropertyArgs(args) {
            this._args = args;
        }
        PropertyArgs.prototype.hasArg = function (key) {
            return this._args[key] != null;
        };
        PropertyArgs.prototype.getKeys = function () {
            return _$1.keys(this._args);
        };
        PropertyArgs.prototype.getArg = function (key, valueContext) {
            var arg = this._args[key];
            if (arg instanceof PropertyTagObject) {
                var tag = resolveTagObject(valueContext, [arg]);
                var match = tag.match(/^\"(.*)\"$/);
                return match ? match[1] : undefined;
            }
            else if (arg) {
                return resolveTagObject(valueContext, arg);
            }
            else {
                return undefined;
            }
        };
        PropertyArgs.Empty = new PropertyArgs({});
        return PropertyArgs;
    }());
    var PropertySet = /** @class */ (function () {
        function PropertySet(chartObject) {
            /**
             * The private map of user-defined properties
             */
            this._propertyDictionary = {};
            /**
             * A map of properties that are supported natively by FDSProperty on any object.
             */
            this.dynamicProperties = {
                'FDSProperty': true,
                'FDSIf': true,
                'FDSMath': true,
                'FDSSpan': true,
                'FDSCloseSpan': true,
                'FDSBR': true
            };
            this.EmptyPropertyString = new CompiledPropertyString([], this);
            /**
             * `this.parentPropertySet` is a reference to the `PropertySet` of the parent
             * object of `chartObject`. Resolutions of properties will bubble up the parent chain.
             */
            this.parentPropertySet = null;
            this._chartObject = chartObject;
            this._getObject = function (objid) { return chartObject.getRoot().getObject(objid); };
        }
        PropertySet.prototype.getValueContextFromOptions = function (contextOptions) {
            var valueContext = {
                formattingApplied: false,
                propertySet: this,
                object: this._chartObject,
                seriesIndex: undefined,
                seriesDim: undefined,
            };
            // Copy any parameters from the passed in object.
            if (typeof contextOptions === 'object') {
                _$1.assign(valueContext, contextOptions);
            }
            return valueContext;
        };
        PropertySet.prototype.getList = function () {
            return Object.keys(this._propertyDictionary);
        };
        /**
         * this is out here because the v8 compiler can't optimize with try catches
         * putting this out here minimizes the scope of what can't be optimized to just this function
         * @param rawPropertyString - the property to parse
         */
        PropertySet.prototype._tryParsePropertyString = function (rawPropertyString) {
            try {
                parser$1.yy = {
                    PropertyTagObject: PropertyTagObject,
                    PropertySet: this
                };
                return parser$1.parse(rawPropertyString);
            }
            catch (error) {
                if (ENABLE_DEBUG && this._chartObject.root.commonDebug) {
                    console.error(error.toString());
                }
                return ['ERROR: Malformed FDSProperty tag!'];
            }
            finally {
                parser$1.yy = undefined;
            }
        };
        /**
         * Build a `CompiledPropertyString` from a raw string containing property tags
         * @param rawPropertyString - The unparsed property string.
         */
        PropertySet.prototype.compilePropertyString = function (rawPropertyString) {
            if (ENABLE_DEBUG) {
                console.assert(typeof rawPropertyString === 'string', "A " + typeof rawPropertyString + " value was passed to compilePropertyString. This is likely an internal bug in FDSChartJS and should be investigated.");
            }
            // exit early for the empty string cases. We return a cached string for performance since this happens a lot.
            if (typeof rawPropertyString !== 'string' || rawPropertyString === '' || rawPropertyString == null) {
                return this.EmptyPropertyString;
            }
            // we can also skip parsing for any text that doesn't have matching angle brackets
            if (rawPropertyString.indexOf('<') < 0) {
                return new CompiledPropertyString([rawPropertyString], this);
            }
            // `parsedFormatString` is really the abstract syntax tree as returned
            // from the parsing phase above.
            var propertyAST = this._tryParsePropertyString(rawPropertyString);
            return new CompiledPropertyString(propertyAST, this);
        };
        /**
         * Add a user-defined property to the property dictionary.
         * @param key - the name of the property
         * @param value - the string that it should resolve to.
         */
        PropertySet.prototype.addProperty = function (key, value) {
            this._propertyDictionary[key] = value;
            return true;
        };
        /**
         * Remove a user-defined property from the property dictionary
         * @param key - the name of the property
         */
        PropertySet.prototype.removeProperty = function (key) {
            // return if the property doesn't exist
            if (this._propertyDictionary[key] === undefined) {
                return false;
            }
            delete this._propertyDictionary[key];
            return true;
        };
        /**
         * Resolve the property `<key>` up the inheritance chain
         * @param key - the name of the property to get
         * @param kwArgs - a map of `ProperyArgs` that are passed along (for FDSIf, FDSProperty, etc).
         * @return the property string a property handler, or undefined if not found.
         */
        PropertySet.prototype.getProperty = function (key, kwArgs) {
            var chartObj = this._chartObject;
            var parentPropertySet = this.parentPropertySet;
            // Short-circuit through the various properties available:
            //
            // 1. Any built-in dynamic property handlers (FDSIf, math operators, etc.)
            // 2. Any static properties defined on this object
            // 3. Any dynamic property handlers defined on our associated chart object
            // 4. All of the above, as defined on the parent of the associated chart
            //    object
            // 5. `undefined`
            return PropertySet._getDynamicPropertyHandler(this, key, kwArgs) ||
                this._propertyDictionary[key] ||
                PropertySet._getDynamicPropertyHandler(this._chartObject, key, kwArgs) ||
                (parentPropertySet ? parentPropertySet.getProperty(key, kwArgs) : undefined) ||
                undefined;
        };
        /**
         * Sets the parent `PropertySet`. If a property is not found on this level, then the
         * parentPropertySet will be checked recursively until there are no more parents.
         */
        PropertySet.prototype.setParentPropertySet = function (parentPropertySet) {
            this.parentPropertySet = parentPropertySet;
        };
        /**
         * Looks for functions named `'_prop'+propertyKey` on `object`'s prototype and returns
         * a wrapper which will invoke that function if there is a match. Otherwise,
         * returns undefined.
         * @param object - Either an `FDSChartObject` or a `PropertySet` containing dynamic property handlers
         * @param propertyKey - the name of the property we are looking for
         * @param propertyArgs - the additional property arguments to pass along.
         */
        PropertySet._getDynamicPropertyHandler = function (object, propertyKey, propertyArgs) {
            var createTextFromFDSSpanArgs = function (valueContext, args) {
                var formattedArgs = args.getKeys().map(function (key) { return key + "=\"" + args.getArg(key, valueContext) + "\""; }).join(' ');
                return "<FDSSpan " + formattedArgs + ">";
            };
            if (propertyKey === '/FDSSpan') {
                propertyKey = 'FDSCloseSpan';
            }
            if (object.dynamicProperties[propertyKey] != null) {
                // Get our prototype and check to see if we have a dynamic property
                // handler defined, specified by the property tag prepended with
                // `_prop`
                var prototype = Object.getPrototypeOf(object);
                var propFn_1 = prototype['_prop' + propertyKey];
                if (typeof propFn_1 === 'function') {
                    // Return a nullary function that calls our member function in our
                    // current execution context and passes the `valueContext` (which
                    // would be bound as `object`, thanks to the way
                    // `CompiledFormatString`s work) as an argument to our member
                    // function.
                    return function (valueContext, args, richText) {
                        if (!richText) {
                            if (propertyKey === 'FDSCloseSpan') {
                                return '</FDSSpan>';
                            }
                            if (propertyKey === 'FDSSpan') {
                                return (createTextFromFDSSpanArgs(valueContext, args));
                            }
                        }
                        return propFn_1.call(object, valueContext, args);
                    };
                }
            }
            // If we got this far, there aren't any matching dynamic properties, so
            // return undefined in order to keep searching.
            return undefined;
        };
        /**
         * Dynamic property handler for <FDSBR> tags
         */
        PropertySet.prototype._propFDSBR = function (valueContext, args) {
            return '\n';
        };
        /**
         * Dynamic property handler for <FDSSpan ...> rich-text tags
         */
        PropertySet.prototype._propFDSSpan = function (valueContext, args) {
            return new FDSSpanTag(args, valueContext);
        };
        /**
         * Dynamic property handler for </FDSSpan> rich-text closing tags
         */
        PropertySet.prototype._propFDSCloseSpan = function (valueContext, args) {
            return new FDSCloseSpanTag();
        };
        /**
         * Dynamic property handler for <FDSProperty ...> tags
         */
        PropertySet.prototype._propFDSProperty = function (valueContext, args) {
            var value = args.getArg('VALUE', valueContext);
            if (value != null) {
                return value;
            }
            else {
                var chartObj = args.hasArg('OBJECT') ?
                    this._getObject(args.getArg('OBJECT', valueContext)) :
                    valueContext.object;
                if (chartObj == null) {
                    return 'ERROR: FDSProperty object resolution failure!';
                }
                var key = args.getArg('NAME', valueContext);
                if (key) {
                    var property = chartObj.properties.getProperty(key, args) || '';
                    return resolvePropertyHandle(property, valueContext, args, false, key);
                }
                // for compatibility, empty FDSProperty must return empty string
                if (args.getKeys().length === 0) {
                    return '';
                }
                else {
                    return 'ERROR: Malformed FDSProperty tag!';
                }
            }
        };
        /**
         * Dynamic property handler for <FDSIf ...> tags
         */
        PropertySet.prototype._propFDSIf = function (valueContext, args) {
            // `<FDSIf>` tags are really just a fancy way to dispatch into the map of
            // arguments based on the evaluation of the `cond` argument.
            var cond = args.getArg('COND', valueContext);
            if (cond === undefined) {
                return 'ERROR: Malformed FDSIf tag!';
            }
            // we need to uppercase the condition here because we uppercase everything else
            var chosenBranchName = cond.toString().trim().toUpperCase();
            var res = args.getArg(chosenBranchName, valueContext);
            if (this._chartObject.root.propertyUsageManager &&
                this._chartObject.root.propertyUsageManager.isTrackingProperties()) {
                this._resolveSkippedBranches(args, chosenBranchName, valueContext); // So any skipped branches properties
                // count as used
            }
            return (res != null) ? res : cond;
        };
        PropertySet.prototype._resolveSkippedBranches = function (args, chosenBranchName, valueContext) {
            var branchesToResolve = _$1.without(args.getKeys(), 'COND', chosenBranchName);
            for (var _i = 0, branchesToResolve_1 = branchesToResolve; _i < branchesToResolve_1.length; _i++) {
                var currentBranchName = branchesToResolve_1[_i];
                args.getArg(currentBranchName, valueContext);
            }
        };
        /**
         * Dynamic property handler for <FDSMath ...> tags
         */
        PropertySet.prototype._propFDSMath = function (valueContext, args) {
            // this is something that exists in FDSChart for compatibility
            // tags with no args return the empty string
            if (args.getKeys().length === 0) {
                return '';
            }
            var op;
            if (args.hasArg('OP')) {
                op = args.getArg('OP', valueContext).trim();
            }
            else {
                return 'ERROR: FDSMath requires OP parameter!';
            }
            var parseBinaryOp = function (_op, arg) {
                if (args.hasArg(arg)) {
                    var val = args.getArg(arg, valueContext);
                    if (['OR', 'AND', 'XOR'].indexOf(_op) >= 0) {
                        return (val !== '@NA') ? stringToBoolean(val) : val;
                    }
                    else if (!(['S_EQ', 'S_NEQ', 'S_EQ_IC', 'S_NEQ_IC'].indexOf(_op) >= 0)) {
                        return parseArgAsFloat(val);
                    }
                    else {
                        return val;
                    }
                }
                return null;
            };
            var left;
            var right;
            var x;
            var y;
            // Operators with L & R args
            if ([
                'ADD', 'MUL', 'DIV', 'SUB', 'MOD', 'LT', 'LTE', 'GT', 'GTE', 'EQ', 'NEQ', 'AND', 'OR', 'XOR', 'S_EQ',
                'S_NEQ', 'S_EQ_IC', 'S_NEQ_IC'
            ].indexOf(op) >= 0) {
                left = parseBinaryOp(op, 'L');
                right = parseBinaryOp(op, 'R');
                if (left == null || right == null) {
                    return 'ERROR: This FDSMath operation requires L and R parameters!';
                }
                if (IsSomeNAN(left) || IsSomeNAN(right)) {
                    return '@NA';
                }
            }
            else if (['POW', 'SIN', 'COS', 'TAN', 'ASIN', 'ACOS', 'ATAN', 'ATAN2', 'LOG', 'ABS'].indexOf(op) >= 0) {
                // Other math functions use `x` and `y` parameters, if available
                if (args.hasArg('X')) {
                    x = parseArgAsFloat(args.getArg('X', valueContext));
                }
                if (args.hasArg('Y')) {
                    y = parseArgAsFloat(args.getArg('Y', valueContext));
                }
                if (['POW', 'ATAN2'].indexOf(op) >= 0) {
                    if (x == null || y == null) {
                        return 'ERROR: This FDSMath operation requires X and Y parameters!';
                    }
                    else if (IsSomeNAN(x) || IsSomeNAN(y)) {
                        return '@NA';
                    }
                }
                else {
                    if (x == null) {
                        return 'ERROR: This FDSMath operation requires X parameter!';
                    }
                    else if (IsSomeNAN(x)) {
                        return '@NA';
                    }
                }
            }
            else if (['NOT'].indexOf(op) >= 0) {
                if (args.hasArg('X')) {
                    x = args.getArg('X', valueContext);
                    if (x === '@NA') {
                        return x;
                    }
                    x = stringToBoolean(x);
                }
                else {
                    return 'ERROR: This FDSMath operation requires X parameter!';
                }
            }
            var ret = '';
            switch (op) {
                case 'ADD':
                    ret = (left + right);
                    break;
                case 'MUL':
                    ret = (left * right);
                    break;
                case 'DIV':
                    if (right === 0) {
                        return 'ERROR: FDSMath failed; RHS parameter is zero!';
                    }
                    ret = (left / right);
                    break;
                case 'SUB':
                    ret = (left - right);
                    break;
                case 'MOD':
                    if (right === 0) {
                        return 'ERROR: FDSMath failed; RHS parameter is zero!';
                    }
                    ret = (left % right);
                    break;
                case 'LT':
                    ret = (left < right);
                    break;
                case 'LTE':
                    ret = (left <= right);
                    break;
                case 'GT':
                    ret = (left > right);
                    break;
                case 'GTE':
                    ret = (left >= right);
                    break;
                case 'EQ':
                    ret = (left === right);
                    break;
                case 'NEQ':
                    ret = (left !== right);
                    break;
                case 'OR':
                    ret = (left || right);
                    break;
                case 'AND':
                    ret = (left && right);
                    break;
                case 'NOT':
                    ret = (!x);
                    break;
                case 'XOR':
                    ret = ((left ^ right) === 1);
                    break;
                case 'S_EQ':
                    ret = (left.toString() === right.toString());
                    break;
                case 'S_NEQ':
                    ret = (left.toString() !== right.toString());
                    break;
                case 'S_EQ_IC':
                    ret = (left.toString().toLowerCase() === right.toString().toLowerCase());
                    break;
                case 'S_NEQ_IC':
                    ret = (left.toString().toLowerCase() !== right.toString().toLowerCase());
                    break;
                case 'POW':
                    ret = Math.pow(x, y);
                    break;
                case 'ATAN2':
                    ret = Math.atan2(y, x);
                    break;
                case 'SIN':
                    ret = Math.sin(x);
                    break;
                case 'COS':
                    ret = Math.cos(x);
                    break;
                case 'TAN':
                    ret = Math.tan(x);
                    break;
                case 'ASIN':
                    ret = Math.asin(x);
                    break;
                case 'ACOS':
                    ret = Math.acos(x);
                    break;
                case 'ATAN':
                    ret = Math.atan(x);
                    break;
                case 'LOG':
                    ret = Math.log(x);
                    break;
                case 'ABS':
                    ret = Math.abs(x);
                    break;
                default:
                    ret = 'Error: op ' + op + ' not supported.';
            }
            var foo = ret;
            if (typeof foo === 'number') {
                ret = roundToMaxPrecision(foo);
            }
            if (typeof ret === 'boolean') {
                ret = ret.toString();
            }
            valueContext.formattingApplied = false;
            return ret;
        };
        return PropertySet;
    }());
    /**
     * Resolve a property syntax tree to an array of strings and rich-text primatives.
     */
    var resolveTagObjectForRichText = function (valueContext, ast) {
        var strArray = [];
        for (var _i = 0, ast_1 = ast; _i < ast_1.length; _i++) {
            var chunk = ast_1[_i];
            if (chunk instanceof PropertyTagObject) {
                var result = chunk.resolveToString(valueContext, true);
                if (result instanceof RichTextString) {
                    strArray = strArray.concat(result.data);
                }
                else {
                    strArray.push(result);
                }
            }
            else {
                strArray.push(chunk);
            }
        }
        return new RichTextString(strArray);
    };
    /**
     * Resolve a property syntax tree to a string, stripping rich-text in the process.
     */
    var resolveTagObject = function (valueContext, ast) {
        var str = '';
        for (var _i = 0, ast_2 = ast; _i < ast_2.length; _i++) {
            var chunk = ast_2[_i];
            if (chunk instanceof PropertyTagObject) {
                str += chunk.resolveToString(valueContext, false);
            }
            else {
                str += chunk;
            }
        }
        return str;
    };
    function resolvePropertyHandle(property, valueContext, args, richText, tag) {
        /**
         * If we have a dynamic property handler function, evaluated it, if not, simply
         * return the property, since it's most likely a string.
         */
        var format = new FDSFormat();
        var dataType = args.getArg('TYPE', valueContext);
        var formatStr = args.getArg('FORMAT', valueContext);
        var useFormat = false;
        var res;
        var propStr;
        valueContext.formattingApplied = false;
        var oldIndex = valueContext.seriesIndex;
        var oldDim = valueContext.seriesDim;
        if (args.hasArg('INDEX')) {
            var index = parseArgAsFloat(args.getArg('INDEX', valueContext));
            valueContext.seriesIndex = !isNaN(index) ? index : -1;
        }
        if (args.hasArg('DIMENSION')) {
            var dim = parseArgAsFloat(args.getArg('DIMENSION', valueContext));
            valueContext.seriesDim = !isNaN(dim) ? dim : -1;
        }
        if (property instanceof Function) {
            res = property(valueContext, args, richText);
        }
        else {
            res = property;
        }
        valueContext.seriesIndex = oldIndex;
        valueContext.seriesDim = oldDim;
        if (res instanceof CompiledPropertyString) {
            if (richText) {
                return res.fromValueRT(valueContext);
            }
            else {
                return res.fromValue(valueContext);
            }
        }
        else if (dataType != null && formatStr != null) {
            var resNum = void 0;
            if (typeof res === 'number') {
                propStr = res.toString();
                resNum = res;
            }
            else if (typeof res === 'string') {
                propStr = res;
                resNum = parseArgAsFloat(res);
            }
            else if (res instanceof RichTextString) {
                propStr = res.toString();
                resNum = parseArgAsFloat(propStr);
            }
            else {
                console.warn('Unexpected result of property resolution. Expected string/number.');
                resNum = NAN;
                propStr = '';
            }
            if (!valueContext.formattingApplied) {
                if (isNaN(resNum)) {
                    propStr = '@NA';
                }
                else {
                    switch (dataType.toUpperCase()) {
                        case 'INT':
                            format.setNumberFormat(formatStr);
                            propStr = format.formatAsNumber(resNum);
                            break;
                        case 'FLOAT':
                            format.setNumberFormat(formatStr);
                            propStr = format.formatAsNumber(resNum);
                            break;
                        case 'TIME':
                            format.setTimeFormat(formatStr);
                            propStr = format.formatAsTime(resNum);
                            break;
                        case 'DATE':
                            format.setDateFormat(formatStr);
                            propStr = format.formatAsDate(resNum);
                            break;
                        case 'DATETIME':
                            format.setDateTimeFormat(formatStr);
                            propStr = format.formatAsDateTime(resNum);
                            break;
                        default:
                            propStr = 'ERROR: Unsupported format type specified!';
                    }
                    valueContext.formattingApplied = true;
                }
            }
        }
        // check if by this point we found a prop string
        if (propStr === undefined) {
            if (res instanceof RichTextString) {
                res = richText ? res : res.toString();
            }
            else if ((res instanceof FDSSpanTag || res instanceof FDSCloseSpanTag)) {
                res = richText ? res : '';
            }
            else if (ENABLE_DEBUG) {
                if (res != null && !(_$1.isString(res) || _$1.isNumber(res))) {
                    console.warn('Unexpected result of property resolution. Expected string, number or RichTextString.');
                }
            }
            propStr = (res != null) ? res : '';
            var propertySet = valueContext.propertySet, object = valueContext.object;
            var trackingProperties = object && object.root && object.root.propertyUsageManager &&
                object.root.propertyUsageManager.isTrackingProperties();
            if (trackingProperties && propStr === '' && tag && propertySet.dynamicProperties[tag] == null) {
                // save this undefined property because it is still being used and should be tracked
                object.usedProperties[tag] = true;
            }
        }
        return propStr;
    }
    /**
     * This class represents a parsed FDSProperty string and provides methods for resolving them.
     * @class
     */
    var CompiledPropertyString = /** @class */ (function () {
        /**
         * Constructs a `CompiledPropertyString` from an abstract syntax tree and a `PropertySet`
         * @constructor
         */
        function CompiledPropertyString(ast, propertySet) {
            this._ast = ast;
            this._propertySet = propertySet;
        }
        CompiledPropertyString.prototype.isEmpty = function () {
            return this._ast == null || this._ast.length === 0;
        };
        CompiledPropertyString.prototype.isOnlyText = function () {
            return _$1.every(this._ast, _$1.isString);
        };
        CompiledPropertyString.prototype._fromValueImpl = function (contextArgs, resolveFunc) {
            var valueContext = this._propertySet.getValueContextFromOptions(contextArgs);
            return resolveFunc(valueContext, this._ast);
        };
        /**
         * Resolves the property string, and discard rich-text FDSSpan tags.
         * Additional arguments provided through `contextArgs` get copied to the valueContext when resolving.
         * @param {ValueContextOptions} contextArgs - the value to be used when resolving.
         * @return a resolved property string.
         */
        CompiledPropertyString.prototype.fromValue = function (contextArgs) {
            return this._fromValueImpl(contextArgs, resolveTagObject);
        };
        /**
         * Resolves the property string, and includes rich-text information in the resulting array.
         * Additional arguments provided through `contextArgs` get copied to the valueContext when resolving.
         * @param {ValueContextOptions} contextArgs - the value to be used when resolving.
         * @return a resolved property string.
         */
        CompiledPropertyString.prototype.fromValueRT = function (contextArgs) {
            return this._fromValueImpl(contextArgs, resolveTagObjectForRichText);
        };
        return CompiledPropertyString;
    }());
    /**
     * The `PropertyTagObject` object is created during the parsing phase to
     * represent a parsed property tag object including its arguments.
     * @class
     */
    var PropertyTagObject = /** @class */ (function () {
        function PropertyTagObject(propertySet, tag, args) {
            var _this = this;
            this._propertySet = propertySet;
            // Now we are a full blown `PropertyArgs`
            this._args = new PropertyArgs(args);
            if (_$1.isString(tag)) {
                this._tag = tag;
                this._property = this._propertySet.getProperty(this._tag, this._args) || '';
            }
            else {
                this._tag = '';
                this._property = function (valueContext, propArgs, richText) {
                    var res = new CompiledPropertyString(tag, _this._propertySet);
                    var temp = '<';
                    if (richText) {
                        temp += res.fromValueRT(valueContext);
                    }
                    else {
                        temp += res.fromValue(valueContext);
                    }
                    temp += '>';
                    return _this._propertySet.compilePropertyString(temp).fromValue(valueContext);
                };
            }
        }
        PropertyTagObject.prototype.resolveToString = function (valueContext, richText) {
            if (richText === void 0) { richText = false; }
            if (this._property === '') {
                this._property = (this._propertySet.getProperty(this._tag, this._args)) || '';
            }
            return resolvePropertyHandle(this._property, valueContext, this._args, richText, this._tag);
        };
        return PropertyTagObject;
    }());
    /**
     * This is a wrapper around parseFloat that strips commas before parsing.
     * Otherwise, commas used as thousands-separators get interpreted as the end of string.
     */
    function parseArgAsFloat(input) {
        return parseFloat(input.replace(/,/g, ''));
    }
    
    var RichTextRenderer;
    (function (RichTextRenderer) {
        /**
         * Container for state changes applied as part of a rich-text span (`<FDSSpan>`)
         *
         * @class RichTextState
         */
        var RichTextState = /** @class */ (function () {
            /**
             * Creates an instance of RichTextState.
             *
             * @param Which font to use as the basis for text output.
             */
            function RichTextState(font) {
                this.font = font;
                this.bgColor = undefined;
                this.fontColor = COLORREFtoHex(font.color);
                this.superscript = false;
                this.subscript = false;
                this.cursor = undefined;
                this.linkData = undefined;
            }
            /**
             * Set the internal rich-text state from the key-value FDSSpan arguments
             *
             * @param prop - the FDSSpan argument name
             * @param val - the FDSSpan argument value.
             */
            RichTextState.prototype.setProperty = function (prop, val) {
                var fontOptions;
                switch (prop) {
                    case 'FONTCOLOR':
                        this.fontColor = val;
                        break;
                    case 'FONTFAMILY':
                    case 'FONTNAME':
                        fontOptions = { family: val };
                        break;
                    case 'FONTHEIGHT':
                    case 'FONTSIZE':
                        fontOptions = { height: Number(val) };
                        break;
                    case 'FONTWEIGHT':
                        fontOptions = { weight: Number(val) };
                        break;
                    case 'ITALIC':
                        fontOptions = { italic: stringToBoolean(val) };
                        break;
                    case 'UNDERLINE':
                        fontOptions = { underline: stringToBoolean(val) };
                        break;
                    case 'BACKGROUNDCOLOR':
                    case 'BGCOLOR':
                        this.bgColor = val;
                        break;
                    case 'SUPERSCRIPT':
                        this.superscript = stringToBoolean(val);
                        this.subscript = false;
                        fontOptions = { height: ~~(0.6666666666666666 /* SUPERSCRIPT_SCALE */ * this.font.height) };
                        break;
                    case 'SUBSCRIPT':
                        this.subscript = stringToBoolean(val);
                        this.superscript = false;
                        fontOptions = { height: ~~(0.6666666666666666 /* SUPERSCRIPT_SCALE */ * this.font.height) };
                        break;
                    case 'CURSOR':
                        this.cursor = val;
                        break;
                    case 'EVENT':
                        this.linkData = { type: 'event', data: val, cursor: this.cursor };
                        break;
                    case 'HREF':
                        this.linkData = { type: 'href', data: encodeURI(val), cursor: this.cursor };
                        break;
                    case 'ACTION':
                        this.linkData = { type: 'action', data: val, cursor: this.cursor };
                        break;
                }
                if (fontOptions) {
                    this.font = this.font.with(fontOptions);
                }
            };
            /**
             * Creates a deep copy of the current RichTextState
             *
             * @returns a copy of the RichTextState
             */
            RichTextState.prototype.copy = function () {
                var newRTS = new RichTextState(this.font);
                newRTS.bgColor = this.bgColor;
                newRTS.fontColor = this.fontColor;
                newRTS.superscript = this.superscript;
                newRTS.subscript = this.subscript;
                newRTS.cursor = this.cursor;
                newRTS.linkData = _$1.clone(this.linkData);
                return newRTS;
            };
            /**
             * Apply any changes between the previous and current rich-text states to the chart rendering context.
             *
             * @param ctx - the chart rendering context.
             * @param [prevStyle] - the previous state object to compare against if one exists.
             */
            RichTextState.prototype.apply = function (ctx, prevStyle) {
                var applyFontColor = function (fontColor) {
                    var color = parseInt(fontColor, 10);
                    if (!isNaN(color)) {
                        ctx.setFontFillStyle(COLORREFtoHex(color));
                    }
                    else {
                        ctx.setFontFillStyle(fontColor);
                    }
                };
                // If the font changed, update it on the canvas context.
                if (!prevStyle || !this.font.equals(prevStyle.font)) {
                    ctx.setFont(this.font);
                    if (this.fontColor) {
                        applyFontColor(this.fontColor);
                    }
                }
                // Also check if the font color changed.
                if (!prevStyle || this.fontColor !== prevStyle.fontColor) {
                    // check if it is a colorref or a normal CSS style color
                    if (this.fontColor == null) {
                        ctx.setFontFillStyle(COLORREFtoHex(this.font.color));
                    }
                    else {
                        applyFontColor(this.fontColor);
                    }
                }
            };
            return RichTextState;
        }());
        RichTextRenderer.RichTextState = RichTextState;
        /**
         * Converts the FDSSpan property arguments into an HTML span.
         *
         * @param chunk - the property argument wrapper for the FDSSpan tag.
         * @returns an HTML string for the <span> tag
         */
        function richTextChunkToSpanTag(chunk) {
            var out = "<span style='";
            for (var prop in chunk) {
                if (!chunk.hasOwnProperty(prop)) {
                    continue;
                }
                var val = chunk[prop];
                switch (prop) {
                    case 'FONTCOLOR':
                        // if this parses as a number, its probably a colorref
                        if (!isNaN(Number(val))) {
                            val = COLORREFtoHex(Number(val));
                        }
                        out += "color:" + val + ";";
                        break;
                    case 'FONTFAMILY':
                    case 'FONTNAME':
                        out += "font-family:" + val + ";";
                        break;
                    case 'FONTHEIGHT':
                    case 'FONTSIZE':
                        out += "font-size:" + val + ";";
                        break;
                    case 'FONTWEIGHT':
                        val = FDSFont.convertFontWeightToCSS(Number(val));
                        out += "font-weight:" + val + ";";
                        break;
                    case 'ITALIC':
                        if (!val) {
                            break;
                        }
                        else {
                            val = '';
                        }
                        out += 'font-style: italic;';
                        break;
                    case 'UNDERLINE':
                        if (!val) {
                            break;
                        }
                        else {
                            val = '';
                        }
                        out += 'text-decoration: underline;';
                        break;
                    case 'BACKGROUNDCOLOR':
                    case 'BGCOLOR':
                        if (!isNaN(Number(val))) {
                            val = COLORREFtoHex(Number(val));
                        }
                        out += "background-color:" + val + ";";
                        break;
                }
            }
            out += "'>";
            return out;
        }
        /**
         * A helper function to strip formatting from a string and just get plain text
         *
         * @param text - the string, or rich-text array to convert to plain text.
         * @returns an unformatted string stripped of rich-text information
         */
        function convertToPlaintext(text) {
            var data = (typeof text === 'string') ? [text] : text.data;
            var outStr = '';
            for (var _i = 0, _a = data.filter(_$1.isString); _i < _a.length; _i++) {
                var chunk = _a[_i];
                outStr += chunk.replace(/\n|\n\r|\r\n/g, ' ');
            }
            return outStr;
        }
        RichTextRenderer.convertToPlaintext = convertToPlaintext;
        /**
         * Converts the rich-text array to html using the span tag.
         *
         * @param text - the string, or rich-text array to convert to html.
         * @returns an HTML string
         */
        function convertToHTML(text) {
            if (typeof text === 'string') {
                return text.replace(/\n|\n\r|\r\n/g, '<br />');
            }
            else {
                var numOpenTags = 0;
                var outStr_1 = '';
                for (var _i = 0, _a = text.data; _i < _a.length; _i++) {
                    var chunk = _a[_i];
                    // sanity check - I ran into undefined chunks a few times
                    if (!chunk) {
                        continue;
                    }
                    if (typeof chunk === 'string') {
                        outStr_1 += cleanString(chunk).replace(/\n|\n\r|\r\n/g, '<br />');
                    }
                    else {
                        if (chunk instanceof FDSCloseSpanTag) {
                            if (numOpenTags > 0) {
                                outStr_1 += '</span>';
                            }
                            numOpenTags--;
                            continue;
                        }
                        else {
                            outStr_1 += richTextChunkToSpanTag(chunk);
                            numOpenTags++;
                        }
                    }
                }
                _$1.times(numOpenTags, function () { return outStr_1 += '</span>'; });
                return outStr_1;
            }
        }
        RichTextRenderer.convertToHTML = convertToHTML;
        /**
         * A helper method to determine if the text we are dealing with is simple enough to bypass the more expensive
         * rich-text measurement / writing. To avoid measuring the string multiple times, this function also returns
         * the text width which it calculates as part of its implementation.
         *
         * This function considers the text array simple if it has only one element, and that element is either string or a
         * number. Addtionally, in the case of strings, the string must be less than the font widthHint, and have no line
         * breaks.
         *
         * @param ctx - the chart rendering context
         * @param text - the richtext array.
         * @param font - the font the text will eventually be drawn with (used for widthHint)
         */
        function isSimpleText(ctx, text, font) {
            var isSimple = false;
            var width = 0;
            var simpleText;
            if (text.isEmpty()) {
                return { isSimple: true, width: 0, simpleText: '' };
            }
            else if (text.data.length === 1 && !font.underline) {
                var first$$1 = text.data[0];
                if (typeof first$$1 === 'number') {
                    // TODO: we probably shouldn't ever hit this case in an ideal world.
                    simpleText = first$$1.toString();
                    isSimple = true;
                }
                else if (typeof first$$1 === 'string' && first$$1.indexOf('\n') === -1) {
                    width = ctx.measureTextWidth(first$$1);
                    isSimple = width < font.widthHint;
                    if (isSimple) {
                        simpleText = first$$1;
                    }
                }
            }
            return { isSimple: isSimple, width: width, simpleText: simpleText };
        }
        /**
         * Calculates the x-offset needed to align a textbox against a given width.
         * @param alignment - The alignment desired for the textbox.
         * @param textMetrics - The dimensions of the textbox.
         * @param alignWidth - The width against which we will align the textbox.
         * @returns The x-offset needed to align the textbox against alignWidth.
         */
        function calcXOffsetForTextAlignment(alignment, textMetrics, alignWidth) {
            var offset = 0;
            switch (alignment) {
                case 2 /* CENTER */:
                    offset = ~~((alignWidth / 2) - (textMetrics.width / 2));
                    if (offset < 0) {
                        offset = 0;
                    }
                    break;
                case 1 /* RIGHT */:
                    offset = alignWidth - textMetrics.width;
                    break;
            }
            return offset;
        }
        RichTextRenderer.calcXOffsetForTextAlignment = calcXOffsetForTextAlignment;
        /**
         * Measures the text dimensions. In addition to the text dimensions, this function will return a `PreparedText`
         * object, saving future preparation/processing of the text if it is passed along to the writeRichText method.
         *
         * @param ctx - the chart rendering context
         * @param textToMeasure - the text to be measured
         * @param font - the font that will be used for drawing/measurement
         * @param optPreparedText - If the text has already been prepared for rich-text, passing it in here will save some
         *   computation. This is typically only used by writeRichText when figuring out alignment
         * @returns the text dimensions and the prepared richtext data.
         */
        function measureRichText(ctx, textToMeasure, font, optPreparedText) {
            var text;
            if (typeof textToMeasure === 'string') {
                text = new RichTextString(textToMeasure);
            }
            else {
                text = textToMeasure;
            }
            // workaround for FDSDateTimeScale's buggy undefined tick labels
            // TODO: remove this when FDSDateTimeScale works.
            if (text.data.length === 1 && _$1.isUndefined(text.data[0])) {
                text = RichTextString.Empty;
            }
            ctx.save();
            var textOut = [];
            font.setOnCanvas(ctx);
            var minLineHeight;
            var maxLineHeight;
            var firstLineSize;
            var height;
            /* tslint:disable:prefer-const */
            var _a = isSimpleText(ctx, text, font), isSimple = _a.isSimple, width = _a.width, simpleText = _a.simpleText;
            /* tslint:enable:prefer-const */
            // Short circuit for the case where there is no rich text and the text
            // fits in the line
            if (isSimple) {
                minLineHeight = maxLineHeight = firstLineSize = height = font.getHeight(ctx);
                textOut.push({
                    content: [
                        new RichTextState(font),
                        {
                            text: simpleText,
                            height: height,
                            width: width
                        }
                    ],
                    width: width,
                    height: height
                });
            }
            else {
                textOut = optPreparedText ? optPreparedText : prepareRichText(ctx, text, font);
                width = 0;
                height = 0;
                minLineHeight = Infinity;
                maxLineHeight = 0;
                firstLineSize = 0;
                for (var i = 0; i < textOut.length; i++) {
                    // Only want the height of the first line for the purposes of positioning
                    // the glyph
                    var line = textOut[i];
                    if (i === 0) {
                        firstLineSize = line.height;
                    }
                    height += line.height;
                    if (line.width > width) {
                        (width = line.width);
                    }
                    if (line.height > maxLineHeight) {
                        maxLineHeight = line.height;
                    }
                    // save the smallest non-zero line
                    if (line.height < minLineHeight && line.height !== 0) {
                        minLineHeight = line.height;
                    }
                }
            }
            if (minLineHeight === Infinity) {
                minLineHeight = 0;
            }
            ctx.restore();
            // we want to return the height of the font if above the height of the line is determined to be
            // 0 so that things like empty headers still take up space
            if (!height) {
                height = font.getHeight(ctx);
            }
            var _b = _adjustDimensionsForTilt(width, height, font.escapement), newWidth = _b.newWidth, newHeight = _b.newHeight;
            return [
                {
                    width: newWidth,
                    height: newHeight,
                    untiltedWidth: width,
                    untiltedHeight: height,
                    minLineHeight: minLineHeight,
                    maxLineHeight: maxLineHeight,
                    firstLineSize: firstLineSize
                },
                textOut
            ];
        }
        RichTextRenderer.measureRichText = measureRichText;
        /**
         * Adjusts the bounding rectangle to account for rotation.
         *
         * @param width - the original width of the bounding rectangle
         * @param height - the original width of the bounding rectangle
         * @param angle - the angle to rotate in radians
         * @returns the new width and height of the bounded rectangle after rotation
         */
        function _adjustDimensionsForTilt(width, height, angle) {
            // Handle the simple 90 degrees rotations.
            if (fuzzyEQ(angle % Math.PI, 0)) {
                return {
                    newWidth: width,
                    newHeight: height,
                };
            }
            else if (fuzzyEQ(angle % Math.PI, Math.PI / 2)) {
                return {
                    newWidth: height,
                    newHeight: width,
                };
            }
            // set up rect coords for easy math (put center at 0,0)
            var x1 = -width / 2;
            var x2 = width / 2;
            var y1 = -height / 2;
            var y2 = height / 2;
            var cosine = Math.cos(angle);
            var sine = Math.sin(angle);
            // calculate transforms of all points
            var a1 = x1 * cosine + y1 * sine;
            var a2 = x2 * cosine + y2 * sine;
            var a3 = x1 * cosine + y2 * sine;
            var a4 = x2 * cosine + y1 * sine;
            var b1 = x1 * sine + y1 * cosine;
            var b2 = x2 * sine + y2 * cosine;
            var b3 = x1 * sine + y2 * cosine;
            var b4 = x2 * sine + y1 * cosine;
            // find min and max points
            var minX = Math.min(a1, a2, a3, a4);
            var minY = Math.min(b1, b2, b3, b4);
            var maxX = Math.max(a1, a2, a3, a4);
            var maxY = Math.max(b1, b2, b3, b4);
            // calculate new width and height
            return {
                newWidth: Math.round(maxX - minX),
                newHeight: Math.round(maxY - minY),
            };
        }
        /**
         * Converts the RichTextString from the property parser into a format that the RichTextRenderer can consume
         *
         * @param ctx - the chart rendering context
         * @param text - the raw-richtext data to convert
         * @param font - the font that will be used for drawing the text
         */
        function prepareRichText(ctx, text, font) {
            var textOut = [];
            ctx.save();
            var re = /[^\S\n]|[\S]+|\n/g;
            var beginState = new RichTextState(font);
            var currentLine = { content: [beginState], height: 0, width: 0 };
            var prevStyle;
            var styleStack = [beginState];
            beginState.apply(ctx);
            var lineNo = 0;
            var tempSpaces = [];
            var tempSpaceHeight = 0;
            var tempSpaceWidth = 0;
            // width and height of the current section of text
            var width = 0;
            var height = 0;
            var pastTruncation = false;
            /**
             * Add the text blocks to the current line, and update the current line's dimensions
             *
             * @param wordObjArr - the text blocks to add to the current line
             * @param width - the total width of the blocks being added.
             * @param height - the maximum height of the blocks being added.
             */
            function addToLine(wordObjArr, totalWidth, maxHeight) {
                if (totalWidth === void 0) { totalWidth = 0; }
                if (maxHeight === void 0) { maxHeight = 0; }
                // find width and height if they aren't provided
                if (totalWidth === 0) {
                    wordObjArr.forEach(function (o) { return totalWidth += o.width; });
                }
                if (maxHeight === 0) {
                    wordObjArr.forEach(function (o) {
                        if (o.height > maxHeight) {
                            maxHeight = o.height;
                        }
                    });
                }
                currentLine.content = currentLine.content.concat(wordObjArr);
                currentLine.width += totalWidth;
                if (maxHeight > currentLine.height) {
                    currentLine.height = maxHeight;
                }
            }
            /**
             * helper function to add the temp spaces and then clear the array
             */
            function addTempSpaces() {
                addToLine(tempSpaces, tempSpaceWidth, tempSpaceHeight);
                // and reset
                tempSpaces = [];
                tempSpaceWidth = tempSpaceHeight = 0;
            }
            /**
             * searches a word binarily to find where to cut the word to be closest to,
             * but under, a given length
             *
             * @param word - the word to truncate
             * @param desiredWidth The desired width of the string.
             * @returns `word` truncated to be the `desiredWidth`
             */
            function binarySearchWordForLength(word, desiredWidth) {
                if (desiredWidth <= 0) {
                    return '';
                }
                if (ctx.measureTextWidth(word) < desiredWidth) {
                    return word;
                }
                var low = 0;
                var high = word.length;
                var ind = 0;
                while (low < high) {
                    ind = ((low + high) / 2) | 0;
                    var substring = word.slice(0, ind);
                    var subwidth = ctx.measureTextWidth(substring);
                    if (subwidth > desiredWidth) {
                        high = ind - 1;
                    }
                    else if (subwidth === desiredWidth) {
                        break;
                    }
                    else {
                        low = ind + 1;
                    }
                }
                // now some checks to find the correct index
                ind = low + 1;
                word = word.slice(0, ind);
                while ((width = ctx.measureTextWidth(word)) > desiredWidth) {
                    ind--;
                    word = word.slice(0, ind);
                }
                return word;
            }
            /**
             * Add the font's truncation string to the current line if it fits.
             */
            function addTruncateString() {
                var totalWidth = currentLine.width;
                if (totalWidth < currentLine.content[0]['tsWidth']) {
                    // no room to even fit the string
                    currentLine = { content: [], width: 0, height: 0 };
                    return;
                }
                for (var i = currentLine.content.length - 1; i >= 0; i--) {
                    if (currentLine.content[i]['text'] == null) {
                        continue;
                    } // it's not a word
                    var wordObj = currentLine.content[i];
                    if (totalWidth - wordObj.width + wordObj.tsWidth > font.widthHint) {
                        totalWidth -= wordObj.width;
                        currentLine.content = currentLine.content.slice(0, i);
                        currentLine.width = totalWidth;
                    }
                    else {
                        // we can fit the truncateString into this word
                        currentLine.width = currentLine.width - wordObj.width;
                        wordObj.text = binarySearchWordForLength(wordObj.text, wordObj.width - wordObj.tsWidth) +
                            font.truncateString;
                        wordObj.width = ctx.measureTextWidth(wordObj.text);
                        currentLine.width = currentLine.width + wordObj.width;
                        return;
                    }
                }
                // if we hit here, we couldn't fit the truncate string anywhere
                currentLine = { content: [], width: 0, height: 0 };
            }
            for (var _i = 0, _a = text.data; _i < _a.length; _i++) {
                var section = _a[_i];
                if (typeof section === 'object') {
                    if (section instanceof FDSCloseSpanTag) {
                        currentLine.content.push({ popRichText: true });
                        prevStyle = styleStack.pop();
                        styleStack[styleStack.length - 1].apply(ctx, prevStyle);
                        continue;
                    }
                    else {
                        prevStyle = styleStack[styleStack.length - 1];
                        var newState = prevStyle.copy();
                        for (var prop in section) {
                            newState.setProperty(prop, section[prop]);
                        }
                        newState.apply(ctx, prevStyle);
                        styleStack.push(newState);
                        currentLine.content.push(newState);
                    }
                }
                else if (typeof section === 'string') {
                    if (section === '') {
                        continue;
                    }
                    var sectionWords = section.match(re);
                    for (var _b = 0, sectionWords_1 = sectionWords; _b < sectionWords_1.length; _b++) {
                        var word = sectionWords_1[_b];
                        var tsWidth = void 0;
                        if (font.truncate === 1 /* TRUNCATE */) {
                            // save this for calculations later
                            tsWidth = ctx.measureTextWidth(font.truncateString);
                        }
                        // handle manual line breaks
                        if (word === '\n') {
                            pastTruncation = false;
                            textOut.push(currentLine);
                            currentLine = { content: [], height: 0, width: 0 };
                            continue;
                        }
                        // we have something that isn't a line break, ignore it
                        if (pastTruncation) {
                            continue;
                        }
                        width = ctx.measureTextWidth(word);
                        height = styleStack[styleStack.length - 1].font.getHeight(ctx);
                        // If the current line has room for the current word append to the line
                        // otherwise, create a new line with the word. This will also nicely handle
                        // the case that a word is too long to fit on a single line
                        // note: for this check we need to include spaces if the word is not a space, because
                        // they will be added when it's added
                        var tempWidth = currentLine.width + width;
                        if (word.match(/\s+/) == null) {
                            tempWidth += tempSpaceWidth;
                        }
                        if (tempWidth > font.widthHint) {
                            if (font.truncate === 1 /* TRUNCATE */) {
                                var desiredWidth = font.widthHint - currentLine.width;
                                if (tempSpaceWidth > desiredWidth) {
                                    // the spaces are causing the problem - add them til you can't anymore
                                    for (var i = 0; i < tempSpaces.length && currentLine.width < desiredWidth; i++) {
                                        // checking i is just a sanity check - it shouldn't reach the end of the space array
                                        addToLine([tempSpaces[i]], tempSpaces[i].width, tempSpaces[i].height);
                                    }
                                    pastTruncation = true;
                                    addTruncateString();
                                    continue;
                                }
                                else {
                                    // the spaces aren't the problem. Add them now, and remove their width
                                    // from the width we're trying to fill
                                    desiredWidth -= tempSpaceWidth;
                                    addTempSpaces();
                                }
                                // quick checks
                                if (desiredWidth < ctx.measureTextWidth(word[0])) {
                                    // not even room for one letter
                                    pastTruncation = true;
                                    addTruncateString();
                                    continue;
                                }
                                var shorterword = binarySearchWordForLength(word, desiredWidth);
                                if (shorterword.length > 0) {
                                    addToLine([{ text: shorterword, width: width, height: height, tsWidth: tsWidth }], width, height);
                                }
                                pastTruncation = true;
                                addTruncateString();
                                continue;
                            }
                            else {
                                // reset the space holding section
                                tempSpaces = [];
                                tempSpaceWidth = tempSpaceHeight = 0;
                                textOut.push(currentLine);
                                currentLine = { content: [], height: 0, width: 0 };
                                // we dont want to push leading spaces to new lines
                                if (word.match(/\s+/) == null) {
                                    addToLine([{ text: word, width: width, height: height, tsWidth: tsWidth }], width, height);
                                }
                            }
                        }
                        else {
                            if (word.match(/\s+/) == null) {
                                addTempSpaces();
                                addToLine([{ text: word, width: width, height: height, tsWidth: tsWidth }], width, height);
                            }
                            else {
                                // save spaces to only be added in the case of a word on the same line
                                tempSpaces.push({ text: word, width: width, height: height, tsWidth: tsWidth });
                                tempSpaceWidth += width;
                                if (height > currentLine.height) {
                                    tempSpaceHeight = height;
                                }
                            }
                        }
                    }
                }
            }
            if (currentLine.content.length !== 0) {
                textOut.push(currentLine);
            }
            ctx.restore();
            return textOut;
        }
        /**
         * Draw a filled rectangle behind the text using the provided color.
         *
         * @param ctx - the chart rendering context
         * @param x - the x coordinate of the left edge of the rectangle
         * @param y - the y coordinate of the top edge of the rectangle
         * @param w - the width of the rectangle
         * @param h - the height of the rectangle
         * @param color the background color as a CSS string.
         */
        function renderTextBG(ctx, x, y, w, h, color) {
            x = ~~x;
            y = ~~y;
            ctx.setBrushFillStyle(color);
            ctx.fillRect(x, ~~(y - 0.1 * h), w + 2, ~~(h * 1.1));
        }
        /**
         * Draw the underline portion of the text.
         *
         * @param ctx - the chart rendering context
         * @param x - the x coordinate of the left edge of the underline
         * @param y - the y coordinate of the underline
         * @param w - the length of the underline
         * @param color - the color of the text/underline as a CSS string.
         */
        function renderTextUnderline(ctx, x, y, w, h, currentStyle) {
            // Scale the width of the underline with the line height.
            var lineWidth = Math.max(1, Math.round(h / 12));
            var aliasOffset = (lineWidth % 2) === 1 ? 0.5 : 0;
            x = ~~x;
            y = ~~y - aliasOffset;
            ctx.setPenStrokeStyle(currentStyle.fontColor, scaleByDevicePixelRatio(lineWidth), []);
            ctx.beginPath();
            ctx.moveTo(x, y + h);
            ctx.lineTo(x + w, y + h);
            ctx.stroke();
        }
        /**
         * We always draw from the left edge, so when using centered or right-alignment, we need to offset
         * the x-coordinate to accomodate.
         *
         * @param alignment - the desired text alignment
         * @param x - the current x position
         * @param lineWidth - the width of the current line
         * @param totalWidth - the maximum width of all lines
         * @returns the new x-coordinate to simulate alignment.
         */
        function _positionX(alignment, x, lineWidth, totalWidth) {
            switch (alignment) {
                case 1 /* RIGHT */:
                    return x + totalWidth - lineWidth;
                case 2 /* CENTER */:
                    return ~~(x + totalWidth / 2 - lineWidth / 2);
                case 0 /* LEFT */:
                default:
                    return x;
            }
        }
        /**
         * Draws the text to the canvas at the coordinates provided.
         *
         * @param ctx - the chart rendering context
         * @param textToWrite - the text to draw on the canvas
         * @param x - the x-coordinate where the text will be drawn
         * @param y - the y-coordinate where the text will be drawn
         * @param font - the font to draw the text with.
         * @param alignment - the font's horizontal alignment
         * @param optPreparedText - an optional PreparedText object recieved from measureText.
         */
        function writeRichText(ctx, textToWrite, x, y, font, alignment, optPreparedText) {
            var text;
            if (typeof textToWrite === 'string') {
                text = new RichTextString(textToWrite);
            }
            else {
                text = textToWrite;
            }
            if (alignment == null) {
                alignment = font.alignment;
            }
            if (text.isEmpty()) {
                return;
            }
            ctx.save();
            font.setOnCanvas(ctx);
            x = ~~x + 0.5;
            y = ~~y + 0.5;
            // move to the center of the bounding box and rotate
            var _a = measureRichText(ctx, text, font, optPreparedText), dims = _a[0], preparedText = _a[1];
            ctx.translate(x + dims.width / 2, y + dims.height / 2);
            ctx.rotate(font.escapement);
            var screenX = x + dims.width / 2;
            var screenY = y + dims.height / 2;
            // x and y are now relative to the new coordinates
            x = -dims.untiltedWidth / 2;
            y = -dims.untiltedHeight / 2;
            // short circuit for performance, if the inputted array is length 1,
            // then we have no rich text, and we dont need to do complex measuring and changing
            // of the context state
            var _b = isSimpleText(ctx, text, font), isSimple = _b.isSimple, width = _b.width, simpleText = _b.simpleText;
            if (isSimple) {
                x = _positionX(alignment, x, width, dims.untiltedWidth);
                ctx.fillText(simpleText, x, y + font.getBaselineOffset());
                ctx.restore();
                return;
            }
            var textOut = preparedText || prepareRichText(ctx, text, font);
            var styleStack = [];
            var prevStyle;
            var currentLink;
            for (var _i = 0, textOut_1 = textOut; _i < textOut_1.length; _i++) {
                var line = textOut_1[_i];
                // Place the x in the correct spot for the current font's alignment
                var curX = _positionX(alignment, x, line.width, dims.untiltedWidth);
                for (var _c = 0, _d = line.content; _c < _d.length; _c++) {
                    var block = _d[_c];
                    if (block instanceof RichTextState) {
                        prevStyle = styleStack[styleStack.length - 1];
                        block.apply(ctx, prevStyle);
                        styleStack.push(block);
                        continue;
                    }
                    else if (block['popRichText']) {
                        prevStyle = styleStack.pop();
                        styleStack[styleStack.length - 1].apply(ctx, prevStyle);
                        continue;
                    }
                    else {
                        var textblock = block;
                        var currentStyle = styleStack[styleStack.length - 1];
                        if (currentStyle.bgColor != null) {
                            renderTextBG(ctx, curX, y, textblock.width, line.height, currentStyle.bgColor);
                        }
                        var superSubOffset = 0;
                        if (currentStyle.superscript) {
                            superSubOffset = line.height / 2 - textblock.height;
                        }
                        else if (currentStyle.subscript) {
                            superSubOffset = line.height / 2;
                        }
                        else {
                            superSubOffset = line.height - textblock.height;
                        }
                        if (currentStyle.linkData && currentStyle.font.escapement === 0) {
                            var rect = new Rectangle(curX, y, curX + textblock.width, y + textblock.height);
                            rect.offsetRect(screenX, screenY + ~~superSubOffset);
                            if (!currentLink || !_$1.isEqual(currentLink.eventData, currentStyle.linkData)) {
                                currentLink = new RichTextLink(currentStyle.linkData);
                                ctx.layer.addRichTextLink(currentLink);
                            }
                            currentLink.textBlocks.push({ text: textblock.text, font: currentStyle.font, rect: rect });
                        }
                        else {
                            ctx.fillText(textblock.text, curX, y + ~~superSubOffset + currentStyle.font.getBaselineOffset());
                        }
                        if (currentStyle.font.underline) {
                            renderTextUnderline(ctx, curX, y, textblock.width, line.height, currentStyle);
                        }
                        curX += textblock.width;
                    }
                }
                y += line.height;
            }
            ctx.restore();
        }
        RichTextRenderer.writeRichText = writeRichText;
    })(RichTextRenderer || (RichTextRenderer = {}));
    
    /**
     * Class responsible for drawing an annotation textboxs and series labels
     */
    var FDSInfoBox = /** @class */ (function () {
        function FDSInfoBox(ctx) {
            this.FGPen = new FDSPen();
            this.BGBrush = new FDSBrush();
            this.BGBrush.style = 0 /* SOLID */;
            this.font = new FDSFont();
            this.arrowFGPen = new FDSPen();
            this.arrowLinePen = new FDSPen();
            this.arrowBGBrush = new FDSBrush();
            this.arrowBGBrush.style = 0 /* SOLID */;
            this.setStyle(0 /* DEFAULT */, ctx);
            this.text = RichTextString.Empty;
            this.visible = false;
            this.width = this.height = 0;
            this.sizeMode = 0 /* DEFAULT */;
            this.autoPositionMethod = 0 /* NONE */;
            // keep shadows very vaguely fuzzy
            this.shadow = false;
            this.shadowBlur = 2;
            this.shadowColor = 0 /* BLACK */;
            this.shadowX = 3;
            this.shadowY = -3;
            this.borderRadius = 0;
            this.shape = 0 /* RECT */;
            this.showText = true;
        }
        /**
         * The padding around the sides of the textbox
         */
        FDSInfoBox.prototype.getPadding = function () {
            return this._padding;
        };
        FDSInfoBox.prototype.left = function () {
            return this.x;
        };
        FDSInfoBox.prototype.right = function () {
            return this.x + this.width;
        };
        FDSInfoBox.prototype.top = function () {
            return this.y;
        };
        FDSInfoBox.prototype.bottom = function () {
            return this.y + this.height;
        };
        /**
         * Sets a variety of options on the infobox.
         * TODO: refactor this to better type-check the code
         *
         * @param options - a map of options to set
         * @param ctx - the ChartRenderingContext for the canvas where the annotation will be removed
         * @param requireRemove - remove the old box from the canvas before updating
         */
        FDSInfoBox.prototype.update = function (options, ctx, requireRemove) {
            if (requireRemove === void 0) { requireRemove = true; }
            var sizeChanged = false;
            // delete the old box if it's visible, since we're about to change it
            if (this.visible && requireRemove) {
                this.remove(ctx);
            }
            // deal with some special cases:
            // things that need to be floored
            var floored = ['x', 'y', 'widthHint', 'heightHint'];
            // things that change the box size
            var changed = ['widthHint', 'heightHint', 'sizeMode', 'text', 'font', 'shadowX', 'shadowY', 'shadow'];
            // things that should be bound to between 0 and 1
            for (var key in options) {
                var value = options[key];
                if ((floored.indexOf(key)) >= 0) {
                    value = ~~value;
                }
                if ((changed.indexOf(key)) >= 0) {
                    sizeChanged = true;
                }
                if (key === 'borderRadius') {
                    // border radius limited to half the box because otherwise curved corners would overlap
                    value = clamp(value, 0, 0.5);
                }
                if (key === 'annotArrowFrac') {
                    // limit arrow width to no wider than the side it's on
                    value = clamp(value, 0, 1);
                }
                // special case for text - it's gotta be an array to work with richtext
                if (key === 'text') {
                    if (!(value instanceof RichTextString)) {
                        value = new RichTextString(value);
                    }
                }
                this[key] = value;
            }
            // if the size has been affected, update the width/height
            if (sizeChanged) {
                this.computeWidthAndHeight(ctx);
            }
            // the box has changed, so redraw it if it's visible
            if (this.visible) {
                this.draw(ctx);
            }
        };
        // fns for the most common updates
        /**
         * Moves the annotation to new coordinates
         *
         * @param x - the x position
         * @param y - the y position
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.updatePosition = function (x, y, ctx) {
            this.update({
                x: x,
                y: y
            }, ctx);
        };
        /**
         * Moves the arrow to point to the specified coordinates
         *
         * @param x - the target x position
         * @param y - the target y position
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.updateArrow = function (x, y, ctx) {
            this.update({
                arrowX: x,
                arrowY: y
            }, ctx);
        };
        /**
         * Update only the x location of the annotation
         *
         * @param  x - the new x position
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.updateX = function (x, ctx) {
            this.update({ x: x }, ctx);
        };
        /**
         * Update only the y location of the annotation
         *
         * @param  y - the new y position
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.updateY = function (y, ctx) {
            this.update({ y: y }, ctx);
        };
        /**
         * Sets the visibile to true and redraws
         *
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.show = function (ctx) {
            this.update({ visible: true }, ctx);
        };
        /**
         * Sets the visibile to false and redraws
         *
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.hide = function (ctx) {
            this.update({ visible: false }, ctx);
        };
        /**
         * Clears the portion of the canvas where the annotation is/was
         *
         * @param ctx - the ChartRenderingContext that needs to be cleared
         */
        FDSInfoBox.prototype.remove = function (ctx) {
            // for now just clear the bounding box. this won't work if the box overlaps other stuff on the canvas though
            var _a = this._getBoundingBox(true), x = _a[0], y = _a[1], x2 = _a[2], y2 = _a[3];
            ctx.clearRect(x, y, (x2 - x), (y2 - y));
        };
        /**
         * Returns whether or not the annotation is shown.
         */
        FDSInfoBox.prototype.isVisible = function () {
            return this.visible;
        };
        /**
         * Draws the annotation onto the provided canvas
         *
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.draw = function (ctx) {
            if (!this.visible) {
                return;
            }
            var _a = this._computeDrawRect(), x = _a[0], y = _a[1], x2 = _a[2], y2 = _a[3];
            var rect = new Rectangle(x, y, x2, y2);
            this._drawShape(ctx, rect);
            this._drawTail(ctx, rect);
            if (this.showText) {
                this._drawText(x, y, x2, y2, ctx);
            }
        };
        /**
         * function to draw the actual shape of the box (which could be a circle, a rectangle, etc)
         *
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         * @param rect - the annotations coordinates
         */
        FDSInfoBox.prototype._drawShape = function (ctx, rect) {
            var x1 = rect.x1, y1 = rect.y1, x2 = rect.x2, y2 = rect.y2;
            var width = x2 - x1;
            var height = y2 - y1;
            if (this.shape === 0 /* RECT */ && this.borderRadius === 0) {
                // do this with rects instead of using _drawPath cause it's faster
                // Also, uses polyline
                // fill in background
                ctx.save(); // do this so the shadow doesn't persist
                this.BGBrush.setOnCanvas(ctx, rect);
                this._setShadow(ctx);
                ctx.fillRect(x1, y1, width, height);
                ctx.restore();
                // draw outline
                this.FGPen.setOnCanvas(ctx);
                ctx.beginPath();
                this.FGPen.drawPolyline(ctx, { x: x1, y: y1 }, { x: x2, y: y1 }); // top line
                this.FGPen.drawPolyline(ctx, { x: x2, y: y1 }, { x: x2, y: y2 }); // right line
                this.FGPen.drawPolyline(ctx, { x: x2, y: y2 }, { x: x1, y: y2 }); // bottom line
                this.FGPen.drawPolyline(ctx, { x: x1, y: y2 }, { x: x1, y: y1 }); // left line
                this.FGPen.closePolyline();
                ctx.stroke();
            }
            else {
                this._drawPath(x1, y1, x2, y2, ctx);
                ctx.save(); // do this so the shadow doesn't persist
                this.BGBrush.setOnCanvas(ctx, rect);
                this._setShadow(ctx);
                ctx.fill();
                ctx.restore();
                if (this.shape === 7 /* CALLOUT */) {
                    // close the path and outline the whole thing in BG color,
                    // then redraw the path so it can be stroked in FG color
                    ctx.save();
                    ctx.closePath();
                    ctx.setPen(this.FGPen.with({ color: this.BGBrush.color }));
                    ctx.stroke();
                    this._drawPath(x1, y1, x2, y2, ctx);
                    ctx.restore();
                }
                this.FGPen.setOnCanvas(ctx);
                ctx.stroke();
            }
        };
        /**
         * helper function to set up the context with a shadow
         *
         * @param ctx - the chart rendering context
         */
        FDSInfoBox.prototype._setShadow = function (ctx) {
            if (!this.shadow) {
                return;
            }
            var canvasCtx = ctx.getCanvasCtx();
            if (canvasCtx) {
                canvasCtx.shadowColor = COLORREFtoHex(this.shadowColor);
                canvasCtx.shadowOffsetX = this.shadowX;
                canvasCtx.shadowOffsetY = this.shadowY;
                canvasCtx.shadowBlur = this.shadowBlur;
            }
        };
        /**
         * function to draw the actual path for the shape.
         * The path is used to actually draw most shapes, and also for clipping
         *
         * @param x - the left bounding coordinate
         * @param y - the top bounding coordinate
         * @param x2 - the right bounding coordinate
         * @param y2 - the bottom bounding coordinate
         * @param ctx - the chart rendering context
         */
        FDSInfoBox.prototype._drawPath = function (x, y, x2, y2, ctx) {
            var width = x2 - x;
            var height = y2 - y;
            switch (this.shape) {
                case 1 /* CIRCLE */:
                    var radius = Math.max(width, height) / 2;
                    x = x + (width / 2);
                    y = y + (height / 2);
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    break;
                case 2 /* ELLIPSE */:
                    x = x + (width / 2);
                    y = y + (height / 2);
                    ctx.beginPath();
                    ctx.ellipse(x, y, width, height);
                    break;
                case 3 /* MARKER */:
                case 5 /* RECT_TRIGHT */:
                case 4 /* RECT_TLEFT */:
                case 6 /* RECT_TAG */:
                    // Marker is a tag which faces the direction of the data point, a la on-axis crosshair label boxes
                    // The rects are specified to always point left or right
                    var direction = this._getTagDirection();
                    this._getMarkerPath(x, y, x2, y2, direction, ctx);
                    break;
                case 7 /* CALLOUT */:
                    this._getCalloutPath(x, y, x2, y2, ctx);
                    break;
                default:// FCAnnotationStyle.RECT
                    radius = this.borderRadius * Math.min(width, height);
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x2 - radius, y);
                    if (radius !== 0) {
                        ctx.arc(x2 - radius, y + radius, radius, Math.PI * 1.5, 0, false);
                    }
                    // for some bizarro reason, one corner pixel is missing in 1px-wide boxes. This takes care of it
                    if (radius === 0 && this.FGPen.width === 1) {
                        ctx.lineTo(x2, y - 1);
                    }
                    ctx.lineTo(x2, y2 - radius);
                    if (radius !== 0) {
                        ctx.arc(x2 - radius, y2 - radius, radius, 0, Math.PI * 0.5, false);
                    }
                    ctx.lineTo(x + radius, y2);
                    if (radius !== 0) {
                        ctx.arc(x + radius, y2 - radius, radius, Math.PI * 0.5, Math.PI, false);
                    }
                    ctx.lineTo(x, y + radius);
                    if (radius !== 0) {
                        ctx.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 1.5, false);
                    }
                    break;
            }
        };
        /**
         * helper function that returns a marker path (since it's done in two places)
         *
         * @param x - the left bounding coordinate
         * @param y - the top bounding coordinate
         * @param x2 - the right bounding coordinate
         * @param y2 - the bottom bounding coordinate
         * @param direction - the direction the arrow points
         * @param ctx - the chart rendering context
         */
        FDSInfoBox.prototype._getMarkerPath = function (x, y, x2, y2, direction, ctx) {
            var _this = this;
            var width = x2 - x;
            var height = y2 - y;
            ctx.beginPath();
            var getArrowSize = function (scaleBase) {
                if (_$1.isNumber(_this.tagWidth)) {
                    return _this.tagWidth;
                }
                else {
                    return scaleBase * _this.annotArrowFrac;
                }
            };
            var frac;
            switch (direction) {
                case 0 /* UP */:
                    frac = getArrowSize(width);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + (width / 2), y - frac);
                    ctx.lineTo(x2, y);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x, y2);
                    break;
                case 1 /* DOWN */:
                    frac = getArrowSize(width);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x2, y);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x + (width / 2), y2 + frac);
                    ctx.lineTo(x, y2);
                    break;
                case 2 /* LEFT */:
                    frac = getArrowSize(height);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x2, y);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x, y2);
                    ctx.lineTo(x - frac, y + (height / 2));
                    break;
                default:// default to RIGHT arbitrarily
                    frac = getArrowSize(height);
                    ctx.moveTo(x, y);
                    ctx.lineTo(x2, y);
                    ctx.lineTo(x2 + frac, y + (height / 2));
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x, y2);
            }
            ctx.closePath();
        };
        /**
         * helper function to return the direction a tag is pointing based on the shape
         * and the location of the point
         * @returns the marker arrow direction
         */
        FDSInfoBox.prototype._getTagDirection = function () {
            switch (this.shape) {
                case 3 /* MARKER */:
                    // arbitrarily decided that the arrows go up and down unless the data pt is between y and y2
                    if (this.arrowY < this.y) {
                        return 0 /* UP */;
                    }
                    else if (this.arrowY > this.y + this.height) {
                        return 1 /* DOWN */;
                    }
                    else {
                        if (this.arrowX < this.x) {
                            return 2 /* LEFT */;
                        }
                        else if (this.arrowX > this.x + this.width) {
                            return 3 /* RIGHT */;
                        }
                        else {
                            // the data point is behind the rectangle
                            return -1 /* NONE */;
                        }
                    }
                case 5 /* RECT_TRIGHT */:
                    // specifically a right-pointing marker
                    return 3 /* RIGHT */;
                case 4 /* RECT_TLEFT */:
                    // specifically a left-pointing marker
                    return 2 /* LEFT */;
                case 6 /* RECT_TAG */:
                    if (this.arrowX < this.x) {
                        return 2 /* LEFT */;
                    }
                    else {
                        return 3 /* RIGHT */;
                    }
            }
            return -1 /* NONE */;
        };
        /**
         * Draws the text portion of the annotation / infobox
         *
         * @param x - the left bounding coordinate
         * @param y - the top bounding coordinate
         * @param x2 - the right bounding coordinate
         * @param y2 - the bottom bounding coordinate
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype._drawText = function (x, y, x2, y2, ctx) {
            var width = x2 - x;
            var height = y2 - y;
            // set up clipping path if necessary
            if (this.clipped) {
                ctx.save();
                this._drawPath(x, y, x2, y2, ctx);
                ctx.clip();
            }
            // set up font stuff and draw text
            this.font.setOnCanvas(ctx);
            var _a = this._computeTextWidthAndHeight(ctx), textWidth = _a[0], textHeight = _a[1], padding = _a[2];
            if (this.font.alignment === 0 /* LEFT */) {
                x = x;
            }
            else if (this.font.alignment === 1 /* RIGHT */) {
                x = x2 - textWidth;
            }
            else {
                x = x + (width / 2) - (textWidth / 2);
            }
            y = y + (height / 2) - (textHeight / 2);
            RichTextRenderer.writeRichText(ctx, this.text, x + padding, y + padding, this.font, this.font.alignment, this._preparedText);
            if (this.clipped) {
                ctx.restore();
            }
        };
        /**
         * If arrows are enabled, draws an arrow pointing from the box to [arrowX, arrowY]
         *
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         */
        FDSInfoBox.prototype.drawArrow = function (ctx) {
            if (!this.arrow) {
                return;
            }
            var x = this.arrowX;
            var y = this.arrowY;
            var _a = this._getShortestPathTo(x, y), boxX = _a[0], boxY = _a[1];
            this._drawArrowLine(ctx, boxX, boxY, x, y);
            var end = (this.arrowPosition === 1 /* TO */) || (this.arrowPosition === 3 /* BOTH */);
            var start = (this.arrowPosition === 2 /* FROM */) || (this.arrowPosition === 3 /* BOTH */);
            if (start) {
                this._drawArrowHead(ctx, x, y, boxX, boxY);
            }
            if (end) {
                this._drawArrowHead(ctx, boxX, boxY, x, y);
            }
        };
        /**
         * Draws the tail for callout annotations
         *
         * @param ctx - the ChartRenderingContext that the annotation will be drawn onto
         * @param rect - the annotations rectangle, will be passed along to the brush for gradients
         */
        FDSInfoBox.prototype._drawTail = function (ctx, rect) {
            if (this.shape !== 7 /* CALLOUT */) {
                return;
            }
            if (!this._tailPoint1 || !this._tailPoint2) {
                return;
            }
            ctx.beginPath();
            ctx.moveTo(this._tailPoint1.x, this._tailPoint1.y);
            ctx.lineTo(this.arrowX, this.arrowY);
            ctx.lineTo(this._tailPoint2.x, this._tailPoint2.y);
            this.BGBrush.setOnCanvas(ctx, rect);
            ctx.fill();
            this.FGPen.setOnCanvas(ctx);
            ctx.stroke();
            // draw a bg-colored line along the bubble-tail border so there is no gap
            ctx.save();
            ctx.beginPath();
            ctx.setPen(this.FGPen.with({ color: this.BGBrush.color }));
            var offset = this.FGPen.getAliasOffset();
            this._tailPoint1.y += offset;
            this._tailPoint2.y += offset;
            ctx.moveTo(this._tailPoint1.x, this._tailPoint1.y);
            ctx.lineTo(this._tailPoint2.x, this._tailPoint2.y);
            ctx.restore();
        };
        /**
         * Draws a line using the arrowLinePen
         *
         * @param ctx - the chart rendering context
         * @param x1 - start point x-coordinate
         * @param y1 - start point y-coordinate
         * @param x2 - end point x-coordinate
         * @param y2 - end point y-coordinate
         */
        FDSInfoBox.prototype._drawArrowLine = function (ctx, x1, y1, x2, y2) {
            if (this.arrowLinePen.style === 5 /* NULL */) {
                return;
            }
            this.arrowLinePen.setOnCanvas(ctx);
            ctx.beginPath();
            this.arrowLinePen.drawPolyline(ctx, { x: x1, y: y1 }, { x: x2, y: y2 });
            this.arrowLinePen.closePolyline();
            ctx.stroke();
        };
        //
        /**
         * Helper function to draw an arrowhead.
         *
         * @param ctx - the chart rendering context
         * @param x1 - start point x-coordinate
         * @param y1 - start point y-coordinate
         * @param x2 - end point x-coordinate
         * @param y2 - end point y-coordinate
         */
        FDSInfoBox.prototype._drawArrowHead = function (ctx, x1, y1, x2, y2) {
            if (this.arrowStyle !== 0 /* OPEN */ && this.arrowStyle !== 1 /* CLOSED */) {
                return;
            }
            var w = this.arrowSize * this.arrowRatio * 2; // magic number - 2 makes it look correctly proportioned
            var h = this.arrowSize;
            ctx.save();
            ctx.translate(x2, y2);
            var rotAmt = Math.atan2(y2 - y1, x1 - x2);
            ctx.rotate(-rotAmt);
            if (this.arrowStyle !== 0 /* OPEN */) {
                // fill
                this.arrowBGBrush.setOnCanvas(ctx);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(h, -w / 2);
                ctx.lineTo(h, w / 2);
                ctx.closePath();
                ctx.fill();
            }
            // stroke
            this.arrowFGPen.setOnCanvas(ctx);
            ctx.beginPath();
            this.arrowFGPen.drawPolyline(ctx, { x: h, y: w / 2 }, { x: 0, y: 0 });
            this.arrowFGPen.drawPolyline(ctx, { x: 0, y: 0 }, { x: h, y: -w / 2 });
            if (this.arrowStyle !== 0 /* OPEN */) {
                this.arrowFGPen.drawPolyline(ctx, { x: h, y: -w / 2 }, { x: h, y: w / 2 });
            }
            this.arrowFGPen.closePolyline();
            ctx.stroke();
            // undo rotation/translation
            ctx.restore();
        };
        /**
         * helper fn to return the boundaries of the box and its arrow
         *
         * @param padded - whether or not to pad the box with extra pixels (eg, for deleting)
         * @returns [x, y, x2, y2] corner coordinates of the box
         */
        FDSInfoBox.prototype._getBoundingBox = function (padded) {
            if (padded === void 0) { padded = false; }
            var _a = this._computeDrawRect(), x = _a[0], y = _a[1], x2 = _a[2], y2 = _a[3];
            // take thickness of borders into account
            var width = x2 - x;
            var height = y2 - y;
            var w = this.FGPen.width / 2;
            x -= w;
            x2 += w;
            y -= w;
            y2 += w;
            if (this.arrow || this.shape === 7 /* CALLOUT */) {
                if (this.arrowX < x) {
                    x = this.arrowX;
                }
                else if (this.arrowX > x2) {
                    x2 = this.arrowX;
                }
                if (this.arrowY < y) {
                    y = this.arrowY;
                }
                else if (this.arrowY > y2) {
                    y2 = this.arrowY;
                }
            }
            // include the tag
            if (this.shape === 3 /* MARKER */ || this.shape === 5 /* RECT_TRIGHT */ ||
                this.shape === 4 /* RECT_TLEFT */ || this.shape === 6 /* RECT_TAG */) {
                var direction = this._getTagDirection();
                switch (direction) {
                    case 0 /* UP */:
                        var frac = this.annotArrowFrac * width;
                        y -= frac;
                        break;
                    case 1 /* DOWN */:
                        frac = this.annotArrowFrac * width;
                        y2 += frac;
                        break;
                    case 3 /* RIGHT */:
                        frac = this.annotArrowFrac * height;
                        x2 += frac;
                        break;
                    case 2 /* LEFT */:
                        frac = this.annotArrowFrac * height;
                        x -= frac;
                        break;
                }
            }
            // include the shadow
            if (this.shadow) {
                if (this.shadowX > 0) {
                    x2 = x2 + this.shadowBlur + this.shadowX;
                }
                else {
                    x = x - this.shadowBlur + this.shadowX;
                }
                if (this.shadowY > 0) {
                    y2 = y2 + this.shadowBlur + this.shadowY;
                }
                else {
                    y = y - this.shadowBlur + this.shadowY;
                }
            }
            // if padded, add an extra pixel of padding on the edges just to be safe
            x = x - 1;
            y = y - 1;
            x2 = x2 + 1;
            y2 = y2 + 1;
            return [x, y, x2, y2];
        };
        /**
         * Helper fn to return the corner pts of the actual box that is drawn
         *
         * @returns [x, y, x2, y2] corner coordinates of the box
         */
        FDSInfoBox.prototype._computeDrawRect = function () {
            var aliasOffset = this.FGPen.getAliasOffset();
            var x = (~~this.x) + aliasOffset;
            var y = (~~this.y) + aliasOffset;
            var x2 = x + (~~this.width);
            var y2 = y + (~~this.height);
            return [x, y, x2, y2];
        };
        /**
         * computes the width and height of the text along with some additional padding
         *
         * @param ctx - the ChartRenderingContext that will be drawing the text
         * @returns [width, height, padding]
         */
        FDSInfoBox.prototype._computeTextWidthAndHeight = function (ctx) {
            ctx.save();
            this.font.setOnCanvas(ctx);
            var padding = ctx.measureTextWidth('i'); // use the width of a skinny letter for padding
            ctx.restore();
            var h;
            var w;
            if (!this.text) {
                w = h = 0;
            }
            else {
                var _a = RichTextRenderer.measureRichText(ctx, this.text, this.font), dims = _a[0], richtext = _a[1];
                this._preparedText = richtext;
                w = dims.width;
                h = dims.height;
            }
            return [w + 2 * padding, h + 2 * padding, padding];
        };
        // calculate and return the box (not text) width and height
        // padded=true will return the width and height of the space around the entire box (and arrow)
        /**
         * Computes the width and height of the annotation textbox
         *
         * @param ctx - the ChartRenderingContext that will draw the annotation
         * @param includeTail - if true, the dimensions of the annotation + tail will be returned instead of just the
         *   textbox dimensions
         * @returns [width, height]
         */
        FDSInfoBox.prototype.computeWidthAndHeight = function (ctx, includeTail) {
            if (includeTail === void 0) { includeTail = false; }
            // if padded, call to get bounding box (which eventually calls back here unpadded)
            if (includeTail) {
                var _a = this._getBoundingBox(), x = _a[0], y = _a[1], x2 = _a[2], y2 = _a[3];
                return [x2 - x, y2 - y];
            }
            var _b = this._computeTextWidthAndHeight(ctx), textWidth = _b[0], textHeight = _b[1], padding = _b[2];
            // default values
            this.width = textWidth;
            this.height = textHeight;
            this._padding = padding;
            // when mode is force, the box gets set to the hint sizes no matter what
            // when mode is hint, the box gets set to hint size but no smaller than text size
            // either way, hints of -1 are ignored and default is left
            switch (this.sizeMode) {
                case 1 /* CUSTOM_HINT */:
                    if (this.widthHint >= 0) {
                        this.width = Math.max(textWidth, this.widthHint);
                    }
                    if (this.heightHint >= 0) {
                        this.height = Math.max(textHeight, this.heightHint);
                    }
                    break;
                case 2 /* CUSTOM_FORCE */:
                    if (this.widthHint >= 0) {
                        this.width = this.widthHint;
                    }
                    if (this.heightHint >= 0) {
                        this.height = this.heightHint;
                    }
                    break;
            }
            // otherwise (FCSizingMode.DEFAULT) leave them at defaults
            return [this.width, this.height];
        };
        /**
         * Applies different preset styles
         * note: styles overwrite existant features so they only contain features that aren't default
         *
         * @param style - which style to apply
         * @param ctx - the ChartRenderingContext that will draw the annotation
         */
        FDSInfoBox.prototype.setStyle = function (style, ctx) {
            var opts;
            var font;
            var brush;
            var pen;
            switch (style) {
                case 1 /* IPAD */:
                    font = new FDSFont({ color: 16777215 /* WHITE */, height: 10 });
                    brush = new FDSBrush();
                    brush.color = 0 /* BLACK */;
                    brush.alpha = 127.5;
                    brush.style = 0 /* SOLID */;
                    pen = new FDSPen({ color: 16777215 /* WHITE */ });
                    opts = {
                        font: font,
                        BGBrush: brush,
                        FGPen: pen,
                        borderRadius: 0.2
                    };
                    break;
                case 2 /* CG_CALLOUT */:
                    pen = new FDSPen({ color: 8947848 /* CG_CALLOUT_GREY */ });
                    brush = new FDSBrush();
                    brush.color = 16777215 /* WHITE */;
                    brush.style = 0 /* SOLID */;
                    font = new FDSFont({ family: 'sans-serif' });
                    opts = {
                        FGPen: pen,
                        shadow: true,
                        shadowColor: 13487565 /* SHADOW_GREY */,
                        shadowX: 1,
                        shadowY: 1,
                        font: font,
                        shape: 7 /* CALLOUT */
                    };
                    break;
                case 3 /* BASIC_CALLOUT */:
                    opts = {
                        shape: 7 /* CALLOUT */
                    };
                    break;
                default:// InfoBoxStyle.DEFAULT
                    // set ALL the values to defaults
                    pen = new FDSPen({ lineCap: 'square' });
                    brush = new FDSBrush();
                    brush.style = 0 /* SOLID */;
                    brush.color = 16777215 /* WHITE */;
                    brush.alpha = 255;
                    font = new FDSFont({ family: 'Arial', height: 8, alignment: 2 /* CENTER */ });
                    var arrowPen = new FDSPen();
                    var arrowLinePen = new FDSPen();
                    var arrowBrush = new FDSBrush();
                    arrowBrush.color = 0 /* BLACK */;
                    arrowBrush.style = 0 /* SOLID */;
                    opts = {
                        x: 0,
                        y: 0,
                        widthHint: -1,
                        heightHint: -1,
                        sizeMode: 0 /* DEFAULT */,
                        clipped: false,
                        arrow: false,
                        arrowX: 0,
                        arrowY: 0,
                        arrowSize: 8,
                        arrowRatio: .4,
                        arrowStyle: 1 /* CLOSED */,
                        arrowPosition: 1 /* TO */,
                        borderRadius: 0,
                        shape: 0 /* RECT */,
                        annotArrowFrac: 0.05,
                        FGPen: pen,
                        BGBrush: brush,
                        font: font,
                        arrowLinePen: arrowLinePen,
                        arrowFGPen: arrowPen,
                        arrowBGBrush: arrowBrush,
                        shadow: false,
                        shadowColor: 0 /* BLACK */,
                        shadowX: 3,
                        shadowY: 3,
                        showText: true
                    };
            }
            this.update(opts, ctx);
        };
        /**
         * checks if this box and another overlap
         *
         * @param otherbox - the other box
         * @returns true if they overlap
         */
        FDSInfoBox.prototype.overlaps = function (otherbox) {
            var _a = this._computeDrawRect(), ourX1 = _a[0], ourY1 = _a[1], ourX2 = _a[2], ourY2 = _a[3];
            var _b = otherbox._computeDrawRect(), theirX1 = _b[0], theirY1 = _b[1], theirX2 = _b[2], theirY2 = _b[3];
            return !(ourY1 >= theirY2 || ourY2 <= theirY1 || ourX1 >= theirX2 || ourX2 <= theirX1);
        };
        /**
         * get the area of a bounding box surrounding two boxes
         *
         * @param otherbox - the other box
         * @returns the area of the combined bounding box
         */
        FDSInfoBox.prototype.unionArea = function (otherbox) {
            var _a = this._computeDrawRect(), ourX1 = _a[0], ourY1 = _a[1], ourX2 = _a[2], ourY2 = _a[3];
            var _b = otherbox._computeDrawRect(), theirX1 = _b[0], theirY1 = _b[1], theirX2 = _b[2], theirY2 = _b[3];
            var bottom = Math.max(ourY2, theirY2);
            var top = Math.min(ourY1, theirY1);
            var left = Math.min(ourX1, theirX1);
            var right = Math.max(ourX2, theirX2);
            return (bottom - top) * (right - left);
        };
        /**
         * Arrows can attach to any of the 4 edges of the annotation box
         * Find the position which yields the shortest arrow.
         *
         * @param x - the arrowhead x-coordinate
         * @param y - the arrowhead x-coordinate
         * @returns the location of the edge that yields the shortest arrow
         */
        FDSInfoBox.prototype._getShortestPathTo = function (x, y) {
            // set up the four points - top, bottom, left and right centers
            var xPts = [this.x + this.width / 2, this.x + this.width / 2, this.x, this.x + this.width];
            var yPts = [this.y, this.y + this.height, this.y + this.height / 2, this.y + this.height / 2];
            var minX = 0;
            var minY = 0;
            var minPath = Number.POSITIVE_INFINITY;
            for (var i = 0; i < xPts.length; i++) {
                var xPt = xPts[i];
                var yPt = yPts[i];
                var xDist = xPt - x;
                var yDist = yPt - y;
                var path = Math.sqrt(xDist * xDist + yDist * yDist);
                if (path < minPath) {
                    minPath = path;
                    minX = xPt;
                    minY = yPt;
                }
            }
            return [minX, minY];
        };
        /**
         * This function is MASSIVE, my apologies.
         * This function strokes out the callout path, as well as saving the tail points
         *
         * @param x1 - the left coordinate
         * @param y1 - the top coordinate
         * @param x2 - the right coordinate
         * @param y2 - the bottom coordinate
         * @param ctx - the html canvas rendering context
         */
        FDSInfoBox.prototype._getCalloutPath = function (x1, y1, x2, y2, ctx) {
            var height = y2 - y1;
            var width = x2 - x1;
            ctx.beginPath();
            // limit arrow fraction to at most half the size of the box
            // (it was bound to 1 before)
            var frac = clamp(this.annotArrowFrac, 0, 0.25);
            var fracWidth = frac * width;
            var fracHeight = frac * height;
            var radius = Math.min(width, height) * this.borderRadius;
            var arrowPoint = new Point(this.arrowX, this.arrowY);
            var topLeftCenter = new Point(x1 + radius, y1 + radius);
            var topRightCenter = new Point(x2 - radius, y1 + radius);
            var bottomLeftCenter = new Point(x1 + radius, y2 - radius);
            var bottomRightCenter = new Point(x2 - radius, y2 - radius);
            // define some trig things - canvas is backwards, so these angles are backwards
            // these variables will act like normal angles that increase going counterclockwise
            var quarter = Math.PI * 1.5;
            var half = Math.PI;
            var threequarter = Math.PI * 0.5;
            var whole = Math.PI * 2;
            ctx.beginPath();
            var p1;
            var p2;
            var p3;
            var center;
            var startPoint;
            var endPoint;
            var angle;
            var startAngle;
            var endAngle;
            // BELOW THE BOX
            if (this.arrowY > y2 && this.arrowX > (x1 + fracWidth) && this.arrowX <= (x2 - fracWidth)) {
                this._tailPoint1 = p1 = new Point(this.arrowX - fracWidth, y2);
                p2 = arrowPoint;
                this._tailPoint2 = p3 = new Point(this.arrowX + fracWidth, y2);
                if (this.arrowX - fracWidth < x1 + radius) {
                    // Left side of bottom
                    center = bottomLeftCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 3 /* LOWER_LEFT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent
                        startPoint = this._lineTangent(p2, p1, center, radius, false);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((startPoint.y - center.y) / radius));
                    startAngle = threequarter + angle; // add because angles are backwards on canvas
                    // draw the starting arc
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, half, false);
                }
                else if (this.arrowX - fracWidth > x2 - radius) {
                    // right side of bottom
                    center = bottomRightCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 4 /* LOWER_RIGHT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent line
                        startPoint = this._lineTangent(p2, p1, center, radius, false);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((startPoint.y - center.y) / radius));
                    startAngle = threequarter - angle; // subtract because angles are backwards on canvas
                    // draw the starting arcs and lines
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, threequarter, false);
                    ctx.lineTo(x1 + radius, y2);
                    ctx.arc(bottomLeftCenter.x, bottomLeftCenter.y, radius, threequarter, half, false);
                }
                else {
                    // starts somewhere in the middle. draw the starting line and arc
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(x1 + radius, y2);
                    ctx.arc(x1 + radius, y2 - radius, radius, threequarter, half, false);
                }
                // draw the top part of the box
                this._drawCalloutTop(x1, y1, x2, y2, radius, ctx);
                if (this.arrowX + fracWidth > x2 - radius) {
                    // right side of bottom
                    center = bottomRightCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 4 /* LOWER_RIGHT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, false);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((endPoint.y - center.y) / radius));
                    endAngle = threequarter - angle; // subtract because angles are backwards on canvas
                    // draw the final arc
                    ctx.arc(center.x, center.y, radius, 0, endAngle, false);
                }
                else if (this.arrowX + fracWidth < x1 + radius) {
                    // left side of bottom
                    center = bottomLeftCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 3 /* LOWER_LEFT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, false);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((endPoint.y - center.y) / radius));
                    endAngle = threequarter + angle; // add because angles are backwards on canvas
                    // draw the final arcs and lines
                    ctx.arc(x2 - radius, y2 - radius, radius, 0, threequarter, false);
                    ctx.lineTo(x1 + radius, y2);
                    ctx.arc(center.x, center.y, radius, threequarter, endAngle, false);
                }
                else {
                    // ends inside the rect line somewhere
                    ctx.arc(x2 - radius, y2 - radius, radius, 0, threequarter, false);
                    ctx.lineTo(p3.x, p3.y);
                }
                // ABOVE THE BOX
            }
            else if (this.arrowX > (x1 + fracWidth) && this.arrowX <= (x2 - fracWidth) && this.arrowY < y1) {
                this._tailPoint1 = p1 = new Point(this.arrowX + fracWidth, y1);
                p2 = arrowPoint;
                this._tailPoint2 = p3 = new Point(this.arrowX - fracWidth, y1);
                if (this.arrowX + fracWidth > x2 - radius) {
                    // Right side of top
                    center = topRightCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 1 /* UPPER_RIGHT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent
                        startPoint = this._lineTangent(p2, p1, center, radius, true);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((center.y - startPoint.y) / radius));
                    startAngle = quarter + angle; // add because angles are backwards on canvas
                    // draw the starting arc
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, 0, false);
                }
                else if (this.arrowX + fracWidth < x1 + radius) {
                    // Left side of top
                    center = topLeftCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 2 /* UPPER_LEFT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent line
                        startPoint = this._lineTangent(p2, p1, center, radius, true);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((center.y - startPoint.y) / radius));
                    startAngle = quarter - angle; // subtract because angles are backwards on canvas
                    // draw the starting arcs and lines
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, quarter, false);
                    ctx.lineTo(x2 - radius, y1);
                    ctx.arc(x2 - radius, y1 + radius, radius, quarter, 0, false);
                }
                else {
                    // starts somewhere in the middle. draw the starting line and arc
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(x2 - radius, y1);
                    ctx.arc(x2 - radius, y1 + radius, radius, quarter, 0, false);
                }
                // draw the bottom part of the box
                this._drawCalloutBottom(x1, y1, x2, y2, radius, ctx);
                // deal with the left side of the tail now
                if (this.arrowX - fracWidth < x1 + radius) {
                    // Left side of top
                    center = topLeftCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 2 /* UPPER_LEFT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, true);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((center.y - endPoint.y) / radius));
                    endAngle = quarter - angle; // subtract because angles are backwards on canvas
                    // draw the final arc
                    ctx.arc(center.x, center.y, radius, half, endAngle, false);
                }
                else if (this.arrowX - fracWidth > x2 - radius) {
                    // Right side of top
                    center = topRightCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 1 /* UPPER_RIGHT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, true);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((center.y - endPoint.y) / radius));
                    endAngle = quarter + angle; // add because angles are backwards on canvas
                    // draw the final arcs and lines
                    ctx.arc(x1 + radius, y1 + radius, radius, half, quarter, false);
                    ctx.lineTo(x2 - radius, y1);
                    ctx.arc(center.x, center.y, radius, quarter, endAngle, false);
                }
                else {
                    // ends inside the rect line somewhere
                    ctx.arc(x1 + radius, y1 + radius, radius, half, quarter, false);
                    ctx.lineTo(p3.x, p3.y);
                }
                // LEFT OF BOX
            }
            else if (this.arrowY > (y1 + fracHeight) && this.arrowY <= (y2 - fracHeight) && this.arrowX < x1) {
                this._tailPoint1 = p1 = new Point(x1, this.arrowY - fracHeight);
                p2 = arrowPoint;
                this._tailPoint2 = p3 = new Point(x1, this.arrowY + fracHeight);
                if (this.arrowY - fracHeight < y1 + radius) {
                    // Top of left side
                    center = topLeftCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 2 /* UPPER_LEFT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent
                        startPoint = this._lineTangent(p2, p1, center, radius, true);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((center.x - startPoint.x) / radius));
                    startAngle = half + angle; // add because angles are backwards on canvas
                    // draw the starting arc
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, quarter, false);
                }
                else if (this.arrowY - fracHeight > y2 - radius) {
                    // Bottom of left side
                    center = bottomLeftCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 3 /* LOWER_LEFT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent line
                        startPoint = this._lineTangent(p2, p1, center, radius);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((startPoint.y - center.y) / radius));
                    startAngle = threequarter + angle; // add because angles are backwards on canvas
                    // draw the starting arcs and lines
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, half, false);
                    ctx.lineTo(x1, y1 + radius);
                    ctx.arc(x1 + radius, y1 + radius, radius, half, quarter, false);
                }
                else {
                    // starts somewhere in the middle. draw the starting line and arc
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(x1, y1 + radius);
                    ctx.arc(x1 + radius, y1 + radius, radius, half, quarter, false);
                }
                // draw the right part of the box
                this._drawCalloutRight(x1, y1, x2, y2, radius, ctx);
                // deal with the bottom side of the tail now
                if (this.arrowY + fracHeight > y2 - radius) {
                    // Bottom of left side
                    center = bottomLeftCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 3 /* LOWER_LEFT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((endPoint.y - center.y) / radius));
                    endAngle = threequarter + angle; // add because angles are backwards on canvas
                    // draw the final arc
                    ctx.arc(center.x, center.y, radius, threequarter, endAngle, false);
                }
                else if (this.arrowY + fracHeight < y1 + radius) {
                    // Top of left side
                    center = topLeftCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 2 /* UPPER_LEFT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, true);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((center.x - endPoint.x) / radius));
                    endAngle = half + angle; // add because angles are backwards on canvas
                    // draw the final arcs and lines
                    ctx.arc(x1 + radius, y2 - radius, radius, threequarter, half, false);
                    ctx.lineTo(x1, y1 + radius);
                    ctx.arc(center.x, center.y, radius, half, endAngle, false);
                }
                else {
                    // ends inside the rect line somewhere
                    ctx.arc(x1 + radius, y2 - radius, radius, threequarter, half, false);
                    ctx.lineTo(p3.x, p3.y);
                }
                // RIGHT OF THE BOX
            }
            else if (this.arrowY > (y1 + fracHeight) && this.arrowY <= (y2 - fracHeight) && this.arrowX > x2) {
                this._tailPoint1 = p1 = new Point(x2, this.arrowY + fracHeight);
                p2 = arrowPoint;
                this._tailPoint2 = p3 = new Point(x2, this.arrowY - fracHeight);
                // dealing with bottom half of tail
                if (this.arrowY + fracHeight > y2 - radius) {
                    // Bottom of right side
                    center = bottomRightCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 4 /* LOWER_RIGHT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent
                        startPoint = this._lineTangent(p2, p1, center, radius, false);
                    }
                    this._tailPoint1 = startPoint;
                    startAngle = Math.acos(((startPoint.x - center.x) / radius));
                    // draw the starting arc
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, threequarter, false);
                }
                else if (this.arrowY + fracHeight < y1 + radius) {
                    // Top of right side
                    center = topRightCenter;
                    startPoint = this._lineArcIntersection(p2, p1, center, radius, 1 /* UPPER_RIGHT */);
                    if (!startPoint) {
                        // it misses the arc - get a tangent line
                        startPoint = this._lineTangent(p2, p1, center, radius, true);
                    }
                    this._tailPoint1 = startPoint;
                    angle = Math.acos(((center.y - startPoint.y) / radius)); // DOUBLE CHECK
                    startAngle = quarter + angle; // add because angles are backwards on canvas
                    // draw the starting arcs and lines
                    ctx.moveTo(startPoint.x, startPoint.y);
                    ctx.arc(center.x, center.y, radius, startAngle, 0, false);
                    ctx.lineTo(x2, y2 - radius);
                    ctx.arc(x2 - radius, y2 - radius, radius, 0, threequarter, false);
                }
                else {
                    // starts somewhere in the middle. draw the starting line and arc
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(x2, y2 - radius);
                    ctx.arc(x2 - radius, y2 - radius, radius, 0, threequarter, false);
                }
                // draw the left part of the box
                this._drawCalloutLeft(x1, y1, x2, y2, radius, ctx);
                // deal with the top side of the tail now
                if (this.arrowY - fracHeight < y1 + radius) {
                    // Top of right side
                    center = topRightCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 1 /* UPPER_RIGHT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, true);
                    }
                    this._tailPoint2 = endPoint;
                    angle = Math.acos(((center.y - endPoint.y) / radius));
                    endAngle = quarter + angle; // add because angles are backwards on canvas
                    // draw the final arc
                    ctx.arc(center.x, center.y, radius, quarter, endAngle, false);
                }
                else if (this.arrowY - fracHeight > y2 - radius) {
                    // Bottom of right side
                    center = bottomRightCenter;
                    endPoint = this._lineArcIntersection(p2, p3, center, radius, 4 /* LOWER_RIGHT */);
                    if (!endPoint) {
                        // it misses the arc - get a tangent
                        endPoint = this._lineTangent(p2, p3, center, radius, false);
                    }
                    this._tailPoint2 = endPoint;
                    endAngle = Math.acos(((endPoint.x - center.x) / radius));
                    // draw the final arcs and lines
                    ctx.arc(x2 - radius, y1 + radius, radius, quarter, 0, false);
                    ctx.lineTo(x2, y2 - radius);
                    ctx.arc(center.x, center.y, radius, 0, endAngle, false);
                }
                else {
                    // ends inside the rect line somewhere
                    ctx.arc(x2 - radius, y1 + radius, radius, quarter, 0, false);
                    ctx.lineTo(p3.x, p3.y);
                }
                // BOTTOM LEFT
            }
            else if (this.arrowX <= x1 + fracWidth && this.arrowY > y2 - fracHeight &&
                !(this._checkIfInCircle(arrowPoint, bottomLeftCenter, radius))) {
                // do some math so the tail doesn't jump around when we hit the corner
                var ylen = this.arrowY - Math.min(this.arrowY, y2); // distance arrowY is below the box
                var xlen = this.arrowX - Math.min(this.arrowX, x1 - ylen); // distance arrowX is to the left of the box,
                // taking ylen into account
                var xportion = clamp(xlen / fracWidth, 0, 1);
                xportion /= 2;
                var yportion = 1 - xportion;
                this._tailPoint1 = new Point(x1, y2 - yportion * fracHeight * 2);
                this._tailPoint2 = new Point(x1 + (0.5 + xportion) * fracWidth * 2, y2);
                ctx.moveTo(this._tailPoint1.x, this._tailPoint1.y);
                this._drawCalloutTop(x1, y1, x2, y2, radius, ctx);
                // finish the box
                ctx.arc(bottomRightCenter.x, bottomRightCenter.y, radius, 0, threequarter, false);
                ctx.lineTo(this._tailPoint2.x, this._tailPoint2.y);
                // BOTTOM RIGHT
            }
            else if (this.arrowX > x2 - fracWidth && this.arrowY > y2 - fracHeight &&
                !(this._checkIfInCircle(arrowPoint, bottomRightCenter, radius))) {
                // do some math so the tail doesn't jump around when we hit the corner
                var ylen = this.arrowY - Math.min(this.arrowY, y2);
                var xlen = Math.max(this.arrowX, x2 + ylen) - this.arrowX;
                var xportion = clamp(xlen / fracWidth, 0, 1);
                xportion /= 2;
                var yportion = 1 - xportion;
                this._tailPoint1 = new Point(x2 - (0.5 + xportion) * fracWidth * 2, y2);
                this._tailPoint2 = new Point(x2, y2 - yportion * fracHeight * 2);
                ctx.moveTo(this._tailPoint1.x, this._tailPoint1.y);
                this._drawCalloutLeft(x1, y1, x2, y2, radius, ctx);
                // finish the box
                ctx.arc(topRightCenter.x, topRightCenter.y, radius, quarter, 0, false);
                ctx.lineTo(this._tailPoint2.x, this._tailPoint2.y);
                // TOP LEFT
            }
            else if (this.arrowX <= x1 + fracWidth && this.arrowY < y1 + fracHeight &&
                !(this._checkIfInCircle(arrowPoint, topLeftCenter, radius))) {
                // do some math so the tail doesn't jump around when we hit the corner
                var ylen = Math.max(this.arrowY, y1) - this.arrowY;
                var xlen = this.arrowX - Math.min(this.arrowX, x1 - ylen);
                var xportion = clamp(xlen / fracWidth, 0, 1);
                xportion /= 2;
                var yportion = 1 - xportion;
                this._tailPoint1 = new Point(x1 + (0.5 + xportion) * fracWidth * 2, y1);
                this._tailPoint2 = new Point(x1, y1 + yportion * fracHeight * 2);
                ctx.moveTo(this._tailPoint1.x, this._tailPoint1.y);
                this._drawCalloutRight(x1, y1, x2, y2, radius, ctx);
                // finish the box
                ctx.arc(bottomLeftCenter.x, bottomRightCenter.y, radius, threequarter, half, false);
                ctx.lineTo(this._tailPoint2.x, this._tailPoint2.y);
                // TOP RIGHT
            }
            else if (this.arrowX > x2 - fracWidth && this.arrowY < y1 + fracHeight &&
                !(this._checkIfInCircle(arrowPoint, topRightCenter, radius))) {
                // do some math so the tail doesn't jump around when we hit the corner
                var ylen = Math.max(this.arrowY, y1) - this.arrowY;
                var xlen = Math.max(this.arrowX, x2 + ylen) - this.arrowX;
                var xportion = clamp(xlen / fracWidth, 0, 1);
                xportion /= 2;
                var yportion = 1 - xportion;
                this._tailPoint1 = new Point(x2, y1 + yportion * fracHeight * 2);
                this._tailPoint2 = new Point(x2 - (0.5 + xportion) * fracWidth * 2, y1);
                ctx.moveTo(this._tailPoint1.x, this._tailPoint1.y);
                this._drawCalloutBottom(x1, y1, x2, y2, radius, ctx);
                // finish the box
                ctx.arc(topLeftCenter.x, topLeftCenter.y, radius, half, quarter, false);
                ctx.lineTo(this._tailPoint2.x, this._tailPoint2.y);
            }
            else {
                // arrow point is inside the box. just draw a rounded box.
                ctx.moveTo(x1, y2 - radius);
                // arbitrarily use this fn to help draw this
                this._drawCalloutTop(x1, y1, x2, y2, radius, ctx);
                ctx.arc(bottomRightCenter.x, bottomRightCenter.y, radius, 0, threequarter, false);
                ctx.lineTo(x1 + radius, y2);
                ctx.arc(bottomLeftCenter.x, bottomLeftCenter.y, radius, threequarter, half, false);
                this._tailPoint1 = this._tailPoint2 = undefined; // don't bother drawing the tail
            }
        };
        // below functions are an attempt to pull out some code that's called multiple times
        /**
         * Draws the top portion of the callout
         *
         * @param x1 - the left coordinate
         * @param y1 - the top coordinate
         * @param x2 - the right coordinate
         * @param y2 - the bottom coordinate
         * @param radius - the rounded radius
         * @param ctx - the html canvas rendering context
         */
        FDSInfoBox.prototype._drawCalloutTop = function (x1, y1, x2, y2, radius, ctx) {
            var half = Math.PI;
            var quarter = Math.PI * (3 / 2);
            ctx.lineTo(x1, y1 + radius);
            ctx.arc(x1 + radius, y1 + radius, radius, half, quarter, false);
            ctx.lineTo(x2 - radius, y1);
            ctx.arc(x2 - radius, y1 + radius, radius, quarter, 0, false);
            ctx.lineTo(x2, y2 - radius);
        };
        /**
         * Draws the bottom portion of the callout
         *
         * @param x1 - the left coordinate
         * @param y1 - the top coordinate
         * @param x2 - the right coordinate
         * @param y2 - the bottom coordinate
         * @param radius - the rounded radius
         * @param ctx - the html canvas rendering context
         */
        FDSInfoBox.prototype._drawCalloutBottom = function (x1, y1, x2, y2, radius, ctx) {
            var threequarter = Math.PI / 2;
            var half = Math.PI;
            ctx.lineTo(x2, y2 - radius);
            ctx.arc(x2 - radius, y2 - radius, radius, 0, threequarter, false);
            ctx.lineTo(x1 + radius, y2);
            ctx.arc(x1 + radius, y2 - radius, radius, threequarter, half, false);
            ctx.lineTo(x1, y1 + radius);
        };
        /**
         * Draws the left portion of the callout
         *
         * @param x1 - the left coordinate
         * @param y1 - the top coordinate
         * @param x2 - the right coordinate
         * @param y2 - the bottom coordinate
         * @param radius - the rounded radius
         * @param ctx - the html canvas rendering context
         */
        FDSInfoBox.prototype._drawCalloutLeft = function (x1, y1, x2, y2, radius, ctx) {
            var threequarter = Math.PI / 2;
            var half = Math.PI;
            var quarter = Math.PI * (3 / 2);
            ctx.lineTo(x1 + radius, y2);
            ctx.arc(x1 + radius, y2 - radius, radius, threequarter, half, false);
            ctx.lineTo(x1, y1 + radius);
            ctx.arc(x1 + radius, y1 + radius, radius, half, quarter, false);
            ctx.lineTo(x2 - radius, y1);
        };
        /**
         * Draws the right portion of the callout
         *
         * @param x1 - the left coordinate
         * @param y1 - the top coordinate
         * @param x2 - the right coordinate
         * @param y2 - the bottom coordinate
         * @param radius - the rounded radius
         * @param ctx - the html canvas rendering context
         */
        FDSInfoBox.prototype._drawCalloutRight = function (x1, y1, x2, y2, radius, ctx) {
            var threequarter = Math.PI / 2;
            var quarter = Math.PI * (3 / 2);
            ctx.lineTo(x2 - radius, y1);
            ctx.arc(x2 - radius, y1 + radius, radius, quarter, 0, false);
            ctx.lineTo(x2, y2 - radius);
            ctx.arc(x2 - radius, y2 - radius, radius, 0, threequarter, false);
            ctx.lineTo(x1 + radius, y2);
        };
        // helper function to find an intersection between a line and an arc
        // some of the math is explained here:
        // http:// mathworld.wolfram.com/Circle-LineIntersection.html
        // http:// stackoverflow.com/questions/1073336/circle-line-collision-detection
        /**
         * helper function to find an intersection between a line and an arc
         *
         * some of the math is explained here:
         * * http:// mathworld.wolfram.com/Circle-LineIntersection.html
         * * http:// stackoverflow.com/questions/1073336/circle-line-collision-detection
         *
         * @param p1 - the start point
         * @param p2 - the end point
         * @param center - the center point of the arc
         * @param radius - the radius of the arc
         * @param quadrantPosition - which quadrant the arc is in
         * @returns the intersection point, or null
         */
        FDSInfoBox.prototype._lineArcIntersection = function (p1, p2, center, radius, quadrantPosition) {
            var dx = p2.x - p1.x;
            var dy = p2.y - p1.y;
            // a is d dot d
            var a = dx * dx + dy * dy;
            // b is 2 * f dot d, where f is the vector from the center to p1
            var b = 2 * (dx * (p1.x - center.x) + dy * (p1.y - center.y));
            // c is f dot f - r^2
            // so we want (x1 - cx)^2 + (y1 - cy)^2 - r^2
            var xSide = p1.x - center.x;
            var ySide = p1.y - center.y;
            var c = (xSide * xSide) + (ySide * ySide) - (radius * radius);
            // solve for the intersection point
            var discriminant = b * b - 4 * a * c;
            if (discriminant < 0) {
                return null;
            }
            // turns out we only care about one of the points
            // mu1 = (-b + Math.sqrt(discriminant)) / (2 * a)
            var mu2 = (-b - Math.sqrt(discriminant)) / (2 * a);
            var res = new Point(p1.x + mu2 * (p2.x - p1.x), p1.y + mu2 * (p2.y - p1.y));
            if (isNaN(res.x) || isNaN(res.y)) {
                return null;
            }
            // make sure it hits the arc in the right quadrant
            switch (quadrantPosition) {
                case 1 /* UPPER_RIGHT */:
                    if (res.x < center.x || res.y > center.y) {
                        return null;
                    }
                    break;
                case 2 /* UPPER_LEFT */:
                    if (res.x > center.x || res.y > center.y) {
                        return null;
                    }
                    break;
                case 3 /* LOWER_LEFT */:
                    if (res.x > center.x || res.y < center.y) {
                        return null;
                    }
                    break;
                case 4 /* LOWER_RIGHT */:
                    if (res.x < center.x || res.y < center.y) {
                        return null;
                    }
                    break;
            }
            return res;
        };
        /**
         * Returns the point on the circle who's tangent line has the same slope as the line passed in
         *
         * @param p1 - the start point
         * @param p2 - the end point
         * @param center - the center point of the circle
         * @param radius - the radius of the circle
         * @param second - there are two matches for any slope, if true returns the lower tangent
         * @returns a point on the circle with the same slope
         */
        FDSInfoBox.prototype._lineTangent = function (p1, p2, center, radius, second) {
            if (second === void 0) { second = false; }
            var m = (p2.y - p1.y) / (p2.x - p1.x);
            var factor = second ? -1 : 1;
            var y = factor * Math.sqrt((radius * radius) / (m * m + 1)) + center.y;
            var x = -m * (y - center.y) + center.x;
            return new Point(x, y);
        };
        /**
         * Checks if the provided point is within the a circle.
         *
         * @param point - the point being tested
         * @param center - the center of the circle
         * @param {number} radius - the radius of the circle
         * @returns true if the point falls inside the circle
         */
        FDSInfoBox.prototype._checkIfInCircle = function (point, center, radius) {
            var xDiff = point.x - center.x;
            var yDiff = point.y - center.y;
            return (xDiff * xDiff) + (yDiff * yDiff) <= radius * radius;
        };
        return FDSInfoBox;
    }());
    var QuickLabelInfoBox = /** @class */ (function (_super) {
        __extends(QuickLabelInfoBox, _super);
        function QuickLabelInfoBox(ctx, series, quickLabelText, alignment) {
            var _this = _super.call(this, ctx) || this;
            // Create a copy of the font with the proper text alignment set.
            if (alignment != null) {
                _this.font = series.quickLabelFont.with({ alignment: alignment });
            }
            else {
                _this.font = series.quickLabelFont;
            }
            _this.text = quickLabelText;
            _this.widthHint = series.quickLabelBoxWidthHint;
            _this.heightHint = series.quickLabelBoxHeightHint;
            _this.sizeMode = series.quickLabelBoxSizingMode;
            _this.FGPen = series.quickLabelFGPen;
            _this.BGBrush = series.quickLabelBGBrush;
            _this.clipped = series.quickLabelBoxTextClipping;
            _this.shape = series.quickLabelBoxDisplayStyle;
            _this.annotArrowFrac = series.quickLabelArrowMultiplier * 0.1;
            _this.autoPositionMethod = -1 /* PROGRESSIVE */; // this will try every method if necessary
            _this.showText = series.quickLabelShowText;
            // cache some of the series settings on the box itself
            _this.alignment = series.quickLabelPlacement;
            _this.personalGap = series.quickLabelGap;
            _this.personalConsolidation = series.quickLabelConsolidatedTextBoxes;
            _this.series = series;
            _this._vertAlign = series.quickLabelVerticalPosition;
            // Initialize width and height
            _this.computeWidthAndHeight(ctx);
            return _this;
        }
        return QuickLabelInfoBox;
    }(FDSInfoBox));
    
    /**
     * Class for the pie hitshape. Can represent any slice of a pie (up to a full circle)
     * as well as donut slices/shapes
     *
     * @class FDSPieHitShape
     * @extends FDSShape
     */
    var FDSPieHitShape = /** @class */ (function (_super) {
        __extends(FDSPieHitShape, _super);
        /**
         * Constructor takes no arguments and sets up a pie with all variables at 0
         */
        function FDSPieHitShape() {
            var _this = _super.call(this) || this;
            _this.name = 'Pie';
            _this.centerX = _this.centerY = _this.offset = _this.smallerAngle = _this.largerAngle = _this.radius2 = _this.radius
                = _this.innerRadius = _this.innerRadius2 = 0;
            _this._updateBounds();
            return _this;
        }
        /**
         * Function to update the coordinates of the pie's bounding rectangle
         */
        FDSPieHitShape.prototype._updateBounds = function () {
            this.y1 = this.centerY - this.radius - 1;
            this.y2 = this.centerY + this.radius;
            this.x1 = this.centerX - this.radius;
            this.x2 = this.centerX + this.radius + 1;
        };
        /**
         * Sets a new center point for the hit shape
         *
         * @param cx - the new x-coordinate
         * @param cy - the new y-coordinate
         */
        FDSPieHitShape.prototype.setCenter = function (cx, cy) {
            this.centerX = cx;
            this.centerY = cy;
            this._updateBounds();
        };
        // @param r [Number] the new radius
        /**
         * Sets the new pie radius for the pie hit shape
         *
         * @param r - the new radius
         */
        FDSPieHitShape.prototype.setRadius = function (r) {
            this.radius = r;
            this.radius2 = r * r;
            this._updateBounds();
        };
        /**
         * Sets the new inner-radius for the (donut) hit shape
         *
         * @param r - the new radius
         */
        FDSPieHitShape.prototype.setInnerRadius = function (r) {
            this.innerRadius = r;
            this.innerRadius2 = r * r;
        };
        // @param smaller,larger [Number] the two new angles
        /**
         * Sets the angles for the pie slice start/end
         *
         * @param smaller - the slice start angle
         * @param larger - the slice end angle
         */
        FDSPieHitShape.prototype.setAngles = function (smaller, larger) {
            // make sure smaller is actually the smaller angle
            if (smaller > larger) {
                _a = [larger, smaller], smaller = _a[0], larger = _a[1];
            }
            // get both smaller and larger between 0 and 720
            var diff = (larger - smaller) % 360;
            smaller = smaller % 360;
            if (smaller < 0) {
                smaller += 2 * Math.PI;
            }
            this.smallerAngle = smaller;
            this.largerAngle = smaller + diff;
            var _a;
        };
        // @param offset [Number] the new offset
        /**
         * Set the pie starting angle offset
         *
         * @param offset - the new starting angle
         */
        FDSPieHitShape.prototype.setOffset = function (offset) {
            this.offset = offset;
        };
        /**
         * test for whether a point (or other shape) is inside this pie's hit area
         *
         * @param x - the x-coordinate of the point (or shape) being tested
         * @param y - the y-coordinate of the point (or shape) being tested
         * @param [shape] the type of shape being tested - point, vertical line, or horizontal line
         * @returns whether the point (or shape) is inside the pie area
         */
        FDSPieHitShape.prototype.onHitTest = function (cx, cy) {
            var x = cx - this.centerX;
            var y = cy - this.centerY;
            var radius = (x * x) + (y * y);
            // angles are in radians
            var angle = Math.atan2(y, x) - this.offset;
            if (angle < 0) {
                angle = angle + 2 * Math.PI;
            }
            if (this._inAngleRange(angle) && radius <= this.radius2 && radius > this.innerRadius2) {
                return true;
            }
            return false;
        };
        // checks whether a given angle is in between the two angles of this pie
        // needs to check if the angle OR twice the angle is in range, because if the pie shape crosses
        // 2PI radians, smallerAngle will be less than 2PI but largerAngle will be greater than.
        // eg: smallerAngle is 6 and largerAngle is 7. If angle is 6.5 it will get normalized to
        // ~0.2168, which is not between 6 and 7. But 0.2168 + 2PI is (because it's 6.5).
        // we also have to check angle - 2PI for the same reasons
        /**
         * Checks whether a given angle is in between the two angles of this pie
         * needs to check if the angle OR twice the angle is in range, because if the pie shape crosses
         * 2PI radians, smallerAngle will be less than 2PI but largerAngle will be greater than.
         * eg: smallerAngle is 6 and largerAngle is 7. If angle is 6.5 it will get normalized to
         * ~0.2168, which is not between 6 and 7. But 0.2168 + 2PI is (because it's 6.5).
         *
         * @param angle - the angle to test
         * @returns whether the angle is in range
         */
        FDSPieHitShape.prototype._inAngleRange = function (angle) {
            var twoPi = 2 * Math.PI;
            var angleN = angle - twoPi;
            var angleP = angle + twoPi;
            return (this.smallerAngle <= angle && this.largerAngle >= angle) ||
                (this.smallerAngle <= angleN && this.largerAngle >= angleN) ||
                (this.smallerAngle <= angleP && this.largerAngle >= angleP);
        };
        /**
         * Given this pie shape and a rectangle that is overlapping it, provide a shift for the
         * rectangle in either the positive or negative y direction to avoid the overlap.
         *
         * @param x1 - the x-coordinate of the first corner of the rectangle
         * @param y1 - the y-coordinate of the first corner of the rectangle
         * @param x2 - the x-coordinate of the second corner of the rectangle
         * @param y2 - the x-coordinate of the second corner of the rectangle
         * @param moveUp - whether the shift should be upwards (negative Y)
         * @returns the amount to shift in the given direction in pixels
         */
        FDSPieHitShape.prototype.getAvoidanceOffset = function (x1, y1, x2, y2, moveUp) {
            var top = this.centerY - this.radius - 1;
            var bottom = this.centerY + this.radius;
            if (moveUp) {
                return Math.min(-1, -Math.abs(Math.max(y1, y2) - top));
            }
            else {
                return Math.max(1, Math.abs(Math.min(y1, y2) - bottom));
            }
        };
        /**
         * Test whether a given rectangle instersects this pie
         *
         * @param x1 - The x-coordinate of the corner of the rectangle
         * @param y1 - The y-coordinate of the corner of the rectangle
         * @param x2 - The x-coordinate of the diagonally opposite corner of the rectangle
         * @param y2 - The y-coordinate of the diagonally opposite corner of the rectangle
         * @returns whether or not the pie and rectangle intersect
         */
        FDSPieHitShape.prototype.hitTest = function (x1, y1, x2, y2) {
            var min$$1 = Math.min, max$$1 = Math.max;
            return this._inXRangeHelper(min$$1(y1, y2), max$$1(y1, y2), min$$1(this.y1, this.y2), max$$1(this.y1, this.y2)) &&
                this._inXRangeHelper(min$$1(x1, x2), max$$1(x1, x2), min$$1(this.x1, this.x2), max$$1(this.x1, this.x2));
        };
        /**
         * The distance of a point from the center of this pie
         *
         * @param x - the x-coordinate of the point being compared
         * @param y - the y-coordinate of the point being compared
         * @returns the x and y distances
         */
        FDSPieHitShape.prototype.distancesFromCentroid = function (x, y) {
            return new Point(x - this.centerX, y - this.centerY);
        };
        FDSPieHitShape.prototype.shadeShape = function (ctx) {
            ctx.save();
            _super.prototype.shadeShape.call(this, ctx);
            if (this.largerAngle === 360) {
                return;
            }
            ctx.beginPath();
            if (!(this.innerRadius > 0)) {
                ctx.moveTo(this.centerX, this.centerY);
            }
            ctx.arc(this.centerX, this.centerY, this.radius, this.smallerAngle, this.largerAngle, false);
            if (this.innerRadius > 0) {
                ctx.arc(this.centerX, this.centerY, this.innerRadius, this.largerAngle, this.smallerAngle, true);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        };
        return FDSPieHitShape;
    }(FDSShape));
    
    var FDSSeriesSampler = /** @class */ (function () {
        function FDSSeriesSampler(series, dim, start, end, step, includeEndpoints, minMaxCheck) {
            if (step === void 0) { step = 1; }
            if (includeEndpoints === void 0) { includeEndpoints = true; }
            if (minMaxCheck === void 0) { minMaxCheck = true; }
            this._series = series;
            this._dim = dim;
            this._start = start;
            this._end = end;
            this._step = step;
            this._includeEndpoints = includeEndpoints;
            this._minMaxCheck = minMaxCheck;
            if (this._dim !== 1 /* X */ && this._dim !== 2 /* Y */) {
                throw new Error('dim must be X or Y');
            }
            this._isEnabled = this._series.selectableItemSamplingEnabled;
            if (!this._series.isSelected()) {
                return;
            }
            // Is this a minmax series?
            this._seriesSampleModeIsMinmax = (this._series.sampleMode === 3 /* MINMAX */);
            // Ignore step passed in as a parameter and use the series sample step size if we're dealing with a minmax series
            if (this._minMaxCheck && this._seriesSampleModeIsMinmax) {
                this._samplingIndexStepSize = this._series.stepSize;
            }
            if (!this._includeEndpoints) {
                // Use the narrowest of the two intervals: drawable series or zoomed window
                this._start = Math.max(this._series.getSampleIndex(this._start), this._series.yStart);
                if (this._end < this._series.getSampleSize()) {
                    this._end = Math.min(this._series.getSampleIndex(this._end), this._series.yEnd);
                }
                else {
                    this._end = Math.min(this._series.getSampleIndex(this._end - 1), this._series.yEnd - 1);
                }
            }
            // First selection marker
            this._nextSamplingPoint = this._start;
            if (this._includeEndpoints) {
                this._maxSamplePoints = Math.max(2, this._series.getSelectionMarkerCount(this._dim));
            }
            else {
                this._maxSamplePoints = Math.max(0, this._series.getSelectionMarkerCount(this._dim));
            }
            this._step = this._calculateStep();
            // Compute minimum space between markers in Index Space. That's the size of a marker (two halves)
            this._ratio = this._series.selectableItemPointMarkerSize / this._series.selectableItemSamplingMinPixelsPerMarker;
            this._sizeOfMarkerInIndexSpace = this._step * this._ratio;
            if (this._minMaxCheck && this._seriesSampleModeIsMinmax) {
                // This IF fails with minmaxed c-spline series. No need for panic, though, the problem is averted by passing
                // end-1 as a parameter to this constructor from FDSNewCSpline::DrawCSpline(...)
                if (!this._series.isMinmaxAndZoomed) {
                    this._end = this._series.lastValidIndex;
                }
            }
            else {
                // recompute m_end because stepping through the series might lead to something different than the end passed
                // in as a parameter Why start instead of m_start? Because draw styles draw the series from start to end, not
                // from m_start
                this._stepCount = ((this._end - this._start) / this._samplingIndexStepSize);
                this._end = Math.floor(this._stepCount * this._samplingIndexStepSize) + this._start;
            }
        }
        FDSSeriesSampler.prototype._calculateStep = function () {
            var selStep = 1;
            var netSize = this._end - this._start;
            if ((this._isEnabled) && (netSize > this._maxSamplePoints)) {
                selStep = netSize / (this._maxSamplePoints - 1.0);
            }
            return selStep;
        };
        FDSSeriesSampler.prototype.isPointSampled = function (index) {
            // Should we draw a selection marker?
            if (fuzzyLTE(index, this._end) && ((!this._isEnabled) ||
                (index >= Math.round(this._nextSamplingPoint)) ||
                (this._includeEndpoints && (fuzzyEQ(index, this._start) || fuzzyEQ(index, this._end))))) {
                // Ensure only one selection marker on the first point
                if (fuzzyEQ(index, this._start) && fuzzyLT(index, this._nextSamplingPoint)) {
                    return false;
                }
                else if (fuzzyEQ(index, this._start) && this._includeEndpoints) {
                    this._nextSamplingPoint = index + this._step;
                    return true;
                }
                // We reached the last point of the series and it must have a selection marker
                if (fuzzyEQ(index, this._end)) {
                    // Compute the next sampling point so that another call to isPointSampled() don't fall through the
                    // condition because of (index >= m_nextSamplingPoint)
                    this._nextSamplingPoint = index + this._step;
                    return true;
                }
                else {
                    // If the next sampling point wil fall beyond the last point...
                    if (fuzzyGTE((index + this._step), this._end)) {
                        // ... and the current index is whitin the range of the last selection marker, return
                        if (fuzzyLTE((this._end - index), this._sizeOfMarkerInIndexSpace) && this._includeEndpoints) {
                            return false;
                        }
                        // ... or else set the last point as the next sampling point
                        this._nextSamplingPoint = this._end;
                        return true;
                    }
                    else {
                        // Ok, so the next marker won't fall beyond the last point in the series, BUT it might fall within the
                        // range of the last marker. If this happens, the next marker (index + m_step) will be close, but not
                        // enough, to the last point in the series so that it won't be snapped to the endpoint. The marker after
                        // this, then, will fall onto the endpoint and they will collide. So, if the next marker falls within
                        // this magical range: [m_end - m_sizeOfMarkerInIndexSpace, m_end], we actually snap it to the last
                        // point of the series.
                        if (fuzzyGTE((index + this._step), (this._end - this._sizeOfMarkerInIndexSpace))) {
                            this._nextSamplingPoint = this._end;
                        }
                        else {
                            this._nextSamplingPoint = index + this._step;
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        return FDSSeriesSampler;
    }());
    
    var getMarkerDrawFunctor = function (markerStyle, markerSize, willDrawStroke, isLegend) {
        if (willDrawStroke === void 0) { willDrawStroke = true; }
        if (isLegend === void 0) { isLegend = false; }
        markerSize = scaleByDevicePixelRatio(markerSize);
        var plus = Math.round(markerSize * 0.5) + (willDrawStroke ? 0 : 1);
        var minus = ~~(markerSize * 0.5);
        var t;
        var t2;
        switch (markerStyle) {
            case 0 /* DIAMOND */:
                return function (ctx, x, y) {
                    ctx.moveTo(x - minus, y);
                    ctx.lineTo(x, y - minus);
                    ctx.lineTo(x + minus, y);
                    ctx.lineTo(x, y + minus);
                    ctx.lineTo(x - minus, y);
                };
            case 1 /* CIRCLE */:
                return function (ctx, x, y) {
                    ctx.ellipse(x, y, markerSize / 2);
                };
            case 2 /* SQUARE */:
                return function (ctx, x, y) {
                    ctx.rect(x - minus, y - minus, markerSize, markerSize);
                };
            case 3 /* TRIANGLE */:
                return function (ctx, x, y) {
                    ctx.moveTo(x - minus, y + minus);
                    ctx.lineTo(x + 0, y - plus);
                    ctx.lineTo(x + plus, y + minus);
                    ctx.lineTo(x - minus, y + minus);
                };
            case 4 /* DELTA */:
                return function (ctx, x, y) {
                    ctx.moveTo(x + minus, y - minus);
                    ctx.lineTo(x + 0, y + plus);
                    ctx.lineTo(x - plus, y - minus);
                    ctx.lineTo(x + minus, y - minus);
                };
            case 5 /* CROSS */:
                t = Math.round(markerSize / 4.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x - t, y + 0);
                    ctx.lineTo(x - minus, y + t);
                    ctx.lineTo(x - minus, y + minus);
                    ctx.lineTo(x - t, y + minus);
                    ctx.lineTo(x + 0, y + t);
                    ctx.lineTo(x + t, y + minus);
                    ctx.lineTo(x + minus, y + minus);
                    ctx.lineTo(x + minus, y + t);
                    ctx.lineTo(x + t, y - 0);
                    ctx.lineTo(x + minus, y - t);
                    ctx.lineTo(x + minus, y - minus);
                    ctx.lineTo(x + t, y - minus);
                    ctx.lineTo(x + 0, y - t);
                    ctx.lineTo(x - t, y - minus);
                    ctx.lineTo(x - minus, y - minus);
                    ctx.lineTo(x - minus, y - t);
                    ctx.lineTo(x - t, y - 0);
                };
            case 6 /* BAR */:
                t = Math.round(markerSize / 6.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x - t, y + minus);
                    ctx.lineTo(x + t, y + minus);
                    ctx.lineTo(x + t, y - plus);
                    ctx.lineTo(x - t, y - plus);
                    ctx.lineTo(x - t, y + minus);
                };
            case 7 /* DASH */:
                t = Math.round(markerSize / 6.0);
                t2 = t * 2;
                return function (ctx, x, y) {
                    ctx.moveTo(x - t2, y + t);
                    ctx.lineTo(x - t2, y - t);
                    ctx.lineTo(x + t2, y - t);
                    ctx.lineTo(x + t2, y + t);
                    ctx.lineTo(x - t2, y + t);
                };
            case 8 /* PLUS */:
                t = Math.round(markerSize / 6.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x - t, y + t);
                    ctx.lineTo(x - t, y + minus);
                    ctx.lineTo(x + t, y + minus);
                    ctx.lineTo(x + t, y + t);
                    ctx.lineTo(x + minus, y + t);
                    ctx.lineTo(x + minus, y - t);
                    ctx.lineTo(x + t, y - t);
                    ctx.lineTo(x + t, y - minus);
                    ctx.lineTo(x - t, y - minus);
                    ctx.lineTo(x - t, y - t);
                    ctx.lineTo(x - minus, y - t);
                    ctx.lineTo(x - minus, y + t);
                    ctx.lineTo(x - t, y + t);
                };
            case 9 /* MINUS */:
                t = Math.round(markerSize / 6.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x - minus, y + t);
                    ctx.lineTo(x - minus, y - t);
                    ctx.lineTo(x + plus, y - t);
                    ctx.lineTo(x + plus, y + t);
                    ctx.lineTo(x - minus, y + t);
                };
            case 10 /* DOT */:
                return function (ctx, x, y) {
                    ctx.moveTo(x + 0, y + 0);
                    ctx.lineTo(x + 1, y + 0);
                };
            case 11 /* T */:
                return function (ctx, x, y) {
                    ctx.moveTo(x + 0, y + minus + 0.5);
                    ctx.lineTo(x + 0, y - minus);
                    ctx.moveTo(x - minus, y + 0);
                    ctx.lineTo(x + minus + 0.5, y + 0);
                };
            case 12 /* X */:
                return function (ctx, x, y) {
                    ctx.moveTo(x - minus, y + minus);
                    ctx.lineTo(x + minus, y - minus - 0.5);
                    ctx.moveTo(x - minus, y - minus);
                    ctx.lineTo(x + minus, y + minus + 0.5);
                };
            case 17 /* SHIELD1 */:
                var t1_1 = Math.round(markerSize / 6.0);
                t2 = Math.round(markerSize / 3.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x + 0, y - minus);
                    ctx.lineTo(x + t1_1, y - t2);
                    ctx.lineTo(x + minus, y - t1_1);
                    ctx.lineTo(x + t2, y + t1_1);
                    ctx.lineTo(x + 0, y + minus);
                    ctx.lineTo(x - t2, y + t1_1);
                    ctx.lineTo(x - minus, y - t1_1);
                    ctx.lineTo(x - t1_1, y - t2);
                    ctx.lineTo(x - 0, y - minus);
                };
            case 18 /* SHIELD2 */:
                t1_1 = Math.round(markerSize / 6.0);
                t2 = Math.round(markerSize / 3.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x + 0, y - minus);
                    ctx.lineTo(x + t1_1, y - t2);
                    ctx.lineTo(x + minus, y - minus);
                    ctx.lineTo(x + t2, y + t1_1);
                    ctx.lineTo(x + 0, y + minus);
                    ctx.lineTo(x - t2, y + t1_1);
                    ctx.lineTo(x - minus, y - minus);
                    ctx.lineTo(x - t1_1, y - t2);
                    ctx.lineTo(x - 0, y - minus);
                };
            case 19 /* SHIELD3 */:
                t1_1 = Math.round(markerSize / 6.0);
                t2 = Math.round(markerSize / 3.0);
                var t4_1 = ~~(markerSize * 0.4);
                return function (ctx, x, y) {
                    ctx.moveTo(x + 0, y - t2);
                    ctx.lineTo(x + t4_1, y - t2);
                    ctx.lineTo(x + t4_1, y - t1_1);
                    ctx.lineTo(x + t2, y + t1_1);
                    ctx.lineTo(x + 0, y + minus);
                    ctx.lineTo(x - t2, y + t1_1);
                    ctx.lineTo(x - t4_1, y - t1_1);
                    ctx.lineTo(x - t4_1, y - t2);
                    ctx.lineTo(x - 0, y - t2);
                };
            case 13 /* ARROW_UP */:
                t1_1 = ~~(markerSize / 10.0);
                t2 = Math.round(markerSize / 4.0);
                return function (ctx, x, y) {
                    if (isLegend) {
                        // legend arrow should be centered rather than below the center
                        y -= ~~(markerSize / 2);
                    }
                    ctx.moveTo(x + 0, y + 0);
                    ctx.lineTo(x + t2, y + t2);
                    ctx.lineTo(x + t1_1, y + t2);
                    ctx.lineTo(x + t1_1, y + markerSize);
                    ctx.lineTo(x - t1_1, y + markerSize);
                    ctx.lineTo(x - t1_1, y + t2);
                    ctx.lineTo(x - t2, y + t2);
                    ctx.lineTo(x + 0, y + 0);
                };
            case 14 /* ARROW_DOWN */:
                t1_1 = ~~(markerSize / 10.0);
                t2 = Math.round(markerSize / 4.0);
                return function (ctx, x, y) {
                    if (isLegend) {
                        // legend arrow should be centered rather than below the center
                        y += ~~(markerSize / 2);
                    }
                    ctx.moveTo(x + 0, y - 0);
                    ctx.lineTo(x + t2, y - t2);
                    ctx.lineTo(x + t1_1, y - t2);
                    ctx.lineTo(x + t1_1, y - markerSize);
                    ctx.lineTo(x - t1_1, y - markerSize);
                    ctx.lineTo(x - t1_1, y - t2);
                    ctx.lineTo(x - t2, y - t2);
                    ctx.lineTo(x + 0, y - 0);
                };
            case 15 /* ARROW_LEFT */:
                t1_1 = ~~(markerSize / 10.0);
                t2 = Math.round(markerSize / 4.0);
                return function (ctx, x, y) {
                    if (isLegend) {
                        // legend arrow should be centered rather than below the center
                        x -= ~~(markerSize / 2);
                    }
                    ctx.moveTo(x + 0, y - 0);
                    ctx.lineTo(x + t2, y - t2);
                    ctx.lineTo(x + t2, y - t1_1);
                    ctx.lineTo(x + markerSize, y - t1_1);
                    ctx.lineTo(x + markerSize, y + t1_1);
                    ctx.lineTo(x + t2, y + t1_1);
                    ctx.lineTo(x + t2, y + t2);
                    ctx.lineTo(x + 0, y + 0);
                };
            case 16 /* ARROW_RIGHT */:
                t1_1 = ~~(markerSize / 10.0);
                t2 = Math.round(markerSize / 4.0);
                return function (ctx, x, y) {
                    if (isLegend) {
                        // legend arrow should be centered rather than below the center
                        x += ~~(markerSize / 2);
                    }
                    ctx.moveTo(x - 0, y - 0);
                    ctx.lineTo(x - t2, y - t2);
                    ctx.lineTo(x - t2, y - t1_1);
                    ctx.lineTo(x - markerSize, y - t1_1);
                    ctx.lineTo(x - markerSize, y + t1_1);
                    ctx.lineTo(x - t2, y + t1_1);
                    ctx.lineTo(x - t2, y + t2);
                    ctx.lineTo(x - 0, y + 0);
                };
            case 21 /* BREAK */:
                return function (ctx, x, y) {
                    ctx.moveTo(x - minus, y + minus);
                    ctx.lineTo(x - minus, y - 0);
                    ctx.lineTo(x + plus, y - plus);
                    ctx.lineTo(x + plus, y - 0);
                    ctx.lineTo(x - minus, y + minus);
                };
            case 22 /* LIGHTNING */:
                t1_1 = ~~(markerSize / 10.0);
                return function (ctx, x, y) {
                    ctx.moveTo(x - minus, y + minus);
                    ctx.lineTo(x - t1_1, y + t1_1);
                    ctx.lineTo(x - minus, y + t1_1);
                    ctx.lineTo(x + plus, y - plus);
                    ctx.lineTo(x + t1_1, y - t1_1);
                    ctx.lineTo(x + plus, y - t1_1);
                    ctx.lineTo(x - minus, y + minus);
                };
            case 23 /* LIGHTNING2 */:
                t1_1 = ~~(markerSize / 10.0);
                t2 = t1_1 + t1_1;
                return function (ctx, x, y) {
                    ctx.moveTo(x + t1_1, y - plus);
                    ctx.lineTo(x + t2, y - t1_1);
                    ctx.lineTo(x + t1_1, y - t1_1);
                    ctx.lineTo(x + t2, y + minus);
                    ctx.lineTo(x - t2, y - t1_1);
                    ctx.lineTo(x - t1_1, y - t1_1);
                    ctx.lineTo(x - t2 - t1_1, y - plus);
                    ctx.lineTo(x + t1_1, y - plus);
                };
            case 24 /* GUIDANCE_SHIELD */:
                // I'm assuming markersize is the longer dimension - for this one its 3x tall and 2x wide
                var msOneThird_1 = ~~(markerSize / 3);
                var msTwoThirds_1 = msOneThird_1 * 2;
                return function (ctx, x, y) {
                    ctx.moveTo(x - msOneThird_1, y - msOneThird_1);
                    ctx.lineTo(x + msOneThird_1, y - msOneThird_1);
                    ctx.lineTo(x + msOneThird_1, y + msOneThird_1);
                    ctx.lineTo(x, y + msTwoThirds_1);
                    ctx.lineTo(x - msOneThird_1, y + msOneThird_1);
                    ctx.lineTo(x - msOneThird_1, y - msOneThird_1);
                };
            default:
                return function (ctx, x, y) {
                    // Do nothing
                };
        }
    };
    function getMarkerInfoboxPixelPoint(markerStyle, markerSize, markerCenterPt, plotRect) {
        var x = markerCenterPt.x, y = markerCenterPt.y;
        var xPixelPoint = Math.round(x + plotRect.x1);
        var yBase = y + plotRect.y1;
        switch (markerStyle) {
            case 7 /* DASH */:
            case 9 /* MINUS */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase - markerSize / 6) },
                    position: "above" /* above */
                };
            case 13 /* ARROW_UP */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase) },
                    position: "above" /* above */
                };
            case 14 /* ARROW_DOWN */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase) },
                    position: "below" /* below */
                };
            case 15 /* ARROW_LEFT */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase) },
                    position: "left" /* left */
                };
            case 16 /* ARROW_RIGHT */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase) },
                    position: "right" /* right */
                };
            case 19 /* SHIELD3 */:
            case 24 /* GUIDANCE_SHIELD */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase - markerSize / 3) },
                    position: "above" /* above */
                };
            case 5 /* CROSS */:
            case 21 /* BREAK */:
            case 22 /* LIGHTNING */:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase - markerSize / 4) },
                    position: "above" /* above */
                };
            default:
                return {
                    point: { x: xPixelPoint, y: Math.round(yBase - markerSize / 2) },
                    position: "above" /* above */
                };
        }
    }
    
    function getDimensionPixelPositionFromIndex(series, index, dimension) {
        var dataSet = series.getData(dimension);
        var data = dataSet.data;
        if (!data) {
            return 0;
        }
        var datapt = dataSet.getAt(index);
        var axis = series.getAxis(dimension);
        if (!axis) {
            return 0;
        }
        var scale = axis.getScale();
        if (!scale) {
            return 0;
        }
        var ndc = scale.lookup(datapt, dataSet.getDateBin());
        var parent = series.getPlotParent();
        return parent.subPlotFromNDC(ndc, dimension);
    }
    
    var BaseDrawStyle = /** @class */ (function () {
        function BaseDrawStyle(series, dim) {
            if (dim === void 0) { dim = 1 /* X */; }
            this.series = series;
            this.root = series.root;
            this._dim = dim;
            if (isSeries(this.series.parent)) {
                // we're a child series, use our parent's scale
                var parentSeries = this.series.parent;
                if (parentSeries.getAxis(1 /* X */) != null) {
                    this._xScale = parentSeries.getAxis(1 /* X */).getScale();
                }
                if (parentSeries.getAxis(2 /* Y */) != null) {
                    this._yScale = parentSeries.getAxis(2 /* Y */).getScale();
                }
                if (parentSeries.getAxis(3 /* Z */) != null) {
                    this._zScale = parentSeries.getAxis(3 /* Z */).getScale();
                }
            }
            else {
                if (this.series.getAxis(1 /* X */) != null) {
                    this._xScale = this.series.getAxis(1 /* X */).getScale();
                }
                if (this.series.getAxis(2 /* Y */) != null) {
                    this._yScale = this.series.getAxis(2 /* Y */).getScale();
                }
                if (this.series.getAxis(3 /* Z */) != null) {
                    this._zScale = this.series.getAxis(3 /* Z */).getScale();
                }
            }
            this._xData = this.series.getData(1 /* X */);
            this._yData = this.series.getData(2 /* Y */);
            this._zData = this.series.getData(3 /* Z */);
            this._xBin = this._xData.getDateBin();
            this._yBin = this._yData.getDateBin();
            this._zBin = this._zData.getDateBin();
            this._colorData = this.series.getData(4 /* COLOR */);
            this._selectionMarkerScale = 1.0;
            this._labelPositions = [];
            this._markerPositions = [];
            this._useHorizontalMargins = false;
            this._useVerticalMargins = false;
            // Calculate start, end and step information, and store respective trim information for
            // x and y accordingly.
            var seriesSize = this.series.size;
            this._start = 0;
            this._end = seriesSize;
            this._step = 1;
            this._setHitVector = this.root.tooltipsEnabled || this.root.interactivityWithoutTooltips;
            this.seriesSelected = this.series.isSelected();
            this._selectablePointCache = [];
            this._colorsMapNum = 0;
            if (this._dim == null ||
                (this._dim === 1 /* X */ && this._xData.dataType === 'STRING' && !this._xData.isIndex) ||
                (this._dim === 2 /* Y */ && this._yData.dataType === 'STRING' && !this._yData.isIndex)) {
                this.series.xStart = this._start;
                this.series.xEnd = this._end;
                this.series.lastValidIndex = this._end;
                this._yStart = this._start;
                this._yEnd = this._end;
                this._selectionSampler = new FDSSeriesSampler(this.series, this._dim, this._start, this._end, 1);
                return;
            }
            // Calculate any and all sampling after this point.
            var chartWidth = this.root.getWidth();
            if (chartWidth >= 0) {
                _a = this.series.computeXTrim(chartWidth, this._start, this._end, this._step), this._start = _a[0], this._end = _a[1], this._step = _a[2];
            }
            if (this._xData.sorted) {
                var endVal = this.series.getSampleSize();
                if (this._xData.ascending) {
                    while ((this._start > 0) &&
                        (this._xData.getAt(this.series.getSampleIndex(this._start)) >= this._xScale.threshMin)) {
                        this._start = Math.max(0, this._start - 1);
                    }
                    while (this._end < (endVal - 1) &&
                        this._xData.getAt(this.series.getSampleIndex(this._end)) <= this._xScale.threshMax) {
                        this._end = Math.min(endVal - 1, this._end + 1);
                    }
                }
                else {
                    while ((this._start > 0) &&
                        (this._xData.getAt(this.series.getSampleIndex(this._start)) <= this._xScale.threshMax)) {
                        this._start = Math.max(0, this._start - 1);
                    }
                    while (this._end < (endVal - 1) &&
                        this._xData.getAt(this.series.getSampleIndex(this._end)) >= this._xScale.threshMin) {
                        this._end = Math.min(endVal - 1, this._end + 1);
                    }
                }
            }
            this.series.xStart = this._start;
            this.series.xEnd = this._end;
            this._yStart = 0;
            this._yEnd = seriesSize;
            _b = this.series.computeYTrim(this._yStart, this._yEnd), this._yStart = _b[0], this._yEnd = _b[1];
            this.series.yStart = this._yStart;
            this.series.yEnd = this._yEnd;
            this._selectionSampler = new FDSSeriesSampler(this.series, this._dim, this._start, this._end, this._step);
            var _a, _b;
        }
        BaseDrawStyle.prototype._choosePens = function (ctx, legend) {
            return { brush: null, pen: null, penProps: null };
        };
        BaseDrawStyle.prototype.getCoordinates = function (prm, i, passedVals, retVals) {
            var ndcy = this._yScale.lookup(passedVals.yval1);
            var ndcx = this._xScale.lookup(passedVals.xval1);
            retVals.y1 = retVals.y2 = prm.plot.subPlotFromNDC(ndcy, 2 /* Y */);
            retVals.x1 = retVals.x2 = prm.plot.subPlotFromNDC(ndcx, 1 /* X */);
            return retVals;
        };
        BaseDrawStyle.prototype._adjustCoordinates = function (valuePos, values$$1) {
            var x1 = values$$1.x1, x2 = values$$1.x2, y1 = values$$1.y1, y2 = values$$1.y2;
            if (valuePos === 2 /* MAX */) {
                var tempx = x1;
                var tempy = y1;
                x1 = Math.max(x1, x2);
                y1 = Math.max(y1, y2);
                x2 = Math.min(tempx, x2);
                y2 = Math.min(tempy, y2);
            }
            else if (valuePos === 1 /* MIN */) {
                var tempx = x1;
                var tempy = y1;
                x1 = Math.min(x1, x2);
                y1 = Math.min(y1, y2);
                x2 = Math.max(tempx, x2);
                y2 = Math.max(tempy, y2);
            }
            else if (valuePos === 3 /* CENTER */) {
                x1 = x2 = (x1 + x2) / 2;
                y1 = y2 = (y1 + y2) / 2;
            }
            return { x1: x1, x2: x2, y1: y1, y2: y2 };
        };
        BaseDrawStyle.prototype._doCoordinateMath = function (prm, i, passedVals, retVals, valuePos) {
            return this._adjustCoordinates(valuePos, this.getCoordinates(prm, i, passedVals, retVals));
        };
        BaseDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
        };
        BaseDrawStyle.prototype.prepareToDraw = function () {
            this._selectablePointCache = [];
        };
        BaseDrawStyle.prototype.drawBackgroundToBuffer = function (prm, ctx) {
        };
        BaseDrawStyle.prototype.isSimpleMarker = function (markerStyle) {
            switch (markerStyle) {
                case 10 /* DOT */:
                case 11 /* T */:
                case 12 /* X */:
                    return true;
                default:
                    return false;
            }
        };
        BaseDrawStyle.prototype._setupSelectionMarkerPenAndBrush = function (usingDifference, ctx) {
            var selectionMarkerPen = new FDSPen();
            var selectionMarkerBrush = new FDSBrush();
            selectionMarkerBrush.style = 0 /* SOLID */;
            var aliasOffset = 0;
            if (usingDifference) {
                selectionMarkerPen = selectionMarkerPen.with({ color: 16777215 /* WHITE */, width: 1 });
                selectionMarkerBrush.color = 16777215 /* WHITE */;
                ctx.globalCompositeOperation = 'difference';
                // aliasOffset = irrelevant
            }
            else {
                selectionMarkerPen = selectionMarkerPen.with({ color: 0 /* BLACK */, width: 1 });
                selectionMarkerBrush.color = 16777215 /* WHITE */;
                aliasOffset = selectionMarkerPen.getAliasOffset();
                ctx.translate(aliasOffset, aliasOffset);
            }
            selectionMarkerPen.setOnCanvas(ctx);
            selectionMarkerBrush.setOnCanvas(ctx);
            return aliasOffset;
        };
        BaseDrawStyle.prototype.drawSelectionMarkers = function (prm, ctx) {
            if (!this.series.isSelected()) {
                return;
            }
            // reset its interaction handles - these are saved in here
            this.root.interactionHandlePixelPoints[this.series.id] = [];
            ctx.save();
            var usingDifference = this.root.canvasDifferenceSupported();
            var aliasOffset = this._setupSelectionMarkerPenAndBrush(usingDifference, ctx);
            var circleSize = this.series.interactionHandleSize;
            var selectionMarkerSize = this.root.selectableItemPointMarkerSize;
            var selectionMarkerFunctor = getMarkerDrawFunctor(this.root.selectableItemPointMarkerType, Math.round(selectionMarkerSize * this._selectionMarkerScale), !usingDifference);
            var circleMarkerFunctor = getMarkerDrawFunctor(1 /* CIRCLE */, circleSize * 2);
            for (var _i = 0, _a = this._selectablePointCache; _i < _a.length; _i++) {
                var _b = _a[_i], pt = _b.pt, type = _b.type;
                pt.x = Math.round(pt.x);
                pt.y = Math.round(pt.y);
                // save pixel points for all selected points
                this.root.interactionHandlePixelPoints[this.series.id].push({ x: pt.x, y: pt.y });
                if (usingDifference) {
                    pt.x += aliasOffset;
                    pt.y += aliasOffset;
                }
                ctx.beginPath();
                switch (type) {
                    case 3 /* DATAPOINT */:
                    case 6 /* DATAPOINTLEFT */:
                    case 7 /* DATAPOINTRIGHT */:
                        circleMarkerFunctor(ctx, pt.x, pt.y);
                        break;
                    default:
                        selectionMarkerFunctor(ctx, pt.x, pt.y);
                }
                ctx.fill();
                if (!usingDifference) {
                    ctx.stroke();
                }
            }
            ctx.restore();
        };
        BaseDrawStyle.prototype.drawMarkersToBuffer = function (prm, ctx, isMarkerStyle) {
            if (isMarkerStyle === void 0) { isMarkerStyle = false; }
            if (this.series.drawStyle === -1 /* NONE */) {
                return;
            }
            var isMarkerDrawstyle = this._isMarkerDrawStyle();
            if (!(isMarkerDrawstyle || this.series.seriesMarker)) {
                return;
            }
            ctx.save();
            var xOff = this.series.markerXOffset;
            var yOff = this.series.markerYOffset;
            var markerStyle = this.series.markerStyle;
            var isSimpleMarker = this.isSimpleMarker(markerStyle);
            var _a = this.configureMarkerPens(isMarkerStyle, isSimpleMarker, ctx), brush = _a[0], seriesOutlinePenProps = _a[1];
            var drawFunc = getMarkerDrawFunctor(markerStyle, this.series.markerSize, seriesOutlinePenProps.willDrawStroke);
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            // We need to keep track of the autoposition offsets that we calculate so that we can add them when we draw the
            // marker text.
            var xAutoOffsets = {};
            var yAutoOffsets = {};
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            if (drawFunc != null) {
                var aliasOffset = seriesOutlinePenProps.aliasOffset;
                // check if we have enough stuff in the position array
                var usePositionArray = (this._markerPositions.length >= this._xData.data.length);
                var autoPositionerOptions = this._setUpMarkerAutoPositionOptions(prm);
                for (var j = this._start; j < this._end; j += this._step) {
                    var i = this.series.getSampleIndex(j);
                    // don't draw markers on slices we skipped
                    if (this._shouldSkipSeriesDataItemIndex(i)) {
                        continue;
                    }
                    var dataItem = this._xData.getAt(i);
                    var yDataItem = this._yData.getAt(i);
                    if (dataItem !== undefined && yDataItem !== undefined && !IsSomeNAN(dataItem) && !IsSomeNAN(yDataItem)) {
                        ctx.beginPath();
                        // Draw each data point as a point on a line
                        var x = void 0, y = void 0;
                        if (usePositionArray) {
                            x = this._markerPositions[i].x;
                            y = this._markerPositions[i].y;
                        }
                        else {
                            x = (prm.plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */));
                            y = (prm.plot.subPlotFromNDC(this._yScale.lookup(yDataItem, this._yBin), 2 /* Y */));
                        }
                        x = (~~(x + xOff)) + aliasOffset;
                        y = (~~(y - yOff)) + aliasOffset;
                        if (this.series.seriesMarkerAutoPosition) {
                            var xRadius = Math.round(this.series.seriesMarkerAutoPositionXFactor *
                                (this.series.markerSize / 2));
                            var yRadius = Math.round(this.series.seriesMarkerAutoPositionYFactor *
                                (this.series.markerSize / 2));
                            var markerRect = { x: x - xRadius, y: y - yRadius, width: xRadius * 2, height: yRadius * 2 };
                            var offset = this._calcMarkerAutoPositionOffset(prm, markerRect, autoPositionerOptions);
                            xAutoOffsets[i] = offset.x;
                            yAutoOffsets[i] = offset.y;
                            x += offset.x;
                            y += offset.y;
                        }
                        if (isMarkerDrawstyle) {
                            // save the pixel points, including the space before/above the plot rect
                            var pR = prm.plot.plotRect;
                            pixelPoints[i] = { x: Math.round(x + pR.x1), y: Math.round(y + pR.y1) };
                            infoboxPixelPoints[i] = getMarkerInfoboxPixelPoint(this.series.markerStyle, this.series.markerSize, { x: x, y: y }, pR);
                        }
                        drawFunc(ctx, x, y);
                        this.series.addLookupPoint(x + prm.plotRect.x1, [y + prm.plotRect.y1], i);
                        var halfSize = this.series.markerSize / 2;
                        var rect = new Rectangle(x - halfSize, y - halfSize, x + halfSize, y + halfSize);
                        if (this.series.useColor) {
                            this._setColorMapColor(ctx, brush, colorData.getAt(i), i, rect);
                        }
                        else {
                            brush.setBubble3dMode(this.series.tryGetMarker3dLightPosition());
                            brush.setOnCanvas(ctx, rect);
                        }
                        if (!isSimpleMarker) {
                            ctx.fill();
                            ctx.stroke();
                        }
                        else {
                            ctx.stroke();
                        }
                        prm.allSeriesMarkerRects.push(rect);
                        if (this.series.seriesMarkerAutoPositionMode !== 0 /* ANNOTATION */) {
                            prm.nonAnnotationSeriesMarkerRects.push(rect);
                        }
                        // add hitshapes
                        var hitPie = new FDSPieHitShape();
                        hitPie.setCenter(x + prm.plotRect.x1, y + prm.plotRect.y1);
                        hitPie.setRadius(((this.series.markerSize / 2) + 1)); // minimum of 1
                        hitPie.setAngles(0, 2 * Math.PI);
                        hitPie.setOffset(0);
                        hitPie.name = 3 /* DATAPOINT */;
                        hitPie.index = i;
                        this.series.hitVector.push(hitPie);
                        // Cache point for selection markers
                        if (isMarkerDrawstyle && this.seriesSelected && this._selectionSampler.isPointSampled(i)) {
                            this.cacheSelectable(prm, 0 /* NONE */, x, y);
                        }
                    }
                }
                this._resetColorMapColor(brush);
            }
            if (isMarkerDrawstyle) {
                this.root.pixelPoints[this.series.id] = pixelPoints;
                this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
            }
            if (this.series.markerText) {
                var markerFont = this.series.seriesMarkerFont;
                if (markerStyle === 20 /* TEXT */ || this.series.markerFontColorFollowsSeriesColor) {
                    markerFont = markerFont.with({ color: this.series.seriesFGPen.color });
                }
                for (var j = this._start; j < this._end; j += this._step) {
                    var i = this.series.getSampleIndex(j);
                    var dataItem = this._xData.getAt(i);
                    var yDataItem = this._yData.getAt(i);
                    if (dataItem !== undefined && yDataItem !== undefined && !IsSomeNAN(yDataItem)) {
                        var cps = this.series.markerTextCFS.fromValueRT({ seriesIndex: i });
                        var _b = RichTextRenderer.measureRichText(ctx, cps, markerFont), dim = _b[0], preparedText = _b[1];
                        // Draw each data point as a point on a line
                        var x = ((prm.plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */)) +
                            xOff) - (dim.width / 2) + xAutoOffsets[i];
                        var y = ((prm.plot.subPlotFromNDC(this._yScale.lookup(yDataItem, this._yBin), 2 /* Y */)) -
                            yOff) - (dim.height / 2) + yAutoOffsets[i];
                        RichTextRenderer.writeRichText(ctx, cps, ~~x, ~~y, markerFont, 2 /* CENTER */, preparedText);
                    }
                }
            }
            ctx.restore();
        };
        BaseDrawStyle.prototype._setUpMarkerAutoPositionOptions = function (plotRenderManager) {
            var dimension = (this.series.seriesMarkerAutoPositionMode === 1 /* SERIES_X */) ? 1 /* X */ : 2;
            var directionIsPositive = (this.series.seriesMarkerAutoPositionDirection === 0 /* POSITIVE */);
            var direction = directionIsPositive ? 0 /* POSITIVE */ : 1;
            var autoPositionerOptions = new AutoPositionerOptions(dimension, false, direction, 0);
            return autoPositionerOptions;
        };
        BaseDrawStyle.prototype._calcMarkerAutoPositionOffset = function (plotRenderManager, rect, options) {
            var markerAutoPositionMode = this.series.seriesMarkerAutoPositionMode;
            var isAnnotationMode = markerAutoPositionMode === 0;
            if (isAnnotationMode && !this.series.isAnnotation) {
                return { x: 0, y: 0 };
            }
            var rectCache = isAnnotationMode ? plotRenderManager.allSeriesMarkerRects : plotRenderManager.nonAnnotationSeriesMarkerRects;
            var autoPositioner = new AutoPositionerOverlapEliminating(plotRenderManager);
            var useSimpleAutoPosition = this.series.seriesMarkerAutoPositionDirection !== 2;
            var minX = plotRenderManager.plot.subPlotFromNDC(0, 1 /* X */);
            var maxX = plotRenderManager.plot.subPlotFromNDC(1, 1 /* X */);
            var minY = plotRenderManager.plot.subPlotFromNDC(1, 2 /* Y */);
            var maxY = plotRenderManager.plot.subPlotFromNDC(0, 2 /* Y */);
            var boundaryRect = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
            var autoPositionResult;
            if (useSimpleAutoPosition) {
                autoPositionResult = autoPositioner.calcAutoPositionOffsetInOneDirection(rect, rectCache, boundaryRect, options);
                if (!autoPositionResult.isSuccess && isAnnotationMode) {
                    var optionsInOppositeDirection = options.createOptionsWithReverseDirection();
                    autoPositionResult = autoPositioner.calcAutoPositionOffsetInOneDirection(rect, rectCache, boundaryRect, optionsInOppositeDirection);
                }
            }
            else {
                autoPositionResult = plotRenderManager.calcProgressiveAutoPositionOffset(rect, rectCache, boundaryRect, options);
            }
            return autoPositionResult.offset;
        };
        BaseDrawStyle.prototype._getStepSize = function () {
            var size = (this.series.getData(2 /* Y */) != null) ?
                this.series.getData(2 /* Y */).statistics.countValid :
                this.series.size;
            var step = this.series.computeLabelSampling(size);
            switch (this.series.getEffectiveDrawStyle()) {
                case 28 /* VERTRECT */:
                case 29 /* HORZRECT */:
                case 27 /* RECT */:
                case 32 /* LINES */:
                    step = 2;
                    break;
            }
            return step;
        };
        BaseDrawStyle.prototype._getValues = function (index) {
            if (index < 0 || index >= this.series.size) {
                return null;
            }
            var y1 = this._yData.getAt(index);
            var x1 = this._xData.getAt(index);
            var y2;
            var x2;
            switch (this.series.drawStyle) {
                case 28 /* VERTRECT */:
                case 29 /* HORZRECT */:
                case 27 /* RECT */:
                    y2 = this._yData.getAt(index + 1);
                    x2 = this._xData.getAt(index + 1);
                    break;
                default:
                    x2 = x1;
                    y2 = y1;
            }
            return {
                x1s: [x1],
                x2s: [x2],
                y1s: [y1],
                y2s: [y2]
            };
        };
        BaseDrawStyle.prototype._getLabel = function (index, compiledValue) {
            if (index < 0 || index >= this.series.size) {
                return null;
            }
            var str = RichTextString.Empty;
            if (!(this.series.getInteractivityStatus() & 8 /* TEXTEDITING */)) {
                str = compiledValue.fromValueRT({ seriesIndex: index });
            }
            else {
                var data = void 0;
                if (data = this.series.getData(0 /* VALUE */)) {
                    if (data.getSize() > 0) {
                        str = new RichTextString(data.getStringAt(0).replace(/<FDSBR>/g, '\n'));
                    }
                }
            }
            return { strings: [str] };
        };
        BaseDrawStyle.prototype.drawTextToBuffer = function (prm, ctx, delay) {
            if (delay === void 0) { delay = true; }
            // reset/set up pixel points
            this.root.seriesLabelPixelPoints[this.series.id] = [];
            if (!(isSeries(this.series) && this.series.seriesValue) || !this._canDrawLabels()) {
                return;
            }
            // save for use later
            var isRefLine = this.series.isAnnotation && (this.series.drawStyle === 16 /* VERTICAL */ ||
                this.series.drawStyle === 17 /* HORIZONTAL */);
            var xData = this._xData.data;
            var yData = this._yData.data;
            var xOff = scaleByDevicePixelRatio(this.series.seriesValueXOffset);
            var yOff = scaleByDevicePixelRatio(this.series.seriesValueYOffset);
            var valuePropertyObj = this.series.properties.compilePropertyString(this.series.seriesValueText);
            var labelStyle = this.series.seriesValueStyle;
            var effectiveDrawStyle = this.series.getEffectiveDrawStyle();
            var isPieDrawStyle = effectiveDrawStyle === 19 /* PIE */ || effectiveDrawStyle === 36;
            var isColStyle = isVerticalBarType(effectiveDrawStyle) ||
                effectiveDrawStyle === 4 /* RANGEBAR */ ||
                effectiveDrawStyle === 61;
            var isBarStyle = isHorizonalBarType(effectiveDrawStyle);
            var _a = this.computeWorldBarBases(), ndcX = _a.ndcX, ndcY = _a.ndcY;
            var baseY = prm.plot.subPlotFromNDC(ndcY, 2 /* Y */);
            var baseX = prm.plot.subPlotFromNDC(ndcX, 1 /* X */);
            // set up pie stuff if necessary
            var doPieStuff = isPieDrawStyle && this.series.pieDesc.piePercent;
            var total = 0;
            var pieFormatter;
            if (doPieStuff) {
                pieFormatter = new FDSFormat();
                pieFormatter.setNumberFormat(this.series.pieDesc.percentFormat);
                total = this.series.getData(2 /* Y */).dataSetSumOfAbsoluteVals(0);
            }
            var seriesSize = this.series.size;
            var step = this._getStepSize();
            // check if we have enough stuff in the position array
            var usePositionArray = this._labelPositions.length > 0 && (this._labelPositions.length >= seriesSize);
            var labelFont = this.series.seriesLabelFont;
            // when the font width hint isn't specifically set but the box width is, we want the text
            // to wrap = set the font width hint to the box width
            var isDefaultSize = this.series.seriesValueSizingMode !== 0 /* DEFAULT */ &&
                this.series.attributeSet.isDefault('SeriesValueFontWidthHint');
            if (isDefaultSize) {
                labelFont = labelFont.with({ widthHint: this.series.seriesValueWidthHint });
            }
            this.series.annotationTextpoints = [];
            for (var i = 0; i < seriesSize; i += this._step) {
                // don't draw labels on slices that are skipped
                if (isPieDrawStyle) {
                    var pieThis = this;
                    if (pieThis.slices[i].angSlice < pieThis.minSliceAngle) {
                        continue;
                    }
                }
                var _b = this._getValues(i), x1s = _b.x1s, x2s = _b.x2s, y1s = _b.y1s, y2s = _b.y2s;
                var strings = this._getLabel(i, valuePropertyObj).strings;
                if (strings.length !== x1s.length || x1s.length !== x2s.length || x2s.length !== y1s.length ||
                    y1s.length !== y2s.length) {
                    return;
                }
                for (var j = 0; j < strings.length; j++) {
                    var xvalue1 = x1s[j];
                    var xvalue2 = x2s[j];
                    var yvalue1 = y1s[j];
                    var yvalue2 = y2s[j];
                    var value = strings[j];
                    // skip reference line textboxes with no text
                    // value is an RT array so we gotta check the text inside
                    if (value.isEmpty()) {
                        continue;
                    }
                    var passVals = {
                        xval1: xvalue1,
                        xval2: xvalue2,
                        yval1: yvalue1,
                        yval2: yvalue2
                    };
                    var retVals = {
                        x1: 0,
                        x2: baseX,
                        y1: 0,
                        y2: baseY
                    };
                    retVals = this._doCoordinateMath(prm, i, passVals, retVals, undefined);
                    var xPlotPos = retVals.x1;
                    var yPlotPos = retVals.y1;
                    var label = new FDSInfoBox(ctx);
                    var x1 = retVals.x1, x2 = retVals.x2, y1 = retVals.y1, y2 = retVals.y2;
                    if (doPieStuff) {
                        value = value.concat(pieFormatter.formatAsNumber(Math.abs(yvalue1) / total * 100));
                    }
                    if (this.series.seriesValueTextFollowsSeriesColor) {
                        labelFont = labelFont.with({ color: this._getLabelTextColorFromSeriesColor(i, labelFont.color) });
                    }
                    label.update({
                        widthHint: this.series.seriesValueWidthHint,
                        heightHint: this.series.seriesValueHeightHint,
                        sizeMode: this.series.seriesValueSizingMode,
                        clipped: this.series.seriesValueTextClipping,
                        arrow: this.series.seriesValueArrow,
                        arrowSize: this.series.seriesValueArrowSize,
                        arrowRatio: this.series.seriesValueArrowRatio,
                        arrowStyle: this.series.seriesValueArrowStyle,
                        arrowPosition: this.series.seriesValueArrowPosition,
                        FGPen: this.series.seriesLabelPen,
                        BGBrush: this.series.seriesLabelBrush,
                        font: labelFont,
                        arrowLinePen: this.series.seriesArrowLinePen,
                        arrowFGPen: this.series.seriesArrowPen,
                        arrowBGBrush: this.series.seriesArrowBrush,
                        shape: this.series.seriesValueDisplayStyle,
                        annotArrowFrac: this.series.annotationArrowFraction,
                        borderRadius: this.series.seriesValueBorderRadius,
                        text: value
                    }, ctx);
                    if (labelStyle !== 0 /* DEFAULT */) {
                        label.setStyle(labelStyle, ctx); // overwrite certain attributes with the style
                    }
                    // text has to be updated and style adjusted before width and height can be calculated
                    var xPt = void 0, yPt = void 0;
                    if (usePositionArray) {
                        xPt = this._labelPositions[i].x;
                        yPt = this._labelPositions[i].y;
                    }
                    else {
                        xPt = prm.plotRect.x1 + xPlotPos;
                        yPt = prm.plotRect.y1 + yPlotPos;
                    }
                    var x = void 0, y = void 0;
                    if (this.series.seriesValueUsePlotCoordX) {
                        var plotWidth = prm.plotRect.x2 - prm.plotRect.x1;
                        x = ((this.series.seriesValuePlotCoordX * plotWidth) + prm.plotRect.x1) - (label.width / 2);
                        x += xOff;
                    }
                    else {
                        x = (xPt + xOff) - (label.width / 2.0); // center on point
                    }
                    if (this.series.seriesValueUsePlotCoordY) {
                        var plotHeight = prm.plotRect.y2 - prm.plotRect.y1;
                        // subtract since y-coordinates are top-down but this fraction is bottom-up
                        y = prm.plotRect.y2 - (this.series.seriesValuePlotCoordY * plotHeight);
                        y -= yOff;
                    }
                    else {
                        y = yPt - yOff - (label.height / 2.0);
                    }
                    // check and see if the datapoint is in the plot, if not, skip drawing its value
                    if (!this._isPointInPlot(prm, new Point(xPlotPos, yPlotPos)) &&
                        !this.series.seriesValueOutsideDrawnOnEdge) {
                        continue;
                    }
                    var boundingRect = (this.series.seriesValueBoundMode === 1 /* CHART_LEVEL */) ?
                        this.root.chartSubRect
                        :
                            prm.plotRect;
                    if (isPieDrawStyle) {
                        // adjust labels to be on the edge of the pie piece not the center
                        if (xPt < (boundingRect.x2 - boundingRect.x1) / 2) {
                            // left half of the pie
                            x -= label.width / 2;
                        }
                        else {
                            // right half of pie
                            x += label.width / 2;
                        }
                    }
                    else if (isColStyle) {
                        switch (this.series.seriesValuePlacement) {
                            case 1 /* INSIDE */:
                                if (y1 === baseY && baseY === y2) {
                                }
                                else if (y1 >= baseY && y2 >= baseY) {
                                    y -= label.height / 2;
                                }
                                else {
                                    y += label.height / 2;
                                }
                                break;
                            case 2 /* OUTSIDE */:
                                if (y1 === baseY && baseY === y2) {
                                    y -= label.height / 2;
                                }
                                else if (y1 >= baseY && y2 >= baseY) {
                                    y += label.height / 2;
                                }
                                else {
                                    y -= label.height / 2;
                                }
                                break;
                        }
                    }
                    else if (isBarStyle) {
                        switch (this.series.seriesValuePlacement) {
                            case 1 /* INSIDE */:
                                if (x1 === baseX && baseX === x2) {
                                }
                                else if (x1 >= baseX && x2 >= baseX) {
                                    x -= label.width / 2;
                                }
                                else {
                                    x += label.width / 2;
                                }
                                break;
                            case 2 /* OUTSIDE */:
                                if (x1 === baseX && baseX === x2) {
                                    x -= label.width / 2;
                                }
                                else if (x1 >= baseX && x2 >= baseX) {
                                    x += label.width / 2;
                                }
                                else {
                                    x -= label.width / 2;
                                }
                                break;
                        }
                    }
                    // out-of-bounds checks
                    if (x < boundingRect.x1) {
                        x = boundingRect.x1;
                    }
                    if (x + label.width > boundingRect.x2) {
                        x = boundingRect.x2 - label.width;
                    }
                    if (y < boundingRect.y1) {
                        y = boundingRect.y1;
                    }
                    if (y + label.height > boundingRect.y2) {
                        y = boundingRect.y2 - label.height;
                    }
                    var minimumTextSize = new Point(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
                    if (this.series.seriesValueSizingMode === 1 /* CUSTOM_HINT */) {
                        var customWidth = makeEven(Math.max(label.width, this.series.attributeSet.get('SeriesValueWidthHint')));
                        var customHeight = makeEven(Math.max(label.height, this.series.attributeSet.get('SeriesValueHeightHint')));
                        minimumTextSize.x = Math.max(Math.round(customWidth), minimumTextSize.x);
                        minimumTextSize.y = Math.max(Math.round(customHeight), minimumTextSize.y);
                    }
                    if (this.series.isAnnotation) {
                        var origin = Point.zero();
                        // if the text box is given a hint its possible its wider than we tell it to be, so we need to
                        // offset the text box by the difference in the hint and the actual size
                        if (this.series.seriesValueSizingMode === 1 /* CUSTOM_HINT */) {
                            var translationAmount = Point.zero();
                            var customWidth = 0;
                            var customHeight = 0;
                            _c = this._computeOffset(minimumTextSize), customWidth = _c[0], customHeight = _c[1], translationAmount = _c[2];
                            if (translationAmount.x !== 0) {
                                x += translationAmount.x;
                            }
                            if (translationAmount.y !== 0) {
                                y += translationAmount.y;
                            }
                        }
                        else {
                            this.series.minimumWidth = minimumTextSize.x;
                            this.series.minimumHeight = minimumTextSize.y;
                        }
                    }
                    this.series.annotationTextpoints.push(new Point(x + (label.width / 2), y + (label.height / 2)));
                    label.updatePosition(x, y, ctx);
                    label.autoPositionMethod = this.series.seriesValueAutoPositionMethod;
                    var arrowX = void 0, arrowY = void 0;
                    if (this._markerPositions.length >= xData.length) {
                        // use marker positions if they exist
                        var plotParent = this.series.getPlotParent();
                        arrowX = this._markerPositions[i].x + plotParent.plotRect.x1;
                        arrowY = this._markerPositions[i].y + plotParent.plotRect.y1;
                    }
                    else if (this.series.highAnnotation || this.series.lowAnnotation) {
                        arrowX = xPt;
                        if (this.series.highAnnotation) {
                            var maxY = this._yData.Max()[0];
                            arrowY = this.series.getPlotParent().plotRect.y1 +
                                (prm.plot.subPlotFromNDC(this._yScale.lookup(maxY, this._yBin), 2 /* Y */));
                        }
                        if (this.series.lowAnnotation) {
                            var minY = this._yData.Min()[0];
                            arrowY = this.series.getPlotParent().plotRect.y1 +
                                (prm.plot.subPlotFromNDC(this._yScale.lookup(minY, this._yBin), 2 /* Y */));
                        }
                    }
                    else {
                        arrowX = xPt;
                        arrowY = yPt;
                    }
                    label.updateArrow(arrowX, arrowY, ctx);
                    // add hit shapes only if the annotation is not being edited
                    var isTextEditing = (this.series.getInteractivityStatus() & 8 /* TEXTEDITING */) !== 0;
                    var isDraggableSelectable = (this.series.getInteractivityMode() &
                        (2 /* DRAGGABLE */ | 1 /* SELECTABLE */)) !==
                        0;
                    var shouldSaveHitShape = this._setHitVector && !isTextEditing && isDraggableSelectable;
                    var hitShapeId = this.series.hittableShapeIdentifier;
                    if (this.series.seriesValueAutoPosition) {
                        // if the label needs to be autopositioned, save it til later when all labels have
                        // been drawn.
                        // save index and series id for pixel points later
                        label.index = i;
                        label.seriesID = this.series.id;
                        label.saveHitshape = shouldSaveHitShape;
                        label.hitShapeId = hitShapeId;
                        prm.autoPositionBoxes.push(label);
                    }
                    else {
                        // if not, show it now.
                        if (delay) {
                            label.visible = true;
                            // also save it to help autoposition other labels
                            prm.infoboxes.push(label);
                        }
                        else {
                            label.drawArrow(ctx);
                            label.show(ctx);
                        }
                        // because we show it now we can save the hitshape too
                        var rect = new FDSRectangleHitShape(new Rectangle(label.x, label.y, label.x + label.width, label.y + label.height));
                        rect.name = hitShapeId;
                        rect.objectPart = 2 /* SERIESLABEL */;
                        rect.index = i;
                        this.series.hitVector.push(rect);
                        // save pixel point
                        var pixX = ~~(label.x + (label.width / 2));
                        var pixY = ~~(label.y + (label.height / 2));
                        this.root.seriesLabelPixelPoints[this.series.id][i] = { x: pixX, y: pixY };
                    }
                    var width = label.width, height = label.height;
                    if (this.series.getInteractivityStatus() &
                        (2 /* DRAGGING */ | 4 /* SIZING */ | 1 /* SELECTION */)) {
                        if (this.series.getInteractivityMode() & 4 /* RESIZABLE */) {
                            this._drawAnnotationMarkerHitShape(prm, x, y, 14 /* DATAPOINTNW */);
                            this._drawAnnotationMarkerHitShape(prm, x + width, y, 13 /* DATAPOINTNE */);
                            this._drawAnnotationMarkerHitShape(prm, x, y + height, 16 /* DATAPOINTSW */);
                            this._drawAnnotationMarkerHitShape(prm, x + width, y + height, 15 /* DATAPOINTSE */);
                            this._drawAnnotationMarkerHitShape(prm, x + (width / 2), y, 9 /* DATAPOINTN */);
                            this._drawAnnotationMarkerHitShape(prm, x + (width / 2), y + height, 10 /* DATAPOINTS */);
                            this._drawAnnotationMarkerHitShape(prm, x, y + (height / 2), 12 /* DATAPOINTW */);
                            this._drawAnnotationMarkerHitShape(prm, x + width, y + (height / 2), 11 /* DATAPOINTE */);
                        }
                    }
                    this.series.setCurrentAnnotationTextBoxSize(width, height);
                }
            }
            var _c;
        };
        BaseDrawStyle.prototype._computeOffset = function (minimumTextSize) {
            var customWidth = 0;
            var customHeight = 0;
            var translationAmount = Point.zero();
            var offsetSigns = this.series.offsetSigns;
            var heightHint = this.series.attributeSet.get('SeriesValueHeightHint');
            var widthHint = this.series.attributeSet.get('SeriesValueWidthHint');
            var isHorizontal = RMIBelongsToSMG(this.series.initialHitShapeId, 13 /* EAST */) ||
                RMIBelongsToSMG(this.series.initialHitShapeId, 3 /* WEST */);
            _a = this._updateTranslationAmount(customWidth, minimumTextSize.x, isHorizontal, widthHint, offsetSigns.x, translationAmount.x, this._useHorizontalMargins), customWidth = _a[0], translationAmount.x = _a[1];
            var isVertical = RMIBelongsToSMG(this.series.initialHitShapeId, 7 /* NORTH */) ||
                RMIBelongsToSMG(this.series.initialHitShapeId, 11 /* SOUTH */);
            _b = this._updateTranslationAmount(customHeight, minimumTextSize.y, isVertical, heightHint, offsetSigns.y, translationAmount.y, this._useVerticalMargins), customHeight = _b[0], translationAmount.y = _b[1];
            return [customWidth, customHeight, translationAmount];
            var _a, _b;
        };
        BaseDrawStyle.prototype._updateTranslationAmount = function (customSize, minimumTextSize, directionStatus, sizeHint, offsetSignal, translationAmount, useMargins) {
            var margin = 0;
            if (useMargins) {
                margin = Math.round(this.series.seriesValueDisplayMargins * 2);
            }
            if ((minimumTextSize > sizeHint) &&
                ((this.series.altKeyDownWhileInteracting && directionStatus) || !this.series.altKeyDownWhileInteracting)) {
                customSize = minimumTextSize + margin;
                if (!this.series.controlKeyDownWhileInteracting &&
                    ((this.series.altKeyDownWhileInteracting && directionStatus) || !this.series.altKeyDownWhileInteracting)) {
                    var tmpOffset = ((sizeHint + margin) - customSize) * 0.5;
                    translationAmount = -Math.round(offsetSignal * tmpOffset);
                }
            }
            else {
                customSize = Math.round(sizeHint + margin);
            }
            return [customSize, translationAmount];
        };
        BaseDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
        };
        BaseDrawStyle.prototype._getNDCReferenceFromAxis = function (value, dimension) {
            var axis = this.series.getAxis(dimension);
            var scale = axis.getScale();
            if (dimension === 1 /* X */ && !this.series.attributeSet.isInheritedDefault('SeriesXReference')) {
                return scale.lookup(this.series.seriesXReference, this._xBin);
            }
            else if (dimension === 2 /* Y */ && !this.series.attributeSet.isInheritedDefault('SeriesYReference')) {
                return scale.lookup(this.series.seriesYReference, this._yBin);
            }
            else if (!axis.attributeSet.isInheritedDefault('Reference')) {
                return scale.lookup(axis.reference);
            }
            else {
                return scale.lookup(value);
            }
        };
        // function to check if the data present is valid for this drawstyle
        BaseDrawStyle.prototype.verify = function () {
            return true;
        };
        // returns the DrawStyle.o fall back on if this drawStyle isn't valid
        BaseDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        // make a function for it since the same logic is done here and in the legend preview
        // returns [bgbrush, seriesOutlinePenProps]
        BaseDrawStyle.prototype.configureMarkerPens = function (isMarkerStyle, isSimpleMarker, ctx, legend) {
            if (legend === void 0) { legend = false; }
            // use a special thin pen to draw the legend
            // marker style has different coloring
            var newPen;
            var newBrush;
            var props;
            if (isMarkerStyle) {
                if (isSimpleMarker) {
                    newPen = this.series.seriesFGPen;
                    newBrush = new FDSBrush();
                    newBrush.color = this.series.seriesFGPen.color;
                    newBrush.style = 0 /* SOLID */;
                    props = this.series.seriesFGPen.toPropertyObject();
                }
                else {
                    newPen = this.series.seriesOutlinePen;
                    newBrush = this.series.seriesBGBrush;
                    props = this.series.seriesOutlinePen.toPropertyObject();
                }
            }
            else {
                if (isSimpleMarker) {
                    newPen = this.series.seriesMarkerFGPen;
                    newBrush = new FDSBrush();
                    newBrush.color = this.series.seriesMarkerFGPen.color;
                    newBrush.style = 0 /* SOLID */;
                    props = this.series.seriesMarkerFGPen.toPropertyObject();
                }
                else {
                    newPen = this.series.seriesMarkerOutlinePen;
                    newBrush = this.series.seriesMarkerBGBrush;
                    props = this.series.seriesMarkerOutlinePen.toPropertyObject();
                }
            }
            if (legend) {
                newPen = newPen.with({ width: 1 });
            }
            newPen.setOnCanvas(ctx);
            newBrush.setOnCanvas(ctx);
            return [newBrush, props];
        };
        // Handles anti-aliasing correctly in the marker.
        BaseDrawStyle.prototype.drawOutlierMarkerCorrectly = function (ctx, markerX, markerY, markerStyle, markerSize) {
            var props = this.series.seriesOutlierIndicatorFGPen.toPropertyObject();
            var aliasOffset = props.aliasOffset;
            markerX += aliasOffset;
            markerY += aliasOffset;
            var drawFunc = getMarkerDrawFunctor(markerStyle, markerSize, props.willDrawStroke);
            if (drawFunc) {
                ctx.beginPath();
                drawFunc(ctx, markerX, markerY);
                ctx.fill();
                ctx.stroke();
            }
        };
        // takes in a pen (with a default color already set) and changes its color
        // according to the colormap settings if necessary
        BaseDrawStyle.prototype._setColorMapColor = function (ctx, object, proposedColor, index, rect) {
            if (rect === void 0) { rect = undefined; }
            if (this.series.useColor) {
                var newColor = this._calcColorMapColor(object.color, proposedColor, index);
                if (object instanceof FDSPen) {
                    object = object.with({ color: newColor });
                }
                else if (object instanceof FDSFont) {
                    object = object.with({ color: newColor });
                }
                else if (object instanceof FDSBrush) {
                    object.pushHistory();
                    if (this.series.useColor) {
                        object.setAttr('color', this._calcColorMapColor(object.color, proposedColor, index));
                    }
                    this._colorsMapNum += 1;
                }
                object.setOnCanvas(ctx, rect);
            }
        };
        BaseDrawStyle.prototype._resetColorMapColor = function (object) {
            while (this._colorsMapNum > 0) {
                if (object instanceof FDSBrush) {
                    object.popHistory();
                }
                this._colorsMapNum -= 1;
            }
        };
        BaseDrawStyle.prototype._calcColorMapColor = function (defaultColor, proposedColor, index) {
            var color = defaultColor;
            if (this.series.useColor && !IsSomeNAN(proposedColor)) {
                if (this.series.useColorMap) {
                    var cScale = (this.series.getAxis(4 /* COLOR */)).scale;
                    color = this.series.colorMap.getColor(cScale.lookup(proposedColor)).getCOLORREF();
                }
                else if (this.series.useColorIndex) {
                    if (proposedColor === -1 /* Up */) {
                        color = this.series.seriesColorUp;
                    }
                    else if (proposedColor === -2 /* Down */) {
                        color = this.series.seriesColorDown;
                    }
                    else if (proposedColor === -3 /* Neutral */) {
                        color = this.series.seriesColorNeutral;
                    }
                    else {
                        color = this.series.getSeriesColor(proposedColor);
                    }
                }
                else if (this.series.cycleColorIndex) {
                    color = this.series.getSeriesColor(index);
                }
                else {
                    color = proposedColor;
                }
            }
            return color;
        };
        BaseDrawStyle.prototype.computeWorldBarBases = function () {
            var xAxis = this.series.getAxis(1 /* X */);
            var yAxis = this.series.getAxis(2 /* Y */);
            var minNDCX = this._xScale.applyPlotFactorNDC(0);
            var maxNDCX = this._xScale.applyPlotFactorNDC(1);
            var minNDCY = this._yScale.applyPlotFactorNDC(0);
            var maxNDCY = this._yScale.applyPlotFactorNDC(1);
            var xdef = true;
            var ndcX = minNDCX;
            var worldX = this._xScale.min;
            var ydef = true;
            var ndcY = minNDCY;
            var worldY = this._yScale.min;
            if (!this.series.attributeSet.isInheritedDefault('SeriesYReference')) {
                worldY = this.series.seriesYReference;
                ydef = false;
            }
            else if (!yAxis.attributeSet.isInheritedDefault('Reference')) {
                worldY = yAxis.reference;
                ydef = false;
            }
            if (!this.series.attributeSet.isInheritedDefault('SeriesXReference')) {
                worldX = this.series.seriesXReference;
                xdef = false;
            }
            else if (!xAxis.attributeSet.isInheritedDefault('Reference')) {
                worldX = xAxis.reference;
                xdef = false;
            }
            if (ydef) {
                ndcY = this._yScale.reverse ? maxNDCY : minNDCY;
            }
            else {
                ndcY = this._yScale.lookup(worldY);
            }
            if (xdef) {
                ndcX = this._xScale.reverse ? maxNDCX : minNDCX;
            }
            else {
                ndcX = this._xScale.lookup(worldX);
            }
            return {
                ndcX: ndcX,
                ndcY: ndcY,
                worldX: worldX,
                worldY: worldY
            };
        };
        // Determines the correct reference value for a scale for use with Outliers.
        BaseDrawStyle.prototype.computeReference = function () {
            var xAxis = this.series.getAxis(1 /* X */);
            var yAxis = this.series.getAxis(2 /* Y */);
            // worldX,worldY are just Scale Min by default.
            var worldX = this._xScale.min;
            var worldY = this._yScale.min;
            // First we see if the series reference is non-default, if not fall back to axis.
            // If everything fails, we just use the scale min.
            if (!this.series.attributeSet.isInheritedDefault('SeriesXReference')) {
                worldX = this.series.seriesXReference;
            }
            else if (!xAxis.attributeSet.isInheritedDefault('Reference')) {
                worldX = xAxis.reference;
            }
            if (!this.series.attributeSet.isInheritedDefault('SeriesYReference')) {
                worldY = this.series.seriesYReference;
            }
            else if (!yAxis.attributeSet.isInheritedDefault('Reference')) {
                worldY = yAxis.reference;
            }
            return [worldX, worldY];
        };
        // Determines the offset for a segment of the stacked bar or column.
        BaseDrawStyle.prototype.stackSegmentDistance = function (prm, dim, stackPoint, includeCurrent) {
            var otherDim;
            if (dim === 1 /* X */) {
                otherDim = 2 /* Y */;
            }
            else if (dim === 2 /* Y */) {
                otherDim = 1 /* X */;
            }
            else {
                return [0, 0];
            }
            var sumPos = 0;
            var sumNeg = 0;
            // Determine the starting position for this piece of the bar/column
            var list = prm.plotSeries;
            for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                var pSeries = list_1[_i];
                // don't include the current one in the result
                if (!includeCurrent && pSeries === this.series) {
                    break;
                }
                var effectiveDrawStyle = pSeries.getEffectiveDrawStyle();
                var isValidXDrawStyle = dim === 1 /* X */ && isHorizonalBarType(effectiveDrawStyle);
                var isValidYDrawStyle = dim === 2 /* Y */ && isVerticalBarType(effectiveDrawStyle);
                // skip this series if its not stacked in the dimension we are currently processing
                if (!(isValidXDrawStyle || isValidYDrawStyle)) {
                    continue;
                }
                // not stacked or binned with us
                if ((!pSeries.isStacked) || (pSeries.barNumber !== this.series.barNumber)) {
                    continue;
                }
                // first, find the index of the point in this dataset
                var otherData = pSeries.getData(otherDim);
                var loc = undefined;
                var locIndex = undefined;
                for (var i = 0; i < otherData.getSize(); i++) {
                    var dp_1 = otherData.getAt(i);
                    if (dp_1 === stackPoint) {
                        loc = dp_1;
                        locIndex = i;
                        break;
                    }
                }
                // The DP we are interested in isn't on this series
                if (loc == null || locIndex == null) {
                    continue;
                }
                // Now we actually add it
                var dp = pSeries.getData(dim).getAt(locIndex);
                if (!IsSomeNAN(dp)) {
                    if (dp > 0) {
                        sumPos += dp;
                    }
                    else {
                        sumNeg += dp;
                    }
                }
                // We've reached and added ours so break
                if (pSeries === this.series) {
                    break;
                }
            }
            if (dim === 1 /* X */) {
                sumPos = this._xScale.lookup(sumPos, this._xBin);
                sumNeg = this._xScale.lookup(sumNeg, this._xBin);
            }
            else if (dim === 2 /* Y */) {
                sumPos = this._yScale.lookup(sumPos, this._yBin);
                sumNeg = this._yScale.lookup(sumNeg, this._yBin);
            }
            return [sumNeg, sumPos];
        };
        // Takes a point in pixel coordinates, and determines if the point falls inside of the plot
        BaseDrawStyle.prototype._isPointInPlot = function (prm, point, offsetByPlotRect) {
            if (offsetByPlotRect === void 0) { offsetByPlotRect = true; }
            var tPoint = (offsetByPlotRect) ?
                new Point(prm.plotRect.x1 + point.x, prm.plotRect.y1 + point.y)
                :
                    point;
            return prm.plotRect.hit(tPoint);
        };
        // Draws selection markers around all annotations on a selected series.
        // There is no concept of having an individual annotation selected. With drawing tools,
        // we assume one annotation per series to act as a textbox.
        BaseDrawStyle.prototype.drawAnnotationSelectionMarkers = function (prm, ctx) {
            if (!this.series.isSelected()) {
                return;
            }
            if (!this.series.isAnnotation) {
                return;
            }
            ctx.save();
            ctx.translate(prm.plotRect.x1, prm.plotRect.y1);
            var usingDifference = this.root.canvasDifferenceSupported();
            this._setupSelectionMarkerPenAndBrush(usingDifference, ctx);
            for (var _i = 0, _a = this.series.hitVector; _i < _a.length; _i++) {
                var box = _a[_i];
                if (!isShapeAnnotRectangle(box)) {
                    continue;
                }
                var x = box.x - prm.plotRect.x1;
                var y = box.y - prm.plotRect.y1;
                var width = box.width;
                var height = box.height;
                this.root.interactionHandlePixelPoints[this.series.id] = [];
                this._simpleMarker(ctx, prm, x, y, false, !usingDifference);
                this._simpleMarker(ctx, prm, x + width, y + height, false, !usingDifference);
                this._simpleMarker(ctx, prm, x, y + height, false, !usingDifference);
                this._simpleMarker(ctx, prm, x + width, y, false, !usingDifference);
                this._simpleMarker(ctx, prm, x + (width / 2), y + height, false, !usingDifference);
                this._simpleMarker(ctx, prm, x + (width / 2), y, false, !usingDifference);
                this._simpleMarker(ctx, prm, x, y + (height / 2), false, !usingDifference);
                this._simpleMarker(ctx, prm, x + width, y + (height / 2), false, !usingDifference);
            }
            ctx.restore();
        };
        // Simple marker for selection markers. Circle is assumed to be interactive, square is not.
        BaseDrawStyle.prototype._simpleMarker = function (ctx, prm, x, y, isCircle, willDrawStroke) {
            if (!this._isPointInPlot(prm, new Point(x, y))) {
                return;
            }
            var circleSize = this.series.interactionHandleSize;
            var selectionMarkerSize = this.root.selectableItemPointMarkerSize;
            var selectionMarkerFunctor = getMarkerDrawFunctor(this.root.selectableItemPointMarkerType, selectionMarkerSize, willDrawStroke);
            var circleMarkerFunctor = getMarkerDrawFunctor(1 /* CIRCLE */, circleSize * 2);
            ctx.beginPath();
            if (isCircle) {
                circleMarkerFunctor(ctx, x, y);
            }
            else {
                selectionMarkerFunctor(ctx, x, y);
            }
            ctx.fill();
            if (willDrawStroke) {
                ctx.stroke();
            }
            // save pixel points for all selected points
            x = Math.round(x + prm.plotRect.x1);
            y = Math.round(y + prm.plotRect.y1);
            this.root.interactionHandlePixelPoints[this.series.id].push({ x: x, y: y });
        };
        // Draws a hitshape for an annotation selection marker
        BaseDrawStyle.prototype._drawAnnotationMarkerHitShape = function (prm, x, y, type) {
            var selectionMarkerSize = DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var hitRect = new FDSRectangleHitShape(x - selectionMarkerSize, y - selectionMarkerSize, selectionMarkerSize * 2, selectionMarkerSize * 2);
            hitRect.index = 0;
            hitRect.name = type;
            this.series.hitVector.push(hitRect);
        };
        // fills the points passed in. Relies on setting the state of the context previously
        BaseDrawStyle.prototype.fillPolygon = function (ctx, points) {
            if (points.length <= 0) {
                return;
            }
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (var i = 0; i < points.length; i++) {
                var pt = points[i];
                if (i === 0) {
                    continue;
                }
                ctx.lineTo(pt.x, pt.y);
            }
            ctx.fill();
        };
        BaseDrawStyle.prototype.strokePolyline = function (ctx, pen, points) {
            if (points.length <= 0) {
                return;
            }
            ctx.beginPath();
            pen.closePolyline();
            ctx.moveTo(points[0].x, points[0].y);
            var lastPt = points[0];
            for (var i = 0; i < points.length; i++) {
                var pt = points[i];
                if (i === 0) {
                    continue;
                }
                pen.drawPolyline(ctx, lastPt, pt);
                lastPt = pt;
            }
            ctx.stroke();
            pen.closePolyline();
        };
        BaseDrawStyle.prototype.cacheSelectableInChartSpace = function (prm, hitname, point) {
            if (!isBounded(point.x, prm.plotRect.x1, prm.plotRect.x2)) {
                return;
            }
            if (!isBounded(point.y, prm.plotRect.y1, prm.plotRect.y2)) {
                return;
            }
            this._selectablePointCache.push({ pt: point, type: hitname });
        };
        BaseDrawStyle.prototype.cacheSelectable = function (prm, hitname, _p, _y) {
            if (_.isNumber(_p)) {
                _p = new Point(_p, _y);
            }
            _p.x += prm.plotRect.x1;
            _p.y += prm.plotRect.y1;
            this.cacheSelectableInChartSpace(prm, hitname, _p);
        };
        BaseDrawStyle.prototype.autoPositionLabels = function (labels, prm, ctx) { return false; };
        BaseDrawStyle.prototype._getLabelTextColorFromSeriesColor = function (index, defaultColor) {
            var labelFontColor = defaultColor;
            if (this.series.isAnnotation) {
                var seriesParent = this.series.getSeriesParent();
                if (seriesParent) {
                    labelFontColor = seriesParent.calculatedSeriesColor;
                }
            }
            else {
                labelFontColor = this.series.calculatedSeriesColor;
                if (this._colorData && this.series.useColor) {
                    var proposedColor = this._colorData.getAt(index);
                    labelFontColor = this._calcColorMapColor(labelFontColor, proposedColor, index);
                }
            }
            return labelFontColor;
        };
        BaseDrawStyle.prototype._isMarkerDrawStyle = function () {
            return false;
        };
        BaseDrawStyle.prototype._shouldSkipSeriesDataItemIndex = function (i) {
            return false;
        };
        // Implemented in TreemapDrawStyle and ChoroplethDrawStyle
        BaseDrawStyle.prototype.getColorScaleRange = function () {
            return undefined;
        };
        // Implemented in Area and old Columns
        BaseDrawStyle.prototype.getStackedYPosition = function (prm, xData) {
            return undefined;
        };
        BaseDrawStyle.prototype._canDrawLabels = function () {
            return true;
        };
        BaseDrawStyle.prototype.getClickTooltipArrowPoint = function (x, y, index) {
            var seriesInfoboxPixelPoints = this.series.root.infoboxPixelPoints[this.series.id];
            if (seriesInfoboxPixelPoints && seriesInfoboxPixelPoints[index]) {
                return seriesInfoboxPixelPoints[index];
            }
            var parent = this.series.getPlotParent();
            var arrowX = getDimensionPixelPositionFromIndex(this.series, index, 1 /* X */) + parent.plotRect.x1;
            var arrowY = getDimensionPixelPositionFromIndex(this.series, index, 2 /* Y */) + parent.plotRect.y1;
            return { point: new Point(arrowX, arrowY), position: "above" /* above */ };
        };
        return BaseDrawStyle;
    }());
    
    var HSLMAX = 240;
    // stores rgb values as floats from 0 to 1
    // only converts to 0-255 system when getHex is called
    var FDSColor = /** @class */ (function () {
        function FDSColor(r, g, b) {
            if (r === void 0) { r = -1; }
            if (g === void 0) { g = -1; }
            if (b === void 0) { b = -1; }
            if (g === -1 || b === -1 || r === -1) {
                if (r === -1) {
                    // default values
                    this.r = this.g = this.b = 0;
                }
                else {
                    // just r passed in - it's a colorref
                    _a = COLORREFtoRGB(r), r = _a[0], g = _a[1], b = _a[2];
                    _b = [r / 255, g / 255, b / 255], this.r = _b[0], this.g = _b[1], this.b = _b[2];
                }
            }
            else {
                // more than one value passed in - assign those to r, g, and b
                this.r = r;
                this.g = g;
                this.b = b;
            }
            var _a, _b;
        }
        // converts RGB to hex, maybe faster? who knows in javascript tho
        FDSColor.prototype._fastRGBtoHex = function (r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        };
        FDSColor.prototype.lightenByFactor = function (factor) {
            var _a = RGBtoHSL(this.r, this.g, this.b), h = _a[0], s = _a[1], l = _a[2];
            var scaled_l = l * factor;
            if (l > 0.99) {
                scaled_l = 0.99;
            }
            if (l < 0.0) {
                scaled_l = 0.0;
            }
            return _b = HSLtoRGB(h, s, scaled_l), this.r = _b[0], this.g = _b[1], this.b = _b[2], _b;
            var _b;
        };
        FDSColor.prototype.lightenByPercent = function (percent) {
            var _a = RGBtoHSL(this.r, this.g, this.b), h = _a[0], s = _a[1], l = _a[2];
            var lightened = l;
            if (percent > 0) {
                lightened += (1 - l) * percent / 100.0;
            }
            else {
                lightened -= l * (percent / -100.0);
            }
            return _b = HSLtoRGB(h, s, clamp(lightened, 0, 1)), this.r = _b[0], this.g = _b[1], this.b = _b[2], _b;
            var _b;
        };
        FDSColor.prototype.getHex = function () {
            return this._fastRGBtoHex(~~(255 * this.r), ~~(255 * this.g), ~~(255 * this.b));
        };
        FDSColor.prototype.getCOLORREF = function () {
            return RGBtoCOLORREF(this.r * 255, this.g * 255, this.b * 255);
        };
        // function to get a contrasting color to this one
        // https://stackoverflow.com/questions/3942878/how-to-decide-font-color-in-white-or-black-depending-on-background-color
        // with a modified threshold. The 165 was based on trial-and-error with the series colors + maximum contrast
        // quick label text so the text color matched what app design felt was appropriate.
        FDSColor.prototype.getContrastYIQ = function () {
            var colorBrightness = ((this.r * 299 * 255) + (this.g * 587 * 255) + (this.b * 114 * 255)) / 1000;
            if (colorBrightness >= 165) {
                return 0 /* BLACK */;
            }
            else {
                return 16777215 /* WHITE */;
            }
        };
        FDSColor.invert = function (colorRef) {
            var _a = COLORREFtoRGB(colorRef), r = _a[0], g = _a[1], b = _a[2];
            return RGBtoCOLORREF(255 - r, 255 - g, 255 - b);
        };
        FDSColor.adjustLightnessByFactor = function (colorRef, factor, threshold, scale) {
            var scaleFactorByLightness = function (light, origFactor) {
                if (Math.abs(light - 120) >= threshold) {
                    return origFactor * (1 + scale * (Math.abs(light - 120) - threshold) / (120.0 - threshold));
                }
                return origFactor;
            };
            var scaleFactorBySaturation = function (sat, light, origFactor) {
                var lightScale = (120.0 - Math.abs(light - 120.0)) / 120.0;
                return origFactor * (1 + lightScale * 1.0 * (sat / HSLMAX));
            };
            var _a = COLORREFtoHSL(colorRef), hue = _a[0], sat0 = _a[1], light0 = _a[2];
            // convert to ints in [0,HSLMAX]
            var sat = Math.round(sat0 * HSLMAX);
            var light = Math.round(light0 * HSLMAX);
            if (light > 120) {
                factor *= -1;
            }
            factor = scaleFactorBySaturation(sat, light, factor);
            factor = scaleFactorByLightness(light, factor);
            light += factor * HSLMAX;
            light = clamp(light, 0, HSLMAX);
            // restore to fractions
            sat = sat / HSLMAX;
            light = light / HSLMAX;
            return HSLtoCOLORREF(hue, sat, light);
        };
        return FDSColor;
    }());
    
    /**
     * Class for the polygon hitshape
     *
     * @class FDSPolygonHitShape
     * @extends {FDSShape}
     */
    var FDSPolygonHitShape = /** @class */ (function (_super) {
        __extends(FDSPolygonHitShape, _super);
        // @param points [Array<Point>] a list of points defining the border of the shape
        /**
         * Creates an instance of FDSPolygonHitShape.
         *
         * @param points - a list of points defining the border of the shape
         */
        function FDSPolygonHitShape(points) {
            var _this = _super.call(this) || this;
            _this.name = 'FDSPolygonHitShape';
            _this.points = points;
            return _this;
        }
        /**
         * Test if the polygon intersects a given rectangle
         *
         * @param x1 - the x-coordinate of the first corner
         * @param y1 - the y-coordinate of the first corner
         * @param x2 - the x-coordinate of the second corner
         * @param y2 - the y-coordinate of the second corner
         * @returns true if the rectangle overlaps the polygon
         */
        FDSPolygonHitShape.prototype.hitTest = function (x1, y1, x2, y2) {
            // two possible cases for intersection - either lines intersect, or one of the points is inside the other shape
            // make points for the rectangle for convenience
            var rpts = [new Point(x1, y1), new Point(x2, y1), new Point(x2, y2), new Point(x1, y2)];
            // first check if any polygon points are inside the rectangle (easiest check)
            for (var _i = 0, _a = this.points; _i < _a.length; _i++) {
                var p = _a[_i];
                if (p.x >= Math.min(x1, x2) && p.x <= Math.max(x1, x2) && p.y >= Math.min(y1, y2) && p.y <= Math.max(y1, y2)) {
                    return true;
                }
            }
            // next check if any rect points are inside the polygon (trickier check but only 4 points)
            for (var _b = 0, rpts_1 = rpts; _b < rpts_1.length; _b++) {
                var p = rpts_1[_b];
                if (this.onHitTest(p.x, p.y)) {
                    return true;
                }
            }
            // finally check if any rectangle sides intersect any polygon sides (most expensive check)
            // loop over every side
            for (var i = 0; i < this.points.length; i++) {
                var p1 = this.points[i];
                var p2 = i === this.points.length - 1 ? this.points[0] : this.points[i + 1];
                // compare to each side of the rectangle
                for (var j = 0; j < rpts.length; j++) {
                    var q1 = rpts[j];
                    var q2 = j === rpts.length - 1 ? rpts[0] : rpts[j + 1];
                    if (this._findIntersect(p1, p2, q1, q2) !== undefined) {
                        return true;
                    }
                }
            }
            // if you got this far, nothing intersects
            return false;
        };
        // test if two lines intersect
        // @param p1,p2,q1,q2 [Point] the endpoints of the lines being tested
        // @return [Point] the intersection point, undefined if none
        /**
         * test if two line segements intersect
         * TODO: see if we can replace this with FDSLineHitShape.tryGetIntersection
         *
         * @param p1 - the start point of the first line segment
         * @param p2 - the end point of the first line segment
         * @param q1 - the start point of the second line segment
         * @param q2 - the end point of the second line segment
         * @returns (description)
         */
        FDSPolygonHitShape.prototype._findIntersect = function (p1, p2, q1, q2) {
            if (!(p1 && p2 && q1 && q2)) {
                return undefined;
            }
            // adjust for y not being reversed
            var adjust = Math.max(p1.y, p2.y, q1.y, q2.y);
            var p1y = adjust - p1.y;
            var p2y = adjust - p2.y;
            var q1y = adjust - q1.y;
            var q2y = adjust - q2.y;
            if (p1.x === p2.x) {
                // vertical line
                var r = this._findVerticalIntersect(q1, q2, p1.x);
                if (r && r.y >= Math.min(p1.y, p2.y) && r.y <= Math.max(p1.y, p2.y)) {
                    return r;
                }
                else {
                    return undefined;
                }
            }
            var m1 = (p1y - p2y) / (p1.x - p2.x);
            if (q1.x === q2.x) {
                // vertical line
                var r = this._findVerticalIntersect(p1, p2, q1.x);
                if (r && r.y >= Math.min(q1.y, q2.y) && r.y <= Math.max(q1.y, q2.y)) {
                    return r;
                }
                else {
                    return undefined;
                }
            }
            var m2 = (q1y - q2y) / (q1.x - q2.x);
            // pick some points to work with
            var x1 = p1.x;
            var y1 = p1y;
            var x2 = q1.x;
            var y2 = q1y;
            if (m1 === m2) {
                // parallel or overlapping lines
                // check if they're disjoint
                var y_1 = (m2 * x1) - (m2 * x2) + y2;
                if (y_1 !== y1) {
                    return undefined;
                }
                // check if they overlap in the same segment
                if (q1.x >= Math.min(p1.x, p2.x) && q1.x <= Math.max(p1.x, p2.x)) {
                    return q1;
                }
                if (q2.x >= Math.min(p1.x, p2.x) && q2.x <= Math.max(p1.x, p2.x)) {
                    return q2;
                }
                if (p1.x >= Math.min(q1.x, q2.x) && p1.x <= Math.max(q1.x, q2.x)) {
                    return p1;
                }
                if (p2.x >= Math.min(q1.x, q2.x) && p2.x <= Math.max(q1.x, q2.x)) {
                    return p2;
                }
                // two disjoint segments of the same line
                return undefined;
            }
            var x = ((m2 * x1) - y2 + y1 - (m1 * x1)) / (m2 - m1);
            var y = adjust - ((m2 * x1) - (m2 * x2) + y2);
            // make sure it's in bounds
            if (x < Math.min(p1.x, p2.x) || x > Math.max(p1.x, p2.x)) {
                return undefined;
            }
            else if (x < Math.min(q1.x, q2.x) || x > Math.max(q1.x, q2.x)) {
                return undefined;
            }
            else if (y < Math.min(p1.y, p2.y) || y > Math.max(p1.y, p2.y)) {
                return undefined;
            }
            else if (y < Math.min(q1.y, q2.y) || y > Math.max(q1.y, q2.y)) {
                return undefined;
            }
            else {
                return new Point(x, y);
            }
        };
        /**
         * Given a shape (this polygon) and a rectangle that is overlapping it, provide
         * a shift in either the positive or negative y direction to avoid the shape.
         *
         * @param x1 - the x-coordinate of the first corner
         * @param y1 - the y-coordinate of the first corner
         * @param x2 - the x-coordinate of the second corner
         * @param y2 - the y-coordinate of the second corner
         * @param moveUp - whether the shift should be upwards (negative Y)
         * @returns the amount to shift in the given direction in pixels
         */
        FDSPolygonHitShape.prototype.getAvoidanceOffset = function (x1, y1, x2, y2, moveUp) {
            var p1 = new Point(x1, y1);
            var p2 = new Point(x2, y2);
            var pts = [];
            // loop over every side
            for (var i = 0; i < this.points.length; i++) {
                var q1 = this.points[i];
                var q2 = void 0;
                if (i === this.points.length - 1) {
                    q2 = this.points[0]; // loop around
                }
                else {
                    q2 = this.points[i + 1];
                }
                var intersection = this._findVerticalIntersect(q1, q2, p1.x);
                if (intersection && this._isCorrectlyPositioned(p1, p2, intersection, moveUp)) {
                    // it's the right direction, we keep it
                    pts.push(intersection);
                }
                // now do the same for the other x point
                intersection = this._findVerticalIntersect(q1, q2, p2.x);
                if (intersection && this._isCorrectlyPositioned(p1, p2, intersection, moveUp)) {
                    pts.push(intersection);
                }
                if (q1.x >= Math.min(p1.x, p2.x) && q1.x <= Math.max(p1.x, p2.x) &&
                    this._isCorrectlyPositioned(p1, p2, q1, moveUp)) {
                    pts.push(q1);
                }
            }
            if (pts.length === 0) {
                // empty array - no points above/below to worry about!
                return moveUp ? -1 : 1;
            }
            // find min or max of array as necessary
            // min when moving down, max when moving up
            var comp = moveUp ? Infinity : -Infinity;
            for (var _i = 0, pts_1 = pts; _i < pts_1.length; _i++) {
                var p = pts_1[_i];
                if ((moveUp && p.y < comp) || (!moveUp && p.y > comp)) {
                    comp = p.y;
                }
            }
            var y = moveUp ? Math.max(p1.y, p2.y) : Math.min(p1.y, p2.y);
            // have to shift at least one
            if (moveUp) {
                return Math.min(-1, comp - y);
            }
            else {
                return Math.max(1, comp - y);
            }
        };
        // @param r1,r2 [Point] the corner points of the rectangle
        // @param p [Point] the point being checked for correct position
        // @param above [Boolean]
        /**
         * helper to tell if one point is correctly above/below a rectangle
         *
         * @param r1 - the first corner of the rectangle
         * @param r2 - the second corner of the rectangle
         * @param p - the point being checked for correct position
         * @param above - fi the point should be above or below
         */
        FDSPolygonHitShape.prototype._isCorrectlyPositioned = function (r1, r2, p, above) {
            // remember, y-coords are backwards
            return (above && p.y <= Math.max(r1.y, r2.y)) || ((!above) && p.y >= Math.min(r1.y, r2.y));
        };
        /**
         * helper function to find an intersect point between a line segment and a vertical line
         *
         * @param p1 - the start point
         * @param p2 - the start point
         * @param x - the x-coordinate of the vertical line
         * @returns the intersection point, or undefined if none
         */
        FDSPolygonHitShape.prototype._findVerticalIntersect = function (p1, p2, x) {
            if (x < Math.min(p1.x, p2.x) || x > Math.max(p1.x, p2.x)) {
                return undefined; // no intersection
            }
            // adjust points to not have backwards y-coords
            var adjust = Math.max(p1.y, p2.y); // lowest point is our new 0
            var p1y = adjust - p1.y;
            var p2y = adjust - p2.y;
            var m = (p1y - p2y) / (p1.x - p2.x);
            if (m === Infinity) {
                // line segment overlaps the vertical line O_O
                // just return the point 1 y coord
                return new Point(x, p1.y);
            }
            var y = m * (x - p1.x) + p1y;
            if (y < Math.min(p1y, p2y) || y > Math.max(p1y, p2y)) {
                return undefined;
            }
            // return to normal coords
            y = adjust - y;
            return new Point(x, y);
        };
        /**
         * test for whether a point is inside this polygon
         * algorithm from http://www.alienryderflex.com/polygon/
         *
         * @param cx - the x-coordinate of the point being tested
         * @param cy - the y-coordinate of the point being tested
         * @returns whether the point is inside the polygon area
         */
        FDSPolygonHitShape.prototype.onHitTest = function (cx, cy) {
            var more = 0;
            var less = 0;
            for (var i = 0; i < this.points.length; i++) {
                var p1 = this.points[i];
                var p2 = void 0;
                if (i === this.points.length - 1) {
                    p2 = this.points[0]; // loop around
                }
                else {
                    p2 = this.points[i + 1];
                }
                var node = this._findNode(p1, p2, cy);
                if (node === undefined) {
                    continue;
                }
                if (node.x < cx) {
                    less = less + 1;
                }
                else if (node.x > cx) {
                    more = more + 1;
                }
                else {
                    return true;
                }
            }
            // if there are an odd number of nodes on either side of the point, it's inside the polygon
            return (less % 2 === 1) && (more % 2 === 1);
        };
        /**
         * helper function to find a node for the above algorithm - an intersect
         * point between a line segment and a horizontal line
         *
         * @param p1 - the start point of the line being tested
         * @param p2 - the end point of the line being tested
         * @param y - the y-coordinate of the horizontal line
         * @returns the intersection point, or undefined if none
         */
        FDSPolygonHitShape.prototype._findNode = function (p1, p2, y) {
            if (y <= Math.min(p1.y, p2.y) || y > Math.max(p1.y, p2.y)) {
                // count intersects on top endpoints but not on bottom ones
                return undefined;
            }
            // adjust points to not have backwards y-coords
            var adjust = Math.max(p1.y, p2.y); // lowest point is our new 0
            y = adjust - y;
            var p1y = adjust - p1.y;
            var p2y = adjust - p2.y;
            var m = (p1y - p2y) / (p1.x - p2.x);
            if (m === 0) {
                // horizontal line doesn't count as an intersect point
                return undefined;
            }
            var x = (y - p1y) / m + p1.x;
            if (x < Math.min(p1.x, p2.x) || x > Math.max(p1.x, p2.x)) {
                return undefined;
            }
            // return to normal coords
            y = adjust - y;
            return new Point(x, y);
        };
        FDSPolygonHitShape.prototype.shadeShape = function (ctx) {
            ctx.save();
            _super.prototype.shadeShape.call(this, ctx);
            if (this.points.length <= 0) {
                return;
            }
            ctx.beginPath();
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for (var index = 1; index < this.points.length; index++) {
                var point = this.points[index];
                ctx.lineTo(point.x, point.y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        };
        return FDSPolygonHitShape;
    }(FDSShape));
    
    var BaseRectangularDrawStyle = /** @class */ (function (_super) {
        __extends(BaseRectangularDrawStyle, _super);
        function BaseRectangularDrawStyle(series, dim) {
            var _this = _super.call(this, series, dim) || this;
            // bar drawstyles have 4 markers (on in each corner) because of the
            // extra space they take up, we will scale down the marker size.
            // while 1/2 would make sense mathematically as a scale, it is too small in practice
            // so we will use the 2/3rd scale (as in FDSChartControl)
            _this._selectionMarkerScale = 2 / 3;
            return _this;
        }
        BaseRectangularDrawStyle.getInnerBinPaddingAsNdc = function (axis, binPlacement) {
            var plot = axis.parent, dimension = axis.dimension;
            var startNdc = binPlacement.binStartNdc, endNdc = binPlacement.binEndNdc;
            var paddingPercentOfBin;
            // convert padding from pixels to percentage of bin
            if (axis.innerBinPadding >= 1) {
                var binEndPixels = plot.subPlotFromNDC(endNdc, axis.dimension);
                var binStartPixels = plot.subPlotFromNDC(startNdc, axis.dimension);
                var totalBinSizeInPixels = Math.abs(binEndPixels - binStartPixels);
                paddingPercentOfBin = clamp(axis.innerBinPadding / totalBinSizeInPixels, 0, 1);
            }
            else {
                paddingPercentOfBin = axis.innerBinPadding;
            }
            // convert padding from percentage of bin to ndc space
            var paddingNdc = (endNdc - startNdc) * paddingPercentOfBin;
            return paddingNdc;
        };
        BaseRectangularDrawStyle.getSubBinPosition = function (subBinNumber, totalNumberOfSubBins, binPlacement, padding) {
            var binStartNdc = binPlacement.binStartNdc, binEndNdc = binPlacement.binEndNdc, binFactorOffsetNdc = binPlacement.binFactorOffsetNdc;
            var delta = ((binEndNdc - binFactorOffsetNdc) - (binStartNdc + binFactorOffsetNdc)) / totalNumberOfSubBins;
            var subBinStartNdc = binStartNdc + binFactorOffsetNdc + (delta * subBinNumber);
            var subBinEndNdc = subBinStartNdc + delta;
            if (padding > 0) {
                subBinStartNdc += padding * (subBinNumber / totalNumberOfSubBins);
                subBinEndNdc -= padding * (1 - ((subBinNumber + 1) / totalNumberOfSubBins));
            }
            return { subBinStartNdc: subBinStartNdc, subBinEndNdc: subBinEndNdc };
        };
        // methods for 3d drawing
        BaseRectangularDrawStyle.prototype._draw3DBar = function (x1, x2, y1, y2, ctx, pen, brush, offset, down) {
            if (down === void 0) { down = false; }
            // ensure x1 and y1 are the min of the two
            if (x1 > x2) {
                _a = [x2, x1], x1 = _a[0], x2 = _a[1];
            }
            if (y1 > y2) {
                _b = [y2, y1], y1 = _b[0], y2 = _b[1];
            }
            var yOffset = down ? -offset : offset; // reverse to point down instead of up
            var xOffset = offset;
            var aliasOffset = pen.getAliasOffset();
            // set up points for drawing
            // x/y 1 and 2 are the front rect, 3 and 4 are the back rect
            // a points are in the front rect and b points are in the back rect
            x1 = (~~x1) + aliasOffset;
            x2 = (~~x2) + aliasOffset;
            y1 = (~~y1) + aliasOffset;
            y2 = (~~y2) + aliasOffset;
            var x3 = (~~(x1 + xOffset)) + aliasOffset;
            var x4 = (~~(x2 + xOffset)) + aliasOffset;
            var y3 = (~~(y1 - yOffset)) + aliasOffset;
            var y4 = (~~(y2 - yOffset)) + aliasOffset;
            var a1 = new Point(x1, y1);
            var a2 = new Point(x2, y1);
            var a3 = new Point(x2, y2);
            var a4 = new Point(x1, y2);
            var b1 = new Point(x3, y3);
            var b2 = new Point(x4, y3);
            var b3 = new Point(x4, y4);
            var b4 = new Point(x3, y4);
            // the width of the pen needs to be taken into effect for clipping
            // we clip to prevent weird pointy bits sticking off of wide-line columns etc
            // I'm ceiling-ing it so we don't clip too close to the lines
            var w = Math.ceil(this.series.seriesFGPen.width / 2);
            pen.setOnCanvas(ctx);
            brush.setOnCanvas(ctx, new Rectangle(x3, y3, x4, y4));
            this._drawPoly(ctx, [b1, b2, b3, b4], w); // back face
            var color = new FDSColor(brush.color);
            brush.pushHistory();
            var shadow = new FDSColor(color.r, color.g, color.b);
            shadow.lightenByFactor(0.75);
            brush.setAttr('color', shadow.getCOLORREF());
            if (down) {
                brush.setOnCanvas(ctx, new Rectangle(x1, y3, x2, y1));
                this._drawPoly(ctx, [a1, b1, b2, a2], w); // top face
            }
            else {
                brush.setOnCanvas(ctx, new Rectangle(x1, y2, x4, y4));
                this._drawPoly(ctx, [a4, b4, b3, a3], w); // bottom face
            }
            var doubleShadow = new FDSColor(color.r, color.g, color.b);
            doubleShadow.lightenByFactor(0.5);
            brush.pushHistory();
            brush.setAttr('color', doubleShadow.getCOLORREF());
            brush.setOnCanvas(ctx, new Rectangle(x1, y3, x3, y2));
            this._drawPoly(ctx, [a1, b1, b4, a4], w); // left face
            brush.setOnCanvas(ctx, new Rectangle(x2, y3, x4, y2));
            this._drawPoly(ctx, [a2, b2, b3, a3], w); // right face
            brush.popHistory();
            if (down) {
                brush.setOnCanvas(ctx, new Rectangle(x1, y2, x4, y4));
                this._drawPoly(ctx, [a4, b4, b3, a3], w); // bottom face
            }
            else {
                brush.setOnCanvas(ctx, new Rectangle(x1, y3, x2, y1));
                this._drawPoly(ctx, [a1, b1, b2, a2], w); // top face
            }
            brush.popHistory();
            brush.setOnCanvas(ctx, new Rectangle(x1, y1, x2, y2));
            this._drawPoly(ctx, [a1, a2, a3, a4], w); // front face
            var _a, _b;
        };
        BaseRectangularDrawStyle.prototype._make3DHitShape = function (x1, y1, x2, y2, offset, down) {
            if (down === void 0) { down = false; }
            var pR = this.series.getPlotParent().plotRect;
            // make sure the hitshape's points are in bounds
            x1 = clamp(x1, pR.x1, pR.x2);
            x2 = clamp(x2, pR.x1, pR.x2);
            var x3 = clamp(x1 + offset, pR.x1, pR.x2);
            var x4 = clamp(x2 + offset, pR.x1, pR.x2);
            y1 = clamp(y1, pR.y1, pR.y2);
            y2 = clamp(y2, pR.y1, pR.y2);
            var points;
            if (down) {
                var y3 = clamp(y1 + offset, pR.y1, pR.y2);
                var y4 = clamp(y2 + offset, pR.y1, pR.y2);
                points = [
                    new Point(x1, y1),
                    new Point(x2, y1),
                    new Point(x4, y3),
                    new Point(x4, y4),
                    new Point(x3, y4),
                    new Point(x1, y2)
                ];
            }
            else {
                var y3 = clamp(y1 - offset, pR.y1, pR.y2);
                var y4 = clamp(y2 - offset, pR.y1, pR.y2);
                points = [
                    new Point(x1, y1),
                    new Point(x3, y3),
                    new Point(x4, y3),
                    new Point(x4, y4),
                    new Point(x2, y2),
                    new Point(x1, y2)
                ];
            }
            return new FDSPolygonHitShape(points);
        };
        BaseRectangularDrawStyle.prototype._drawPoly = function (ctx, pts, width) {
            if (width === void 0) { width = null; }
            if (pts.length < 1) {
                return;
            }
            if (width != null) {
                // we care about clipping
                // find the min and max xs and ys
                var miny = void 0, maxy = void 0, minx = void 0, maxx = void 0;
                minx = miny = Infinity;
                maxx = maxy = -Infinity;
                for (var _i = 0, pts_1 = pts; _i < pts_1.length; _i++) {
                    var pt = pts_1[_i];
                    if (pt.x < minx) {
                        minx = pt.x;
                    }
                    if (pt.x > maxx) {
                        maxx = pt.x;
                    }
                    if (pt.y < miny) {
                        miny = pt.y;
                    }
                    if (pt.y > maxy) {
                        maxy = pt.y;
                    }
                }
                minx = minx - width;
                maxx = maxx + width;
                miny = miny - width;
                maxy = maxy + width;
                // save and draw the clip path
                ctx.save();
                ctx.rect(minx, miny, maxx - minx, maxy - miny);
                ctx.clip();
            }
            // draw the actual shape
            ctx.beginPath();
            ctx.moveTo(pts[0].x, pts[0].y);
            for (var i = 1; i < pts.length; i++) {
                ctx.lineTo(pts[i].x, pts[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            if (width != null) {
                ctx.restore();
            }
        };
        return BaseRectangularDrawStyle;
    }(BaseDrawStyle));
    
    /**
     * A line defined by its pt1 and pt2 coordiantes.
     * Useful for boundaries and hit testing.
     */
    var Line = /** @class */ (function () {
        /**
         * Constructs a Line given coordinates
         */
        function Line(pt1, pt2) {
            this.pt1 = pt1;
            this.pt2 = pt2;
            this.xDistance = (this.pt1.x - this.pt2.x);
            this.yDistance = (this.pt1.y - this.pt2.y);
            this.length = Math.sqrt((this.xDistance * this.xDistance) + (this.yDistance * this.yDistance));
            this.xMid = Math.round((this.pt1.x + this.pt2.x) / 2);
            this.yMid = Math.round((this.pt1.y + this.pt2.y) / 2);
            this.midPoint = new Point(this.xMid, this.yMid);
        }
        Line.constructFromPoints = function (pt1, pt2) {
            return new Line(pt1, pt2);
        };
        Line.constructFromValues = function (x1, y1, x2, y2) {
            var pt1 = new Point(x1, y1);
            var pt2 = new Point(x2, y2);
            return new Line(pt1, pt2);
        };
        return Line;
    }());
    
    /**
     * A hit shape for lines with a thickness.
     *
     * @class FDSLineHitShape
     * @extends {FDSShape}
     */
    var FDSLineHitShape = /** @class */ (function (_super) {
        __extends(FDSLineHitShape, _super);
        /**
         * Creates an instance of FDSLineHitShape.
         *
         * @param x coordinate of the first endpoint
         * @param y coordinate of the first endpoint
         * @param x coordinate of the second endpoint
         * @param y coordinate of the second endpoint
         */
        function FDSLineHitShape(x1, y1, x2, y2) {
            if (x1 === void 0) { x1 = 0; }
            if (y1 === void 0) { y1 = 0; }
            if (x2 === void 0) { x2 = 0; }
            if (y2 === void 0) { y2 = 0; }
            var _this = _super.call(this) || this;
            _this.x1 = x1;
            _this.y1 = y1;
            _this.x2 = x2;
            _this.y2 = y2;
            /**
             * How thick the line is for hit detection.
             */
            _this.thickness = 5;
            _this.name = 'Line';
            // don't call setline if all the inputs are 0
            if (_this.x1 !== 0 || _this.x2 !== 0 || _this.y1 !== 0 || _this.y2 !== 0) {
                if (Math.abs(_this.x1 - _this.x2) < 1 && Math.abs(_this.y1 - _this.y2) < 1) {
                    _this.x2 = _this.x1 + 1;
                    _this.y2 = _this.y1 + 1;
                }
            }
            return _this;
        }
        /**
         * Test if the line intersects a given rectangle, represented by diagonal coordinates
         *
         * @param x1 - The x-coordinate of the corner of the rectangle
         * @param y1 - The y-coordinate of the corner of the rectangle
         * @param x2 - The x-coordinate of the diagonally opposite corner of the rectangle
         * @param y2 - The y-coordinate of the diagonally opposite corner of the rectangle
         * @returns whether or not the line and rectangle intersect
         */
        FDSLineHitShape.prototype.hitTest = function (x1, y1, x2, y2) {
            var rectTop = Math.min(y1, y2);
            var rectBottom = Math.max(y1, y2);
            var rectLeft = Math.min(x1, x2);
            var rectRight = Math.max(x1, x2);
            var bounded1 = (this.x1 < rectRight && this.x1 > rectLeft) && (this.y1 < rectBottom && this.y1 > rectTop);
            var bounded2 = (this.x2 < rectRight && this.x2 > rectLeft) && (this.y2 < rectBottom && this.y2 > rectTop);
            if (bounded1 || bounded2) {
                return true;
            }
            else {
                // we may have a crossing line, so we need to do more expensive tests
                var ret = this._intersects(rectLeft, rectTop, rectLeft, rectBottom); // left segment
                ret = ret || this._intersects(rectRight, rectTop, rectRight, rectBottom); // right segment
                ret = ret || this._intersects(rectLeft, rectBottom, rectRight, rectBottom); // top segment
                ret = ret || this._intersects(rectLeft, rectTop, rectRight, rectTop); // bottom segment
                ret = ret || this._intersects(rectLeft, rectTop, rectRight, rectBottom); // upslope crossing segment
                ret = ret || this._intersects(rectLeft, rectBottom, rectRight, rectTop); // downslope crossing segment
                return ret;
            }
        };
        /**
         * Check if a line segment intersects with this shape
         *
         * @param x1 - the x-coordinate of the first point
         * @param y1 - the y-coordinate of the first point
         * @param x2 - the x-coordinate of the second point
         * @param y2 - the y-coordinate of the second point
         * @returns {boolean} (description)
         */
        FDSLineHitShape.prototype._intersects = function (x1, y1, x2, y2) {
            // Using objects instead of newing points appears to avoid a V8 bug that can crash Chromium
            var intersection = this.tryGetIntersection({ x: x1, y: y1 }, { x: x2, y: y2 }, { x: this.x1, y: this.y1 }, { x: this.x2, y: this.y2 });
            return intersection != null;
        };
        /**
         * Given this line and a rectangle that is overlapping it, provide a shift for the
         * rectangle in either the positive or negative y direction to avoid the overlap.
         *
         * @param x1 - the x-coordinate of the first corner of the rectangle
         * @param y1 - the y-coordinate of the first corner of the rectangle
         * @param x2 - the x-coordinate of the second corner of the rectangle
         * @param y2 - the x-coordinate of the second corner of the rectangle
         * @param moveUp - whether the shift should be upwards (negative Y)
         * @returns the amount to shift in the given direction in pixels
         */
        FDSLineHitShape.prototype.getAvoidanceOffset = function (x1, y1, x2, y2, moveUp) {
            if (moveUp) {
                var rectBottom = Math.max(y1, y2);
                var lineTop = Math.min(this.y2, this.y1);
                if (lineTop > rectBottom) {
                    console.warn('Error getting avoidance offset. Line and rectangle are not actually overlapping');
                    return 0; // this doesn't make sense. indicative of misuse
                }
                // have to shift at least one
                return Math.min(-1, lineTop - rectBottom);
            }
            else {
                var rectTop = Math.min(y1, y2);
                var lineBottom = Math.max(this.y2, this.y1);
                if (lineBottom < rectTop) {
                    console.warn('Error getting avoidance offset. Line and rectangle are not actually overlapping');
                    return 0; // again a nonsensical result
                }
                return Math.max(1, lineBottom - rectTop);
            }
        };
        /**
         * test for whether a point (or other shape) is inside this line's hit area
         *
         * @param x - the x-coordinate of the point (or shape) being tested
         * @param y - the y-coordinate of the point (or shape) being tested
         * @param [shape] the type of shape being tested - point, vertical line, or horizontal line
         * @returns whether the point (or shape) is inside the line area
         */
        FDSLineHitShape.prototype.onHitTest = function (x, y, shape) {
            if (shape === void 0) { shape = 0 /* POINT */; }
            switch (shape) {
                case 1 /* VLINE */:
                    if (x >= Math.min(this.x1, this.x2) && x <= Math.max(this.x1, this.x2)) {
                        return true;
                    }
                    break;
                case 2 /* HLINE */:
                    if (y >= Math.min(this.y1, this.y2) && y <= Math.max(this.y1, this.y2)) {
                        return true;
                    }
                    break;
                case 0 /* POINT */:
                default:
                    if ((x >= this.x1 - this.thickness && x <= this.x1 + this.thickness) &&
                        (y >= this.y1 - this.thickness && y <= this.y1 + this.thickness)) {
                        // within thickness of endpoint 1
                        return true;
                    }
                    else if ((x >= this.x2 - this.thickness && x <= this.x2 + this.thickness) &&
                        (y >= this.y2 - this.thickness && y <= this.y2 + this.thickness)) {
                        // within thickness of endpoint 2
                        return true;
                    }
                    else if (this.x1 === this.x2) {
                        // vertical line will crash the next test so test it separately here
                        return x >= this.x1 - this.thickness && x <= this.x1 + this.thickness &&
                            y >= Math.min(this.y1, this.y2) && y <= Math.max(this.y1, this.y2);
                    }
                    else {
                        // check if bounded by line segment
                        if (x >= Math.min(this.x1, this.x2) - this.thickness &&
                            x <= Math.max(this.x1, this.x2) + this.thickness &&
                            y >= Math.min(this.y1, this.y2) - this.thickness &&
                            y <= Math.max(this.y1, this.y2) + this.thickness) {
                            // y = mx + b
                            var m = (this.y1 - this.y2) / (this.x1 - this.x2);
                            var b = this.y1 - m * this.x1;
                            var dist = Math.abs(m * x + b - y) / Math.sqrt(m * m + 1);
                            if (dist < this.thickness) {
                                return true;
                            }
                        }
                    }
            }
            return false;
        };
        /**
         * This function is for handling the case where two line-segments are vertical or horizontal aligned and might
         * intersect. In this case, instead of a single point, its possible to intersect along an entire segment, in which
         * case we return the center of the overlaping region
         *
         * @private
         * @param pt1 - The first endpoint of the first line
         * @param pt2 - The second endpoint of the first line
         * @param pt3 - The first endpoint of the second line
         * @param pt4 - The second endpoint of the second line
         * @returns the central intersection point if there is one, or undefined
         */
        FDSLineHitShape.prototype._intersectCongruencyHelper = function (pt1, pt2, pt3, pt4) {
            var line1min = Math.min(pt1, pt2);
            var line1max = Math.max(pt1, pt2);
            var line2min = Math.min(pt3, pt4);
            var line2max = Math.max(pt3, pt4);
            if (fuzzyLTE(line1min, line2min) && fuzzyLTE(line2min, line1max)) {
                return (line1max + line2min) / 2;
            }
            else if (fuzzyLTE(line2min, line1min) && fuzzyLTE(line1min, line2max)) {
                return (line2max + line1min) / 2;
            }
            else if (fuzzyLTE(line1min, line2min) && fuzzyGTE(line1max, line2max)) {
                return (line2max + line2min) / 2;
            }
            else if (fuzzyLTE(line2min, line1min) && fuzzyGTE(line2max, line1max)) {
                return (line1max + line1min) / 2;
            }
            else {
                return undefined;
            }
        };
        /**
         * If `x` is contained within the bounds of the line, return the point on the line at that x-coordinate.
         *
         * @param pt1 - the start point of the line
         * @param pt2 - the end point of the line
         * @param x - the x-coordinate being tested
         * @returns the intersection point or undefined
         */
        FDSLineHitShape.tryGetIntersectionWithX = function (pt1, pt2, x) {
            if (pt1.x > pt2.x) {
                _a = [pt2, pt1], pt1 = _a[0], pt2 = _a[1];
            }
            if (fuzzyLT(x, pt1.x) || fuzzyGT(x, pt2.x)) {
                return undefined;
            }
            else if (fuzzyEQ(pt1.x, pt2.x)) {
                if (fuzzyEQ(pt1.x, x)) {
                    return new Point(x, pt1.y + pt2.y);
                }
                else {
                    return undefined;
                }
            }
            else {
                var dx = pt2.x - pt1.x;
                var dy = pt2.y - pt1.y;
                var xAmt = (x - pt1.x) / dx;
                var y = (xAmt * dy) + pt1.y;
                return new Point(x, y);
            }
            var _a;
        };
        /**
         * Gets the intersection point of two line segments if they intersect.
         * If the lines don't intersect, will return undefined.
         *
         * @param pt1 - The first endpoint of the first line
         * @param pt2 - The second endpoint of the first line
         * @param pt3 - The first endpoint of the second line
         * @param pt4 - The second endpoint of the second line
         * @returns the intersection point, or undefined.
         */
        FDSLineHitShape.prototype.tryGetIntersection = function (pt1, pt2, pt3, pt4) {
            var intersectXNumerator = (pt2.x - pt1.x) * (pt3.y - pt1.y) - (pt2.y - pt1.y) * (pt3.x - pt1.x);
            var intersectYNumerator = (pt4.x - pt3.x) * (pt3.y - pt1.y) - (pt4.y - pt3.y) * (pt3.x - pt1.x);
            var intersectDenominator = (pt2.y - pt1.y) * (pt4.x - pt3.x) - (pt2.x - pt1.x) * (pt4.y - pt3.y);
            if (fuzzyEQ(0.0, intersectDenominator)) {
                // segments are parallel or coincident (if numerators are zero) -- either way theres no overlap
                if (fuzzyEQ(0.0, intersectXNumerator) && fuzzyEQ(0.0, intersectYNumerator)) {
                    // the root line is coincident, but now we need to figure out if there is any actual overlap. This is
                    // a lot easier than it sounds, because we can now make it a one dimensional problem
                    if (fuzzyEQ(pt3.x, pt4.x)) {
                        // line is vertical, need to work in Y-space
                        var t = this._intersectCongruencyHelper(pt3.y, pt4.y, pt1.y, pt2.y);
                        if (t != null) {
                            return new Point(pt1.x, t);
                        }
                    }
                    else {
                        // line is horizontal or single-point, need to work in X-space
                        var t = this._intersectCongruencyHelper(pt3.x, pt4.x, pt1.x, pt2.x);
                        if (t != null) {
                            return new Point(t, pt1.y);
                        }
                    }
                }
                else {
                    return undefined;
                }
            }
            var ua = intersectXNumerator / intersectDenominator;
            var ub = intersectYNumerator / intersectDenominator;
            if (isBounded(ua, 0.0, 1.0) && isBounded(ub, 0.0, 1.0)) {
                return new Point(pt3.x + ua * (pt4.x - pt3.x), pt3.y + ua * (pt4.y - pt3.y));
            }
            else {
                return undefined;
            }
        };
        FDSLineHitShape.prototype.shadeShape = function (ctx) {
            ctx.save();
            _super.prototype.shadeShape.call(this, ctx);
            ctx.fillRect(this.x1 - this.thickness, this.y1 - this.thickness, this.thickness * 2, this.thickness * 2);
            ctx.beginPath();
            var hitLine = Line.constructFromValues(this.x1, this.y1, this.x2, this.y2);
            var xOffset = this.thickness * hitLine.xDistance / hitLine.length;
            var yOffset = this.thickness * hitLine.yDistance / hitLine.length;
            var shadeLine1 = Line.constructFromValues(this.x1 + yOffset, this.y1 - xOffset, this.x2 + yOffset, this.y2 - xOffset);
            var shadeLine2 = Line.constructFromValues(this.x1 - yOffset, this.y1 + xOffset, this.x2 - yOffset, this.y2 + xOffset);
            ctx.moveTo(shadeLine1.pt1.x, shadeLine1.pt1.y);
            ctx.lineTo(shadeLine1.pt2.x, shadeLine1.pt2.y);
            ctx.lineTo(shadeLine2.pt2.x, shadeLine2.pt2.y);
            ctx.lineTo(shadeLine2.pt1.x, shadeLine2.pt1.y);
            ctx.closePath();
            ctx.fill();
            ctx.fillRect(this.x2 - this.thickness, this.y2 - this.thickness, this.thickness * 2, this.thickness * 2);
            ctx.restore();
        };
        return FDSLineHitShape;
    }(FDSShape));
    
    var OutlierRender;
    (function (OutlierRender) {
        // Full size bar with a single 'tear' outlier effect.
        function breakBars(ctx, point1X, point1Y, point2X, point2Y, pBreakX, pBreakY, breakSize, drawOutline, aliasOffset) {
            var jagSize = scaleByDevicePixelRatio(5);
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart = new Point(pBreakX, point2.y);
            var pBreakEnd = new Point(pBreakX, point1.y);
            // Always draw left to right, so ensure first x is smaller.
            if (point1.x > point2.x) {
                _a = [point2.x, point1.x], point1.x = _a[0], point2.x = _a[1];
                _b = [point2.y, point1.y], point1.y = _b[0], point2.y = _b[1];
            }
            pBreakStart.x -= breakSize;
            pBreakEnd.x += breakSize;
            // Determine if we can actually draw the break or not
            if (pBreakStart.x > pBreakEnd.x || //  If break overlaps
                pBreakEnd.x > point2.x || // if end is too far
                pBreakStart.x < point1.x || // if start is too early
                (point2.x - pBreakEnd.x) < jagSize || // if remaining breakline is too small at end
                (pBreakStart.x - point1.x) < jagSize) {
                return true;
            }
            // Top and Bottom
            drawJagBar(ctx, point1, point2, pBreakStart, jagSize, true, drawOutline, aliasOffset);
            drawJagBar(ctx, point1, point2, pBreakEnd, jagSize, false, drawOutline, aliasOffset);
            return false;
            var _a, _b;
        }
        OutlierRender.breakBars = breakBars;
        // Full size bar with a 'tear' outlier effect on each end.
        function breakBarsLong(ctx, point1X, point1Y, point2X, point2Y, pBreak1X, pBreak1Y, pBreak2X, pBreak2Y, breakSize, drawOutline, aliasOffset) {
            var jagSize = scaleByDevicePixelRatio(5);
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart1 = new Point(pBreak1X, pBreak2Y);
            var pBreakEnd1 = new Point(pBreak1X, pBreak1Y);
            var pBreakStart2 = new Point(pBreak2X, pBreak2Y);
            var pBreakEnd2 = new Point(pBreak2X, pBreak2Y);
            // Always draw left to right, so ensure first x is smaller.
            if (pBreakStart1.x > pBreakStart2.x) {
                _a = [pBreakStart2.x, pBreakStart1.x], pBreakStart1.x = _a[0], pBreakStart2.x = _a[1];
                _b = [pBreakStart2.y, pBreakStart1.y], pBreakStart1.y = _b[0], pBreakStart2.y = _b[1];
                _c = [pBreakEnd2.x, pBreakEnd1.x], pBreakEnd1.x = _c[0], pBreakEnd2.x = _c[1];
                _d = [pBreakEnd2.y, pBreakEnd1.y], pBreakEnd1.y = _d[0], pBreakEnd2.y = _d[1];
            }
            pBreakEnd1.y = point1.y;
            pBreakStart1.y = point2.y;
            pBreakEnd2.y = point1.y;
            pBreakStart2.y = point2.y;
            // Always draw left to right, so ensure first x is sm# Thin column with a single 'tear' outlier effect.aller.
            if (point1.x > point2.x) {
                _e = [point2.x, point1.x], point1.x = _e[0], point2.x = _e[1];
                _f = [point2.y, point1.y], point1.y = _f[0], point2.y = _f[1];
            }
            pBreakStart1.x -= breakSize;
            pBreakEnd1.x += breakSize;
            pBreakStart2.x -= breakSize;
            pBreakEnd2.x += breakSize;
            // Determine if we can actually draw the break or not
            if (pBreakStart1.x > pBreakEnd1.x || // If break overlaps
                pBreakStart2.x > pBreakEnd2.x || // If break overlaps
                pBreakEnd2.x > point2.x || // if end is too far
                pBreakStart1.x < point1.x || // if start is too early
                (point2.x - pBreakEnd2.x) < jagSize || // if remaining breakline is too small at end
                (pBreakStart1.x - point1.x) < jagSize) {
                return true;
            }
            // Top, middle and bottom
            drawJagBar(ctx, point1, point2, pBreakStart1, jagSize, true, drawOutline, aliasOffset);
            drawJagBarMiddle(ctx, point1, point2, pBreakStart2, pBreakEnd1, jagSize, drawOutline, aliasOffset);
            drawJagBar(ctx, point1, point2, pBreakEnd2, jagSize, false, drawOutline, aliasOffset);
            return false;
            var _a, _b, _c, _d, _e, _f;
        }
        OutlierRender.breakBarsLong = breakBarsLong;
        // Full size column with a single 'tear' outlier effect.
        function breakColumn(ctx, point1X, point1Y, point2X, point2Y, pBreakX, pBreakY, breakSize, drawOutline, aliasOffset) {
            var jagSize = scaleByDevicePixelRatio(5);
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart = new Point(point2.x, pBreakY);
            var pBreakEnd = new Point(point1.x, pBreakY);
            // Always draw top to bottom
            if (point1.y > point2.y) {
                _a = [point2.x, point1.x], point1.x = _a[0], point2.x = _a[1];
                _b = [point2.y, point1.y], point1.y = _b[0], point2.y = _b[1];
            }
            pBreakStart.y -= breakSize;
            pBreakEnd.y += breakSize;
            // Determine if we can actually draw the break or not
            if (pBreakStart.y > pBreakEnd.y || // If break overlaps
                pBreakEnd.y > point2.y || // if end is too far
                pBreakStart.y < point1.y || // if start is too early
                (pBreakStart.y - point1.y) < jagSize || // if remaining breakline is too small at end
                (point2.y - pBreakEnd.y) < jagSize) {
                return true;
            }
            // Top and Bottom
            drawJagColumn(ctx, point1, point2, pBreakStart, jagSize, true, drawOutline, aliasOffset);
            drawJagColumn(ctx, point1, point2, pBreakEnd, jagSize, false, drawOutline, aliasOffset);
            return false;
            var _a, _b;
        }
        OutlierRender.breakColumn = breakColumn;
        // Full size column with a 'tear' outlier effect on each end.
        function breakColumnLong(ctx, point1X, point1Y, point2X, point2Y, pBreak1X, pBreak1Y, pBreak2X, pBreak2Y, breakSize, drawOutline, aliasOffset) {
            var jagSize = scaleByDevicePixelRatio(5);
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart1 = new Point(pBreak1X, pBreak1Y);
            var pBreakEnd1 = new Point(pBreak1X, pBreak1Y);
            var pBreakStart2 = new Point(pBreak2X, pBreak2Y);
            var pBreakEnd2 = new Point(pBreak2X, pBreak2Y);
            // Always draw left to right, so ensure first x is smaller.
            if (pBreakStart1.y > pBreakStart2.y) {
                _a = [pBreakStart2.x, pBreakStart1.x], pBreakStart1.x = _a[0], pBreakStart2.x = _a[1];
                _b = [pBreakStart2.y, pBreakStart1.y], pBreakStart1.y = _b[0], pBreakStart2.y = _b[1];
                _c = [pBreakEnd2.x, pBreakEnd1.x], pBreakEnd1.x = _c[0], pBreakEnd2.x = _c[1];
                _d = [pBreakEnd2.y, pBreakEnd1.y], pBreakEnd1.y = _d[0], pBreakEnd2.y = _d[1];
            }
            pBreakEnd1.x = point1.x;
            pBreakStart1.x = point2.x;
            pBreakEnd2.x = point1.x;
            pBreakStart2.x = point2.x;
            // Always draw left to right, so ensure first x is smaller.
            if (point1.y > point2.y) {
                _e = [point2.x, point1.x], point1.x = _e[0], point2.x = _e[1];
                _f = [point2.y, point1.y], point1.y = _f[0], point2.y = _f[1];
            }
            pBreakStart1.y -= breakSize;
            pBreakEnd1.y += breakSize;
            pBreakStart2.y -= breakSize;
            pBreakEnd2.y += breakSize;
            // Determine if we can actually draw the break or not
            if (pBreakStart1.y > pBreakEnd1.y || // If break overlaps
                pBreakStart2.y > pBreakEnd2.y || // If break overlaps
                pBreakEnd2.y > point2.y || // if end is too far
                pBreakStart1.y < point1.y || // if start is too early
                (point2.y - pBreakEnd2.y) < jagSize || // if remaining breakline is too small at end
                (pBreakStart1.y - point1.y) < jagSize) {
                return true;
            }
            // Top, middle and bottom
            drawJagColumn(ctx, point1, point2, pBreakStart1, jagSize, true, drawOutline, aliasOffset);
            drawJagColumnMiddle(ctx, point1, point2, pBreakStart2, pBreakEnd1, jagSize, drawOutline, aliasOffset);
            drawJagColumn(ctx, point1, point2, pBreakEnd2, jagSize, false, drawOutline, aliasOffset);
            return false;
            var _a, _b, _c, _d, _e, _f;
        }
        OutlierRender.breakColumnLong = breakColumnLong;
        // Thin bar with a single 'tear' outlier effect.
        function breakThinBars(ctx, point1X, point1Y, point2X, point2Y, point3X, point3Y, breakSize, hatchAngle, hatchSize, aliasOffset) {
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart = new Point(point3X, point3Y);
            var pBreakEnd = new Point(point3X, point3Y);
            if (point1.x > point2.x) {
                _a = [point2.x, point1.x], point1.x = _a[0], point2.x = _a[1];
                _b = [point2.y, point1.y], point1.y = _b[0], point2.y = _b[1];
            }
            pBreakStart.x -= breakSize;
            pBreakEnd.x += breakSize;
            if (pBreakStart.x > pBreakEnd.x || // if break overlaps
                pBreakEnd.x > point2.x || // if end is too far
                pBreakStart.x < point1.x || // if start is too early
                (point2.x - pBreakEnd.x) < 2 || // if the remaining breakline is just too small at the end
                (pBreakStart.x - point1.x) < 2) {
                return true;
            }
            drawLine(ctx, point1, pBreakStart, aliasOffset);
            drawLine(ctx, pBreakEnd, point2, aliasOffset);
            var angle = DegToRad(hatchAngle + 90);
            var dx = hatchSize * Math.cos(angle);
            var dy = hatchSize * Math.sin(angle);
            drawJagThinBars(ctx, pBreakStart, dx, dy, aliasOffset);
            drawJagThinBars(ctx, pBreakEnd, dx, dy, aliasOffset);
            return false;
            var _a, _b;
        }
        OutlierRender.breakThinBars = breakThinBars;
        // Thin bar with a 'tear' outlier effect on each end.
        function breakThinBarsLong(ctx, point1X, point1Y, point2X, point2Y, pBreak1X, pBreak1Y, pBreak2X, pBreak2Y, breakSize, hatchAngle, hatchSize, aliasOffset) {
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart1 = new Point(pBreak1X, pBreak1Y);
            var pBreakEnd1 = new Point(pBreak1X, pBreak1Y);
            var pBreakStart2 = new Point(pBreak2X, pBreak2Y);
            var pBreakEnd2 = new Point(pBreak2X, pBreak2Y);
            if (pBreakStart1.x > pBreakStart2.x) {
                _a = [pBreakStart2.x, pBreakStart1.x], pBreakStart1.x = _a[0], pBreakStart2.x = _a[1];
                _b = [pBreakStart2.y, pBreakStart1.y], pBreakStart1.y = _b[0], pBreakStart2.y = _b[1];
                _c = [pBreakEnd2.x, pBreakEnd1.x], pBreakEnd1.x = _c[0], pBreakEnd2.x = _c[1];
                _d = [pBreakEnd2.y, pBreakEnd1.y], pBreakEnd1.y = _d[0], pBreakEnd2.y = _d[1];
            }
            if (point1.x > point2.x) {
                _e = [point2.x, point1.x], point1.x = _e[0], point2.x = _e[1];
                _f = [point2.y, point1.y], point1.y = _f[0], point2.y = _f[1];
            }
            pBreakStart1.x -= breakSize;
            pBreakEnd1.x += breakSize;
            pBreakStart2.x -= breakSize;
            pBreakEnd2.x += breakSize;
            if (pBreakStart1.x > pBreakEnd1.x || // if break overlaps
                pBreakStart2.x > pBreakEnd2.x || // if break overlaps
                pBreakEnd2.x > point2.x || // if end is too far
                pBreakStart1.x < point1.x || // if start is too early
                (point2.x - pBreakEnd2.x) < 2 || // if the remaining breakline is just too small at the end
                (pBreakStart1.x - point1.x) < 2) {
                return true;
            }
            // Special case...
            if ((pBreakEnd2.x - pBreakStart1.x) < (2 * breakSize)) {
                // Allow varying breakpoint size until they are too close
                var tmpBreakSize = pBreakEnd2.x - pBreakStart1.x;
                if (tmpBreakSize < breakSize) {
                    tmpBreakSize = breakSize;
                }
                // New break point that is about the middle of the old breaks
                var pNewBreakX = (pBreakStart1.x + pBreakEnd2.x) / 2;
                var pNewBreakY = (pBreakStart1.y + pBreakEnd2.y) / 2;
                // Call single breakpoint function
                breakThinColumn(ctx, point1.x, point1.y, point2.x, point2.y, pNewBreakX, pNewBreakY, breakSize, hatchAngle, hatchSize, aliasOffset);
                return false;
            }
            drawLine(ctx, point1, pBreakStart1, aliasOffset);
            drawLine(ctx, pBreakEnd1, pBreakStart2, aliasOffset);
            drawLine(ctx, pBreakEnd2, point2, aliasOffset);
            var angle = DegToRad(hatchAngle + 90);
            var dx = hatchSize * Math.cos(angle);
            var dy = hatchSize * Math.sin(angle);
            drawJagThinBars(ctx, pBreakStart1, dx, dy, aliasOffset);
            drawJagThinBars(ctx, pBreakEnd1, dx, dy, aliasOffset);
            drawJagThinBars(ctx, pBreakStart2, dx, dy, aliasOffset);
            drawJagThinBars(ctx, pBreakEnd2, dx, dy, aliasOffset);
            return false;
            var _a, _b, _c, _d, _e, _f;
        }
        OutlierRender.breakThinBarsLong = breakThinBarsLong;
        // Thin column with a single 'tear' outlier effect.
        function breakThinColumn(ctx, point1X, point1Y, point2X, point2Y, point3X, point3Y, breakSize, hatchAngle, hatchSize, aliasOffset) {
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart = new Point(point3X, point3Y);
            var pBreakEnd = new Point(point3X, point3Y);
            if (point1.y > point2.y) {
                _a = [point2.x, point1.x], point1.x = _a[0], point2.x = _a[1];
                _b = [point2.y, point1.y], point1.y = _b[0], point2.y = _b[1];
            }
            pBreakStart.y -= breakSize;
            pBreakEnd.y += breakSize;
            if (pBreakStart.y > pBreakEnd.y || // if break overlaps
                pBreakEnd.y > point2.y || // if end is too far
                pBreakStart.y < point1.y || // if start is too early
                (point2.y - pBreakEnd.y) < 2 || // if the remaining breakline is just too small at the end
                (pBreakStart.y - point1.y) < 2) {
                return true;
            }
            drawLine(ctx, point1, pBreakStart, aliasOffset);
            drawLine(ctx, pBreakEnd, point2, aliasOffset);
            var angle = DegToRad(hatchAngle);
            var dx = hatchSize * Math.cos(angle);
            var dy = hatchSize * Math.sin(angle);
            drawJagThinColumns(ctx, pBreakStart, dx, dy, aliasOffset);
            drawJagThinColumns(ctx, pBreakEnd, dx, dy, aliasOffset);
            return false;
            var _a, _b;
        }
        OutlierRender.breakThinColumn = breakThinColumn;
        // Thin column with a 'tear' outlier effect on each end.
        function breakThinColumnLong(ctx, point1X, point1Y, point2X, point2Y, pBreak1X, pBreak1Y, pBreak2X, pBreak2Y, breakSize, hatchAngle, hatchSize, aliasOffset) {
            var point1 = new Point(point1X, point1Y);
            var point2 = new Point(point2X, point2Y);
            var pBreakStart1 = new Point(pBreak1X, pBreak1Y);
            var pBreakEnd1 = new Point(pBreak1X, pBreak1Y);
            var pBreakStart2 = new Point(pBreak2X, pBreak2Y);
            var pBreakEnd2 = new Point(pBreak2X, pBreak2Y);
            if (pBreakStart1.y > pBreakStart2.y) {
                _a = [pBreakStart2.x, pBreakStart1.x], pBreakStart1.x = _a[0], pBreakStart2.x = _a[1];
                _b = [pBreakStart2.y, pBreakStart1.y], pBreakStart1.y = _b[0], pBreakStart2.y = _b[1];
                _c = [pBreakEnd2.x, pBreakEnd1.x], pBreakEnd1.x = _c[0], pBreakEnd2.x = _c[1];
                _d = [pBreakEnd2.y, pBreakEnd1.y], pBreakEnd1.y = _d[0], pBreakEnd2.y = _d[1];
            }
            if (point1.y > point2.y) {
                _e = [point2.x, point1.x], point1.x = _e[0], point2.x = _e[1];
                _f = [point2.y, point1.y], point1.y = _f[0], point2.y = _f[1];
            }
            pBreakStart1.y -= breakSize;
            pBreakEnd1.y += breakSize;
            pBreakStart2.y -= breakSize;
            pBreakEnd2.y += breakSize;
            if (pBreakStart1.y > pBreakEnd1.y || // if break overlaps
                pBreakStart2.y > pBreakEnd2.y || // if break overlaps
                pBreakEnd2.y > point2.y || // if end is too far
                pBreakStart1.y < point1.y || // if start is too early
                (point2.y - pBreakEnd2.y) < 2 || // if the remaining breakline is just too small at the end
                (pBreakStart1.y - point1.y) < 2) {
                return true;
            }
            // Special case...
            if ((pBreakEnd2.y - pBreakStart1.y) < (2 * breakSize)) {
                // Allow varying breakpoint size until they are too close
                var tmpBreakSize = pBreakEnd2.y - pBreakStart1.y;
                if (tmpBreakSize < breakSize) {
                    tmpBreakSize = breakSize;
                }
                // New break point that is about the middle of the old breaks
                var pNewBreakX = (pBreakStart1.x + pBreakEnd2.x) / 2;
                var pNewBreakY = (pBreakStart1.y + pBreakEnd2.y) / 2;
                // Call single breakpoint function
                breakThinBars(ctx, point1.x, point1.y, point2.x, point2.y, pNewBreakX, pNewBreakY, breakSize, hatchAngle, hatchSize, aliasOffset);
                return false;
            }
            // Just draw the normal breakline
            drawLine(ctx, point1, pBreakStart1, aliasOffset);
            drawLine(ctx, pBreakEnd1, pBreakStart2, aliasOffset);
            drawLine(ctx, pBreakEnd2, point2, aliasOffset);
            var angle = DegToRad(hatchAngle);
            var dx = hatchSize * Math.cos(angle);
            var dy = hatchSize * Math.sin(angle);
            drawJagThinColumns(ctx, pBreakStart1, dx, dy, aliasOffset);
            drawJagThinColumns(ctx, pBreakEnd1, dx, dy, aliasOffset);
            drawJagThinColumns(ctx, pBreakStart2, dx, dy, aliasOffset);
            drawJagThinColumns(ctx, pBreakEnd2, dx, dy, aliasOffset);
            return false;
            var _a, _b, _c, _d, _e, _f;
        }
        OutlierRender.breakThinColumnLong = breakThinColumnLong;
        function drawJagBar(ctx, point1, point2, pBreak, jagSize, jagTop, drawOutline, aliasOffset) {
            // This is necessary because we're handling references.
            point1 = point1.copy();
            point2 = point2.copy();
            pBreak = pBreak.copy();
            point1.x += aliasOffset;
            point1.y -= aliasOffset;
            point2.x -= aliasOffset;
            point2.y += aliasOffset;
            pBreak.x += aliasOffset;
            pBreak.y += aliasOffset;
            ctx.beginPath();
            if (jagTop) {
                ctx.moveTo(point1.x, point1.y);
                ctx.lineTo(pBreak.x, point1.y);
                ctx.lineTo(pBreak.x - jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.33));
                ctx.lineTo(pBreak.x + jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.66));
                ctx.lineTo(pBreak.x, point2.y);
                ctx.lineTo(point1.x, point2.y);
                ctx.lineTo(point1.x, point1.y);
            }
            else {
                ctx.moveTo(point2.x, point1.y);
                ctx.lineTo(point2.x, point2.y);
                ctx.lineTo(pBreak.x, point2.y);
                ctx.lineTo(pBreak.x + jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.66));
                ctx.lineTo(pBreak.x - jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.33));
                ctx.lineTo(pBreak.x, point1.y);
                ctx.lineTo(point2.x, point1.y);
            }
            ctx.closePath();
            ctx.fill();
            if (drawOutline) {
                ctx.stroke();
            }
        }
        function drawJagBarMiddle(ctx, point1, point2, pBreakStart, pBreakEnd, jagSize, drawOutline, aliasOffset) {
            // This is necessary because we're handling references.
            point1 = point1.copy();
            point2 = point2.copy();
            pBreakStart = pBreakStart.copy();
            pBreakEnd = pBreakEnd.copy();
            point1.x += aliasOffset;
            point1.y -= aliasOffset;
            point2.x -= aliasOffset;
            point2.y += aliasOffset;
            pBreakStart.x += aliasOffset;
            pBreakStart.y += aliasOffset;
            pBreakEnd.x += aliasOffset;
            pBreakEnd.y += aliasOffset;
            ctx.beginPath();
            ctx.moveTo(pBreakEnd.x, point2.y);
            ctx.lineTo(pBreakStart.x, point2.y);
            ctx.lineTo(pBreakStart.x + jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.66));
            ctx.lineTo(pBreakStart.x - jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.33));
            ctx.lineTo(pBreakStart.x, point1.y);
            ctx.lineTo(pBreakEnd.x, point1.y);
            ctx.lineTo(pBreakEnd.x - jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.33));
            ctx.lineTo(pBreakEnd.x + jagSize, Math.round(point1.y + (point2.y - point1.y) * 0.66));
            ctx.lineTo(pBreakEnd.x, point2.y);
            ctx.closePath();
            ctx.fill();
            if (drawOutline) {
                ctx.stroke();
            }
        }
        function drawJagColumn(ctx, point1, point2, pBreak, jagSize, jagTop, drawOutline, aliasOffset) {
            // This is necessary because we're handling references.
            point1 = point1.copy();
            point2 = point2.copy();
            pBreak = pBreak.copy();
            point1.x -= aliasOffset;
            point1.y += aliasOffset;
            point2.x += aliasOffset;
            point2.y -= aliasOffset;
            pBreak.x += aliasOffset;
            pBreak.y += aliasOffset;
            ctx.beginPath();
            if (jagTop) {
                ctx.moveTo(point1.x, point1.y);
                ctx.lineTo(point2.x, point1.y);
                ctx.lineTo(point2.x, pBreak.y);
                ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.66), pBreak.y + jagSize);
                ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.33), pBreak.y - jagSize);
                ctx.lineTo(point1.x, pBreak.y);
                ctx.lineTo(point1.x, point1.y);
            }
            else {
                ctx.moveTo(point1.x, point2.y);
                ctx.lineTo(point2.x, point2.y);
                ctx.lineTo(point2.x, pBreak.y);
                ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.66), pBreak.y + jagSize);
                ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.33), pBreak.y - jagSize);
                ctx.lineTo(point1.x, pBreak.y);
                ctx.lineTo(point1.x, point2.y);
            }
            ctx.closePath();
            ctx.fill();
            if (drawOutline) {
                ctx.stroke();
            }
        }
        function drawJagColumnMiddle(ctx, point1, point2, pBreakStart, pBreakEnd, jagSize, drawOutline, aliasOffset) {
            // This is necessary because we're handling references.
            point1 = point1.copy();
            point2 = point2.copy();
            pBreakStart = pBreakStart.copy();
            pBreakEnd = pBreakEnd.copy();
            point1.x -= aliasOffset;
            point1.y += aliasOffset;
            point2.x += aliasOffset;
            point2.y -= aliasOffset;
            pBreakStart.x += aliasOffset;
            pBreakStart.y += aliasOffset;
            pBreakEnd.x += aliasOffset;
            pBreakEnd.y += aliasOffset;
            ctx.beginPath();
            ctx.moveTo(point1.x, pBreakEnd.y);
            ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.33), pBreakEnd.y - jagSize);
            ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.66), pBreakEnd.y + jagSize);
            ctx.lineTo(point2.x, pBreakEnd.y);
            ctx.lineTo(point2.x, pBreakStart.y);
            ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.66), pBreakStart.y + jagSize);
            ctx.lineTo(Math.round(point1.x + (point2.x - point1.x) * 0.33), pBreakStart.y - jagSize);
            ctx.lineTo(point1.x, pBreakStart.y);
            ctx.lineTo(point1.x, pBreakEnd.y);
            ctx.closePath();
            ctx.fill();
            if (drawOutline) {
                ctx.stroke();
            }
        }
        function drawLine(ctx, start, end, aliasOffset) {
            ctx.beginPath();
            ctx.moveTo(start.x + aliasOffset, start.y + aliasOffset);
            ctx.lineTo(end.x + aliasOffset, end.y + aliasOffset);
            ctx.stroke();
        }
        // We have to bother with aliasOffset here as well in case the angle makes a straight line.
        function drawJagThinBars(ctx, pBreak, dx, dy, aliasOffset) {
            // Using temp variables because we're dealing with references
            var temp1 = new Point(pBreak.x - dx, pBreak.y + dy);
            var temp2 = new Point(pBreak.x + dx, pBreak.y - dy);
            drawLine(ctx, temp1, temp2, aliasOffset);
        }
        function drawJagThinColumns(ctx, pBreak, dx, dy, aliasOffset) {
            var temp1 = new Point(pBreak.x + dx, pBreak.y - dy);
            var temp2 = new Point(pBreak.x - dx, pBreak.y + dy);
            drawLine(ctx, temp1, temp2, aliasOffset);
        }
    })(OutlierRender || (OutlierRender = {}));
    
    var OldColumnsDrawStyle = /** @class */ (function (_super) {
        __extends(OldColumnsDrawStyle, _super);
        function OldColumnsDrawStyle(series) {
            var _this = _super.call(this, series, 1 /* X */) || this;
            _this.is3D = false;
            // `ThinDrawStyle` will override this in its constructor, since the
            // drawing logic is pretty much the same, we'll just keep it here in
            // `drawToBuffer`.
            _this.isThin = false;
            return _this;
        }
        OldColumnsDrawStyle.prototype.getCoordinates = function (prm, i, passedVals, retVals) {
            var initOffset = 0.0;
            _a = this._xScale.lookupRange(passedVals.xval1), retVals.x1 = _a[1], retVals.x2 = _a[2], initOffset = _a[3];
            if (fuzzyLT(initOffset, 0.001)) {
                initOffset = 0.0;
            }
            var delta = ((retVals.x2 - initOffset) - (retVals.x1 + initOffset)) / prm.nHorizontalBars;
            retVals.x1 = retVals.x1 + initOffset + (delta * this.series.barNumber * Number(prm.useDelta));
            retVals.x1 = retVals.x2 = (prm.plot.subPlotFromNDC(retVals.x1, 1 /* X */) +
                prm.plot.subPlotFromNDC(retVals.x1 + delta, 1 /* X */)) / 2.0;
            retVals.y1 = prm.plot.subPlotFromNDC(this._yScale.lookup(passedVals.yval1), 2 /* Y */);
            return retVals;
            var _a;
        };
        OldColumnsDrawStyle.prototype._drawThinBarBracket = function (ctx, barBasePixels, leftEdgePixels, rightEdgePixels, lineWidth) {
            var bracketSize = scaleByDevicePixelRatio(4);
            var bracketBase = barBasePixels + 1; // we need to add back the one pixel so that we draw exactly on the
            // baseline instead of above it
            // Bracket legs
            ctx.fillRect(leftEdgePixels, bracketBase, lineWidth, bracketSize);
            ctx.fillRect(rightEdgePixels - lineWidth, bracketBase, lineWidth, bracketSize);
            // Bracket body
            ctx.fillRect(leftEdgePixels, bracketBase - lineWidth, rightEdgePixels - leftEdgePixels, lineWidth);
        };
        OldColumnsDrawStyle.prototype.computeWorldBarBases = function () {
            var barBases = _super.prototype.computeWorldBarBases.call(this);
            if (this.series.isStacked) {
                var yAxis = this.series.getAxis(2 /* Y */);
                if (this.series.attributeSet.isInheritedDefault('SeriesYReference') &&
                    yAxis.attributeSet.isInheritedDefault('Reference')) {
                    barBases.ndcY = this._yScale.lookup(0);
                }
            }
            return barBases;
        };
        OldColumnsDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            // Determine if we are rendering in the outlier style
            if (this._yScale.outlierActive() && this.series.seriesOutlierIndicator) {
                this._outlierDrawToBuffer(prm, ctx);
                return;
            }
            if (this.series.isStacked) {
                if (prm.renderCache.colsSumMap == null) {
                    prm.renderCache.colsSumMap = {};
                }
            }
            ctx.save();
            var plot = prm.plot, nHorizontalBars = prm.nHorizontalBars;
            var ndcY = this.computeWorldBarBases().ndcY;
            // clamping to prevent drawing off the canvas
            var yRef = clamp(ndcY, 0, 1);
            var yMax = ~~((plot.subPlotFromNDC(this._yScale.lookup(this._yScale.threshMin, this._yBin), 2 /* Y */)) + 0.5);
            var yMin = ~~((plot.subPlotFromNDC(this._yScale.lookup(this._yScale.threshMax, this._yBin), 2 /* Y */)) + 0.5);
            // This is equivalent to rounding to the nearest integer without the call to
            // Math.round
            var y1 = ~~((plot.subPlotFromNDC(yRef, 2 /* Y */)) + 0.5);
            var _a = this._choosePens(ctx, false), brush = _a.brush, pen = _a.pen, penProps = _a.penProps;
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            // Set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            var selectionIndex = 0;
            for (var j = 0; j < this.series.size; j += this._step) {
                var xPoint = this._xData.data[j];
                var i = this.series.getSampleIndex(j);
                xPoint = this._xData.getAt(i);
                var yPoint = this._yData.getAt(i);
                if (xPoint == null || yPoint == null || isNaN(yPoint) || IsSomeInternalNAN(xPoint)) {
                    continue;
                }
                var xValue1 = void 0, x1 = void 0, x2 = void 0, initOffset = void 0;
                _b = this._xScale.lookupRange(xPoint), xValue1 = _b[0], x1 = _b[1], x2 = _b[2], initOffset = _b[3];
                if (this.series.useColor) {
                    this._setColorMapColor(ctx, brush, colorData.getAt(i), i);
                }
                var offset = initOffset >= 0.001 ? initOffset : 0;
                var offset3d = offset * (prm.plotRect.x2 - prm.plotRect.x1);
                var binPlacementInfo = {
                    binStartNdc: x1,
                    binEndNdc: x2,
                    binFactorOffsetNdc: offset,
                };
                var innerBinPadding = BaseRectangularDrawStyle.getInnerBinPaddingAsNdc(this._xScale.axis, binPlacementInfo);
                var subBinPosition = BaseRectangularDrawStyle.getSubBinPosition(this.series.barNumber, nHorizontalBars, binPlacementInfo, innerBinPadding);
                x1 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinStartNdc, 1 /* X */));
                x2 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinEndNdc, 1 /* X */));
                var bracketX1 = x1;
                var bracketX2 = x2;
                if (this.isThin) {
                    x1 = x2 = Math.round((x1 + x2) / 2);
                }
                var positiveStacking = false;
                var y2 = void 0;
                var ny1 = void 0, ny2 = void 0;
                // Stacked is a bit more complicated...
                if (this.series.isStacked) {
                    _c = this.stackSegmentDistance(prm, 2 /* Y */, xPoint, true), ny1 = _c[0], y1 = _c[1];
                    _d = this.stackSegmentDistance(prm, 2 /* Y */, xPoint, false), ny2 = _d[0], y2 = _d[1];
                    y1 = ~~(plot.subPlotFromNDC(y1, 2 /* Y */));
                    positiveStacking = (ny1 === ny2);
                }
                else {
                    y2 = this._yScale.lookup(yPoint, this._yBin);
                }
                y2 = ~~(plot.subPlotFromNDC(y2, 2 /* Y */));
                if (!this.isThin && (x2 <= x1)) {
                    x2 = x1 + 1;
                }
                // Make sure the box always draws from top to bottom
                var baseY1 = Math.min(y1, y2);
                var baseY2 = baseY1 + Math.abs(y1 - y2);
                var snapY = y2;
                // These are the coords that the column will draw on
                var drawX1 = x1;
                var drawX2 = x2;
                var drawY1 = baseY1;
                var drawY2 = baseY2;
                if (this.series.isStacked) {
                    if (!positiveStacking) {
                        // Figure out negative stacking
                        ny1 = ~~(plot.subPlotFromNDC(ny1, 2 /* Y */));
                        ny2 = ~~(plot.subPlotFromNDC(ny2, 2 /* Y */));
                        if (ny1 === ny2) {
                            ny2 += 1;
                        }
                        drawY1 = ny1;
                        drawY2 = ny2;
                    }
                    // Save points to a cache
                    if (prm.renderCache.colsSumMap[xPoint] == null) {
                        prm.renderCache.colsSumMap[xPoint] = {};
                    }
                    prm.renderCache.colsSumMap[xPoint][this.series.id] = drawY1;
                }
                var drawWidth = Math.abs(drawX1 - drawX2);
                var drawHeight = Math.abs(drawY1 - drawY2);
                // Save the pixel points, including the space before/above the plot rect
                var pR = prm.plot.plotRect;
                var x = Math.min(drawX1, drawX2);
                var y = Math.min(drawY1, drawY2);
                x = Math.round(x + (drawWidth / 2));
                y = Math.round(y + (drawHeight / 2));
                pixelPoints[i] = { x: x + pR.x1, y: y + pR.y1 };
                var isBelowReferenceLine = this.series.isStacked ? !positiveStacking : y2 > y1;
                if (isBelowReferenceLine) {
                    infoboxPixelPoints[i] = {
                        point: { x: x + pR.x1, y: Math.max(drawY1, drawY2) + pR.y1 },
                        position: "below" /* below */
                    };
                }
                else {
                    infoboxPixelPoints[i] = {
                        point: { x: x + pR.x1, y: Math.min(drawY1, drawY2) + pR.y1 },
                        position: "above" /* above */
                    };
                }
                if (!this.series.barColumn3dDepthFactorDefault) {
                    // They give us the depth, we need to get the x and y offset
                    x = this.series.barColumn3dDepthFactor * drawWidth;
                    offset3d = Math.sqrt((x * x) / 2);
                }
                var thinX = void 0;
                if (this.is3D) {
                    if (this.series.isStacked) {
                        var obj = {
                            x1: drawX1,
                            x2: drawX2,
                            y1: drawY1,
                            y2: drawY2,
                            brush: brush,
                            pen: pen,
                            offset3D: offset3d,
                            series: this.series
                        };
                        if (prm.stacked3DColumns[x1] != null) {
                            prm.stacked3DColumns[x1].push(obj);
                        }
                        else {
                            prm.stacked3DColumns[x1] = [obj];
                        }
                    }
                    else {
                        this._draw3DBar(drawX1, drawX2, drawY1, drawY2, ctx, pen, brush, offset3d);
                    }
                }
                else if (this.isThin) {
                    if (this.series.drawThinColumnBrackets) {
                        this._drawThinBarBracket(ctx, drawY2, bracketX1, bracketX2, penProps.lineWidth);
                    }
                    // Draw a rectangle with the width of the series foreground pen,
                    // offset to the left by half (rounded down) the width of the pen so
                    // that the shape draws centered at the datapoint.
                    thinX = (~~(drawX1 + (drawWidth / 2))) - (~~(penProps.lineWidth / 2));
                    ctx.fillRect(thinX, drawY1, penProps.lineWidth, drawHeight);
                }
                else if (this.series.isStacked) {
                    var strokeWidth = drawWidth - 1;
                    var strokeHeight = drawHeight - 1;
                    brush.setOnCanvas(ctx, new Rectangle(drawX1, drawY1, drawX2, drawY2));
                    if (positiveStacking) {
                        ctx.fillRect(drawX1, drawY1, drawWidth, drawHeight);
                        ctx.strokeRect(drawX1 + penProps.aliasOffset, drawY1 + penProps.aliasOffset, strokeWidth, strokeHeight);
                    }
                    else {
                        ctx.fillRect(drawX1, drawY2, drawWidth, drawHeight);
                        ctx.strokeRect(drawX1 + penProps.aliasOffset, drawY2 + penProps.aliasOffset, strokeWidth, strokeHeight);
                    }
                    snapY = drawY1;
                }
                else {
                    var strokeWidth = drawWidth - 1;
                    var strokeHeight = drawHeight - 1;
                    brush.setOnCanvas(ctx, new Rectangle(drawX1, drawY1, drawX2, drawY2));
                    ctx.fillRect(drawX1, drawY1, drawWidth, drawHeight);
                    ctx.strokeRect(drawX1 + penProps.aliasOffset, drawY1 + penProps.aliasOffset, strokeWidth, strokeHeight);
                }
                if (this.series.isStacked) {
                    this._addSeriesValuesAndMarkersForStacked(drawWidth, drawX1, prm, drawY1);
                }
                // Create and add the hitshapes
                var minX = Math.min(x1, x2);
                var maxX = Math.max(x1, x2);
                // Stores the selection marker point positions
                var selMarkerX1 = minX;
                var selMarkerY1 = baseY1;
                var selMarkerX2 = maxX;
                var selMarkerY2 = baseY2;
                var hitShape = void 0;
                if (this.is3D && (!this.series.isStacked)) {
                    hitShape = this._make3DHitShape(minX + prm.plotRect.x1, baseY1 + prm.plotRect.y1, maxX + prm.plotRect.x1, baseY2 + prm.plotRect.y1, offset3d);
                }
                else if (this.isThin) {
                    var hitX = thinX;
                    var hitW = penProps.lineWidth;
                    hitShape = new FDSLineHitShape(hitX + prm.plotRect.x1, baseY1 + prm.plotRect.y1, hitX + hitW + prm.plotRect.x1, baseY2 + prm.plotRect.y1);
                    // Selection Marker Positioning
                    selMarkerX1 = hitX;
                    selMarkerX2 = hitX + hitW;
                    selMarkerY2 = baseY1 + Math.abs(y1 - y2);
                }
                else if (this.series.isStacked) {
                    if (y1 !== y2) {
                        if (this.is3D) {
                            hitShape = this._make3DHitShape(x1 + prm.plotRect.x1, y1 + prm.plotRect.y1, x1 + Math.abs(x1 - x2) + prm.plotRect.x1, y1 + Math.abs(y1 - y2) + prm.plotRect.y1, offset3d, true);
                        }
                        else {
                            hitShape = new FDSRectangleHitShape(x1 + prm.plotRect.x1, y1 + prm.plotRect.y1, Math.abs(x1 - x2), Math.abs(y1 - y2));
                        }
                        // Selection Marker Positioning
                        selMarkerX1 = x1;
                        selMarkerY1 = y1;
                        selMarkerX2 = x1 + Math.abs(x1 - x2);
                        selMarkerY2 = y1 + Math.abs(y1 - y2);
                    }
                    else {
                        if (this.is3D) {
                            hitShape = this._make3DHitShape(x1 + prm.plotRect.x1, ny2 + prm.plotRect.y1, x1 + (x2 - x1) + prm.plotRect.x1, ny2 + Math.abs(ny2 - ny1) + prm.plotRect.y1, offset3d, true);
                        }
                        else {
                            hitShape = new FDSRectangleHitShape(x1 + prm.plotRect.x1, ny2 + prm.plotRect.y1, x2 - x1, Math.abs(ny2 - ny1));
                        }
                        // Selection Marker Positioning
                        selMarkerX1 = x1;
                        selMarkerY1 = ny2;
                        selMarkerX2 = x1 + (x2 - x1);
                        selMarkerY2 = ny2 + Math.abs(ny2 - ny1);
                    }
                }
                else {
                    var hitX = x1;
                    var hitW = Math.abs(x1 - x2);
                    hitShape = new FDSRectangleHitShape(hitX + prm.plotRect.x1, baseY1 + prm.plotRect.y1, hitW, Math.abs(y1 - y2));
                    // Selection Marker Positioning
                    selMarkerX1 = hitX;
                    selMarkerX2 = hitX + hitW;
                    selMarkerY2 = baseY1 + Math.abs(y1 - y2);
                }
                hitShape.index = i;
                this.series.hitVector.push(hitShape);
                // Cache the selection marker positions
                if (this.seriesSelected && Math.abs(selMarkerY2 - selMarkerY1) >= 1 &&
                    this._selectionSampler.isPointSampled(selectionIndex++)) {
                    this.cacheSelectable(prm, 0 /* NONE */, selMarkerX1, selMarkerY1);
                    this.cacheSelectable(prm, 0 /* NONE */, selMarkerX1, selMarkerY2);
                    if (!this.isThin) {
                        this.cacheSelectable(prm, 0 /* NONE */, selMarkerX2, selMarkerY2);
                        this.cacheSelectable(prm, 0 /* NONE */, selMarkerX2, selMarkerY1);
                    }
                }
                this.series.addLookupPoint(prm.plotRect.x1 + ((x1 + x2) / 2), [prm.plotRect.y1 + snapY], i);
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
            this._resetColorMapColor(brush);
            ctx.restore();
            var _b, _c, _d;
        };
        OldColumnsDrawStyle.prototype._addSeriesValuesAndMarkersForStacked = function (drawWidth, drawX1, prm, drawY1) {
            var strokeWidth = drawWidth - 1;
            if (this.series.seriesValue) {
                var point = new Point(drawX1 + (strokeWidth / 2) + prm.plotRect.x1, (drawY1) + prm.plotRect.y1);
                this._labelPositions.push(point);
            }
            if (this.series.seriesMarker) {
                var point = new Point(drawX1 + (strokeWidth / 2), drawY1);
                this._markerPositions.push(point);
            }
        };
        OldColumnsDrawStyle.prototype._outlierDrawToBuffer = function (prm, ctx) {
            ctx.save();
            var plot = prm.plot, nHorizontalBars = prm.nHorizontalBars;
            var ndcY = this.computeWorldBarBases().ndcY;
            // clamping to prevent drawing off the canvas
            var yRef = clamp(ndcY, 0, 1);
            var yMax = ~~((plot.subPlotFromNDC(this._yScale.lookup(this._yScale.threshMin, this._yBin), 2 /* Y */)) + 0.5);
            var yMin = ~~((plot.subPlotFromNDC(this._yScale.lookup(this._yScale.threshMax, this._yBin), 2 /* Y */)) + 0.5);
            // This is equivalent to rounding to the nearest integer without the call to
            // Math.round
            var y1 = ~~((plot.subPlotFromNDC(yRef, 2 /* Y */)) + 0.5);
            // Outlier stuff
            var breakSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorBreakSize, plot.plotRect.getWidth()));
            var hatchAngle = this.series.seriesOutlierIndicatorHatchAngle;
            var hatchSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorHatchSize, plot.plotRect.getWidth()));
            var ptMax = this._yScale.threshMax;
            var ptMin = this._yScale.threshMin;
            var valMax = this._yScale.lookup(ptMax, this._yBin);
            var valMin = this._yScale.lookup(ptMin, this._yBin);
            var markerStyle = this.series.seriesOutlierIndicatorMarkerStyle;
            var markerSize = this.series.seriesOutlierIndicatorSize;
            var outlierStyle = this.series.seriesOutlierIndicatorStyle;
            var sign = valMax > valMin ? 1 : -1;
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            var selectionIndex = 0;
            var _a = this._choosePens(ctx, false), brush = _a.brush, penProps = _a.penProps;
            for (var j = 0; j < this.series.size; j += this._step) {
                var xPoint = this._xData.data[j];
                var aliasOffset = penProps.aliasOffset;
                var i = this.series.getSampleIndex(j);
                xPoint = this._xData.getAt(i);
                var yPoint = this._yData.getAt(i);
                if (xPoint == null || yPoint == null || isNaN(yPoint) || IsSomeInternalNAN(xPoint)) {
                    continue;
                }
                var xValue1 = void 0, x1 = void 0, x2 = void 0, initOffset = void 0;
                _b = this._xScale.lookupRange(xPoint), xValue1 = _b[0], x1 = _b[1], x2 = _b[2], initOffset = _b[3];
                if (this.series.useColor) {
                    this._setColorMapColor(ctx, brush, colorData.getAt(i), i);
                }
                var offset = initOffset >= 0.001 ? initOffset : 0;
                var binPlacementInfo = {
                    binStartNdc: x1,
                    binEndNdc: x2,
                    binFactorOffsetNdc: offset,
                };
                var innerBinPadding = BaseRectangularDrawStyle.getInnerBinPaddingAsNdc(this._xScale.axis, binPlacementInfo);
                var subBinPosition = BaseRectangularDrawStyle.getSubBinPosition(this.series.barNumber, nHorizontalBars, binPlacementInfo, innerBinPadding);
                x1 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinStartNdc, 1 /* X */));
                x2 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinEndNdc, 1 /* X */));
                var bracketX1 = x1;
                var bracketX2 = x2;
                if (this.isThin) {
                    x1 = x2 = Math.round((x1 + x2) / 2);
                }
                var y2 = this._yScale.lookup(yPoint, this._yBin);
                y2 = ~~(plot.subPlotFromNDC(y2, 2 /* Y */));
                if (!this.isThin && (x2 <= x1)) {
                    x2 = x1 + 1;
                }
                // Make sure the box always draws from top to bottom
                var baseY1 = Math.min(y1, y2);
                var baseY2 = baseY1 + Math.abs(y1 - y2);
                // Outlier stuff
                var value1 = yPoint;
                valMax = ~~(plot.subPlotFromNDC(this._yScale.lookup(ptMax, this._yBin), 2 /* Y */));
                valMin = ~~(plot.subPlotFromNDC(this._yScale.lookup(ptMin, this._yBin), 2 /* Y */));
                var _c = this.computeReference(), worldX = _c[0], worldY = _c[1];
                // We always want to draw the stroke outline on any of the shapes rendering below.
                // Using a variable here to increase readability so we're not just blindly passing in true.
                var drawOutline = true;
                // Determines if we just render a normal bar without outlier markings.
                var drawNormal = false;
                if (outlierStyle === 0 /* TEAR */) {
                    if (this.isThin) {
                        if (this.series.drawThinColumnBrackets) {
                            this._drawThinBarBracket(ctx, valMin, bracketX1, bracketX2, penProps.lineWidth);
                        }
                        if ((value1 > ptMax) && (worldY < ptMin)) {
                            drawNormal = OutlierRender.breakThinColumnLong(ctx, x1, y1, x2, y2, x2, (valMax + (hatchSize * 2)), x2, (valMin - (hatchSize * 2)), breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if ((value1 < ptMin) && (worldY > ptMax)) {
                            drawNormal = OutlierRender.breakThinColumnLong(ctx, x2, y2, x1, y1, x1, (valMax + (hatchSize * 2)), x1, (valMin - (hatchSize * 2)), breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (value1 > ptMax) {
                            drawNormal = OutlierRender.breakThinColumn(ctx, x1, y1, x2, y2, x2, (valMax + (hatchSize * 2)), breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (value1 < ptMin) {
                            drawNormal = OutlierRender.breakThinColumn(ctx, x2, y2, x1, y1, x2, (valMin - (hatchSize * 2)), breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (worldY < ptMin) {
                            drawNormal = OutlierRender.breakThinColumn(ctx, x2, y2, x1, y1, x2, (valMin - (hatchSize * 2)), breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (worldY > ptMax) {
                            drawNormal = OutlierRender.breakThinColumn(ctx, x2, y2, x1, y1, x2, (valMax + (hatchSize * 2)), breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else {
                            drawNormal = true;
                        }
                    }
                    else {
                        if ((value1 > ptMax) && (worldY < ptMin)) {
                            drawNormal = OutlierRender.breakColumnLong(ctx, x1, y1, x2, y2, x2, (valMax + (hatchSize * 2)), x2, (valMin - (hatchSize * 2)), breakSize, drawOutline, aliasOffset);
                        }
                        else if ((value1 < ptMin) && (worldY > ptMax)) {
                            drawNormal = OutlierRender.breakColumnLong(ctx, x2, y2, x1, y1, x1, (valMax + (hatchSize * 2)), x1, (valMin - (hatchSize * 2)), breakSize, drawOutline, aliasOffset);
                        }
                        else if (value1 > ptMax) {
                            drawNormal = OutlierRender.breakColumn(ctx, x1, y1, x2, y2, x2, (valMax + (hatchSize * 2)), breakSize, drawOutline, aliasOffset);
                        }
                        else if (value1 < ptMin) {
                            drawNormal = OutlierRender.breakColumn(ctx, x2, y2, x1, y1, x2, (valMin - (hatchSize * 2)), breakSize, drawOutline, aliasOffset);
                        }
                        else if (worldY < ptMin) {
                            drawNormal = OutlierRender.breakColumn(ctx, x2, y2, x1, y1, x2, (valMin - (hatchSize * 2)), breakSize, drawOutline, aliasOffset);
                        }
                        else if (worldY > ptMax) {
                            drawNormal = OutlierRender.breakColumn(ctx, x2, y2, x1, y1, x2, (valMax + (hatchSize * 2)), breakSize, drawOutline, aliasOffset);
                        }
                        else {
                            drawNormal = true;
                        }
                    }
                }
                else {
                    drawNormal = true;
                }
                var thinX = void 0;
                // This is necessary for the hitshapes and selection markers to function correctly.
                if (this.isThin) {
                    thinX = (~~(x1 + ((Math.abs(x1 - x2)) / 2))) - (~~(penProps.lineWidth / 2));
                }
                if (drawNormal) {
                    if (this.isThin) {
                        // Draw a rectangle with the width of the series foreground pen,
                        // offset to the left by half (rounded down) the width of the pen so
                        // that the shape draws centered at the datapoint.
                        ctx.fillRect(thinX, baseY1, penProps.lineWidth, (Math.abs(y1 - y2)));
                    }
                    else {
                        var strokeWidth = (Math.abs(x1 - x2)) - 1;
                        var strokeHeight = (Math.abs(y1 - y2)) - 1;
                        ctx.fillRect(x1, baseY1, (Math.abs(x1 - x2)), (Math.abs(y1 - y2)));
                        ctx.strokeRect(x1 + penProps.aliasOffset, baseY1 + penProps.aliasOffset, strokeWidth, strokeHeight);
                    }
                }
                // Create and add the hitshapes
                var minX = Math.min(x1, x2);
                var maxX = Math.max(x1, x2);
                // Stores the selection marker point positions
                var selMarkerX1 = minX;
                var selMarkerY1 = baseY1;
                var selMarkerX2 = maxX;
                var selMarkerY2 = baseY2;
                var hitX = void 0, hitW = void 0;
                if (this.isThin) {
                    hitX = thinX;
                    hitW = penProps.lineWidth;
                }
                else {
                    hitX = x1;
                    hitW = Math.abs(x1 - x2);
                }
                var hitRect = new FDSRectangleHitShape(hitX + prm.plotRect.x1, baseY1 + prm.plotRect.y1, hitW, (Math.abs(y1 - y2)));
                hitRect.index = i;
                this.series.hitVector.push(hitRect);
                this.series.addLookupPoint(hitRect.x + (hitRect.width / 2), [hitRect.y], i);
                // Cache the selection marker positions
                if (this.seriesSelected && Math.abs(selMarkerY2 - selMarkerY1) >= 1 &&
                    this._selectionSampler.isPointSampled(selectionIndex++)) {
                    this.cacheSelectable(prm, 0 /* NONE */, selMarkerX1, selMarkerY1);
                    this.cacheSelectable(prm, 0 /* NONE */, selMarkerX1, selMarkerY2);
                    if (!this.isThin) {
                        this.cacheSelectable(prm, 0 /* NONE */, selMarkerX2, selMarkerY2);
                        this.cacheSelectable(prm, 0 /* NONE */, selMarkerX2, selMarkerY1);
                    }
                }
                // Handle outlier markers (These are separate from normal markers!)
                if (outlierStyle === 1 /* MARKER */) {
                    ctx.save();
                    // Set up Pen and Brush
                    this.series.seriesOutlierIndicatorFGPen.setOnCanvas(ctx);
                    this.series.seriesOutlierIndicatorBGBrush.setOnCanvas(ctx);
                    if (value1 > ptMax) {
                        var markerX = Math.round((x1 + x2) / 2.0);
                        var markerY = valMax + ((markerSize / 2) * sign);
                        this.drawOutlierMarkerCorrectly(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if (value1 < ptMin) {
                        var markerX = Math.round((x1 + x2) / 2.0);
                        var markerY = valMin - ((markerSize / 2) * sign);
                        this.drawOutlierMarkerCorrectly(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    ctx.restore();
                }
            }
            this._resetColorMapColor(brush);
            ctx.restore();
            var _b;
        };
        OldColumnsDrawStyle.prototype.verify = function () {
            return true;
        };
        OldColumnsDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        OldColumnsDrawStyle.prototype.getStackedYPosition = function (prm, xData) {
            if (this.series.isStacked) {
                return prm.renderCache.colsSumMap[xData.toString()][this.series.id] + prm.plotRect.y1;
            }
            else {
                return undefined;
            }
        };
        // Helper function to setOnCanvas the necessary pens and brushes
        // (since the same logic is in both the main draw fn and the legend fn)
        // returns [brush, pen property object]
        OldColumnsDrawStyle.prototype._choosePens = function (ctx, legend) {
            var penProps = null;
            var pen;
            // Set up fg color
            if (legend) {
                // Use a special thin pen to draw the legend
                if (this.isThin) {
                    pen = this.series.seriesFGPen;
                }
                else {
                    pen = this.series.seriesOutlinePen;
                }
                pen = pen.with({ width: 1 });
                pen.setOnCanvas(ctx);
                penProps = pen.toPropertyObject();
            }
            else {
                if (this.isThin) {
                    pen = this.series.seriesFGPen;
                }
                else {
                    pen = this.series.seriesOutlinePen;
                }
                pen.setOnCanvas(ctx);
                penProps = pen.toPropertyObject();
            }
            var brush;
            // Set up bg color
            if (this.isThin) {
                brush = new FDSBrush();
                brush.color = this.series.seriesFGPen.color;
                brush.style = 0 /* SOLID */;
            }
            else {
                brush = this.series.seriesBGBrush;
            }
            brush.setOnCanvas(ctx);
            return { brush: brush, pen: pen, penProps: penProps };
        };
        OldColumnsDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, true);
            // Logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            var halfminus = ~~(minus / 2);
            if (this.isThin) {
                ctx.beginPath();
                ctx.moveTo(x - halfminus, y + minus);
                ctx.lineTo(x - halfminus, y);
                ctx.moveTo(x, y + minus);
                ctx.lineTo(x, y - plus);
                ctx.moveTo(x + halfplus, y + minus);
                ctx.lineTo(x + halfplus, y);
                ctx.stroke();
            }
            else {
                ctx.fillRect(x - halfminus, y - plus, halfminus + halfplus, minus + plus);
                ctx.strokeRect(x - halfminus, y - plus, halfminus + halfplus, minus + plus);
            }
        };
        return OldColumnsDrawStyle;
    }(BaseRectangularDrawStyle));
    
    var Columns3dDrawStyle = /** @class */ (function (_super) {
        __extends(Columns3dDrawStyle, _super);
        function Columns3dDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this.is3D = true;
            return _this;
        }
        Columns3dDrawStyle.prototype.getCoordinates = function (prm, i, passedVals, retVals) {
            var xoffset;
            var initOffset = 0.0;
            _a = this._xScale.lookupRange(passedVals.xval1), retVals.x1 = _a[1], retVals.x2 = _a[2], initOffset = _a[3];
            if (fuzzyLT(initOffset, 0.001)) {
                initOffset = 0.0;
            }
            var num = prm.plot.subPlotFromNDC(initOffset, 1 /* X */);
            var yoffset = xoffset = ~~num;
            var delta = ((retVals.x2 - initOffset) - (retVals.x1 + initOffset)) / prm.nHorizontalBars;
            retVals.x1 = retVals.x1 + initOffset + (delta * this.series.barNumber * Number(prm.useDelta));
            retVals.x1 = retVals.x2 = (prm.plot.subPlotFromNDC(retVals.x1, 1 /* X */) +
                prm.plot.subPlotFromNDC(retVals.x1 + delta, 1 /* X */)) / 2.0;
            retVals.y1 = prm.plot.subPlotFromNDC(this._yScale.lookup(passedVals.yval1), 2 /* Y */);
            var isPositiveStacking = retVals.y2 > retVals.y1;
            if (this.series.seriesValuePlacement === 2 /* OUTSIDE */ && isPositiveStacking) {
                this._centerLabelOnTopOf3dColumn(retVals, yoffset, xoffset);
            }
            return retVals;
            var _a;
        };
        Columns3dDrawStyle.prototype._centerLabelOnTopOf3dColumn = function (retVals, yoffset, xoffset) {
            retVals.y1 -= yoffset / 2.0;
            retVals.x1 += xoffset / 2.0;
        };
        Columns3dDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            // The normal bars style checks if it's 3d and if so calls our 3d draw method before
            // it draws each bar
            _super.prototype.drawToBuffer.call(this, prm, ctx);
        };
        Columns3dDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, false);
            var size = Math.min(height * 0.8, width * 0.8);
            var h = size * 0.8;
            var w = h / 2;
            var w3d = ~~(size * 0.2); // Size of the 3d part
            var halfW = ~~(w / 2);
            var halfH = ~~(h / 2);
            // First do the 3d bits
            ctx.beginPath();
            ctx.moveTo(x - halfW, y - halfH);
            ctx.lineTo((x - halfW) + w3d, y - halfH - w3d);
            ctx.lineTo(x + halfW + w3d, y - halfH - w3d);
            ctx.lineTo(x + halfW, y - halfH);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + halfW, y - halfH);
            ctx.lineTo(x + halfW + w3d, y - halfH - w3d);
            ctx.lineTo(x + halfW + w3d, (y + halfH) - w3d);
            ctx.lineTo(x + halfW, y + halfH);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Now do the main rect
            // reset w and h to account for rounding nonsense
            w = 2 * halfW;
            h = 2 * halfH;
            ctx.fillRect(x - halfW, y - halfH, w, h);
            ctx.strokeRect(x - halfW, y - halfH, w, h);
        };
        Columns3dDrawStyle.prototype.verify = function () {
            return true;
        };
        Columns3dDrawStyle.prototype.hint = function () {
            return 6 /* COLUMNS */;
        };
        return Columns3dDrawStyle;
    }(OldColumnsDrawStyle));
    
    var PlotRenderManager = /** @class */ (function () {
        function PlotRenderManager(crm, plot) {
            this.crm = crm;
            this.plot = plot;
            this.chart = this.crm.chart;
            this.selectionEnabled = true;
            this.crosshairX = this.crosshairY = 0;
            this.nHorizontalBars = 1;
            this.nVerticalBars = 1;
            this.useDelta = true;
            this._lastPass = false;
            // masterlist of infoboxes for autopositioning
            this.autoPositionBoxes = [];
            this.infoboxes = [];
            this.hasData = this.hasPrimaryData = false;
            this.renderCache = new BaseRenderCache(null);
        }
        // sets up conditional colors on every series before drawing happens
        PlotRenderManager.prototype.preDraw = function () {
            _$1.forOwn(this.plot.seriesList, function (series) { return series.preDraw(); });
        };
        PlotRenderManager.prototype.draw = function (redrawNonInteractive) {
            var _this = this;
            if (redrawNonInteractive === void 0) { redrawNonInteractive = true; }
            this.plot.hitShapes = [];
            // three arrays to make sure we draw these in separate passes
            var firstSeries = [];
            var middleSeries = [];
            var lastSeries = [];
            this.plotRect = this.plot.plotRect;
            this.chartRect = new Rectangle(this.plot.minXFactor, this.plot.minYFactor, this.plot.maxXFactor, this.plot.maxYFactor);
            // These lists will keep track of the series markers we draw across all series.
            this.allSeriesMarkerRects = [];
            this.nonAnnotationSeriesMarkerRects = [];
            this.autoPositionBoxes = [];
            this.infoboxes = [];
            this.hasData = false;
            this.hasPrimaryData = false;
            function isRectLike(ds) {
                return (ds === 27 /* RECT */ || ds === 29 /* HORZRECT */ || ds === 28 /* VERTRECT */);
            }
            _$1.forOwn(this.plot.seriesList, function (series) {
                if (series.isAnnotation) {
                    // rectangle annotations go behind the series, other ones go on top
                    if (isRectLike(series.getEffectiveDrawStyle())) {
                        firstSeries.push(series);
                    }
                    else {
                        lastSeries.push(series);
                    }
                }
                else {
                    middleSeries.push(series);
                }
                _this.hasData = _this.hasData || series.hasValidData;
                _this.hasPrimaryData = _this.hasPrimaryData || series.hasValidPrimaryData;
                // the series might have children - draw those too
                for (var id in series.children) {
                    var child = series.children[id];
                    if (!isSeries(child)) {
                        continue;
                    }
                    var childSeries = child;
                    if (childSeries.isAnnotation) {
                        if (isRectLike(childSeries.getEffectiveDrawStyle())) {
                            firstSeries.push(childSeries);
                        }
                        else {
                            lastSeries.push(childSeries);
                        }
                    }
                    else if (childSeries.hasValidData) {
                        middleSeries.push(childSeries);
                    }
                    _this.hasData = _this.hasData || childSeries.hasValidData;
                    _this.hasPrimaryData = _this.hasPrimaryData || childSeries.hasValidPrimaryData;
                }
            });
            // combine the series arrays so that annotations are drawn first
            this.plotSeries = firstSeries.concat((middleSeries.concat(lastSeries)));
            if (redrawNonInteractive) {
                this._dsList = [];
                // Drawing takes place in two phases: non-interactive and interactive.
                // Non-interactive drawing is the expensive stuff: series, axes, etc.,
                // while interactive drawing is the easy stuff like labels, headers and
                // crosshairs.
                this._dsList = this._drawNonInteractive();
            }
            this._drawInteractive(this._dsList);
            // do this at the end because some hitshapes are set up during draw
            this.plot.setHitList();
        };
        PlotRenderManager.prototype.resetSeriesCrosshairIndices = function () {
            _$1.forOwn(this.plot.seriesList, function (series) {
                series.crosshairIndex = -1;
            });
        };
        PlotRenderManager.prototype._drawNonInteractive = function () {
            // Draw noninteractive components
            var ctx = this.chart.getContext();
            this._drawFill(ctx);
            this._drawOutline(ctx);
            this._drawPlotOutline(ctx);
            // We can stop right here if we're just rendering empty message.
            if (!this.hasPrimaryData) {
                this._drawLegend(ctx);
                return [];
            }
            this._drawSeriesBackground(ctx);
            if (!this.plot.isFullPlotDrawStyle()) {
                this._drawAxes(ctx);
            }
            var dsList = this._drawSeries(ctx);
            renderReferenceLines(ctx, this.plot);
            this._drawQuickLabels(ctx);
            this._drawLegend(ctx);
            return dsList;
        };
        PlotRenderManager.prototype._drawInteractive = function (dsList) {
            // Draw potentially interactive components to a separate canvas
            var overlayCtx = this.chart.getOverlayContext();
            this._drawHeaders(overlayCtx);
            this._drawFooter(overlayCtx);
            this._drawInteractionObject(overlayCtx);
        };
        PlotRenderManager.prototype.drawSelectionMarkers = function (markerCtx) {
            this._drawSeriesSelectionMarkers(markerCtx, this._dsList);
        };
        PlotRenderManager.prototype._drawInteractionObject = function (overlayCtx) {
            var interactionObj = this.chart.getInteractionObject();
            // This means that our drawing tool we are interacting with is on this plot
            if (!isSeries(interactionObj) || interactionObj.getPlotParent() !== this.plot) {
                return;
            }
            var series = interactionObj;
            // set up the label brush
            if (series.seriesValueBGColorDef) {
                series.seriesLabelBrush.color = this.plot.plotBGBrush.color;
            }
            series.hitVector = [];
            overlayCtx.save();
            this._setupCtxClippingAndTranslation(overlayCtx);
            // interaction object is always selected and sometimes this member on the DrawStyle.ecomes stale so lets set it
            // to true
            this.chart.interactiveDrawStyle.seriesSelected = true;
            this.chart.interactiveDrawStyle.drawBackgroundToBuffer(this, overlayCtx);
            this.chart.interactiveDrawStyle.drawToBuffer(this, overlayCtx);
            this.chart.interactiveDrawStyle.drawMarkersToBuffer(this, overlayCtx);
            overlayCtx.restore();
            this.chart.interactiveDrawStyle.drawTextToBuffer(this, overlayCtx, false);
            this._drawDeferredAutoPositionLabels(overlayCtx, [this.chart.interactiveDrawStyle]);
        };
        PlotRenderManager.prototype.hasSelectionMarkers = function () {
            var interactionObj = this.chart.getInteractionObject();
            if (isSeries(interactionObj)) {
                return true;
            }
            return _$1.some(this._dsList, function (ds) { return ds.series.isSelected(); });
        };
        PlotRenderManager.prototype._drawSeriesSelectionMarkers = function (markerCtx, dsList) {
            if (dsList === void 0) { dsList = null; }
            var interactionObj = this.chart.getInteractionObject();
            if (dsList === null) {
                return;
            }
            for (var _i = 0, dsList_1 = dsList; _i < dsList_1.length; _i++) {
                var ds = dsList_1[_i];
                if (ds.series.isSelected() && ds.series !== interactionObj) {
                    ds.drawSelectionMarkers(this, markerCtx);
                    ds.drawAnnotationSelectionMarkers(this, markerCtx);
                }
            }
            // Draw the interactive object's selection markers last separately.
            if (isSeries(interactionObj) && interactionObj.getPlotParent() === this.plot) {
                this.chart.interactiveDrawStyle.drawSelectionMarkers(this, markerCtx);
                this.chart.interactiveDrawStyle.drawAnnotationSelectionMarkers(this, markerCtx);
            }
        };
        PlotRenderManager.prototype._drawHeaders = function (overlayCtx) {
            var headers = [
                this.plot.header,
                this.plot.heading1,
                this.plot.heading2,
                this.plot.heading3,
                this.plot.heading4
            ];
            var headerNames = ['Header', 'Heading1', 'Heading2', 'Heading3', 'Heading4'];
            this.plot.storedHeaderRects = [];
            this.plot.root.headerPixelPoints[this.plot.id] = [];
            var headerOffset = 0;
            for (var i = 0; i < headers.length; i++) {
                var header = headers[i];
                if (header.visible) {
                    var _a = header.computeTextDimensions(overlayCtx), width = _a[0], height = _a[1];
                    header.drawToCanvas(overlayCtx, (this.plot.headerRect.y1 + headerOffset), this.plot.headerRect, this);
                    // save the header hitshape
                    var rect = new FDSRectangleHitShape(this.plot.headerRect.x1, this.plot.headerRect.y1 + headerOffset, this.plotRect.getWidth(), height);
                    rect.name = headerNames[i];
                    this.plot.storedHeaderRects.push(rect);
                    // also save the pixel point
                    var pixX = ~~(rect.x + rect.width / 2);
                    var pixY = ~~(rect.y + rect.height / 2);
                    this.plot.root.headerPixelPoints[this.plot.id].push({ x: pixX, y: pixY });
                    headerOffset += height;
                }
            }
        };
        PlotRenderManager.prototype._drawFooter = function (overlayCtx) {
            if (!this.plot.footer.visible) {
                return;
            }
            // Position of the footer text is based off the height of the
            // plot, axis elements, legend (if in alt position) and centered
            // with the remaining space before the end of the chart.
            var plotHeight = this.plot.plotRect.y2;
            var axisHeight = this.plot.bottomAxisHeight;
            var footerMinorOffset = 5; // Matches FDSChart the closest
            var isLegendBelowPlot = (this.plot.isActiveLegendHeatmap()) ?
                (this.plot.heatmapLegend.legendProperties.position === 0 /* BELOW */) :
                (this.plot.legend.legendProperties.axisPosition === 1 /* ALTERNATE */);
            var legendHeight = isLegendBelowPlot ? this.plot.legendRect.y2 - this.plot.legendRect.y1 : 0;
            var footerOffset = plotHeight + axisHeight + legendHeight + footerMinorOffset + this.plot.bottomPlotMargin;
            this.plot.footer.drawToCanvas(overlayCtx, (footerOffset), this.plot.footerRect, this);
            // save the footer hitshape
            var _a = this.plot.footer.computeTextDimensions(overlayCtx), width = _a[0], height = _a[1];
            var rect = new FDSRectangleHitShape(this.plot.footerRect.x1, footerOffset, this.plotRect.getWidth(), height);
            rect.name = 'Footer';
            this.plot.storedHeaderRects.push(rect);
            // also save the footer pixel points
            var pixX = ~~(rect.x + rect.width / 2);
            var pixY = ~~(rect.y + rect.height / 2);
            this.plot.root.headerPixelPoints[this.plot.id].push({ x: pixX, y: pixY });
        };
        PlotRenderManager.prototype._drawOutline = function (ctx) {
            if (this.plot.chartFGPen.style !== 5 /* NULL */) {
                this.plot.chartFGPen.setOnCanvas(ctx);
                this.chartRect.strokeInternal(ctx);
            }
        };
        PlotRenderManager.prototype._drawFill = function (ctx) {
            if (this.plot.chartBGBrush.style !== 1 /* NULL */) {
                // fill in the plot bg based on the plotfactor dimensions
                this.plot.chartBGBrush.setOnCanvas(ctx, this.chartRect);
                ctx.fillRect(this.chartRect.x1, this.chartRect.y1, this.chartRect.getWidth(), this.chartRect.getHeight());
            }
            if (this.plot.plotBGBrush.style !== 1 /* NULL */) {
                // Set the plot rect based on the plot dimensions
                this.plot.plotBGBrush.setOnCanvas(ctx, this.plotRect);
                ctx.fillRect(this.plotRect.x1, this.plotRect.y1, this.plotRect.getWidth(), this.plotRect.getHeight());
            }
            // save pixel points for the corners and center
            var width = this.plotRect.getWidth();
            var leftX = ~~(this.plotRect.x1 + width / 30);
            var centX = ~~(this.plotRect.x1 + width / 2);
            var rightX = ~~(this.plotRect.x1 + (width * 29) / 30);
            var height = this.plotRect.getHeight();
            var upY = ~~(this.plotRect.y1 + height / 30);
            var centY = ~~(this.plotRect.y1 + height / 2);
            var lowY = ~~(this.plotRect.y1 + (height * 29) / 30);
            var pixPts = [];
            // order: upper left, upper right, lower left, lower right, center
            pixPts.push({ x: leftX, y: upY });
            pixPts.push({ x: rightX, y: upY });
            pixPts.push({ x: leftX, y: lowY });
            pixPts.push({ x: rightX, y: lowY });
            pixPts.push({ x: centX, y: centY });
            this.plot.root.pixelPoints[this.plot.id] = pixPts;
            if (!this.hasPrimaryData) {
                this.drawEmptyMessage(ctx);
            }
        };
        PlotRenderManager.prototype.drawEmptyMessage = function (ctx) {
            var emptyMessage = this.plot.attributeSet.get('EmptyMessage');
            var _a = RichTextRenderer.measureRichText(ctx, emptyMessage, this.plot.emptyMessageFont), textDimensions = _a[0], prepared = _a[1];
            RichTextRenderer.writeRichText(ctx, emptyMessage, this.plot.plotFromNDC(0.5, 1 /* X */) - textDimensions.width / 2, this.plot.plotFromNDC(0.5, 2 /* Y */) - textDimensions.height / 2, this.plot.emptyMessageFont, 2 /* CENTER */, prepared);
        };
        PlotRenderManager.prototype._drawAxes = function (ctx) {
            var axesToDraw = [];
            var startPrimaryX = this.plotRect.y2;
            var startAltX = this.plotRect.y1;
            // start the axis at the plot edge, unless there are quicklabels...
            var startPrimaryY = this.plotRect.x2 + this.plot.rightQuickLabelOffsets.beforeAxes;
            var startAltY = this.plotRect.x1 - this.plot.leftQuickLabelOffsets.beforeAxes;
            var currentPrimaryAxisPos = {};
            currentPrimaryAxisPos[1 /* X */] = startPrimaryX;
            currentPrimaryAxisPos[2 /* Y */] = currentPrimaryAxisPos[3 /* Z */] = startPrimaryY;
            var currentAlternateAxisPos = {};
            currentAlternateAxisPos[1 /* X */] = startAltX;
            currentAlternateAxisPos[2 /* Y */] = currentAlternateAxisPos[3 /* Z */] = startAltY;
            var oldPrimaryAxisPos = {};
            var oldAlternateAxisPos = {};
            // We have to do some special positioning if there are multiple axes on the same side
            var axisPrimary = {};
            var axisAlternate = {};
            axisPrimary[1 /* X */] = axisPrimary[2 /* Y */] = axisAlternate[1 /* X */] = axisAlternate[2 /* Y */] = false;
            // used by quicklabels
            this._primaryAxisInner = this._alternateAxisOuter = Infinity;
            this._alternateAxisInner = this._primaryAxisOuter = -1;
            for (var _i = 0, _a = this.plot.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (!axis.shouldDraw()) {
                    axis.clearLabels();
                    continue;
                }
                if ([1 /* X */, 2 /* Y */, 3 /* Z */].indexOf(axis.dimension) === -1) {
                    continue;
                }
                var x = 0;
                var y = 0;
                var axisHeight = 0;
                var axisWidth = 0;
                var titleWidth = 0;
                var labelWidth = 0;
                var quickLabelPrimaryMaxWidth = 0;
                var quickLabelAlternateMaxWidth = 0;
                var newWidth = 0;
                if (axis.dimension === 2 /* Y */) {
                    for (var _b = 0, _c = axis.associatedSeries; _b < _c.length; _b++) {
                        var series = _c[_b];
                        if (!series.quickLabel) {
                            continue;
                        }
                        newWidth = series.getCalculatedQuickLabelWidth();
                        if (series.quickLabelRightPositionModifier === 3 /* ON_AXIS */) {
                            quickLabelPrimaryMaxWidth = Math.max(quickLabelPrimaryMaxWidth, newWidth);
                        }
                        if (series.quickLabelLeftPositionModifier === 3 /* ON_AXIS */) {
                            quickLabelAlternateMaxWidth = Math.max(quickLabelAlternateMaxWidth, newWidth);
                        }
                    }
                }
                var axisFontHeight = axis.axisFont.getHeight();
                oldAlternateAxisPos[axis.dimension] = currentAlternateAxisPos[axis.dimension];
                oldPrimaryAxisPos[axis.dimension] = currentPrimaryAxisPos[axis.dimension];
                if (axis.titleEnabled) {
                    var _d = axis.getTitleDimensions(ctx), tWidth = _d[0], tHeight = _d[1];
                    if (axis.dimension === 1 /* X */) {
                        titleWidth = tHeight;
                    }
                    else {
                        titleWidth = tWidth;
                    }
                }
                if (axis.labeled) {
                    if (axis.dimension === 1 /* X */) {
                        labelWidth = axis.scale.maxDimensions.height + axis.labelOffset;
                    }
                    else {
                        labelWidth = axis.scale.maxDimensions.width + axis.labelOffset + axis.labelLeftMargin;
                    }
                }
                var maxQuickLabelWidth = axis.isOnPrimarySide(axis.labelPosition) ?
                    quickLabelPrimaryMaxWidth :
                    quickLabelAlternateMaxWidth;
                var componentMap = [
                    {
                        draw: axis.isAxisLineDrawn(),
                        componentPos: axis.axisPosition,
                        width: axis.axisFGPen.width + axis.axisOffset
                    },
                    {
                        draw: axis.areTicksDrawn(),
                        componentPos: axis.ticksPosition,
                        width: axis.getTickLength() + axis.ticksOffset
                    },
                    {
                        draw: axis.areLabelsDrawn(),
                        componentPos: axis.labelPosition,
                        width: Math.max(labelWidth, maxQuickLabelWidth)
                    },
                    {
                        // titles at end don't affect the axis rect size
                        draw: (axis.titlePosition !== 4 /* HIDDEN */) && axis.titleEnabled && !axis.titleAtEnd,
                        componentPos: axis.titlePosition,
                        width: titleWidth + axis.titleOffset
                    }
                ];
                if (axis.dimension === 1 /* X */) {
                    axisWidth = this.plotRect.getWidth();
                    axisHeight = axis.maxDimensions.height;
                    x = this.plotRect.x1;
                }
                else {
                    axisWidth = 0;
                    axisHeight = this.plotRect.getHeight();
                    y = this.plotRect.y1;
                }
                for (var _e = 0, componentMap_1 = componentMap; _e < componentMap_1.length; _e++) {
                    var _f = componentMap_1[_e], draw = _f.draw, componentPos = _f.componentPos, width = _f.width;
                    if (!draw) {
                        continue;
                    }
                    if (axis.dimension === 2 /* Y */) {
                        axisWidth += width;
                    }
                    if (axis.isOnPrimarySide(componentPos) || componentPos === 2 /* BOTH */) {
                        currentPrimaryAxisPos[axis.dimension] += width;
                    }
                    if (!axis.isOnPrimarySide(componentPos) || componentPos === 2 /* BOTH */) {
                        currentAlternateAxisPos[axis.dimension] -= width;
                    }
                }
                // Following code is used to add the gap between mutliple axes on the same
                // side of the plot
                var alternateWidth = Math.abs(currentAlternateAxisPos[axis.dimension] - oldAlternateAxisPos[axis.dimension]);
                var primaryWidth = Math.abs(currentPrimaryAxisPos[axis.dimension] - oldPrimaryAxisPos[axis.dimension]);
                if (alternateWidth > 0) {
                    if (axisAlternate[axis.dimension]) {
                        currentAlternateAxisPos[axis.dimension] -= this.plot.axisGap;
                        oldAlternateAxisPos[axis.dimension] -= this.plot.axisGap;
                    }
                    else {
                        axisAlternate[axis.dimension] = true;
                    }
                }
                if (primaryWidth > 0) {
                    if (axisPrimary[axis.dimension]) {
                        currentPrimaryAxisPos[axis.dimension] += this.plot.axisGap;
                        oldPrimaryAxisPos[axis.dimension] += this.plot.axisGap;
                    }
                    else {
                        axisPrimary[axis.dimension] = true;
                    }
                }
                if (axis.dimension === 2 /* Y */) {
                    // save axis box inner and outer edges for displaying quick labels later
                    this._alternateAxisOuter = Math.min(this._alternateAxisOuter, currentAlternateAxisPos[axis.dimension]);
                    this._alternateAxisInner = Math.max(this._alternateAxisInner, oldAlternateAxisPos[axis.dimension]);
                    this._primaryAxisInner = Math.min(this._primaryAxisInner, oldPrimaryAxisPos[axis.dimension]);
                    this._primaryAxisOuter = Math.max(this._primaryAxisOuter, currentPrimaryAxisPos[axis.dimension]);
                }
                var alternateAxisRect = void 0;
                var primaryAxisRect = void 0;
                if (axis.dimension === 1 /* X */) {
                    alternateAxisRect = new Rectangle(x, currentAlternateAxisPos[axis.dimension], x + axisWidth, oldAlternateAxisPos[axis.dimension]);
                    primaryAxisRect = new Rectangle(x, currentPrimaryAxisPos[axis.dimension], x + axisWidth, oldPrimaryAxisPos[axis.dimension]);
                }
                else {
                    alternateAxisRect = new Rectangle(currentAlternateAxisPos[axis.dimension], y, oldAlternateAxisPos[axis.dimension], y + axisHeight);
                    primaryAxisRect = new Rectangle(currentPrimaryAxisPos[axis.dimension], y, oldPrimaryAxisPos[axis.dimension], y + axisHeight);
                }
                axesToDraw.push({
                    axis: axis,
                    alternateAxisRect: alternateAxisRect,
                    primaryAxisRect: primaryAxisRect
                });
            }
            // error checking - these won't get set if there is no axis on their side.
            // then we should set them on the plot edge
            if (this._alternateAxisInner === -1) {
                this._alternateAxisInner = this.plotRect.x1;
            }
            if (this._alternateAxisOuter === -1) {
                this._alternateAxisOuter = this.plotRect.x1;
            }
            if (this._primaryAxisInner === Infinity) {
                this._primaryAxisInner = this.plotRect.x2;
            }
            if (this._primaryAxisOuter === Infinity) {
                this._primaryAxisOuter = this.plotRect.x2;
            }
            // empty the array of stored axis rects - we're about to remake it
            this.plot.storedAxisRects = [];
            for (var _g = 0, axesToDraw_1 = axesToDraw; _g < axesToDraw_1.length; _g++) {
                var _h = axesToDraw_1[_g], axis = _h.axis, alternateAxisRect = _h.alternateAxisRect, primaryAxisRect = _h.primaryAxisRect;
                var id = (axis.isBuiltInAxis ? axis.getPrefix() : axis.id);
                if (alternateAxisRect.getWidth() !== 0 && alternateAxisRect.getHeight() !== 0) {
                    this.plot.addAxisRect(id, alternateAxisRect, 'Axis');
                }
                if (primaryAxisRect.getWidth() !== 0 && primaryAxisRect.getHeight() !== 0) {
                    this.plot.addAxisRect(id, primaryAxisRect, 'Axis');
                }
            }
            renderAxisLines(ctx, this.plot, axesToDraw);
        };
        PlotRenderManager.prototype._drawPlotOutline = function (ctx) {
            // This needs to happen after the call to `_drawAxes`, since
            // when the axes draw their grid lines, the grid lines may draw on top of
            // the plot outline.
            var fgPen = this.plot.plotFGPen;
            if (fgPen.style !== 5 /* NULL */) {
                fgPen.setOnCanvas(ctx);
                this.plotRect.stroke(ctx);
            }
        };
        PlotRenderManager.prototype._setupCtxClippingAndTranslation = function (ctx) {
            if (this.plot.clipSubPlot || this.plot.clipSubPlotX) {
                var leftClip = this.plot.subPlotFromNDC(0.0, 1 /* X */);
                var rightClip = this.plot.subPlotFromNDC(1.0, 1 /* X */);
                ctx.rect(this.plotRect.x1 + leftClip, this.plotRect.y1, rightClip, this.plotRect.getHeight());
                ctx.clip();
            }
            else if (this.plot.clipPlot) {
                ctx.rect(this.plotRect.x1, this.plotRect.y1, this.plotRect.getWidth(), this.plotRect.getHeight());
                ctx.clip();
            }
            ctx.translate(this.plotRect.x1, this.plotRect.y1);
        };
        PlotRenderManager.prototype._drawSeriesBackground = function (ctx) {
            ctx.save();
            this._setupCtxClippingAndTranslation(ctx);
            if (this.hasData) {
                for (var _i = 0, _a = this.plotSeries; _i < _a.length; _i++) {
                    var series = _a[_i];
                    if (!series.drawBelow || !series.visible || series.interactiveVisibleOverride) {
                        continue;
                    }
                    // set up the label brush
                    if (series.seriesValueBGColorDef) {
                        series.seriesLabelBrush.color = this.plot.plotBGBrush.color;
                    }
                    // Might need this for sampling, unsure yet.
                    series.plotWidth = this.plotRect.getWidth();
                    // Choose appropriate render manager for the specified drawstyle
                    var drawStyle = series.getDrawStylePrototype().drawStyle;
                    drawStyle.drawBackgroundToBuffer(this, ctx);
                }
            }
            ctx.restore();
        };
        PlotRenderManager.prototype._drawSeries = function (ctx) {
            this.renderCache.setInvalidated();
            var dsList = [];
            ctx.save();
            ctx.beginPath();
            this._setupCtxClippingAndTranslation(ctx);
            _a = this.plot.getXYBins(), this.nHorizontalBars = _a[0], this.nVerticalBars = _a[1], this.useDelta = _a[2];
            this.plot.seriesInterval = [];
            this.stacked3DColumns = {};
            this.stacked3DBars = {};
            this._lastPass = false;
            for (var i = 0; i < this.plotSeries.length; i++) {
                var series = this.plotSeries[i];
                series.hitVector = [];
                if (!series.visible || series.interactiveVisibleOverride) {
                    continue;
                }
                if (i === this.plotSeries.length - 1) {
                    this._lastPass = true;
                }
                this.chart.pixelPoints[series.id] = [];
                this.chart.infoboxPixelPoints[series.id] = [];
                series.clearPointLookup();
                // set up the label brush
                if (series.seriesValueBGColorDef) {
                    series.seriesLabelBrush.color = this.plot.plotBGBrush.color;
                }
                // Might need this for sampling, unsure yet.
                series.plotWidth = this.plotRect.getWidth();
                // Choose appropriate render manager for the specified drawstyle
                var drawStyle = series.getDrawStylePrototype().drawStyle;
                if (!series.drawBelow) {
                    drawStyle.drawBackgroundToBuffer(this, ctx);
                }
                drawStyle.drawToBuffer(this, ctx);
                drawStyle.drawMarkersToBuffer(this, ctx);
                drawStyle.drawTextToBuffer(this, ctx);
                dsList.push(drawStyle);
                // Add the series and its first and last lookup points to the
                // interval list so we can get the series under the crosshair
                // later
                var range = series.getPointLookupRange();
                if (range) {
                    this.plot.seriesInterval.push({
                        series: series,
                        first: range.min,
                        last: range.max
                    });
                }
            }
            // now we deal with 3d stacked bars/columns
            var colsLen = Object.keys(this.stacked3DColumns).length;
            var barsLen = Object.keys(this.stacked3DBars).length;
            if (colsLen > 0 || barsLen > 0) {
                // create a new DrawStyle.ith a dummy series. it doesn't matter, we just need one drawing function
                // problem: creating this wipes out the pixel points for series 0. so save and restore them.
                var series0 = this.plotSeries[0];
                var tmpPixels = this.plot.root.pixelPoints[series0.id];
                var cds = new Columns3dDrawStyle(series0);
                if (colsLen > 0) {
                    for (var xPt in this.stacked3DColumns) {
                        var arr = this.stacked3DColumns[xPt];
                        arr.sort(function (a, b) { return b.y1 - a.y1; });
                        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                            var obj = arr_1[_i];
                            obj.pen.setOnCanvas(ctx);
                            obj.brush.setOnCanvas(ctx);
                            cds._draw3DBar(obj.x1, obj.x2, obj.y1, obj.y2, ctx, obj.pen, obj.brush, obj.offset3D);
                        }
                    }
                }
                if (barsLen > 0) {
                    for (var yPt in this.stacked3DBars) {
                        var arr = this.stacked3DBars[yPt];
                        arr.sort(function (a, b) { return a.x1 - b.x1; });
                        for (var _b = 0, arr_2 = arr; _b < arr_2.length; _b++) {
                            var obj = arr_2[_b];
                            obj.pen.setOnCanvas(ctx);
                            obj.brush.setOnCanvas(ctx);
                            cds._draw3DBar(obj.x1, obj.x2, obj.y1, obj.y2, ctx, obj.pen, obj.brush, obj.offset3D, true);
                        }
                    }
                }
                this.plot.root.pixelPoints[series0.id] = tmpPixels;
            }
            ctx.restore();
            this._drawDeferredAutoPositionLabels(ctx, dsList);
            return dsList;
            var _a;
        };
        PlotRenderManager.prototype._drawDeferredAutoPositionLabels = function (ctx, dsList) {
            var didDrawStyleHandleAutoPosition = false;
            if (dsList[0]) {
                didDrawStyleHandleAutoPosition = dsList[0].autoPositionLabels(this.autoPositionBoxes, this, ctx);
            }
            var autoPositionBoxesAliasOffset = (!_$1.isEmpty(this.autoPositionBoxes)) ? this.autoPositionBoxes[0].FGPen.getAliasOffset() : 0;
            var autoPositionerOptions = new AutoPositionerOptions(2 /* Y */, true, null, autoPositionBoxesAliasOffset);
            // now that all the series labels have been generated, autoposition them!
            for (var _i = 0, _a = this.autoPositionBoxes; _i < _a.length; _i++) {
                var box = _a[_i];
                if (!didDrawStyleHandleAutoPosition) {
                    var offset = this._calcAutoPositionOffset(box, this.infoboxes, box.autoPositionMethod, autoPositionerOptions);
                    box.updateY(box.y + offset.y, ctx);
                }
                box.visible = true;
                // save the hitshape now
                if (box.saveHitshape) {
                    var series = this.chart.getChild(box.seriesID);
                    if (series != null) {
                        // if not, something weird has happened, don't proceed
                        var hitShapeId = series.hittableShapeIdentifier;
                        var rect = new FDSRectangleHitShape(new Rectangle(box.left(), box.top(), box.right(), box.bottom()));
                        rect.name = box.hitShapeId;
                        rect.objectPart = 2 /* SERIESLABEL */;
                        rect.index = box.index;
                        series.hitVector.push(rect);
                    }
                }
                this.infoboxes.push(box);
                // save pixel points now that it's been positioned
                var pixX = ~~(box.x + box.width / 2);
                var pixY = ~~(box.y + box.height / 2);
                this.chart.seriesLabelPixelPoints[box.seriesID][box.index] = { x: pixX, y: pixY };
            }
            // we need to first draw all the arrows before we move onto the boxes
            for (var _b = 0, _c = this.infoboxes; _b < _c.length; _b++) {
                var box = _c[_b];
                box.drawArrow(ctx);
            }
            // now draw all the boxes
            for (var _d = 0, _e = this.infoboxes; _d < _e.length; _d++) {
                var box = _e[_d];
                box.draw(ctx);
            }
            if (this.plot.seriesInterval.length !== 0) {
                this.plot.sortSeriesInterval();
            }
        };
        PlotRenderManager.prototype._calcAutoPositionOffset = function (rect, placedRects, autoPositionMode, options) {
            var boundRect = { x: 0, y: this.plotRect.y, height: this.plotRect.height, width: this.chartRect.width };
            var autoPositioner;
            var autoPositionOffset = { x: 0, y: 0 };
            switch (autoPositionMode) {
                case 4 /* FAST */:
                    autoPositioner = new AutoPositionerOverlapEliminating(this);
                    break;
                case 2 /* FIBONACCI */:
                    autoPositioner = new AutoPositionerFibonacciFallback(this);
                    break;
                case 1 /* LINEAR */:
                    autoPositioner = new AutoPositionerLinearFallback(this);
                    break;
                default:
                    break;
            }
            if (autoPositioner) {
                autoPositionOffset = autoPositioner.calcAutoPositionOffset(rect, placedRects, boundRect, options).offset;
            }
            else if (autoPositionMode === -1 /* PROGRESSIVE */) {
                autoPositionOffset = this.calcProgressiveAutoPositionOffset(rect, placedRects, boundRect, options).offset;
            }
            return autoPositionOffset;
        };
        PlotRenderManager.prototype.calcProgressiveAutoPositionOffset = function (rect, placedRects, boundaryRect, options) {
            var autoPositioner = new AutoPositionerOverlapEliminating(this);
            var autoPositionCalcResult = autoPositioner.calcAutoPositionOffset(rect, placedRects, boundaryRect, options);
            if (!autoPositionCalcResult.isSuccess) {
                autoPositioner = new AutoPositionerFibonacciFallback(this);
                autoPositionCalcResult = autoPositioner.calcAutoPositionOffset(rect, placedRects, boundaryRect, options);
                if (!autoPositionCalcResult.isSuccess) {
                    autoPositioner = new AutoPositionerLinearFallback(this);
                    autoPositionCalcResult = autoPositioner.calcAutoPositionOffset(rect, placedRects, boundaryRect, options);
                }
            }
            return autoPositionCalcResult;
        };
        PlotRenderManager.prototype._drawQuickLabels = function (ctx) {
            var _this = this;
            // clear the pixel points objects
            _$1.forIn(this.plot.seriesList, function (s) {
                _this.chart.quicklabelPixelPoints[s.id] = undefined;
            });
            // short circuit
            if (this.quickLabels.length === 0) {
                return;
            }
            // these are the actual boundaries of the series within the plot
            // the quicklabels will be drawn against these borders
            var minFactor = this.plot.getPlotFactor(1 /* X */, 'min');
            var maxFactor = this.plot.getPlotFactor(1 /* X */, 'max');
            // pass in the min/max factor because plotFromNDC doesn't use it
            var minX = this.plot.plotFromNDC(minFactor, 1 /* X */);
            var maxX = this.plot.plotFromNDC(maxFactor, 1 /* X */);
            var edges = {
                rightInside: 0,
                rightOutside: 0,
                rightBeforeAxes: 0,
                leftInside: Infinity,
                leftOutside: Infinity,
                leftBeforeAxes: Infinity,
                rightOnAxis: {},
                leftOnAxis: {}
            };
            var getTargetAxisId = function (ql) {
                var targetAxis = ql.series.getAxis(2 /* Y */);
                return targetAxis.getPrefix() || targetAxis.id;
            };
            var shownlabels = [];
            // first pass - calculate position and find edges for consolidation
            for (var _i = 0, _a = this.quickLabels; _i < _a.length; _i++) {
                var ql = _a[_i];
                // center the box vertically
                var scaleX = ql.series.getScale(1 /* X */);
                var scaleY = ql.series.getScale(2 /* Y */);
                var xPt = scaleX.lookup(ql.personalPoint.x);
                var yPt = scaleY.lookup(ql.personalPoint.y);
                var x = this.plot.plotFromNDC(xPt, 1 /* X */);
                var y = this.plot.plotFromNDC(yPt, 2 /* Y */);
                if (ql.series.isStacked) {
                    var drawStyle = ql.series.getDrawStylePrototype().drawStyle;
                    var newY = drawStyle.getStackedYPosition(this, ql.personalPoint.x);
                    if (!_$1.isUndefined(newY)) {
                        y = newY;
                    }
                }
                y -= (ql.height / 2);
                // error checking - label can't go below plot
                if (y + ql.height > this.plotRect.y2) {
                    y = this.plotRect.y2 - ql.height;
                }
                ql.update({
                    y: y,
                    arrowX: x,
                    arrowY: y
                }, ctx);
                var targetAxisId = getTargetAxisId(ql);
                var offset = void 0;
                var actualAxisWidth = void 0;
                var qlAxisRect = void 0;
                // largest and smallest x for the QuickLabelPositionModifier.OUTSIDE case
                var largestX = this.plotRect.x2;
                var smallestX = this.plotRect.x1;
                edges.rightOnAxis[targetAxisId] = 0;
                edges.leftOnAxis[targetAxisId] = Infinity;
                for (var _b = 0, _c = this.plot.storedAxisRects; _b < _c.length; _b++) {
                    var tempRect = _c[_b];
                    if (tempRect.tag !== 'Axis') {
                        continue;
                    }
                    if (tempRect.text === targetAxisId) {
                        qlAxisRect = tempRect.rect;
                    }
                    if (largestX < tempRect.rect.x2) {
                        largestX = tempRect.rect.x2;
                    }
                    if (smallestX > tempRect.rect.x1) {
                        smallestX = tempRect.rect.x1;
                    }
                }
                switch (ql.personalPosition) {
                    case 2 /* RIGHT */:
                        switch (ql.personalModifier) {
                            case 1 /* OUTSIDE */:
                                // the axis width that's saved contains the outside quicklabels,
                                // which we don't want to include here obviously
                                offset = this._adjustQuickLabelPosition(ql, this.plot.rightQuickLabelOffsets.outside);
                                actualAxisWidth = this.plot.rightAxisWidth - this.plot.rightQuickLabelOffsets.outside;
                                if (!qlAxisRect || qlAxisRect.x1 >= this.plotRect.x1) {
                                    ql.updateX(largestX + offset, ctx);
                                }
                                else {
                                    ql.updateX(this.plotRect.x2, ctx);
                                }
                                edges.rightOutside = Math.max(ql.right(), edges.rightOutside);
                                break;
                            case 2 /* BEFORE_AXES */:
                                offset = this._adjustQuickLabelPosition(ql, this.plot.rightQuickLabelOffsets.beforeAxes);
                                ql.updateX(this.plotRect.x2 + offset, ctx);
                                edges.rightBeforeAxes = Math.max(ql.right(), edges.rightBeforeAxes);
                                break;
                            case 3 /* ON_AXIS */:
                                offset = this._adjustQuickLabelPosition(ql, this.plot.rightQuickLabelOffsets.onAxis);
                                if (!qlAxisRect || qlAxisRect.x2 <= this.plotRect.x1) {
                                    // if we aren't drawing the axis, or it's on the opposite side
                                    ql.updateX(this.plotRect.x2 + offset, ctx);
                                }
                                else {
                                    ql.updateX(qlAxisRect.x1 + offset, ctx);
                                }
                                edges.rightOnAxis[targetAxisId] = Math.max(ql.right(), edges.rightOnAxis[targetAxisId]);
                                break;
                            default:// QuickLabelPositionModifier.INSIDE
                                offset = this._adjustQuickLabelPosition(ql, this.plot.rightQuickLabelOffsets.inside);
                                ql.updateX(maxX + offset, ctx);
                                edges.rightInside = Math.max(ql.right(), edges.rightInside);
                        }
                        break;
                    case 1 /* LEFT */:
                        switch (ql.personalModifier) {
                            case 1 /* OUTSIDE */:
                                offset = this._adjustQuickLabelPosition(ql, this.plot.leftQuickLabelOffsets.outside);
                                // again don't include the outside quicklabel widths in the
                                // outside label positioning
                                ql.updateX(smallestX - ql.width - offset, ctx);
                                edges.leftOutside = Math.min(ql.left(), edges.leftOutside);
                                break;
                            case 2 /* BEFORE_AXES */:
                                offset = this._adjustQuickLabelPosition(ql, this.plot.leftQuickLabelOffsets.beforeAxes);
                                ql.updateX(this.plotRect.x1 - ql.width - offset, ctx);
                                edges.leftBeforeAxes = Math.min(ql.left(), edges.leftBeforeAxes);
                                break;
                            case 3 /* ON_AXIS */:
                                offset = this._adjustQuickLabelPosition(ql, this.plot.leftQuickLabelOffsets.onAxis);
                                if (!qlAxisRect || qlAxisRect.x1 >= this.plotRect.x2) {
                                    // if we aren't drawing the axis, or it's on the opposite side
                                    ql.updateX(this.plotRect.x1 - ql.width - offset, ctx);
                                }
                                else {
                                    ql.updateX(qlAxisRect.x2 - ql.width - offset, ctx);
                                }
                                edges.leftOnAxis[targetAxisId] = Math.min(ql.left(), edges.leftOnAxis[targetAxisId]);
                                break;
                            default:// QuickLabelPositionModifier.INSIDE
                                offset = this._adjustQuickLabelPosition(ql, this.plot.leftQuickLabelOffsets.inside);
                                ql.updateX(minX - ql.width - offset, ctx);
                                edges.leftInside = Math.min(ql.left(), edges.leftInside);
                        }
                        break;
                }
            }
            var quickLabelAliasOffset = (!_$1.isEmpty(this.quickLabels)) ? this.quickLabels[0].FGPen.getAliasOffset() : 0;
            var autoPositionerOptions = new AutoPositionerOptions(2 /* Y */, false, null, quickLabelAliasOffset);
            // second pass - adjust the size of labels that need adjusting, autoposition, and draw
            for (var _d = 0, _e = this.quickLabels; _d < _e.length; _d++) {
                var ql = _e[_d];
                this._adjustQuickLabelForConsolidation(ql, edges, ctx, getTargetAxisId(ql));
                var quickLabelOffset = this._calcAutoPositionOffset(ql, shownlabels, ql.autoPositionMethod, autoPositionerOptions);
                ql.updateY(ql.y + quickLabelOffset.y, ctx);
                shownlabels.push(ql);
                ql.show(ctx);
                // just save the first ql point (we don't need both)
                if (!this.plot.root.quicklabelPixelPoints[ql.series.id]) {
                    var pixX = ql.x + ql.width / 2;
                    var pixY = ql.y + ql.height / 2;
                    this.plot.root.quicklabelPixelPoints[ql.series.id] = { x: pixX, y: pixY };
                }
                // now add hitshapes
                var rect = new FDSRectangleHitShape(ql.x, ql.y, ql.width, ql.height);
                rect.index = ql.personalIndex;
                rect.objectPart = 1 /* QUICKLABEL */;
                ql.series.hitVector.push(rect);
            }
        };
        // helper function to adjust label within space around it
        PlotRenderManager.prototype._adjustQuickLabelPosition = function (ql, offsets) {
            var offset = 0;
            switch (ql.alignment) {
                case 3 /* MIDDLE */:
                    offset = offsets / 2 - ql.width / 2;
                    break;
                case 2 /* OUTSIDE */:
                    offset = offsets - ql.width;
                    break;
            }
            offset += ql.personalGap;
            if (offset > offsets - ql.width) {
                offset = offsets - ql.width;
            }
            if (ql.personalModifier === 3 /* ON_AXIS */) {
                var yAxis = ql.series.getAxis(2 /* Y */);
                var onAxisOffset = yAxis.getTickLength() + yAxis.ticksOffset + yAxis.labelOffset - ql.getPadding();
                offset += onAxisOffset;
                // we subtract axisOffset because we want the tag to only go up to the axis line, even if that is offset from
                // the plot.
                ql.tagWidth = onAxisOffset - yAxis.axisOffset;
            }
            return offset;
        };
        // helper function because this is a big ugly switch to have in the main function
        PlotRenderManager.prototype._adjustQuickLabelForConsolidation = function (ql, edges, ctx, targetAxisId) {
            if (!ql.personalConsolidation) {
                return;
            }
            var newEdge;
            var qlRight = ql.right();
            var qlLeft = ql.left();
            // this sets newEdge to be the largest edge. it'll stay undefined if this box doesn't need to be changed
            switch (ql.personalPosition) {
                case 2 /* RIGHT */:
                    switch (ql.personalModifier) {
                        case 1 /* OUTSIDE */:
                            if (edges.rightOutside > qlRight) {
                                newEdge = edges.rightOutside;
                            }
                            break;
                        case 2 /* BEFORE_AXES */:
                            if (edges.rightBeforeAxes > qlRight) {
                                newEdge = edges.rightBeforeAxes;
                            }
                            break;
                        case 3 /* ON_AXIS */:
                            if (edges.rightOnAxis[targetAxisId] > qlRight) {
                                newEdge = edges.rightOnAxis[targetAxisId];
                            }
                            break;
                        default:// QuickLabelPositionModifier.INSIDE
                            if (edges.rightInside > qlRight) {
                                newEdge = edges.rightInside;
                            }
                    }
                    // here newEdge is the x2 position, so just update the width
                    if (newEdge != null) {
                        ql.update({
                            sizeMode: 1 /* CUSTOM_HINT */,
                            widthHint: newEdge - qlLeft
                        }, ctx);
                    }
                    break;
                case 1 /* LEFT */:
                    switch (ql.personalModifier) {
                        case 1 /* OUTSIDE */:
                            if (edges.leftOutside < qlLeft) {
                                newEdge = edges.leftOutside;
                            }
                            break;
                        case 2 /* BEFORE_AXES */:
                            if (edges.leftBeforeAxes < qlLeft) {
                                newEdge = edges.leftBeforeAxes;
                            }
                            break;
                        case 3 /* ON_AXIS */:
                            if (edges.leftOnAxis[targetAxisId] < qlLeft) {
                                newEdge = edges.leftOnAxis[targetAxisId];
                            }
                            break;
                        default:// QuickLabelPositionModifier.INSIDE
                            if (edges.leftInside < qlLeft) {
                                newEdge = edges.leftInside;
                            }
                    }
                    // here newEdge is the x1 position for the box, so we need to change the
                    // width and also find a new x
                    if (newEdge != null) {
                        ql.update({
                            sizeMode: 1 /* CUSTOM_HINT */,
                            widthHint: qlRight - newEdge,
                            x: newEdge
                        }, ctx);
                    }
                    break;
            }
        };
        PlotRenderManager.prototype._drawLegend = function (ctx) {
            // reset pixel points
            this.plot.root.legendPixelPoints[this.plot.id] = undefined;
            var activeLegend = this.plot.isActiveLegendHeatmap() ? this.plot.heatmapLegend : this.plot.legend;
            if (!activeLegend.legendProperties.visible) {
                return;
            }
            var _a = activeLegend.getCanvasDimensions(), legendWidth = _a[0], legendHeight = _a[1];
            if (legendWidth === 0 || legendHeight === 0) {
                return;
            }
            var _b = activeLegend.getLegendOffsetsInsideRectangle(this.plot.legendRect), xOffset = _b[0], yOffset = _b[1];
            ctx.drawLayer(activeLegend.canvas, ~~(this.plot.legendRect.x1 + xOffset), ~~(this.plot.legendRect.y1 + yOffset));
            // save the pixel points
            var pixX = this.plot.legendRect.x1 + xOffset + this.plot.legendRect.getWidth() / 2;
            var pixY = this.plot.legendRect.y1 + yOffset + this.plot.legendRect.getHeight() / 2;
            this.plot.root.legendPixelPoints[this.plot.id] = { x: pixX, y: pixY };
        };
        // Snap `x` and `y` to data point coordinates as appropriate. Returns `[x,
        // y, index]`.
        PlotRenderManager.prototype._snapCoordsToSeries = function (x, y, snapSeries) {
            if (!snapSeries) {
                return [x, y, -1];
            }
            var _a = snapSeries.searchPointLookup(x, y, true), ptx = _a[0], pty = _a[1], ptindex = _a[2];
            if (ptx === -1) {
                return [x, y, -1];
            }
            if (this.chart.attributeSet.get('CrosshairsSnapXToSeries')) {
                x = ptx;
            }
            if (this.chart.attributeSet.get('CrosshairsSnapYToSeries')) {
                y = pty;
            }
            return [~~x, ~~y, ptindex];
        };
        PlotRenderManager.prototype.computeCrosshairPosition = function (cursorPt) {
            // We need to separate the phases of computing the position of and drawing
            // the crosshair, because we draw the crosshair as an overlay after
            // calling `_drawInteractive`, which depends on the series crosshair index
            // being correct.
            var snapSeries = this.chart.getTypedObject(this.plot.compiledCrosshairsSnapStr.fromValue(), isSeries);
            var _a = this._snapCoordsToSeries(cursorPt.x, cursorPt.y, snapSeries), crosshairX = _a[0], crosshairY = _a[1], index = _a[2];
            this.crosshairX = crosshairX;
            this.crosshairY = crosshairY;
            var plotPt = new Point(this.crosshairX, this.crosshairY);
            for (var _i = 0, _b = this.plotSeries; _i < _b.length; _i++) {
                var series = _b[_i];
                if (this.chart.crosshairsEnabled) {
                    series.crosshairIndex = series.getIndexFromPos(plotPt);
                }
            }
            var p = new Point(this.crosshairX, this.crosshairY);
            var point = new Point((p.x - this.plotRect.x1) / this.plotRect.getWidth(), 1 - ((p.y - this.plotRect.y1) / this.plotRect.getHeight()));
            for (var _c = 0, _d = this.plot.axes; _c < _d.length; _c++) {
                var axis = _d[_c];
                if ((axis.dimension === 1 /* X */ && this.plot.crosshairsXHitTest(p, 0)) ||
                    (axis.dimension === 2 /* Y */ && this.plot.crosshairsYHitTest(p, 0))) {
                    axis.crosshairPosition = point;
                    axis.crosshairDrawing = true;
                }
                else {
                    axis.crosshairDrawing = false;
                }
            }
            return this.plotRect.hit(cursorPt);
        };
        PlotRenderManager.prototype.crosshairsLabelNeedDrawing = function () {
            for (var _i = 0, _a = this.plot.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (axis.crosshairsLabeled || (!axis.labeled && axis.crosshairsLabelDrawnWithoutAxisLabels)) {
                    return true;
                }
            }
            return false;
        };
        PlotRenderManager.prototype.drawCrosshair = function (ctx) {
            if (!(this.plot.attributeSet.get('CrosshairsDrawOnPlot')) || this.plot.isFullPlotDrawStyle()) {
                return;
            }
            ctx.save();
            var crosshairMarkerBrush = new FDSBrush();
            crosshairMarkerBrush.style = 0 /* SOLID */;
            var crosshairMarkerOutline = new FDSPen({ color: 0 /* BLACK */, width: 1 });
            var crosshairLine = new FDSPen({ color: this.plot.crosshairsLineColor, width: 1 });
            var drawHorizontal = this.plot.attributeSet.get('CrosshairsShowHorizontal');
            var drawVertical = this.plot.attributeSet.get('CrosshairsShowVertical');
            var offsetX = (~~this.crosshairX) + 0.5;
            var offsetY = (~~this.crosshairY) + 0.5;
            ctx.setPen(crosshairLine);
            if (drawVertical && isBounded(offsetX, this.plotRect.x1, this.plotRect.x2)) {
                ctx.beginPath();
                ctx.moveTo(offsetX, this.plotRect.y1);
                ctx.lineTo(offsetX, this.plotRect.y2);
                ctx.stroke();
            }
            if (drawHorizontal && isBounded(offsetY, this.plotRect.y1, this.plotRect.y2)) {
                ctx.beginPath();
                ctx.moveTo(this.plotRect.x1, offsetY);
                ctx.lineTo(this.plotRect.x2, offsetY);
                ctx.stroke();
            }
            ctx.setPen(crosshairMarkerOutline);
            // draw markers
            for (var _i = 0, _a = this.plotSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if ((!series.crosshairsDrawMarker) || (!series.visible)) {
                    continue;
                }
                var point = series.getPointAtIndex(series.crosshairIndex, this.plot);
                if (series.isStacked) {
                    var effectiveDrawStyle = series.getEffectiveDrawStyle();
                    if (effectiveDrawStyle === 9 /* AREA */) {
                        // stacked area drawstyle
                        var dataPt = series.getData(1 /* X */).getAt(series.crosshairIndex);
                        var ind = this.renderCache.stackIndexMap[series.id];
                        if (ind != null) {
                            point.y = this.renderCache.cumulativeSumMap[dataPt][ind];
                        }
                    }
                    else if (isVerticalBarType(effectiveDrawStyle)) {
                        var dataPt = series.getData(1 /* X */).getAt(series.crosshairIndex);
                        point.y = this.renderCache.colsSumMap[dataPt][series.id];
                    }
                    else if (isHorizonalBarType(effectiveDrawStyle)) {
                        var dataPt = series.getData(2 /* Y */).getAt(series.crosshairIndex);
                        point.x = this.renderCache.barsSumMap[dataPt][series.id];
                    }
                }
                if (!point || !isBounded(point.x, 0, this.plotRect.getWidth()) ||
                    !isBounded(point.y, 0, this.plotRect.getHeight())) {
                    continue;
                }
                // convert back to chart space
                var ptx = point.x + (this.plotRect.x1 - this.chart.chartRect.x1);
                var pty = point.y + (this.plotRect.y1 - this.chart.chartRect.y1);
                var color = void 0;
                if (series.attributeSet.isDefault('CrosshairsMarkerColor')) {
                    color = series.seriesFGPen.color;
                }
                else {
                    color = series.crosshairsMarkerColor;
                }
                // Set marker color
                var drawFunc = getMarkerDrawFunctor(series.crosshairsMarkerStyle, series.crosshairsMarkerSize);
                ctx.save();
                crosshairMarkerBrush.color = color;
                ctx.setBrush(crosshairMarkerBrush);
                ctx.beginPath();
                drawFunc(ctx, ptx, pty);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        };
        // Quick and dirty check to see if our cursor is outside of the plot
        PlotRenderManager.prototype._isPositionOutsidePlot = function (x, y) {
            return x < this.plotRect.x1 ||
                x > this.plotRect.x1 + this.plotRect.getWidth() ||
                y < this.plotRect.y1 ||
                y > this.plotRect.y1 + this.plotRect.getHeight();
        };
        // Handles drawing crosshair axis labels
        PlotRenderManager.prototype.drawCrosshairsAxesLabels = function () {
            // Don't draw if our crosshair leaves the plot
            if (this._isPositionOutsidePlot(this.crosshairX, this.crosshairY)) {
                return;
            }
            for (var _i = 0, _a = this.plot.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                // The axis.labelPosition governs if we draw the label on the right, left or both sides.
                if (axis.labelPosition === 2 /* BOTH */) {
                    axis.drawCrosshairsAxesLabels(this.chart, this.plotRect, false, this.crosshairX, this.crosshairY);
                    axis.drawCrosshairsAxesLabels(this.chart, this.plotRect, true, this.crosshairX, this.crosshairY);
                }
                else {
                    axis.drawCrosshairsAxesLabels(this.chart, this.plotRect, !axis.isOnPrimarySide(axis.labelPosition), this.crosshairX, this.crosshairY);
                }
            }
        };
        PlotRenderManager.prototype.drawSelection = function (event, ctx) {
            if (event.touches.length < 2) {
                return;
            }
            var clientRect = this.chart.containing_element.getBoundingClientRect();
            var lTouch = event.touches[0];
            var rTouch = event.touches[1];
            if (rTouch.screenX < lTouch.screenX) {
                _a = [rTouch, lTouch], lTouch = _a[0], rTouch = _a[1];
            }
            // We need to unscale the touch x and y because the hitshapes are not scaled.
            var unscaledLTouch = this.plot.root.minimumSizeManager.unscaleWidth(lTouch.clientX);
            var unscaledRTouch = this.plot.root.minimumSizeManager.unscaleWidth(rTouch.clientX);
            var leftX = clamp(scaleByDevicePixelRatio(unscaledLTouch - clientRect.left), this.plotRect.x1, this.plotRect.x2);
            var rightX = clamp(scaleByDevicePixelRatio(unscaledRTouch - clientRect.left), this.plotRect.x1, this.plotRect.x2);
            var snapSeriesName = this.chart.attributeSet.get('CrosshairsSnapToSeries');
            var snapSeries = this.chart.getTypedObject(snapSeriesName, isSeries);
            if (snapSeries) {
                var leftIndex = void 0;
                var rightIndex = void 0;
                _b = this._snapCoordsToSeries(leftX, 0, snapSeries), leftX = _b[0], leftIndex = _b[2];
                _c = this._snapCoordsToSeries(rightX, 0, snapSeries), rightX = _c[0], rightIndex = _c[2];
                snapSeries.leftSelectIndex = leftIndex;
                snapSeries.rightSelectIndex = rightIndex;
            }
            ctx.save();
            this.chart.selectionToolBrush.setOnCanvas(ctx, this.plotRect);
            var selectionPen = new FDSPen({ color: 16777215 /* WHITE */, width: 2 });
            // We don't have a pen object (or related attributes) at this point for
            // controlling the drawing of the zoom rectangle stroke, but we can call
            // `FDSPen.getAliasOffset` without an instantiated pen object.
            var aliasOffset = selectionPen.getAliasOffset();
            ctx.fillRect(leftX + aliasOffset, this.plotRect.y1 + aliasOffset, rightX - leftX, this.plotRect.getHeight());
            ctx.strokeRect(leftX + aliasOffset, this.plotRect.y1 + aliasOffset, rightX - leftX, this.plotRect.getHeight());
            ctx.restore();
            var _a, _b, _c;
        };
        return PlotRenderManager;
    }());
    
    // Used for encapsulating some helper array utility functions
    var ArrayUtils = /** @class */ (function () {
        function ArrayUtils() {
        }
        /**
         * Clears the array by popping all elements.
         * This is mainly only useful if you need to modify the actual array reference to mutate a parameter passed in to a
         * function.
         */
        ArrayUtils.clear = function (array) {
            for (var i = array.length; i > 0; i--) {
                array.pop();
            }
        };
        /**
         * Constructs a new array of size `size` with repeating values `value`
         * @param value - The value to repeat `size` times
         * @param size - The size of the returned array.
         * @return a new array with `size` elements, each containing `value`.
         */
        ArrayUtils.makeArrayOf = function (value, size) {
            var i = size;
            var arr = [];
            while (i--) {
                arr[size - i] = value;
            }
            return arr;
        };
        /**
         * @return the element in the provided array with the minimum `.value`.
         */
        ArrayUtils.min = function (arr, lessFn) {
            var min$$1 = { value: Number.POSITIVE_INFINITY, index: -1 };
            for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                var val = arr_1[_i];
                if (lessFn(val, min$$1)) {
                    min$$1 = val;
                }
            }
            return min$$1;
        };
        /**
         * @return the element in the provided array with the maxumum `.value`.
         */
        ArrayUtils.max = function (arr, greaterFn) {
            var max$$1 = { value: Number.NEGATIVE_INFINITY, index: -1 };
            for (var _i = 0, arr_2 = arr; _i < arr_2.length; _i++) {
                var val = arr_2[_i];
                if (greaterFn(val, max$$1)) {
                    max$$1 = val;
                }
            }
            return max$$1;
        };
        /**
         * If the array is already big enough, this just sets `arr[index]`, otherwise it grows the array appending `pad`
         * elements until its large enough.
         * @param array - The array we are setting on.
         * @param index - The index being set or inserted.
         * @param value - The value we are setting at `index`
         * @param pad - The padding value when growing the array.
         */
        ArrayUtils.setAtGrow = function (array, index, value, pad) {
            for (var i = array.length; i < index; i++) {
                array[i] = pad;
            }
            array[index] = value;
        };
        /**
         * Removes an first instance of an element from the array. This function mutates the passed in array.
         * @param array - The array to remove an element from
         * @param elem - The Element to remove
         */
        ArrayUtils.remove = function (array, elem) {
            var index = array.indexOf(elem);
            if (index > -1) {
                array.splice(index, 1);
            }
        };
        return ArrayUtils;
    }());
    
    /**
     * Contains information about a given hit-test.
     */
    var FDSPick = /** @class */ (function () {
        function FDSPick(message, point) {
            if (message === void 0) { message = ''; }
            if (point === void 0) { point = new Point(0, 0); }
            this.init(message, point);
        }
        FDSPick.prototype.init = function (message, point) {
            this._point = point;
            this._lMenu = this._rMenu = this._lClickAction = this.cursor = '';
            this._level = 0;
            this._selectionType = 0 /* NONE */;
            this._data = ArrayUtils.makeArrayOf('', 9 /* SIZE */);
            this._data[6 /* Message */] = message;
            // reset this (used by axis label tooltips)
            this.hoverText = '';
        };
        FDSPick.prototype.getPick = function () {
            return this._data;
        };
        FDSPick.prototype.accessObject = function () {
            return this._data[0 /* Object */];
        };
        FDSPick.prototype.setAccessObject = function (v) {
            this._data[0 /* Object */] = v;
        };
        FDSPick.prototype.accessSubObject = function () {
            return this._data[1 /* SubObject */];
        };
        FDSPick.prototype.setAccessSubObject = function (v) {
            this._data[1 /* SubObject */] = v;
        };
        FDSPick.prototype._accessPath = function () {
            return this._data[2 /* Path */];
        };
        FDSPick.prototype._setAccessPath = function (v) {
            this._data[2 /* Path */] = v;
        };
        FDSPick.prototype.accessData = function () {
            return this._data[3 /* Data */];
        };
        FDSPick.prototype.setAccessData = function (v) {
            this._data[3 /* Data */] = v;
        };
        FDSPick.prototype.accessDrilldown = function () {
            return this._data[4 /* Directive */];
        };
        FDSPick.prototype.setAccessDrilldown = function (v) {
            this._data[4 /* Directive */] = v;
        };
        FDSPick.prototype.accessMessage = function () {
            return this._data[6 /* Message */];
        };
        FDSPick.prototype.setAccessMessage = function (v) {
            this._data[6 /* Message */] = v;
        };
        FDSPick.prototype.accessObjectPart = function () {
            return this._data[8 /* ObjectPart */];
        };
        FDSPick.prototype.setAccessObjectPart = function (v) {
            this._data[8 /* ObjectPart */] = v;
        };
        FDSPick.prototype.accessPoint = function () {
            return this._point;
        };
        FDSPick.prototype.accessLClickAction = function () {
            return this._lClickAction;
        };
        FDSPick.prototype.setAccessLClickAction = function (v) {
            this._lClickAction = v;
        };
        FDSPick.prototype.getPickInteractivity = function () {
            return this._selectionType;
        };
        FDSPick.prototype.setPickInteractivity = function (v) {
            if (v === void 0) { v = 0 /* NONE */; }
            this._selectionType = v;
        };
        FDSPick.prototype.setLevel = function (level, path) {
            path.replace('\\', '\\\\');
            path.replace(':', '\\:');
            this._level = level;
            var list = this._accessPath().split(':');
            ArrayUtils.setAtGrow(list, level, path, '');
            var accessPath = '';
            var end = this._level;
            for (var i = 1; 1 < end ? i <= end : i >= end; 1 < end ? i++ : i--) {
                accessPath += ':' + list[i];
            }
            this._setAccessPath(accessPath);
            return true;
        };
        return FDSPick;
    }());
    
    var Inhouse = /** @class */ (function () {
        function Inhouse() {
        }
        Inhouse.isEnabled = false;
        return Inhouse;
    }());
    
    var FDSMenu = /** @class */ (function () {
        function FDSMenu(chart) {
            this._menuInitialized = false;
            this._menuEnabled = false;
            // a whole bunch of objects for storing menu stuff
            this._chart = chart;
            this._suppressedIDs = {};
            this._ignoredIDs = {};
            this._globalMenus = {};
            this._menuOverrides = {};
            this._setMenuStrings = {};
            this._activeGraphSupport = this._checkActiveGraphSupport();
            this._menuPick = new FDSPick();
        }
        FDSMenu.prototype._checkActiveGraphSupport = function () {
            if (isHeadlessMode) {
                return { isPcModeAvailable: false, isShellModeAvailable: false };
            }
            // For now, we will only support copy as activegraph if running inside the workstation
            // in order to guarantee that a supported atlas version is installed (required for protocol hander registration)
            if (typeof window === 'undefined' || !window.THIEF_BASE || !window.THIEF_BASE.support) {
                return { isPcModeAvailable: false, isShellModeAvailable: false };
            }
            var support = window.THIEF_BASE.support;
            // General support for copy as activegraph began in build 2013.11.362
            var isPcModeAvailable = support.assertWorkstationVersion('2013.11.362.001');
            var isShellModeAvailable = support.assertWorkstationVersion('2016.3.392.001');
            // Due to a bug in parsing unicode data from JSON, we have disabled json as the transport format for builds prior
            // to 2013.15.257.96 see http://is.factset.com/rpd/summary.aspx?messageId=21094865
            var needsXmlForCompat = support.assertWorkstationVersion('2013.15.257.096');
            return { isPcModeAvailable: isPcModeAvailable, isShellModeAvailable: isShellModeAvailable, needsXmlForCompat: needsXmlForCompat };
        };
        FDSMenu.prototype.doContextMenu = function (event) {
            var point = this._chart.renderManager.getCursorPos(event);
            this._targetEvent = event;
            this._menuTargetX = point.x;
            this._menuTargetY = point.y;
            var isChartMenuSupressed = event.ctrlKey && event.shiftKey;
            // Show the menu if ctrl+shift is not being held down and if context menu is enabled.
            if (!isChartMenuSupressed && this._chart.contextMenuEnabled && !this._chart.progressSpinner.isSpinning) {
                this.createContextMenu();
                this.enableMenu();
                this._chart.tooltip.hide();
            }
            else {
                this.disableMenu();
            }
        };
        /* functions for various object actions */
        FDSMenu.prototype.ignoreIDs = function (args) {
            var argArr;
            argArr = (typeof args === 'string') ? [args] : args;
            this._ignoredIDs = {};
            for (var _i = 0, argArr_1 = argArr; _i < argArr_1.length; _i++) {
                var id = argArr_1[_i];
                this._ignoredIDs[id] = true;
            }
        };
        FDSMenu.prototype.suppressIDs = function (args) {
            var argArr;
            argArr = (typeof args === 'string') ? [args] : args;
            this._suppressedIDs = {};
            for (var i = 0; i < argArr.length; i++) {
                var id = args[i];
                this._suppressedIDs[id] = true;
            }
        };
        FDSMenu.prototype.globalAppend = function (args) {
            return this._globalMenuAction(args, 'append');
        };
        FDSMenu.prototype.globalPrepend = function (args) {
            return this._globalMenuAction(args, 'prepend');
        };
        FDSMenu.prototype.globalSet = function (args) {
            return this._globalMenuAction(args, 'set');
        };
        FDSMenu.prototype._globalMenuAction = function (args, action) {
            if (args[0] !== 'Menu') {
                return [false, "Unknown menu name " + args[0]];
            }
            this._globalMenus[action] = args[1];
            return [true, ''];
        };
        FDSMenu.prototype.globalClear = function (args) {
            if (args[0] !== 'Menu') {
                return [false, "Unknown menu name " + args[0]];
            }
            this._globalMenus = {};
            return [true, ''];
        };
        FDSMenu.prototype.objectAppend = function (args, objID) {
            return this._objectMenuAction(args, objID, 'append');
        };
        FDSMenu.prototype.objectPrepend = function (args, objID) {
            return this._objectMenuAction(args, objID, 'prepend');
        };
        FDSMenu.prototype.objectSet = function (args, objID) {
            return this._objectMenuAction(args, objID, 'set');
        };
        FDSMenu.prototype._objectMenuAction = function (args, objID, action) {
            if (args[0] !== 'Menu') {
                return [false, "Unknown menu name " + args[0]];
            }
            if (!this._menuOverrides[objID]) {
                this._menuOverrides[objID] = {};
            }
            this._menuOverrides[objID][action] = args[1];
            if (action === 'set') {
                this._setMenuStrings[objID] = args[1];
            }
            return [true, ''];
        };
        FDSMenu.prototype.objectClear = function (args, objID) {
            if (args[0] !== 'Menu') {
                return [false, "Unknown menu name " + args[0]];
            }
            if (this._menuOverrides[objID]) {
                // if it even exists, clear out all the overrides for this id
                this._menuOverrides[objID] = {};
            }
            return [true, ''];
        };
        FDSMenu.prototype.objectGet = function (args, objID) {
            if (args[0] !== 'Menu') {
                return [false, "Unknown menu name " + args[0]];
            }
            if (this._setMenuStrings[objID] != null) {
                return [this._setMenuStrings[objID], ''];
            }
            return ['', ''];
        };
        // helper function to get the correct object from a menu click
        FDSMenu.prototype._getMenuPickObj = function () {
            // save the mouse position to be used inside thief menus
            var point = new Point(this._menuTargetX, this._menuTargetY);
            this._menuPick.init('ContextMenu', point);
            this._chart.hitTest(point, this._menuPick);
            return this._chart.getObject(this._menuPick.accessObject(), this._menuPick.accessSubObject());
        };
        FDSMenu.prototype._getMenuFromClick = function () {
            var hsIndex = -1;
            var object = this._getMenuPickObj();
            if (isSeries(object)) {
                hsIndex = Number(this._menuPick.accessSubObject());
            }
            var baseMenu = this._getMenuObjectFromAttributes(object, hsIndex);
            var prepend = [];
            var append = [];
            var objPrepend = [];
            var objAppend = [];
            var override;
            if (override = this._menuOverrides[object.id]) {
                objPrepend = this._createMenuItems(override.prepend, object, hsIndex) || objPrepend;
                baseMenu = this._createMenuItems(override.set, object, hsIndex) || baseMenu;
                objAppend = this._createMenuItems(override.append, object, hsIndex) || objAppend;
            }
            prepend = this._createMenuItems(this._globalMenus.prepend, object, hsIndex) || prepend;
            baseMenu = this._createMenuItems(this._globalMenus.set, object, hsIndex) || baseMenu;
            append = this._createMenuItems(this._globalMenus.append, object, hsIndex) || append;
            // check if the inhouse property has been set to true from the console
            if (Inhouse.isEnabled) {
                baseMenu = this._appendMenuWithInhouseItems(baseMenu);
            }
            var menu = prepend.concat(objPrepend)
                .concat(baseMenu)
                .concat(objAppend)
                .concat(append);
            this._parseMenuProperties(menu, object, hsIndex);
            this._removeSuppressedIDs(menu);
            return menu;
        };
        FDSMenu.prototype._createMenuItems = function (menuString, object, index) {
            var menu = [];
            if (_$1.isUndefined(menuString)) {
                return undefined;
            }
            // Try parsing from XML if it starts with <FDSChartMenu
            if (menuString.search(/^\s*<FDSChartMenu/) === 0) {
                menu = this._createMenuFromXML(menuString);
            }
            // As a fallback, try parsing from delimited string
            if (menu.length === 0) {
                var menuProperties = object.properties.compilePropertyString(menuString);
                menu = this._createMenuFromDelimitedString(menuProperties.fromValue({ seriesIndex: index }));
            }
            return menu;
        };
        // helper function to parse the attributes into a menu object
        FDSMenu.prototype._getMenuObjectFromAttributes = function (object, index) {
            while (object) {
                // first try getting the menu from the menuXML attribute
                if (!object.contextMenuXML.isDefault) {
                    // first try parsing the xml attribute
                    var menu = this._createMenuFromXML(object.contextMenuXML.value);
                    // only use this menu if it's valid menu xml
                    // if it isn't valid menu xml then the menu creation will return false
                    if (menu) {
                        return menu;
                    }
                }
                // now try getting it from the Menu attribute
                if (!object.contextMenuString.isDefault) {
                    var menuProperties = object.properties.compilePropertyString(object.contextMenuString.value);
                    return this._createMenuFromDelimitedString(menuProperties.fromValue({ seriesIndex: index }));
                    // if it is defaulted, use the default string instead
                }
                else {
                    // don't get the attribute if it's default - it'll inherit from its parents
                    this._getDefaultMenu();
                }
                // if we reached here, both the Menu and MenuXML attributes are invalid
                // (and Menu isn't default). Check parent's menu
                object = object.parent;
            }
            // if we reach here, no objects have valid menus. give up and use default menu
            return this._getDefaultMenu();
        };
        FDSMenu.prototype.canCopyAsActiveGraph = function () {
            var copyMode = this._chart.copyAsActiveGraphMode;
            var _a = this._activeGraphSupport, isPcModeAvailable = _a.isPcModeAvailable, isShellModeAvailable = _a.isShellModeAvailable;
            var isModeAvailable = (copyMode === 0 /* UseFDSChartPC */ && isPcModeAvailable) ||
                (copyMode === 1 /* UseFDSChartJsShell */ && isShellModeAvailable);
            return this._chart.copyAsActiveGraphEnabled && (isModeAvailable || Inhouse.isEnabled);
        };
        FDSMenu.prototype._getDefaultMenu = function () {
            var isSimpleZoomEnabled = false;
            var activePlotName = this._chart.activePlot;
            var activePlot = this._chart.objects[activePlotName];
            if (isPlot(activePlot)) {
                isSimpleZoomEnabled = activePlot.getSimpleZoomEnabled();
            }
            var defaultMenuString = GetDefaultMenuString(this.canCopyAsActiveGraph(), isSimpleZoomEnabled);
            return this._createMenuFromDelimitedString(defaultMenuString);
        };
        FDSMenu.prototype._parseMenuProperties = function (menu, object, index) {
            for (var _i = 0, menu_1 = menu; _i < menu_1.length; _i++) {
                var item = menu_1[_i];
                if (item.rawcontent != null) {
                    var propertyObj = object.properties.compilePropertyString(item.rawcontent);
                    item.content = propertyObj.fromValue({ seriesIndex: index });
                }
                if (item.menu) {
                    this._parseMenuProperties(item.menu, object, index);
                }
            }
        };
        // helper function to create a new menu that is the passed-in menu with the addition of inhouse-exclusive menu items
        FDSMenu.prototype._appendMenuWithInhouseItems = function (menu) {
            // we copy the input menu and append to the copy instead of working with the input menu directly
            var menuCopy = menu.slice();
            var inhouseItems = menuCopy.length > 0 ? ['SEPARATOR'] : [];
            var isIE = (navigator.userAgent.indexOf('MSIE ') > 0 || navigator.userAgent.indexOf('Trident/') > 0);
            if (isIE) {
                inhouseItems = inhouseItems.concat([
                    'MENU,Icon!icon-factset:Inhouse',
                    'SYS_SAVE_CHART_STATE_TO_FILE,Icon!icon-download:Save Chart State to File',
                    'SYS_OPEN_JSON_IN_NEW_WINDOW,Icon!icon-launch:Open JSON in New Window',
                    'ENDMENU'
                ]);
            }
            else {
                inhouseItems = inhouseItems.concat([
                    'MENU,Icon!icon-factset:Inhouse',
                    'SYS_SAVE_CHART_STATE_TO_FILE,Icon!icon-download:Save Chart State to File',
                    'SYS_OPEN_IN_TEST_HARNESS,Icon!icon-launch:Open in Test Harness',
                    'ENDMENU'
                ]);
            }
            var inhouseMenuItems = this._createMenu(inhouseItems, 0)[0];
            return menuCopy.concat(inhouseMenuItems);
        };
        FDSMenu.prototype._createMenuFromDelimitedString = function (str) {
            var items = str.split('\n');
            var menu = this._createMenu(items, 0)[0];
            return menu;
        };
        FDSMenu.prototype._createMenuFromXML = function (stringOrElement) {
            var element;
            if (typeof stringOrElement === 'string') {
                // try to parse this string as xml
                var root = this._chart._parseXML(stringOrElement);
                // find the first <FDSChartMenu> node and use that
                var chartMenuNodeList = root ? root.getElementsByTagName('FDSChartMenu') : undefined;
                if (chartMenuNodeList && chartMenuNodeList.length > 0) {
                    element = chartMenuNodeList[0];
                }
                else {
                    return undefined;
                }
            }
            else {
                element = stringOrElement;
            }
            // now make sure we have
            if (typeof (element) !== 'object' || (element.children == null)) {
                // a menu element must be an object with children
                return undefined;
            }
            var menu = [];
            var options;
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < element.children.length; i++) {
                var child = element.children[i];
                var menuItem = void 0;
                if (!child.tagName) {
                    continue;
                } // probably whitespace, ignore it
                switch (child.tagName) {
                    case 'body':
                        // this usually means you got an error
                        // dumb wasy to check if the grandchild is a parser error as it usually will be
                        if (child.children && child.children[0] && child.children[0].tagName === 'parsererror') {
                            return undefined;
                        }
                        break;
                    case 'parsererror':
                        // something went wrong!
                        return undefined;
                    case 'MenuItem':
                        options = this._getOptionMapFromElement(child);
                        menuItem = this._createMenuItem(child.getAttribute('ID'), options, child.textContent);
                        break;
                    case 'Separator':
                        menuItem = { divider: true };
                        break;
                    case 'SubMenu':
                        var submenu = this._createMenuFromXML(child);
                        if (!submenu) {
                            return undefined;
                        } // if the submenu failed, fail the whole menu
                        menuItem = { menu: submenu, rawcontent: child.getAttribute('Name') };
                        options = this._getOptionMapFromElement(child);
                        if (options['icon']) {
                            menuItem.icon = options['icon'];
                        }
                        break;
                }
                if (menuItem) {
                    menu.push(menuItem);
                }
            }
            return menu;
        };
        FDSMenu.prototype._getOptionMapFromElement = function (elt) {
            var http;
            var fdsup;
            var action;
            var icon;
            var ret = {};
            // next list any boolean options
            var boolOptions = ['Grayed', 'Enabled', 'Disabled', 'Checked', 'Unchecked', 'Radio'];
            for (var _i = 0, boolOptions_1 = boolOptions; _i < boolOptions_1.length; _i++) {
                var opt = boolOptions_1[_i];
                if (elt.getAttribute(opt) != null) {
                    ret[opt] = '';
                }
            }
            // next add any links
            if ((http = elt.getAttribute('HTTP')) != null) {
                ret['http'] = http;
            }
            if ((fdsup = elt.getAttribute('FDSUP')) != null) {
                ret['fdsup'] = fdsup;
            }
            if ((action = elt.getAttribute('Action')) != null) {
                ret['action'] = action;
            }
            if ((icon = elt.getAttribute('Icon')) != null) {
                ret['icon'] = icon;
            }
            return ret;
        };
        // a recursive function for creating menus
        // takes in an array of items and where to start looking at them
        // returns a menu array and the index where it stopped looking
        FDSMenu.prototype._createMenu = function (items, index) {
            var menu = [];
            // need the final value outside the loop
            var i;
            for (i = index; i < items.length; i++) {
                var item = items[i];
                var _a = this._splitMenuItem(item), id = _a[0], options = _a[1], str = _a[2];
                var menuItem = void 0;
                // menu/endmenu items have to be handled here because they are handled differently in MenuXML
                if (id === 'MENU') {
                    var _b = this._createMenu(items, i + 1), submenu = _b[0], idx = _b[1];
                    menuItem = { menu: submenu, rawcontent: str };
                    var icon = options.icon;
                    if (icon) {
                        menuItem.icon = icon;
                    }
                    i = idx;
                }
                else if (id === 'ENDMENU') {
                    return [menu, i];
                }
                else {
                    menuItem = this._createMenuItem(id, options, str);
                }
                if (menuItem) {
                    menu.push(menuItem);
                }
            }
            return [menu, i];
        };
        // helper function to split a menu item string into three things:
        // - the menu id
        // - an array of menu options
        // - the menu string
        FDSMenu.prototype._splitMenuItem = function (item) {
            // find the first colon that isn't in a link
            var index = item.indexOf(':');
            var options;
            var str;
            if (index === -1) {
                // item with no colon in it
                options = item;
                str = '';
            }
            else {
                var lcItem = item.toLowerCase();
                if ((lcItem.slice(index - 9, index) === 'http!http' || lcItem.slice(index - 11, index) === 'https!https') &&
                    lcItem.slice(index + 1, index + 3) === '//') {
                    // this colon is in a link option, find the next one
                    index = item.indexOf(':', index + 1);
                }
                options = item.slice(0, index);
                str = item.slice(index + 1);
            }
            var optionArray = options.split(',');
            // the first term is always the menu id, the rest (if any) are options
            var id = optionArray.shift();
            var optionMap = this._getOptionMapFromArray(optionArray);
            return [id, optionMap, str];
        };
        FDSMenu.prototype._getOptionMapFromArray = function (optionArray) {
            var optionMap = {};
            for (var _i = 0, optionArray_1 = optionArray; _i < optionArray_1.length; _i++) {
                var option = optionArray_1[_i];
                // options with arguments are split by an exclamation point
                var optionSplitIndex = option.indexOf('!');
                // If there are no arguments, just return an empty string.
                if (optionSplitIndex === -1) {
                    optionMap[option] = '';
                }
                else {
                    var key = option.substr(0, optionSplitIndex).toLowerCase();
                    var value = option.substr(optionSplitIndex + 1);
                    optionMap[key] = value;
                }
            }
            return optionMap;
        };
        // helper function to split up an option string into its component links (if it has one)
        // returns the link as a string if it exists, otherwise undefined
        FDSMenu.prototype._getLinkSelectedFunction = function (optionKey, optionValue) {
            var _this = this;
            var link;
            var lcLink;
            switch (optionKey) {
                case 'http':
                case 'https': {
                    link = optionValue;
                    lcLink = optionValue.toLowerCase();
                    if (optionKey === 'http' && lcLink.slice(0, 7) !== 'http://') {
                        link = 'http://' + link;
                    }
                    else if (optionKey === 'https' && lcLink.slice(0, 7) !== 'https://') {
                        link = 'https://' + link;
                    }
                    return (function (_link) {
                        return function () { return window.open(_link); };
                    })(link);
                }
                case 'fdsup': {
                    link = optionValue;
                    lcLink = optionValue.toLowerCase();
                    if (lcLink.slice(0, 8) !== 'fdsup://') {
                        link = 'fdsup://' + link;
                    }
                    // fdsup will create an empty window/new tab if we use window.open
                    return (function (_link) {
                        return function () { return location.href = _link; };
                    })(link);
                }
                case 'action':
                    return function () {
                        var point = new Point(_this._menuTargetX, _this._menuTargetY);
                        _this._chart.handleAction(_this._chart.getChild(_this._menuPick.accessObject()), optionValue, point);
                    };
                default:
                    return function () {
                    };
            }
        };
        FDSMenu.prototype._fireMenuEvent = function (eventName, id) {
            // From FDSChart event specifications:
            // x: chart x of mouse in chart local screen coordinates
            // y: chart y of mouse in chart local screen coordinates
            // Data: Str1: Picked Object
            //      Str2: User defined integer menu ID (as a string)
            //      Str3: Pick path (colon separated starting with :FDSChart) NOTE: we don't support this right now
            //      Str4: Tooltip of picked item if defined
            var point = new Point(this._menuTargetX, this._menuTargetY);
            this._menuPick.setAccessSubObject(id);
            this._chart.fireChartEvent(eventName, point, this._menuPick.getPick());
        };
        FDSMenu.prototype._fireFlyoutEvent = function () {
            // custom event that looks like a Chart Event but has the correct subObj
            var point = new Point(this._menuTargetX, this._menuTargetY);
            this._chart.fireChartEvent('ShowFlyout', point, this._menuPick.getPick());
        };
        // function to save the json as a file
        FDSMenu.prototype._fireSaveChartStateToFileEvent = function () {
            var filename = 'fdschartjs.json';
            var data = this._chart.dumpJSON();
            var blob = new Blob([data], { type: 'application/json' });
            if (typeof window.navigator.msSaveBlob === 'function') {
                window.navigator.msSaveBlob(blob, filename); // For internet explorer.
            }
            else {
                var url_1 = window.URL.createObjectURL(blob);
                var a_1 = document.createElement('a');
                a_1.setAttribute('href', url_1);
                a_1.setAttribute('download', filename);
                a_1.setAttribute('style', 'display:none');
                document.body.appendChild(a_1);
                a_1.click();
                // We set a timeout to make sure that the "a" element is not removed before the click is completed.
                setTimeout(function () {
                    document.body.removeChild(a_1);
                    window.URL.revokeObjectURL(url_1);
                }, 100);
            }
        };
        FDSMenu.prototype._fireOpenJsonInNewWindowEvent = function (edgeTestHarnessUrl) {
            var newWindow = window.open();
            var newWindowHTML = "<!DOCTYPE html><title>FDSCHARTJS\u2014Dumped JSON</title>\n      <textarea rows=30 style=\"width:50%; display:block; margin-left:1%;\">" + JSON.stringify(this._chart.serializeToJSON(), null, 2) + "</textarea>\n      <p style=\"margin-left:1%;\">The FDSChartJS edge test harness is located <a href=\"" + edgeTestHarnessUrl + "\" target=\"_blank\">here.</a></p>";
            newWindow.document.write(newWindowHTML);
            newWindow.document.close();
        };
        FDSMenu.prototype._fireOpenInTestHarnessEvent = function (testHarnessUrl) {
            var message = { source: 'FDSChartJS', task: 'DUMP_JSON_TO_TEST_HARNESS', data: this._chart.serializeToJSON() };
            var testHarnessWindow;
            // We set up an event listener that waits for a ready message from the test harness.
            var handleReadyMessage = function (event) {
                var obj = event.data;
                if (obj.source === 'TestHarness') {
                    if (obj.task === 'READY') {
                        testHarnessWindow.postMessage(message, testHarnessUrl);
                        // This should just be a one time transaction, so we remove the listener when we are done.
                        window.removeEventListener('message', handleReadyMessage, true);
                    }
                }
            };
            window.addEventListener('message', handleReadyMessage, true);
            testHarnessWindow = window.open(testHarnessUrl + '#dumpJSON');
        };
        // a helper function to create a menu item
        // takes in a string id, an array of string options, and a string to display on the menu itself
        // Note: this does not handle submenus! those have to be handled indepently
        // whether its a Menu string or MenuXML
        FDSMenu.prototype._createMenuItem = function (id, options, content) {
            var _this = this;
            var menuItem;
            var builtin = true;
            switch (id) {
                case 'SEPARATOR':
                    menuItem = { divider: true, id: id };
                    break;
                case 'SYS_ZOOMBOX':
                case 'SYS_UNZOOM':
                case 'SYS_ABOUT':
                case 'SYS_REFRESH':
                case 'SYS_TRENDLINE':
                case 'SYS_PICKPOINT':
                case 'SYS_PICK':
                case 'SYS_XML':
                case 'SYS_HIDE':
                case 'SYS_NOOP':
                case 'SYS_CLIPDIB':
                case 'SYS_CLIPMETA':
                case 'SYS_CLIPENHMETA':
                case 'SYS_CLIPCSV':
                case 'SYS_CLIPOBJECT':
                case 'SYS_EDIT':
                case 'SYS_ANNOTATE':
                case 'SYS_ANNOTATE_ADD':
                case 'SYS_ANNOTATE_EDIT':
                case 'SYS_ANNOTATE_POSITION':
                case 'SYS_ANNOTATE_FORMAT':
                case 'SYS_DATA':
                case 'SYS_DATA_ALL':
                case 'SYS_DATA_SERIES':
                case 'SYS_PUSH':
                case 'SYS_POP':
                case 'SYS_PRINT':
                case 'SYS_UPDATE':
                case 'SYS_RESET_AXIS':
                case 'SYS_ZOOMLINE':
                case 'SYS_VBSCRIPT':
                case 'SYS_BINARY':
                case 'SYS_SAVE_XML':
                case 'SYS_SAVE_CSV':
                case 'SYS_SAVE_BINARY':
                case 'SYS_SAVE_DIB':
                case 'SYS_SAVE_GIF':
                case 'SYS_SAVE_PNG':
                case 'SYS_SAVE_JPEG':
                case 'SYS_SAVE_METAFILE':
                case 'SYS_FLYOUT':
                case 'SYS_SAVE_CHART_STATE_TO_FILE':
                case 'SYS_OPEN_JSON_IN_NEW_WINDOW':
                case 'SYS_OPEN_IN_TEST_HARNESS':
                    menuItem = { id: id, rawcontent: content, selected: function () { return _this._menuIDClicked(id); } };
                    break;
                default:
                    // it's just a random string, fire an event.
                    menuItem = { id: id, rawcontent: content, selected: function () { return _this._fireMenuEvent('UserMenu', id); } };
                    builtin = false;
            }
            // now iterate through the options
            // debug to check if there are any conflicting options
            var conflicting = false;
            var itemsSeen = {};
            if (id === 'SYS_CLIPOBJECT' && !this.canCopyAsActiveGraph()) {
                menuItem.disabled = true;
                itemsSeen['Disabled'] = true;
            }
            for (var optionKey in options) {
                var optionValue = options[optionKey];
                switch (optionKey) {
                    case 'Grayed':
                        // grayed takes priority over enabled
                        menuItem.disabled = true;
                        itemsSeen.Grayed = true;
                        conflicting = conflicting || itemsSeen.Enabled;
                        break;
                    case 'Disabled':
                        // disabled takes priority over enabled
                        menuItem.disabled = true;
                        itemsSeen.Disabled = true;
                        conflicting = conflicting || itemsSeen.Enabled;
                        break;
                    case 'Enabled':
                        // disabled and grayed take priority over enabled
                        if (itemsSeen.Disabled || itemsSeen.Grayed) {
                            conflicting = true;
                        }
                        else {
                            menuItem.disabled = false;
                        }
                        itemsSeen.Enabled = true;
                        break;
                    case 'Checked':
                        // checked takes priority over unchecked
                        menuItem.icon = 'icon-check1-s';
                        itemsSeen.Checked = true;
                        conflicting = conflicting || itemsSeen.Unchecked || itemsSeen.Radio || itemsSeen.Icon;
                        break;
                    case 'Unchecked':
                        // checked takes priority over unchecked
                        if (itemsSeen.Checked) {
                            conflicting = true;
                        }
                        itemsSeen.Unchecked = true;
                        break;
                    case 'Radio':
                        // checked takes priority over radio
                        if (itemsSeen.Checked || itemsSeen.Icon) {
                            conflicting = true;
                        }
                        else {
                            menuItem.icon = 'icon-radio-on-xs';
                        }
                        itemsSeen.Radio = true;
                        break;
                    case 'icon':
                        if (itemsSeen.Checked || itemsSeen.Radio) {
                            conflicting = true;
                        }
                        else if (optionValue) {
                            menuItem.icon = optionValue;
                        }
                        itemsSeen.Icon = true;
                        break;
                    case 'http':
                    case 'https':
                    case 'fdsup':
                    case 'action':
                        // links are ignored when a builtin option was used
                        if (!builtin && _$1.isString(optionValue)) {
                            menuItem.selected = this._getLinkSelectedFunction(optionKey, optionValue);
                        }
                        break;
                    default:
                }
            }
            if (conflicting) {
                if (ENABLE_DEBUG) {
                    console.log("Conflicting menu string qualifiers in item " + menuItem.rawcontent);
                }
            }
            // do a quick check so we don't have to parse things that don't have properties in them
            if (menuItem.rawcontent != null &&
                (menuItem.rawcontent.indexOf('<') === -1 || menuItem.rawcontent.indexOf('>') === -1)) {
                // you need both < and > to make a property, so without one, we have no properties
                // we can save the text directly to the menuItem
                menuItem.content = menuItem.rawcontent;
                // remove the rawItem content so it doesn't get parsed every time
                menuItem.rawcontent = undefined;
            }
            return menuItem;
        };
        FDSMenu.prototype._copyActiveGraphToClipboard = function (data) {
            var _this = this;
            if (!this.canCopyAsActiveGraph()) {
                return;
            }
            var rect = this._chart.chartRect;
            var uri = "FDSCHART://Clipboard/?w=" + rect.x2 + "&h=" + rect.y2;
            // some browsers (IE) expose the clipboard data directly
            if (window['clipboardData'] && window['clipboardData'].setData) {
                window['clipboardData'].setData('text', data);
                location.href = uri;
            }
            else {
                // others require a more convoluted method, but this is inline with the new html clipboard api
                var textArea_1 = document.createElement('textarea');
                this._chart.containing_element.appendChild(textArea_1);
                textArea_1.select();
                textArea_1.focus();
                textArea_1.addEventListener('copy', function (e) {
                    _this._chart.containing_element.removeChild(textArea_1);
                    e.preventDefault();
                    e.clipboardData.setData('text/plain', data);
                    location.href = uri;
                });
                document.execCommand('copy');
            }
        };
        FDSMenu.prototype.handleSysMenuId = function (id) {
            var _this = this;
            var edgeTestHarnessUrl = 'http://fdschartjs.factset.com/versions/edge/#/main';
            switch (id) {
                case 'SYS_FLYOUT':
                    this._fireFlyoutEvent();
                    break;
                case 'SYS_ZOOMBOX':
                    this._chart.objectAction('SimpleZoom');
                    break;
                case 'SYS_UNZOOM':
                    this._chart.objectAction('SimpleZoomReset');
                    break;
                case 'SYS_ABOUT':
                    this._chart.renderManager.displayAboutDialog();
                    break;
                case 'SYS_REFRESH':
                    this._chart.invalidate();
                    break;
                case 'SYS_TRENDLINE':
                    this._chart.objectAction('SYS_TRENDLINE', 0 /* NONE */, Cursor.TRENDLINE);
                    break;
                case 'SYS_PICKPOINT':
                    this._chart.objectAction('SYS_PICKPOINT', 0 /* NONE */, Cursor.TRENDLINE);
                    break;
                case 'SYS_PICK':
                    this._chart.objectAction('SYS_PICK', 0 /* NONE */, Cursor.TRENDLINE);
                    break;
                case 'SYS_HIDE':
                    var obj = this._getMenuPickObj();
                    if (obj['visible'] != null) {
                        // this object can be hidden via attribute
                        obj.attributeSet.setAt('Visible', 'user', false);
                        this._chart.invalidate();
                    }
                    break;
                case 'SYS_CLIPDIB':
                    break;
                case 'SYS_CLIPOBJECT':
                    if (this._chart.copyAsActiveGraphMode === 0 /* UseFDSChartPC */) {
                        var serializedData = this._activeGraphSupport.needsXmlForCompat ?
                            this._chart.dumpXML() :
                            this._chart.dumpJSON();
                        this._copyActiveGraphToClipboard(serializedData);
                    }
                    else {
                        this._chart.toChartImageShellAsync().then(function (serializedData) {
                            _this._copyActiveGraphToClipboard(serializedData);
                        });
                    }
                    break;
                case 'SYS_SAVE_CHART_STATE_TO_FILE':
                    this._fireSaveChartStateToFileEvent();
                    break;
                case 'SYS_OPEN_JSON_IN_NEW_WINDOW':
                    this._fireOpenJsonInNewWindowEvent(edgeTestHarnessUrl);
                    break;
                case 'SYS_OPEN_IN_TEST_HARNESS':
                    this._fireOpenInTestHarnessEvent(edgeTestHarnessUrl);
                    break;
                case 'SYS_NOOP':
                case 'SYS_CLIPMETA':
                case 'SYS_CLIPENHMETA':
                case 'SYS_CLIPCSV':
                case 'SYS_EDIT':
                case 'SYS_ANNOTATE':
                case 'SYS_ANNOTATE_ADD':
                case 'SYS_ANNOTATE_EDIT':
                case 'SYS_ANNOTATE_POSITION':
                case 'SYS_ANNOTATE_FORMAT':
                case 'SYS_DATA':
                case 'SYS_DATA_ALL':
                case 'SYS_DATA_SERIES':
                case 'SYS_PUSH':
                case 'SYS_POP':
                case 'SYS_PRINT':
                case 'SYS_UPDATE':
                case 'SYS_RESET_AXIS':
                case 'SYS_ZOOMLINE':
                case 'SYS_VBSCRIPT':
                case 'SYS_BINARY':
                case 'SYS_SAVE_XML':
                case 'SYS_SAVE_CSV':
                case 'SYS_SAVE_BINARY':
                case 'SYS_SAVE_DIB':
                case 'SYS_SAVE_GIF':
                case 'SYS_SAVE_PNG':
                case 'SYS_SAVE_JPEG':
                case 'SYS_SAVE_METAFILE':
                case 'SYS_XML':
                // any id that is built-in on the PC side but we don't support still
                // shouldn't launch a user menu event, so do nothing
                default:
                    return false;
            }
            return true;
        };
        // helper function to fire an event or call a function based on what item has been clicked on
        FDSMenu.prototype._menuIDClicked = function (id) {
            if (this._ignoredIDs[id]) {
                this._fireMenuEvent('SystemMenu', id);
                return;
            }
            if (!this.handleSysMenuId(id)) {
                this._fireMenuEvent('UserMenu', id);
            }
        };
        // helper function to recursively remove suppressed items from a menu and all its submenus
        FDSMenu.prototype._removeSuppressedIDs = function (menu) {
            var toDelete = [];
            for (var i = 0; i < menu.length; i++) {
                var item = menu[i];
                if (this._suppressedIDs[item.id]) {
                    toDelete.push(i);
                }
                if (item.menu) {
                    this._removeSuppressedIDs(item.menu);
                }
            }
            for (var j = toDelete.length - 1; j >= 0; j--) {
                // delete from the end so we don't mess up the indices
                menu.splice(toDelete[j], 1);
            }
        };
        return FDSMenu;
    }());
    
    var NullMenu = /** @class */ (function (_super) {
        __extends(NullMenu, _super);
        function NullMenu(chart) {
            var _this = _super.call(this, chart) || this;
            _this._warningFired = false;
            return _this;
        }
        // Initializes menu based on context menu string
        NullMenu.prototype.createContextMenu = function () {
            if (!isHeadlessMode && !this._warningFired) {
                console.warn('Using context menus in FDSChartJS requires Thief Classic or both Thief Angular and FDSChartJSAngularWrapper');
                this._warningFired = true;
            }
        };
        NullMenu.prototype.destroyMenu = function () {
        };
        NullMenu.prototype.disableMenu = function () {
        };
        NullMenu.prototype.enableMenu = function () {
        };
        return NullMenu;
    }(FDSMenu));
    
    var ThiefAngularMenu = /** @class */ (function (_super) {
        __extends(ThiefAngularMenu, _super);
        function ThiefAngularMenu(chart) {
            var _this = _super.call(this, chart) || this;
            _this.isInitialized = false;
            return _this;
        }
        // Set up context menu container
        ThiefAngularMenu.prototype._initializeContextMenu = function () {
            if (!this.isInitialized) {
                var chartElement_1 = angular.element(this._chart.containing_element);
                // In order to append the tooltipDiv with the angular controller we need to compile it first
                var contextScope_1;
                var chartInjector = chartElement_1.injector();
                var menuDivHTML_1;
                chartInjector.invoke([
                    '$compile', '$rootScope', function ($compile, $rootScope) {
                        var compiledMenuDiv = $compile('<div ng-controller="FDSChartJSMenuController"></div>');
                        var containerMenuScope = $rootScope.$new();
                        /* We're taking advantage of scope inheritance here. By creating a "data" object, the child scope that's
                         * created for FDSChartJSMenuController will have access to $scope.data and when the controller
                         * puts functions on scope.data, the parent scope (containerMenuScope) will still have access to it.
                         * If FDSChartJSMenuController put the functions directly on $scope, we wouldn't have access.
                         */
                        containerMenuScope.data = {};
                        contextScope_1 = containerMenuScope;
                        menuDivHTML_1 = compiledMenuDiv(containerMenuScope);
                        chartElement_1.append(menuDivHTML_1);
                    }
                ]);
                this._menuElement = menuDivHTML_1;
                this._menuScope = contextScope_1;
                this.isInitialized = true;
            }
        };
        ThiefAngularMenu.prototype.doContextMenu = function (event) {
            _super.prototype.doContextMenu.call(this, event);
            if (this.isInitialized && this._menuEnabled) {
                event.preventDefault();
                event.stopPropagation();
            }
        };
        ThiefAngularMenu.prototype.createContextMenu = function () {
            if (!this.isInitialized) {
                this._initializeContextMenu();
            }
            this._menuEnabled = true;
            this._menuElement.empty();
            this._menuScope.data.updateMenu(this._menuElement, this._getMenuFromClick(), this._targetEvent.pageX, this._targetEvent.pageY);
        };
        // Destroys context menu container
        ThiefAngularMenu.prototype.destroyMenu = function () {
            if (this.isInitialized) {
                this._menuScope.data.clearMenu();
                this._menuElement.remove();
                this._menuElement = null;
                this._menuScope = null;
                this.isInitialized = false;
            }
        };
        // Clears context menu content
        ThiefAngularMenu.prototype.disableMenu = function () {
            if (this.isInitialized) {
                this._menuScope.data.clearMenu();
                this._menuScope.data.hideMenu();
                this._menuEnabled = false;
            }
        };
        // Makes content menu visible
        ThiefAngularMenu.prototype.enableMenu = function () {
            if (this.isInitialized) {
                this._menuScope.data.showMenu();
                this._menuEnabled = true;
            }
        };
        return ThiefAngularMenu;
    }(FDSMenu));
    
    var ThiefClassicMenu = /** @class */ (function (_super) {
        __extends(ThiefClassicMenu, _super);
        function ThiefClassicMenu(chart) {
            return _super.call(this, chart) || this;
        }
        ThiefClassicMenu.prototype._getContextMenu = function (div) {
            if ($$1 && $$1['thief'] && $$1['thief'].contextMenu) {
                var selector = $$1(div);
                return selector['contextMenu'].bind(selector);
            }
            return undefined;
        };
        // Initializes menu based on context menu string
        ThiefClassicMenu.prototype.createContextMenu = function () {
            if (this._menuInitialized) {
                return;
            }
            var contextMenu = this._getContextMenu(this._chart.containing_element);
            if (!contextMenu) {
                return;
            }
            this._menuEnabled = true;
            contextMenu({ content: this._getMenuFromClick.bind(this) });
            this._menuInitialized = true;
        };
        ThiefClassicMenu.prototype.destroyMenu = function () {
            if (!this._menuInitialized) {
                return;
            }
            var contextMenu = this._getContextMenu(this._chart.containing_element);
            if (!contextMenu) {
                return;
            }
            contextMenu('destroy');
            this._menuInitialized = false;
        };
        ThiefClassicMenu.prototype.disableMenu = function () {
            if (!this._menuEnabled) {
                return;
            }
            var contextMenu = this._getContextMenu(this._chart.containing_element);
            if (!contextMenu) {
                return;
            }
            contextMenu('disable');
            this._menuEnabled = false;
        };
        ThiefClassicMenu.prototype.enableMenu = function () {
            if (this._menuEnabled) {
                return;
            }
            var contextMenu = this._getContextMenu(this._chart.containing_element);
            if (!contextMenu) {
                return;
            }
            contextMenu('enable');
            this._menuEnabled = true;
        };
        return ThiefClassicMenu;
    }(FDSMenu));
    
    var ProgressSpinner = /** @class */ (function () {
        function ProgressSpinner(chart) {
            this.isSpinning = false;
            this._chart = chart;
            this.resetSpinnerSize();
        }
        ProgressSpinner.prototype.resetSpinnerSize = function () {
            var chartElement = this._chart.containing_element;
            this._spinnerSize = 35; // Currently defaulting to 35px for spinner size because that's the fixed size of the Thief Angular spinner.
            this._xOffset = (chartElement.clientWidth - this._spinnerSize) / 2;
            this._yOffset = (chartElement.clientHeight - this._spinnerSize) / 2;
            this._spinnerSize = this._spinnerSize;
            var style = {
                height: this._spinnerSize + "px",
                width: this._spinnerSize + "px",
                position: "relative",
                left: this._xOffset + "px",
                top: this._yOffset + "px",
            };
            this._styleStr = _$1.reduce(style, function (result, value, key) { return result + (key + ":" + value + ";"); }, '');
            if (this.isSpinning) {
                this.hide();
                this.show();
            }
        };
        ProgressSpinner.prototype.show = function () {
            this._chart.tooltip.cleanUp();
            this._chart.contextMenu.destroyMenu();
            if (this._chart.renderManager) {
                this._chart.renderManager.clearInteractions();
            }
            // Hide chart layers so we can show spinner
            this._chart.getLayerManager().hide();
        };
        ProgressSpinner.prototype.hide = function () {
            // Show chart layers so we can hide spinner
            this._chart.getLayerManager().show();
        };
        return ProgressSpinner;
    }());
    
    var NullProgressSpinner = /** @class */ (function (_super) {
        __extends(NullProgressSpinner, _super);
        function NullProgressSpinner(chart) {
            var _this = _super.call(this, chart) || this;
            _this._warningFired = false;
            return _this;
        }
        NullProgressSpinner.prototype.show = function () {
            _super.prototype.show.call(this);
            if (!isHeadlessMode && !this._warningFired) {
                console.warn('Using progress spinners in FDSChartJS requires Thief Classic or both Thief Angular and FDSChartJSAngularWrapper');
                this._warningFired = true;
            }
        };
        NullProgressSpinner.prototype.hide = function () {
            _super.prototype.hide.call(this);
        };
        NullProgressSpinner.prototype.resetSpinnerSize = function () { };
        return NullProgressSpinner;
    }(ProgressSpinner));
    
    var ThiefAngularProgressSpinner = /** @class */ (function (_super) {
        __extends(ThiefAngularProgressSpinner, _super);
        function ThiefAngularProgressSpinner(chart) {
            var _this = _super.call(this, chart) || this;
            _this._progressSpinnerElement = null;
            _this._progressSpinnerScope = null;
            _this._container = chart.containing_element;
            return _this;
        }
        ThiefAngularProgressSpinner.prototype.show = function () {
            _super.prototype.show.call(this);
            if (!this.isSpinning) {
                var chartElement_1 = angular.element(this._container);
                // In order to append the progressSpinnerDiv with the angular controller we need to compile it first
                var chartInjector = chartElement_1.injector();
                var progressSpinnerDivHTML_1;
                var progressSpinnerScope_1;
                var spinnerDivText_1 = "<div ng-controller=\"FDSChartJSProgressSpinnerController\" style=\"" + this._styleStr + "\"></div>";
                chartInjector.invoke([
                    '$compile', '$rootScope', function ($compile, $rootScope) {
                        var compiledProgressSpinnerDiv = $compile(spinnerDivText_1);
                        var containerProgressSpinnerScope = $rootScope.$new();
                        /* We're taking advantage of scope inheritance here. By creating a "data" object, the child scope that's
                          * created for FDSChartJSProgressSpinnerController will have access to $scope.data and when the controller
                          * puts functions on scope.data, the parent scope (containerProgressSpinnerScope) will still have access to it.
                          * If FDSChartJSProgressSpinnerController put the functions directly on $scope, we wouldn't have access.
                         */
                        containerProgressSpinnerScope.data = {};
                        progressSpinnerScope_1 = containerProgressSpinnerScope;
                        progressSpinnerDivHTML_1 = compiledProgressSpinnerDiv(containerProgressSpinnerScope);
                        chartElement_1.append(progressSpinnerDivHTML_1);
                    }
                ]);
                this._progressSpinnerElement = progressSpinnerDivHTML_1;
                this._progressSpinnerScope = progressSpinnerScope_1;
                this._progressSpinnerScope.data.createProgressSpinner(this._progressSpinnerElement);
                this.isSpinning = true;
            }
        };
        ThiefAngularProgressSpinner.prototype.hide = function () {
            _super.prototype.hide.call(this);
            if (this.isSpinning) {
                this._progressSpinnerScope.data.destroy();
                this._progressSpinnerScope.$destroy();
                this._progressSpinnerScope = null;
                this._progressSpinnerElement.remove();
                this._progressSpinnerElement = null;
                this.isSpinning = false;
            }
        };
        return ThiefAngularProgressSpinner;
    }(ProgressSpinner));
    
    var ThiefClassicProgressSpinner = /** @class */ (function (_super) {
        __extends(ThiefClassicProgressSpinner, _super);
        function ThiefClassicProgressSpinner(chart) {
            var _this = _super.call(this, chart) || this;
            _this._classicSpinner = null;
            _this._spinnerContainer = null;
            return _this;
        }
        ThiefClassicProgressSpinner.prototype.show = function () {
            var _this = this;
            _super.prototype.show.call(this);
            if (!this.isSpinning) {
                var _$ = $$1;
                $$1(this._chart.containing_element).append("<div class=\"chartSpinner\" style=\"" + this._styleStr + "\">");
                this._spinnerContainer = $$1('.chartSpinner');
                // Using size 'small' removes the number from the spinner. The size is actually the size of the div.
                this._classicSpinner = _$.thief.progressIndicator({ value: 0, size: 'small' }, this._spinnerContainer);
                var currentValue_1 = 0;
                this._spinTimer = setInterval(function () {
                    currentValue_1 = currentValue_1 >= 1 ? 0 : currentValue_1 + 0.01;
                    _this._classicSpinner.value(currentValue_1);
                }, 100);
                this.isSpinning = true;
            }
        };
        ThiefClassicProgressSpinner.prototype.hide = function () {
            _super.prototype.hide.call(this);
            if (this.isSpinning) {
                clearInterval(this._spinTimer);
                this._spinTimer = null;
                this._spinnerContainer.remove();
                this._spinnerContainer = null;
                this._classicSpinner = null;
                this.isSpinning = false;
            }
        };
        return ThiefClassicProgressSpinner;
    }(ProgressSpinner));
    
    var ChartTooltip = /** @class */ (function () {
        function ChartTooltip(chart) {
            this._hideTimeoutID = null;
            this._showTimeoutID = null;
            this._isShown = false;
            this._isInitialized = false;
            this._chart = chart;
        }
        ChartTooltip.prototype.setDelay = function (delay) {
            this._tooltipDelay = delay;
        };
        ChartTooltip.prototype.hideWithDelay = function () {
            var _this = this;
            if (this._hideTimeoutID != null) {
                return;
            }
            if (this._showTimeoutID != null) {
                clearTimeout(this._showTimeoutID);
                this._showTimeoutID = null;
            }
            this._hideTimeoutID = window.setTimeout((function () {
                _this.hide();
            }), this._tooltipDelay);
        };
        ChartTooltip.prototype.resetTimeouts = function () {
            if (this._showTimeoutID != null) {
                clearTimeout(this._showTimeoutID);
                this._showTimeoutID = null;
            }
            if (this._hideTimeoutID != null) {
                clearTimeout(this._hideTimeoutID);
                this._hideTimeoutID = null;
            }
        };
        ChartTooltip.prototype.doTooltip = function (hit, event) {
            if (!this._chart.tooltipsEnabled || this._chart.suppressAllInteraction ||
                this._chart.progressSpinner.isSpinning) {
                return;
            }
            if (typeof TouchEvent !== 'undefined' && TouchEvent != null && event instanceof TouchEvent) {
                return;
            }
            this._initialize();
            var tooltipContent = this._getTooltipContent();
            var hasTooltipText = tooltipContent && !tooltipContent.isEmpty();
            if (hasTooltipText) {
                this._updateContent(tooltipContent);
            }
            this._updatePosition(event);
            if (hit && hasTooltipText) {
                this._showWithDelay(event);
            }
            else {
                this.hideWithDelay();
            }
        };
        ChartTooltip.prototype._getTooltipContent = function () {
            var objName = this._chart.pick.accessObject();
            var chartObj = this._chart.getChild(objName);
            if (isSeries(chartObj)) {
                var index = Number(this._chart.pick.accessSubObject());
                return chartObj.getTooltipLabel(index);
            }
            if (this._chart.pick.hoverText != null && this._chart.pick.hoverText !== '') {
                // some hover text has been set manually
                return new RichTextString(this._chart.pick.hoverText);
                // this label only exists if axis tooltips are enabled
            }
            return undefined;
        };
        ChartTooltip.prototype.cleanUp = function () {
            this.resetTimeouts();
            if (this._isInitialized) {
                this._destroy();
            }
        };
        ChartTooltip.prototype._showWithDelay = function (event) {
            var _this = this;
            if (this._showTimeoutID != null) {
                return;
            }
            if (this._hideTimeoutID != null) {
                clearTimeout(this._hideTimeoutID);
                this._hideTimeoutID = null;
            }
            this._showTimeoutID = window.setTimeout((function () {
                _this._show(event);
                _this._updatePosition(event);
            }), this._tooltipDelay);
        };
        ChartTooltip.prototype._updateContent = function (text) {
            var plainText = (typeof text === 'string') ? text : RichTextRenderer.convertToHTML(text);
            this._content(plainText);
        };
        ChartTooltip.prototype._updatePosition = function (event) {
            if (this._isShown) {
                this._position(event);
            }
        };
        return ChartTooltip;
    }());
    
    var NullTooltip = /** @class */ (function (_super) {
        __extends(NullTooltip, _super);
        function NullTooltip(chart) {
            var _this = _super.call(this, chart) || this;
            _this._warningFired = false;
            return _this;
        }
        NullTooltip.prototype.hide = function () {
        };
        NullTooltip.prototype._initialize = function () {
            if (!isHeadlessMode && !this._warningFired) {
                console.warn('Using tooltips in FDSChartJS requires Thief Classic or both Thief Angular and FDSChartJSAngularWrapper');
                this._warningFired = true;
            }
        };
        NullTooltip.prototype._show = function () {
        };
        NullTooltip.prototype._content = function (newContent) {
        };
        NullTooltip.prototype._position = function (newPosition) {
        };
        NullTooltip.prototype._destroy = function () {
        };
        return NullTooltip;
    }(ChartTooltip));
    
    var ThiefAngularTooltip = /** @class */ (function (_super) {
        __extends(ThiefAngularTooltip, _super);
        function ThiefAngularTooltip(chart) {
            var _this = _super.call(this, chart) || this;
            _this._tooltipElement = null;
            _this._tooltipScope = null;
            _this._container = chart.containing_element;
            return _this;
        }
        ThiefAngularTooltip.prototype.hide = function () {
            if (this._isInitialized) {
                this._isShown = false;
                this._tooltipScope.data.hide();
            }
        };
        ThiefAngularTooltip.prototype._initialize = function () {
            if (!this._isInitialized) {
                var chartElement_1 = angular.element(this._container);
                // In order to append the tooltipDiv with the angular controller we need to compile it first
                var chartInjector = chartElement_1.injector();
                var tooltipDivHTML_1;
                var tooltipScope_1;
                chartInjector.invoke([
                    '$compile', '$rootScope', function ($compile, $rootScope) {
                        var compiledTooltipDiv = $compile('<div ng-controller="FDSChartJSTooltipController"></div>');
                        var containerTooltipScope = $rootScope.$new();
                        /* We're taking advantage of scope inheritance here. By creating a "data" object, the child scope that's
                          * created for FDSChartJSTooltipController will have access to $scope.data and when the controller
                          * puts functions on scope.data, the parent scope (containerTooltipScope) will still have access to it.
                          * If FDSChartJSTooltipController put the functions directly on $scope, we wouldn't have access.
                         */
                        containerTooltipScope.data = {};
                        tooltipScope_1 = containerTooltipScope;
                        tooltipDivHTML_1 = compiledTooltipDiv(containerTooltipScope);
                        chartElement_1.append(tooltipDivHTML_1);
                    }
                ]);
                this._tooltipElement = tooltipDivHTML_1;
                this._tooltipScope = tooltipScope_1;
                this._tooltipScope.data.createTooltip(this._tooltipElement);
                this._isInitialized = true;
            }
        };
        ThiefAngularTooltip.prototype._content = function (newContent) {
            this._tooltipScope.data.content(newContent);
        };
        ThiefAngularTooltip.prototype._position = function (newPosition) {
            this._tooltipScope.data.position(newPosition, { at: 'right bottom', my: 'left+15 top+15' });
        };
        ThiefAngularTooltip.prototype._show = function () {
            this._isShown = true;
            this._tooltipScope.data.show();
        };
        ThiefAngularTooltip.prototype._destroy = function () {
            this._tooltipScope.data.destroy();
            this._tooltipScope.$destroy();
            this._tooltipScope = null;
            this._tooltipElement.remove();
            this._tooltipElement = null;
            this._isInitialized = false;
        };
        return ThiefAngularTooltip;
    }(ChartTooltip));
    
    var ThiefClassicTooltip = /** @class */ (function (_super) {
        __extends(ThiefClassicTooltip, _super);
        function ThiefClassicTooltip(chart) {
            var _this = _super.call(this, chart) || this;
            _this._classicTooltip = null;
            _this._tooltipContent = null;
            return _this;
        }
        ThiefClassicTooltip.prototype.hide = function () {
            if (this._isInitialized) {
                this._isShown = false;
                this._classicTooltip.hide();
            }
        };
        ThiefClassicTooltip.prototype._initialize = function () {
            if (!this._isInitialized) {
                var _$ = $$1;
                if (this._classicTooltip == null) {
                    this._tooltipContent = $$1('<div>');
                    this._classicTooltip = _$.thief.tooltip({
                        content: this._tooltipContent
                    }, $$1('<div>'));
                }
                this._isInitialized = true;
            }
        };
        ThiefClassicTooltip.prototype._content = function (newContent) {
            this._tooltipContent.html(newContent);
        };
        ThiefClassicTooltip.prototype._position = function (newPosition) {
            this._classicTooltip.position({
                of: newPosition,
                at: 'right bottom',
                my: 'left+15 top+15'
            });
        };
        ThiefClassicTooltip.prototype._show = function (event) {
            this._isShown = true;
            this._classicTooltip.show(event);
        };
        ThiefClassicTooltip.prototype._destroy = function () {
            this._tooltipContent = null;
            this._classicTooltip.destroy();
            this._classicTooltip = null;
            this._isInitialized = false;
        };
        return ThiefClassicTooltip;
    }(ChartTooltip));
    
    var thief = isHeadlessMode ? undefined : window['thief'];
    var hasAngularModules = function () {
        if (typeof angular !== 'undefined' && !window['useThiefClassicForFDSChartJS']) {
            try {
                angular.module('thief');
                angular.module('fdschartjswrapper');
                /* Thief angular is an optional dependency so we can't use bower versioning for it. We need the custom
                   positioning feature for tooltips added in 1.21.0 for Thief Angular to work. */
                var thiefVersionString = angular.module('thief').version;
                var thiefVersions = thiefVersionString.split('.');
                var major = parseInt(thiefVersions[0]);
                var minor = parseInt(thiefVersions[1]);
                var isAcceptableVersion = (major === 1 && minor >= 21) || major > 1;
                if (!isAcceptableVersion) {
                    console.warn('Using Thief Angular with FDSChartJS requires at least version 1.21.0. Falling back to' +
                        ' Thief Classic or none');
                }
                return isAcceptableVersion;
            }
            catch (e) {
                return false;
            }
        }
        else {
            return false;
        }
    };
    var hasThiefClassic = function () {
        var _$ = $$1;
        if (_$ && _$.thief && _$.thief.tooltip && $$1['thief'].contextMenu) {
            return true;
        }
        else {
            return false;
        }
    };
    var getThiefTheme = function () {
        var themeString = 'none';
        if (!isHeadlessMode) {
            if (hasAngularModules()) {
                // Due to issues with using the tfThemeService outside of the normal angular cycle we're
                // duplicating the tfThemeService implementation here until Thief can provide it outside
                // of angular.  See issue #1167 on the Thief Angular gitlab project.
                var _findLinkTag = function (regex, name) {
                    var matchingLinkTags = $$1('link[href]').filter(function (idx, tag) { return regex.test(tag['href']); });
                    console.assert(matchingLinkTags.length === 1, "Expected to find exactly one link tag loading\n                           " + name + ", but found " + matchingLinkTags.length + " instead!");
                    return matchingLinkTags.eq(0);
                };
                var thiefCssRegex = /thief-(angular-)?(crystal|onyx|carbon|quartz)(-standard)?[^\/]*$/;
                var thiefCssLink = _findLinkTag(thiefCssRegex, 'thief-angular CSS')[0];
                console.assert(!!thiefCssLink, "The thief-angular CSS link tag could not be found using\n                        " + thiefCssRegex + " - is it being loaded? The theme will default to quartz,\n                        but attempting to switch themes may have unexpected results.");
                var matches = thiefCssLink && thiefCssLink.href.match(thiefCssRegex);
                themeString = matches ? matches[2] : 'quartz';
            }
            else if (hasThiefClassic()) {
                if ($$1(document.body).hasClass('.carbon')) {
                    themeString = 'carbon';
                }
                else {
                    themeString = 'quartz';
                }
            }
        }
        var themeVal;
        switch (themeString.toLowerCase()) {
            case 'onyx':
                themeVal = 4 /* ONYX */;
                break;
            case 'crystal':
                themeVal = 3 /* CRYSTAL */;
                break;
            case 'carbon':
                themeVal = 2 /* CARBON */;
                break;
            case 'quartz':
            default:
                themeVal = 1 /* QUARTZ */;
                break;
        }
        return themeVal;
    };
    var logThiefInformation = function (chart) {
        if (!isHeadlessMode && chart.generalInfoLog) {
            if (hasAngularModules()) {
                chart.generalInfoLog.log({
                    'thiefType': 'angular',
                    'thiefVersion': angular.module('thief').version
                });
            }
            else if (hasThiefClassic()) {
                chart.generalInfoLog.log({
                    'thiefType': 'classic',
                    'thiefVersion': window['thief'].version.semver
                });
            }
            else {
                chart.generalInfoLog.log({
                    'thiefType': 'none',
                    'thiefVersion': 'none'
                });
            }
        }
    };
    var createTooltip = function (chart) {
        if (!isHeadlessMode) {
            if (hasAngularModules()) {
                return new ThiefAngularTooltip(chart);
            }
            else if (hasThiefClassic()) {
                return new ThiefClassicTooltip(chart);
            }
        }
        // We must not support tooltips
        return new NullTooltip(chart);
    };
    var createContextMenu = function (chart) {
        if (!isHeadlessMode) {
            if (hasAngularModules()) {
                return new ThiefAngularMenu(chart);
            }
            else if (hasThiefClassic()) {
                return new ThiefClassicMenu(chart);
            }
        }
        // We must not support context menus
        return new NullMenu(chart);
    };
    var createProgressSpinner = function (chart) {
        if (!isHeadlessMode) {
            if (hasAngularModules()) {
                return new ThiefAngularProgressSpinner(chart);
            }
            else if (hasThiefClassic()) {
                return new ThiefClassicProgressSpinner(chart);
            }
        }
        // We must not support progress spinners
        return new NullProgressSpinner(chart);
    };
    
    /**
     * Attempts to calculate the previous release from the provided version.
     * This approach does not currently work for new major versions, or know about
     * patch releases from the previous version.
     *
     * It's primary purpose is to provide a version number that should be available on the CDN
     * to provide to the chart-image-service when testing things in edge/regression builds.
     *
     * @export
     * @param version
     * @returns "major.minor.patch"
     */
    function getClosestRelease(version) {
        var major, minor, patch, tag;
        var match = /(\d+)\.(\d+)\.(\d+)(?:-(edge|regression)\.\d+)?$/.exec(version);
        if (!match) {
            // Garbage in garbage out.
            return version;
        }
        major = match[1], minor = match[2], patch = match[3], tag = match[4];
        var minorOffset;
        if (tag === 'edge') {
            minorOffset = 2;
        }
        else if (tag === 'regression') {
            minorOffset = 1;
        }
        if (minorOffset) {
            minor = Math.max(0, Number(minor) - minorOffset);
            patch = '0';
        }
        return major + "." + minor + "." + patch;
    }
    var Version = /** @class */ (function () {
        function Version() {
            this.semver = this.version = '10.23.0-edge.0';
            this.major = '10';
            this.minor = '23';
            this.patch = '0';
        }
        Version.prototype.toString = function () {
            return this.version;
        };
        return Version;
    }());
    
    var ChartRenderManager = /** @class */ (function () {
        function ChartRenderManager(chart) {
            this.interactivityMode = 0 /* NONE */;
            this.didDrawInteraction = false;
            this.cursorX = 0;
            this.cursorY = 0;
            this.zooming = false;
            this.zoomPanning = false;
            this.plotDragManager = null;
            this.chart = chart;
        }
        // Draw the chart canvas fill and then redraw all plots, passing along the
        // value of the `redrawNonInteractive` argument. If `redrawNonInteractive`
        // is false, the non-interactive portions of plots (series, axes, etc.) will
        // not be redrawn. Instead, the result of their last draw will be composited
        // with the redrawn interactive components.
        ChartRenderManager.prototype.draw = function (redrawNonInteractive) {
            if (redrawNonInteractive === void 0) { redrawNonInteractive = true; }
            this.chart.syncAll();
            // get the context fresh - storing the context is a bad idea
            var chartCtx = this.chart.getContext();
            var overlayCtx = this.chart.getOverlayContext();
            var uiCtx = this.chart.getUIContext();
            var width = this.chart.getWidth();
            var height = this.chart.getHeight();
            if (redrawNonInteractive) {
                // fill in the bg for the entire chart
                if (this.chart.canvasBGBrush.style !== 1 /* NULL */) {
                    this.chart.canvasBGBrush.setOnCanvas(chartCtx, this.chart.chartRect);
                    chartCtx.fillRect(0, 0, width, height);
                }
            }
            overlayCtx.clear();
            this.chart.calcHeaderOffsets();
            // draw every plot we have
            this._drawPlots(redrawNonInteractive);
            this.chart.calcHeaderOffsets();
            // these must be drawn after the plots because we have to have plot sizing
            this._drawHeaders(overlayCtx);
            this._drawFooter(overlayCtx);
            this.chart.renderRichTextLinks();
            // all the plots have been calculated, create and consolidate the plot resizers
            this.chart.plotResizeManager.createPlotResizeSliders();
            // draw any resize sliders we need.
            this.chart.plotResizeManager.drawResizeSliders(uiCtx);
            // finally draw the outline
            if (redrawNonInteractive) {
                var fgPen = this.chart.canvasFGPen;
                if (fgPen.style !== 5 /* NULL */) {
                    fgPen.setOnCanvas(chartCtx);
                    this.chart.chartRect.strokeInternal(chartCtx);
                }
            }
            this._drawSelectionMarkers();
            this.chart.setHitList();
            if (redrawNonInteractive && !this.chart.isMockDrawing()) {
                if (this.plotDragManager && this.plotDragManager.chartTheme !== this.chart.getTheme()) {
                    this.plotDragManager.clear();
                    this.plotDragManager = null;
                }
                if (PlotDragManager.isPlotDragManagerNeeded(this.chart)) {
                    if (!this.plotDragManager) {
                        this.plotDragManager = new PlotDragManager(this.chart.containing_element, this.chart, this.chart.getTheme());
                    }
                    else {
                        this.plotDragManager.resetFromChart();
                    }
                }
                else if (this.plotDragManager != null) {
                    this.plotDragManager.clear();
                    this.plotDragManager = null;
                }
            }
        };
        ChartRenderManager.prototype._drawSelectionMarkers = function () {
            var _this = this;
            if (_$1.some(this.chart.chartPlotList, function (plot) { return plot.renderManager.hasSelectionMarkers(); })) {
                this.chart.runWithMarkerContext(function (ctx) {
                    for (var _i = 0, _a = _this.chart.chartPlotList; _i < _a.length; _i++) {
                        var plot = _a[_i];
                        plot.renderManager.drawSelectionMarkers(ctx);
                    }
                });
            }
            else {
                this.chart.resetMarkerContext();
            }
        };
        ChartRenderManager.prototype._drawHeaders = function (overlayCtx) {
            var headers = [
                this.chart.chartHeader,
                this.chart.chartHeading1,
                this.chart.chartHeading2,
                this.chart.chartHeading3,
                this.chart.chartHeading4
            ];
            var headerNames = ['ChartHeader', 'ChartHeading1', 'ChartHeading2', 'ChartHeading3', 'ChartHeading4'];
            this.chart.storedHeaderRects = [];
            this.chart.headerPixelPoints[this.chart.id] = [];
            var headerOffset = this.chart.chartHeadersTopOffset;
            for (var i = 0; i < headers.length; i++) {
                var header = headers[i];
                if (header.visible) {
                    var _a = header.computeTextDimensions(overlayCtx), width = _a[0], height = _a[1];
                    header.drawToCanvas(overlayCtx, this.chart.headerRect.y1 + headerOffset, this.chart.headerRect, this);
                    // save the header hitshape
                    var rect = new FDSRectangleHitShape(this.chart.headerRect.x1, this.chart.headerRect.y1 + headerOffset, this.chart.chartRect.getWidth(), height);
                    rect.name = headerNames[i];
                    this.chart.storedHeaderRects.push(rect);
                    // also save the pixel point
                    var pixX = ~~(rect.x + rect.width / 2);
                    var pixY = ~~(rect.y + rect.height / 2);
                    this.chart.headerPixelPoints[this.chart.id].push({ x: pixX, y: pixY });
                    headerOffset += height;
                }
            }
        };
        ChartRenderManager.prototype._drawFooter = function (overlayCtx) {
            if (!this.chart.chartFooter.visible) {
                return;
            }
            this.chart.chartFooter.drawToCanvas(overlayCtx, this.chart.footerRect.y1, this.chart.footerRect, this);
            // save the footer hitshape
            var _a = this.chart.chartFooter.computeTextDimensions(overlayCtx), width = _a[0], height = _a[1];
            var rect = new FDSRectangleHitShape(this.chart.footerRect.x1, this.chart.footerRect.y1, this.chart.chartRect.getWidth(), height);
            rect.name = 'ChartFooter';
            this.chart.storedHeaderRects.push(rect);
            // also save the footer pixel points
            var pixX = ~~(rect.x + rect.width / 2);
            var pixY = ~~(rect.y + rect.height / 2);
            this.chart.headerPixelPoints[this.chart.id].push({ x: pixX, y: pixY });
        };
        ChartRenderManager.prototype._drawPlots = function (redrawNonInteractive) {
            var marginMaxes = { left: 0, top: 0, right: 0, bottom: 0 };
            // first make sure every plot has the right ql offsets based on grouping.
            // this is necessary for the rest of this to be less terrible.
            this._adjustQLOffsetsForGrouping();
            if (redrawNonInteractive) {
                // first pass. find the max margins info per plot
                for (var _i = 0, _a = this.chart.chartPlotList; _i < _a.length; _i++) {
                    var plot = _a[_i];
                    // format the legend entries to prepare for drawing later
                    // this probably will need to be replaced with something similar to
                    // PC-sides 'initSceneWidth' which does a bit more than just format
                    // legend entries
                    if (plot.isActiveLegendHeatmap()) {
                        plot.heatmapLegend.formatLabels();
                    }
                    else {
                        plot.legend.formatEntries();
                    }
                    // calculate plot dimensions
                    plot.computeDimensions(false);
                    if (plot.groupedLeft || plot.grouped) {
                        marginMaxes.left = Math.max(marginMaxes.left, plot.plotRect.x1 - plot.minXFactor);
                    }
                    if (plot.groupedRight || plot.grouped) {
                        marginMaxes.right = Math.max(marginMaxes.right, plot.maxXFactor - plot.plotRect.x2);
                    }
                    if (plot.groupedTop || plot.groupedY) {
                        marginMaxes.top = Math.max(marginMaxes.top, plot.plotRect.y1 - plot.minYFactor);
                    }
                    if (plot.groupedBottom || plot.groupedY) {
                        marginMaxes.bottom = Math.max(marginMaxes.bottom, plot.maxYFactor - plot.plotRect.y2);
                    }
                }
            }
            // second pass. adjust grouped plots with the collected plot margin info
            if (redrawNonInteractive) {
                for (var _b = 0, _c = this.chart.chartPlotList; _b < _c.length; _b++) {
                    var plot = _c[_b];
                    if (plot.groupedLeft || plot.grouped) {
                        plot.plotRect.x1 = plot.minXFactor + marginMaxes.left;
                    }
                    if (plot.groupedRight || plot.grouped) {
                        plot.plotRect.x2 = plot.maxXFactor - marginMaxes.right;
                    }
                    if (plot.groupedTop || plot.groupedY) {
                        plot.plotRect.y1 = plot.minYFactor + marginMaxes.top;
                    }
                    if (plot.groupedBottom || plot.groupedY) {
                        plot.plotRect.y2 = plot.maxYFactor - marginMaxes.bottom;
                    }
                    // the -1s are there because we can't have a width of 0
                    if (plot.plotRect.x1 >= plot.plotRect.x2) {
                        plot.plotRect.x1 = plot.plotRect.x2 - 1;
                    }
                    if (plot.plotRect.y1 >= plot.plotRect.y2) {
                        plot.plotRect.y1 = plot.plotRect.y2 - 1;
                    }
                    // adjust axes and set up legends and stuff
                    // computeDimensions takes in a boolean plotRectSet which tells
                    //   whether or not the plotRect has been set externally (as is the
                    //   case here)
                    plot.computeDimensions(true);
                }
            }
            // now actually do the drawing
            for (var _d = 0, _e = this.chart.chartPlotList; _d < _e.length; _d++) {
                var plot = _e[_d];
                plot.renderManager.preDraw();
                plot.renderManager.draw(redrawNonInteractive);
            }
        };
        ChartRenderManager.prototype._adjustQLOffsetsForGrouping = function () {
            // there are four kinds of quicklabels, each shared differently:
            // inside - all grouped plots share this so the series line up on the plot.
            // beforeAxes - a plot needs to share this info with all other grouped plots, so they all move their axes over
            // to make room for the biggest labels.
            // onAxis and outside - these are taken care of later. For this, the grouped plots just need to share
            // largest axis width.
            var leftQLMaxes = { inside: 0, beforeAxes: 0 };
            var rightQLMaxes = { inside: 0, beforeAxes: 0 };
            // first pass. get the max margins.
            for (var _i = 0, _a = this.chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                // make sure it has a render manager
                if (!plot.renderManager) {
                    plot.renderManager = new PlotRenderManager(this, plot);
                }
                // calculate what the offsets for quicklabels will need to be
                plot.computeQuickLabelOffsets();
                if (plot.grouped) {
                    // quicklabel stuff only applies to plain grouped plots apparently
                    leftQLMaxes.beforeAxes = Math.max(plot.leftQuickLabelOffsets.beforeAxes, leftQLMaxes.beforeAxes);
                    rightQLMaxes.beforeAxes = Math.max(plot.rightQuickLabelOffsets.beforeAxes, rightQLMaxes.beforeAxes);
                    leftQLMaxes.inside = Math.max(plot.leftQuickLabelOffsets.inside, leftQLMaxes.inside);
                    rightQLMaxes.inside = Math.max(plot.rightQuickLabelOffsets.inside, rightQLMaxes.inside);
                }
            }
            // second pass. update plots based on this info
            for (var _b = 0, _c = this.chart.chartPlotList; _b < _c.length; _b++) {
                var plot = _c[_b];
                if (plot.grouped) {
                    plot.leftQuickLabelOffsets.beforeAxes = leftQLMaxes.beforeAxes;
                    plot.rightQuickLabelOffsets.beforeAxes = rightQLMaxes.beforeAxes;
                    plot.leftQuickLabelOffsets.inside = leftQLMaxes.inside;
                    plot.rightQuickLabelOffsets.inside = rightQLMaxes.inside;
                }
            }
        };
        // Returns the cursor position from an event.
        // If the onTouchEnd flag is true, this is expected to be called from
        // a touchend event, and will use the 'changedTouches' list in the TouchEvent
        //
        ChartRenderManager.prototype.getCursorPos = function (event, onTouchEnd) {
            if (onTouchEnd === void 0) { onTouchEnd = false; }
            // Browsers emit instances of `MouseEvent`, while mobile devices (at
            // least, iOS devices) emit `TouchEvents`, which we need to handle
            // slightly differently.
            var clientRect = this.chart.containing_element.getBoundingClientRect();
            var chartOffsetX;
            var chartOffsetY;
            if (event instanceof MouseEvent) {
                chartOffsetY = scaleByDevicePixelRatio(event.clientY - clientRect.top);
                chartOffsetX = scaleByDevicePixelRatio(event.clientX - clientRect.left);
            }
            else {
                var touch = void 0;
                if (onTouchEnd && event.changedTouches.length > 0) {
                    touch = event.changedTouches[0];
                }
                else if (!onTouchEnd && event.touches.length > 0) {
                    touch = event.touches[0];
                }
                else {
                    return new Point(0, 0);
                }
                chartOffsetY = scaleByDevicePixelRatio(touch.clientY - clientRect.top);
                chartOffsetX = scaleByDevicePixelRatio(touch.clientX - clientRect.left);
            }
            // When scaling occurs due to the minimum size attribute, we don't scale down hitshapes, chart rects, etc.
            // So when a click occurs, we want to upscale it for interaction.
            var unscaledChartOffsetX = this.chart.minimumSizeManager.unscaleWidth(chartOffsetX);
            var unscaledChartOffsetY = this.chart.minimumSizeManager.unscaleHeight(chartOffsetY);
            return new Point(unscaledChartOffsetX, unscaledChartOffsetY);
        };
        ChartRenderManager.prototype.startInteraction = function (event) {
            if (this.chart.suppressAllInteraction) {
                return;
            }
            this.didDrawInteraction = false;
            if (this.chart.crosshairsEnabled) {
                event.preventDefault();
            }
        };
        ChartRenderManager.prototype.stopInteraction = function (event, drawNonInteractive, shouldRedraw) {
            if (drawNonInteractive === void 0) { drawNonInteractive = false; }
            if (shouldRedraw === void 0) { shouldRedraw = false; }
            var persistInteraction = this.chart.attributeSet.get('PersistInteraction');
            shouldRedraw = shouldRedraw || !persistInteraction;
            // reset all the crosshair indices to -1 when we stop interacting to make
            // properties resolve in expected ways.
            for (var _i = 0, _a = this.chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                if (plot.renderManager) {
                    plot.renderManager.resetSeriesCrosshairIndices();
                }
            }
            if (this.interactivityMode !== 0 /* NONE */) {
                if (!persistInteraction && this.didDrawInteraction
                    || persistInteraction && !this.didDrawInteraction) {
                    this.interactivityMode = 0 /* NONE */;
                    shouldRedraw = true;
                }
            }
            if (this.chart.activeSlider != null) {
                this.chart.fireZoomEvent(this.chart.activeSlider.leftPt, this.chart.activeSlider.rightPt, this.chart.activeSlider.axis);
            }
            for (var _b = 0, _c = this.chart.mouseOutActions; _b < _c.length; _b++) {
                var fn = _c[_b];
                if (_$1.isFunction(fn)) {
                    drawNonInteractive = drawNonInteractive || fn(event);
                }
            }
            if (shouldRedraw) {
                this.draw(drawNonInteractive);
                this.chart.crosshairTooltip.hide(this.chart.getUIContext());
                this.chart.tooltip.hideWithDelay();
            }
            event.preventDefault();
            return false;
        };
        ChartRenderManager.prototype.drawInteraction = function (event) {
            var cursorPt = this.getCursorPos(event);
            this.cursorX = cursorPt.x;
            this.cursorY = cursorPt.y;
            if (this.chart.interacting) {
                if (this.chart.activeSlider != null) {
                    this._handleZoomSliderEvent(event);
                    if (this.chart.refreshPlotOnZoom) {
                        this.chart.fireZoomEvent(this.chart.activeSlider.leftPt, this.chart.activeSlider.rightPt, this.chart.activeSlider.axis, true);
                    }
                    return;
                }
            }
            var ignoreDrawTools = this.interactivityMode === 4 /* TRENDLINE */ ||
                this.interactivityMode === 6 /* DRAWBOX */ ||
                this.interactivityMode === 7;
            var needsRedraw = true;
            if (this.chart.crosshairsEnabled || this.chart.selectionToolEnabled ||
                this.chart.dragMode !== 0 /* NONE */) {
                this.draw(false);
                needsRedraw = false;
            }
            if (this.chart.interacting) {
                if (this.chart.rubberBandMode !== 0 /* NONE */) {
                    this._drawRubberBands(event);
                }
                if (this.chart.dragMode === 10 /* PLOT_RESIZE */) {
                    this.chart.plotResizeManager.handleResizeDrag(cursorPt);
                }
                if (!this.chart.activeSlider) {
                    var touches = void 0;
                    if ((typeof MouseEvent !== 'undefined' && MouseEvent !== null) && event instanceof MouseEvent) {
                        touches = 1;
                    }
                    else if ((typeof TouchEvent !== 'undefined' && TouchEvent !== null) && event instanceof TouchEvent) {
                        touches = event.touches.length;
                    }
                    if (touches === 1) {
                        this._handleAxesLabelsEvent(event, cursorPt, needsRedraw);
                        this.handleCrosshairEvent(cursorPt);
                    }
                    else if (touches === 2) {
                        this.chart.crosshairTooltip.hide(this.chart.getUIContext());
                        this._handleSelectionEvent(event);
                    }
                }
            }
            this.didDrawInteraction = this.interactivityMode !== 0 /* NONE */;
        };
        ChartRenderManager.prototype._drawRubberBands = function (event) {
            // we haven't actually started drawing
            var endPt = Point.zero();
            var pt = new Point(this.cursorX, this.cursorY);
            if (!this.chart.snapMouseToSeries(pt, endPt, undefined, event)) {
                endPt = pt;
            }
            if (this.chart.pickPoints.length > 0) {
                var blackPen = new FDSPen({ color: 0 /* BLACK */, width: 1 });
                var ctx = this.chart.getUIContext();
                ctx.clear();
                ctx.save();
                ctx.translate(0.5, 0.5);
                ctx.setPen(blackPen);
                if (this.chart.rubberBandMode === 3 /* LINE */) {
                    ctx.beginPath();
                    ctx.moveTo(this.chart.pickPoints[0].point.x, this.chart.pickPoints[0].point.y);
                    for (var i = 0; i < this.chart.pickPoints.length; i++) {
                        var p = this.chart.pickPoints[i];
                        if (i === 0) {
                            continue;
                        }
                        ctx.lineTo(p.point.x, p.point.y);
                    }
                    ctx.lineTo(endPt.x, endPt.y);
                    ctx.stroke();
                }
                else if (this.chart.rubberBandMode === 2 /* RECT */) {
                    var width = endPt.x - this.chart.pickPoints[0].point.x;
                    var height = endPt.y - this.chart.pickPoints[0].point.y;
                    ctx.strokeRect(this.chart.pickPoints[0].point.x, this.chart.pickPoints[0].point.y, width, height);
                }
                ctx.restore();
            }
            this.chart.drawSnappedMarker();
        };
        ChartRenderManager.prototype._handleZoomSliderEvent = function (event) {
            if (this.chart.suppressAllInteraction) {
                return;
            }
            if (this.chart.activeSlider.action === 0 /* PAN */) {
                this.chart.activeSlider.moveTo({ x: this.cursorX, y: this.cursorY });
            }
            else {
                this.chart.activeSlider.resize({ x: this.cursorX, y: this.cursorY });
            }
        };
        ChartRenderManager.prototype.handleCrosshairEvent = function (cursorPt) {
            if ((!this.chart.crosshairsEnabled) || this.chart.suppressAllInteraction) {
                return;
            }
            // A compromise here. PC-side turns them off all the way when drawing, but I think
            // it makes more sense to have them come back when drawing is over.
            if (this.chart.dragMode !== 0 /* NONE */ && this.chart.dragMode !== 7 /* MOVE */ &&
                this.chart.dragMode !== 8 /* RESIZE */) {
                return;
            }
            this.interactivityMode = 1 /* CROSSHAIRS */;
            var draw = false;
            // Compute the crosshair position on each plot. This ensures that the
            // series, and their property sets, are aware of the correct crosshair
            // index.
            for (var _i = 0, _a = this.chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                // computeCrosshairPosition will return false if the cursor is not over its plot
                draw = plot.renderManager.computeCrosshairPosition(cursorPt) || draw;
            }
            // if we arent over any plots, return
            if (!draw) {
                return;
            }
            for (var _b = 0, _c = this.chart.chartPlotList; _b < _c.length; _b++) {
                var plot = _c[_b];
                plot.renderManager.drawCrosshair(this.chart.getOverlayContext());
            }
            var crosshairTooltipPoint = new Point(this.cursorX, this.cursorY);
            if (this.chart.crosshairsSnapToSeries) {
                var snappedPoint = void 0;
                for (var _d = 0, _e = this.chart.chartPlotList; _d < _e.length; _d++) {
                    var plot = _e[_d];
                    if (plot.seriesList[this.chart.crosshairsSnapToSeries]) {
                        var prm = plot.renderManager;
                        snappedPoint = new Point(prm.crosshairX, prm.crosshairY);
                        break;
                    }
                }
                if (snappedPoint != null) {
                    if (this.chart.crosshairsTooltipSnapX) {
                        crosshairTooltipPoint.x = snappedPoint.x;
                    }
                    if (this.chart.crosshairsTooltipSnapY) {
                        crosshairTooltipPoint.y = snappedPoint.y;
                    }
                }
            }
            if (this.chart.crosshairsTooltipEnabled) {
                this._drawCrosshairTooltip(crosshairTooltipPoint);
            }
            // event.preventDefault()
            // event.stopPropagation()
        };
        ChartRenderManager.prototype._drawCrosshairTooltip = function (crosshairTooltipPoint) {
            switch (this.chart.crosshairsTooltipMode) {
                case 0 /* FOLLOW_CURSOR */:
                    // make sure the tooltip will fit in the x direction
                    var xPos = crosshairTooltipPoint.x + scaleByDevicePixelRatio(this.chart.crosshairsTooltipXOffset);
                    if (xPos + this.chart.crosshairTooltip.width > this.chart.getWidth()) {
                        xPos = crosshairTooltipPoint.x - scaleByDevicePixelRatio(this.chart.crosshairsTooltipXOffset) -
                            this.chart.crosshairTooltip.width;
                    }
                    // make sure the tooltip will fit in the y direction
                    var yPos = crosshairTooltipPoint.y - scaleByDevicePixelRatio(this.chart.crosshairsTooltipYOffset);
                    if (yPos + this.chart.crosshairTooltip.height > this.chart.getHeight()) {
                        yPos = crosshairTooltipPoint.y + scaleByDevicePixelRatio(this.chart.crosshairsTooltipYOffset) -
                            this.chart.crosshairTooltip.height;
                    }
                    this.chart.setCrosshairTooltipOptions({
                        visible: true,
                        text: this.chart.compiledCrosshairsTooltipText.fromValue(),
                        top: yPos,
                        left: xPos
                    });
                    break;
                case 1 /* FILL_SIDE */:
                    var snapPlot = this.chart.getCrosshairsTooltipSnapPlot();
                    var x = snapPlot.plotRect.x1;
                    var y = snapPlot.plotRect.y1;
                    if (crosshairTooltipPoint.x < snapPlot.plotRect.x1 + snapPlot.plotRect.getWidth() / 2) {
                        x = snapPlot.plotRect.x2 - this.chart.crosshairTooltip.width;
                    }
                    // if this is hanging off the bottom, bump it up just enough to fit
                    // we shouldn't have a similar issue with the x coordinate since the plot rect should be fully contained
                    // by the canvas
                    if (y + this.chart.crosshairTooltip.height > this.chart.getHeight()) {
                        y -= y + this.chart.crosshairTooltip.height - this.chart.getHeight();
                    }
                    this.chart.setCrosshairTooltipOptions({
                        visible: true,
                        text: this.chart.compiledCrosshairsTooltipText.fromValue(),
                        top: y,
                        left: x
                    });
                    break;
            }
        };
        ChartRenderManager.prototype._handleAxesLabelsEvent = function (event, cursorPos, needsRedraw) {
            if (needsRedraw === void 0) { needsRedraw = false; }
            if ([0 /* NONE */, 7 /* MOVE */, 8 /* RESIZE */].indexOf(this.chart.dragMode) === -1) {
                return;
            }
            this.interactivityMode = 1 /* CROSSHAIRS */;
            // Compute the crosshair position on each plot. This ensures that the
            // series, and their property sets, are aware of the correct crosshair
            // index.
            var crosshairLabelPlots = [];
            for (var _i = 0, _a = this.chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                if (plot.renderManager && plot.renderManager.computeCrosshairPosition(cursorPos)) {
                    if (plot.renderManager.crosshairsLabelNeedDrawing()) {
                        crosshairLabelPlots.push(plot);
                    }
                }
            }
            if (crosshairLabelPlots.length > 0 && needsRedraw) {
                this.draw(false);
            }
            for (var _b = 0, crosshairLabelPlots_1 = crosshairLabelPlots; _b < crosshairLabelPlots_1.length; _b++) {
                var crosshairLabelPlot = crosshairLabelPlots_1[_b];
                crosshairLabelPlot.renderManager.drawCrosshairsAxesLabels();
            }
            event.preventDefault();
        };
        ChartRenderManager.prototype._handleSelectionEvent = function (event) {
            if (!this.chart.selectionToolEnabled) {
                return false;
            }
            this.interactivityMode = 2 /* SELECTION */;
            this.draw(false);
            for (var _i = 0, _a = this.chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                plot.renderManager.drawSelection(event, this.chart.getOverlayContext());
            }
            event.preventDefault();
            event.stopPropagation();
            return false;
        };
        ChartRenderManager.prototype.clearInteractions = function () {
            this.interactivityMode = 0 /* NONE */;
            this.chart.crosshairTooltip.hide(this.chart.getUIContext());
            if (this.plotDragManager) {
                this.plotDragManager.clear();
                this.plotDragManager = null;
            }
        };
        ChartRenderManager.prototype.zoomChart = function (pick$$1) {
            var obj = this.chart.getObject(pick$$1.accessObject());
            this.chart.pickPoints = [];
            if (isSeries(obj)) {
                if (obj.renderCache && obj.getEffectiveDrawStyle() === 38 /* TREEMAP */) {
                    var index = obj.renderCache.getIndexFromPick(pick$$1);
                    obj.renderCache.zoomIn(index);
                    this.chart.invalidate();
                    return;
                }
            }
            // We don't want to allow simple zoom when horizontal zoom is enabled
            if (!this.chart.attributeSet.get('HorizontalZoom')) {
                this.chart.interactionCursor = Cursor.CROSSHAIRS;
                this.chart.dragMode = 3 /* ZOOM */;
                this.chart.rubberBandMode = 2 /* RECT */;
            }
        };
        ChartRenderManager.prototype.unZoomChart = function (pick$$1) {
            var obj = this.chart.getObject(pick$$1.accessObject());
            if (isSeries(obj)) {
                // Special case for unzooming Treemaps
                if (obj.renderCache && obj.getEffectiveDrawStyle() === 38 /* TREEMAP */) {
                    obj.renderCache.unzoom();
                    this.chart.invalidate();
                    this.chart.fireChartEvent('UnZoom', new Point(0, 0), ['', '', '', '', '', '', '', '']);
                    return;
                }
            }
            if (!this.chart.attributeSet.get('HorizontalZoom')) {
                this.chart.handleUnzoom();
            }
        };
        ChartRenderManager.prototype.displayAboutDialog = function () {
            var version = new Version();
            return thief.ui.alert({
                message: "FDSChartJS " + version.major + "." + version.minor + "<br>(c) FactSet Research Systems, Inc. - All Rights Reserved",
                title: 'About FDSChartJS'
            });
        };
        return ChartRenderManager;
    }());
    
    var DefaultStyleSets = /** @class */ (function () {
        function DefaultStyleSets() {
            this._themeDiffs = {
                'FC_PLOT': {
                    'appAttributes': {
                        'PlotBGColor': {
                            'crystal': 16777215,
                            'onyx': 3289650
                        },
                        'PlotFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        },
                        'XAxisFGColor': {
                            'crystal': 14803425,
                            'onyx': 493447500
                        },
                        'XGridFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        },
                        'XMinorGridFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        },
                        'XTicksFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        },
                        'YAxisFGColor': {
                            'crystal': 14803425,
                            'onyx': 493447500
                        },
                        'YGridFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        },
                        'YMinorGridFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        },
                        'YTicksFGColor': {
                            'crystal': 14803425,
                            'onyx': 4934475
                        }
                    }
                },
                'FC_CHART_STYLE': {
                    'appAttributes': {
                        'CanvasBGColor': {
                            'crystal': 16777215,
                            'onyx': 3289650
                        },
                        'BaseFontColor': {
                            'crystal': 0,
                            'onyx': 16777215
                        },
                    }
                },
                'HIGHLIGHTED_REGIONS_STYLE': {
                    'appAttributes': {
                        'SeriesFGColor': {
                            'crystal': 0,
                            'onyx': 16777215
                        }
                    }
                },
            };
        }
        DefaultStyleSets.prototype._getBaseStyleSet = function () {
            return {
                'action': 'append',
                'objects': [
                    {
                        'id': 'FC_DATA',
                        'type': 'FDSDataStyle',
                        'appAttributes': {}
                    },
                    {
                        'id': 'FC_SERIES',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesBGStyle': 0 /* SOLID */,
                            'SeriesBGGradientColor': 0,
                            'SeriesBGAlpha': 255
                        }
                    },
                    {
                        'id': 'FC_PLOT',
                        'type': 'FDSPlotStyle',
                        'appAttributes': {
                            'PlotBGGradientStyle': 0 /* NONE */,
                            'PlotBGStyle': 0 /* SOLID */,
                            'PlotBGAlpha': 255,
                            'PlotBGColor': 3289650,
                            'PlotBGGradientColor': 0,
                            'PlotFGStyle': 0 /* SOLID */,
                            'PlotFGColor': 4934475,
                            'PlotFGWidth': 1,
                            'TopMargin': 5,
                            'LeftMargin': 5,
                            'BottomMargin': 5,
                            'RightMargin': 5,
                            'EquateLRMargins': true,
                            'LegendBGStyle': 1 /* NULL */,
                            'LegendBGAlpha': 255,
                            'LegendBGColor': 16777215,
                            'LegendBGGradientStyle': 0 /* NONE */,
                            'LegendBGGradientColor': 0,
                            'LegendFGStyle': 5 /* NULL */,
                            'LegendFGColor': 0,
                            'LegendFGWidth': 1,
                            'LegendDirection': 1 /* ROW */,
                            'LegendPosition': 1 /* RIGHT */,
                            'LegendAxisPosition': 0 /* NORMAL */,
                            'LegendVPosition': 1 /* TOP */,
                            'LegendBasePosition': 2 /* CENTER */,
                            'LegendXOffset': 0,
                            'LegendYOffset': 0,
                            'LegendFontHeight': 11,
                            'XFontEscapement': 0,
                            'XAxisFontHeight': 11,
                            'XAxisFGColor': 493447500,
                            'XAxisFGStyle': 0 /* SOLID */,
                            'XAxisFGWidth': 1,
                            'XGrid': true,
                            'XGridFGColor': 4934475,
                            'XGridFGStyle': 0 /* SOLID */,
                            'XGridFGWidth': 1,
                            'XMinorGrid': false,
                            'XMinorGridFGColor': 4934475,
                            'XMinorGridFGStyle': 0 /* SOLID */,
                            'XMinorGridFGWidth': 1,
                            'XTicksFGColor': 4934475,
                            'XTicksFGStyle': 0 /* SOLID */,
                            'XTicksFGWidth': 1,
                            'XTicksLength': 6,
                            'XMinorTicksLengthFactor': 0,
                            'XIntradayScaleLabelFormatMONTH': 'MMM',
                            'XIntradayScaleLabelFormatQUARTER': 'QQQ',
                            'XIntradayScaleLabelFormatYEAR': 'yy',
                            'YFontEscapement': 0,
                            'YAxisFontHeight': 0,
                            'YAxisFGColor': 493447500,
                            'YAxisFGStyle': 0 /* SOLID */,
                            'YAxisFGWidth': 1,
                            'YGrid': true,
                            'YGridFGColor': 4934475,
                            'YGridFGStyle': 0 /* SOLID */,
                            'YGridFGWidth': 1,
                            'YMinorGrid': true,
                            'YMinorGridFGColor': 4934475,
                            'YMinorGridFGStyle': 5 /* NULL */,
                            'YMinorGridFGWidth': 1,
                            'YTicksFGColor': 4934475,
                            'YTicksFGStyle': 0 /* SOLID */,
                            'YTicksFGWidth': 1,
                            'YTicksLength': 6,
                            'YMinorTicksLengthFactor': 0
                        }
                    },
                    {
                        'id': 'FC_CHART_STYLE',
                        'type': 'FDSChartStyle',
                        'appAttributes': {
                            'CanvasBGStyle': 0 /* SOLID */,
                            'CanvasBGGradientStyle': 0 /* NONE */,
                            'CanvasBGColor': 3289650,
                            'CanvasBGGradientColor': 0,
                            'CanvasBGAlpha': 255,
                            'CanvasFGColor': 0,
                            'CanvasFGStyle': 5 /* NULL */,
                            'CanvasFGWidth': 1,
                            'SeriesColorUp': 39219,
                            'SeriesColorDown': 255,
                            'SeriesColorNeutral': 15707648,
                            'BaseFontFamily': 'Arial',
                            'BaseFontHeight': 12,
                            'BaseFontWeight': 400,
                            'BaseFontItalic': false,
                            'BaseFontUnderline': false,
                            'BaseFontColor': 16777215,
                            'SeriesColorCycle': 16,
                            'SeriesColor0': 15707648,
                            'SeriesColor1': 3394713,
                            'SeriesColor2': 6697882,
                            'SeriesColor3': 52479,
                            'SeriesColor4': 9868950,
                            'SeriesColor5': 11037743,
                            'SeriesColor6': 39219,
                            'SeriesColor7': 3368601,
                            'SeriesColor8': 39423,
                            'SeriesColor9': 6579300,
                            'SeriesColor10': 16711935,
                            'SeriesColor11': 10066176,
                            'SeriesColor12': 9889498,
                            'SeriesColor13': 0,
                            'SeriesColor14': 3618815,
                            'SeriesColor15': 153,
                            'SeriesLineStyle0': 0 /* SOLID */,
                            'SeriesLineStyle1': 0 /* SOLID */,
                            'SeriesLineStyle2': 0 /* SOLID */,
                            'SeriesLineStyle3': 0 /* SOLID */,
                            'SeriesLineStyle4': 0 /* SOLID */,
                            'SeriesLineStyle5': 0 /* SOLID */,
                            'SeriesLineStyle6': 0 /* SOLID */,
                            'SeriesLineStyle7': 0 /* SOLID */,
                            'SeriesLineStyle8': 0 /* SOLID */,
                            'SeriesLineStyle9': 0 /* SOLID */,
                            'SeriesLineStyle10': 0 /* SOLID */,
                            'SeriesLineStyle11': 0 /* SOLID */,
                            'SeriesLineStyle12': 0 /* SOLID */,
                            'SeriesLineStyle13': 0 /* SOLID */,
                            'SeriesLineStyle14': 0 /* SOLID */,
                            'SeriesLineStyle15': 0 /* SOLID */,
                            'SeriesLineWidth0': 1,
                            'SeriesLineWidth1': 1,
                            'SeriesLineWidth2': 1,
                            'SeriesLineWidth3': 1,
                            'SeriesLineWidth4': 1,
                            'SeriesLineWidth5': 1,
                            'SeriesLineWidth6': 1,
                            'SeriesLineWidth7': 1,
                            'SeriesLineWidth8': 1,
                            'SeriesLineWidth9': 1,
                            'SeriesLineWidth10': 1,
                            'SeriesLineWidth11': 1,
                            'SeriesLineWidth12': 1,
                            'SeriesLineWidth13': 1,
                            'SeriesLineWidth14': 1,
                            'SeriesLineWidth15': 1,
                            'SeriesOutlineColor0': 11037743,
                            'SeriesOutlineColor1': 2063454,
                            'SeriesOutlineColor2': 7602528,
                            'SeriesOutlineColor3': 39372,
                            'SeriesOutlineColor4': 6579300,
                            'SeriesOutlineColor5': 6697728,
                            'SeriesOutlineColor6': 26163,
                            'SeriesOutlineColor7': 1978701,
                            'SeriesOutlineColor8': 28601,
                            'SeriesOutlineColor9': 6579300,
                            'SeriesOutlineColor10': 6697882,
                            'SeriesOutlineColor11': 6706728,
                            'SeriesOutlineColor12': 2063454,
                            'SeriesOutlineColor13': 3289650,
                            'SeriesOutlineColor14': 153,
                            'SeriesOutlineColor15': 102,
                            'SeriesQuickLabelTextBox': true,
                            'SeriesQuickLabelTextBoxDisplayStyle': 6 /* RECT_TAG */,
                            'SeriesQuickLabelTextBoxBGColor': 0,
                            'SeriesQuickLabelTextBoxBGStyle': 0 /* SOLID */,
                            'SeriesQuickLabelTextBoxBGAlpha': 100,
                            'SeriesQuickLabelTextBoxBGGradientColor': 0,
                            'SeriesQuickLabelTextBoxFGColor': 0,
                            'SeriesQuickLabelTextBoxFGStyle': 5 /* NULL */,
                            'SeriesQuickLabelTextBoxFGWidth': 1,
                            'SeriesQuickLabelColorMaximumContrast': true,
                            'SeriesQuickLabelFontColor': 0,
                            'SeriesQuickLabelColorFollowsSeriesColor': false,
                            'SeriesQuickLabelArrowMultiplier': 3,
                            'SeriesQuickLabelFontHeight': 10,
                            'ChartFooter': false,
                        }
                    },
                    {
                        'id': 'SPAR_PORTFOLIO_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesMarkerStyleList': [
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                            ]
                        }
                    },
                    {
                        'id': 'SPAR_BENCHMARK_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesMarkerStyleList': [
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                                0 /* DIAMOND */,
                            ],
                            'SeriesColorList': [
                                15707648,
                                3394713,
                                6697882,
                                52479,
                                9868950,
                                11037743,
                                39219,
                                3368601,
                                39423,
                                6579300,
                                16711935,
                                10066176,
                                9889498,
                                0,
                                3618815,
                                153
                            ]
                        }
                    },
                    {
                        'id': 'SPAR_UNIVERSE_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesBGStyle': 4 /* STEPPED */,
                            'SeriesBGColor': 13395456,
                            'SeriesBGGradientColor': 16777215
                        }
                    },
                    {
                        'id': 'SPAR_INVESTMENT_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesColorList': [
                                15707648,
                                3394713,
                                6697882,
                                52479,
                                9868950,
                                11037743,
                                39219,
                                3368601,
                                39423,
                                6579300,
                                16711935,
                                10066176,
                                9889498,
                                0,
                                3618815,
                                153
                            ]
                        }
                    },
                    {
                        'id': 'LINE_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesLineWidthList': [
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2,
                                2
                            ],
                            'SeriesLineStyleList': [
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */,
                                0 /* SOLID */
                            ]
                        }
                    },
                    {
                        'id': 'BAR_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {}
                    },
                    {
                        'id': 'BARINDICATOR_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesFGWidth': 1,
                            'SeriesMarkerSize': 9,
                        }
                    },
                    {
                        'id': 'OHLC_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {}
                    },
                    {
                        'id': 'HEAT_MAP_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesColorUp': 723964,
                            'SeriesColorNeutral': 0,
                            'SeriesColorDown': 5111629
                        }
                    },
                    {
                        'id': 'PIE_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'PieTiltAngle': 85,
                            'PieDonutRadius': 0
                        }
                    },
                    {
                        'id': 'MARKER_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesMarkerStyle': 1 /* CIRCLE */,
                            'SeriesMarkerSize': 5
                        }
                    },
                    {
                        'id': 'HIGHLIGHTED_REGIONS_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesFGStyle': 5 /* NULL */,
                            'SeriesFGWidth': 2,
                            'SeriesFGColor': 16777215,
                            'SeriesBGStyle': 0 /* SOLID */,
                            'SeriesBGAlpha': 51,
                            'SeriesBGColor': 8224125,
                            'SeriesBGGradientStyle': 0 /* NONE */,
                            'SeriesBGGradientColor': 0,
                            'AnnotationAllowAnnotInLegend': false
                        }
                    },
                    {
                        'id': 'AREA_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesBGStyle': 0 /* SOLID */,
                            'SeriesBGAlpha': 89,
                            'SeriesBGGradientStyle': 0 /* NONE */,
                            'SeriesBGGradientColor': 0
                        }
                    },
                    {
                        'id': 'BUBBLE_STYLE',
                        'type': 'FDSSeriesStyle',
                        'appAttributes': {
                            'SeriesBGStyle': 0 /* SOLID */,
                            'SeriesBGAlpha': 89,
                            'SeriesBGGradientStyle': 0 /* NONE */,
                            'SeriesBGGradientColor': 0
                        }
                    }
                ],
                'drawStyleMappings': {
                    'LINE_STYLE': [
                        0 /* LINE */
                    ],
                    'BAR_STYLE': [
                        5 /* COLUMNS3D */,
                        6 /* COLUMNS */,
                        11 /* BARS3D */,
                        12 /* BARS */
                    ],
                    'BARINDICATOR_STYLE': [
                        63 /* BARINDICATOR */,
                    ],
                    'OHLC_STYLE': [
                        22 /* OHLC */,
                        37 /* HLCROSS */,
                        2 /* HLC */,
                        23 /* CANDLE */
                    ],
                    'PIE_STYLE': [
                        19 /* PIE */,
                        36 /* PIE3D */
                    ],
                    'MARKER_STYLE': [
                        3 /* MARKER */
                    ],
                    'HEAT_MAP_STYLE': [
                        38 /* TREEMAP */,
                        41 /* KMLMAP */
                    ],
                    'HIGHLIGHTED_REGIONS_STYLE': [
                        27 /* RECT */,
                        28 /* VERTRECT */,
                        29 /* HORZRECT */
                    ],
                    'AREA_STYLE': [
                        9 /* AREA */
                    ],
                    'BUBBLE_STYLE': [
                        31 /* BUBBLE */
                    ]
                },
                'styleSetObjectVersion': 1,
                'editorVersion': 1
            };
        };
        DefaultStyleSets.prototype.getCrystal = function () {
            return this._applyThemeDiffsToBase('crystal');
        };
        DefaultStyleSets.prototype.getOnyx = function () {
            return this._applyThemeDiffsToBase('onyx');
        };
        DefaultStyleSets.prototype._applyThemeDiffsToBase = function (theme) {
            var _this = this;
            var updatedStyleSet = this._getBaseStyleSet();
            _$1.each(updatedStyleSet.objects, function (updatedStyleSetObject) {
                var themeDiff = _$1.get(_this._themeDiffs, [updatedStyleSetObject.id, 'appAttributes']);
                if (themeDiff) {
                    updatedStyleSetObject.appAttributes = _$1.mapValues(updatedStyleSetObject.appAttributes, function (value, attr) {
                        var diffValues = themeDiff[attr];
                        return _$1.get(diffValues, [theme], value);
                    });
                }
            });
            return updatedStyleSet;
        };
        return DefaultStyleSets;
    }());
    
    var FDSActionXMLDriver = /** @class */ (function () {
        function FDSActionXMLDriver(point) {
            if (point === void 0) { point = new Point(0, 0); }
            this._point = point;
            this._actionCallDepth = 0;
        }
        FDSActionXMLDriver.prototype._actionDepthGuard = function () {
            return this._actionCallDepth > 100;
        };
        FDSActionXMLDriver.prototype._convertToActionType = function (actionString) {
            actionString = actionString.toLowerCase();
            switch (actionString) {
                case 'objectaction':
                    return 1 /* ObjectAction */;
                case 'setattribute':
                    return 2 /* SetAttribute */;
                case 'clearobject':
                    return 3 /* ClearObject */;
                case 'deleteobject':
                    return 4 /* DeleteObject */;
                case 'refresh':
                    return 5 /* Refresh */;
                case 'addobject':
                    return 7 /* AddObject */;
                case 'setchild':
                    return 8 /* SetChild */;
                case 'callaction':
                    return 9 /* CallAction */;
                case 'fireevent':
                    return 10 /* FireEvent */;
                case 'navigate':
                    return 11 /* Navigate */;
                default:
                    return 0 /* NoAction */;
            }
        };
        FDSActionXMLDriver.prototype.interpretXML = function (object, xml, pick$$1) {
            this._actionCallDepth++;
            if (this._actionDepthGuard()) {
                console.error('Oops. Ran up against the action depth limit. We may be in an infinite loop. Aborting.');
                return false;
            }
            var chart = isRootChart(object) ? object : object.root;
            var xmlDoc;
            try {
                xmlDoc = chart._parseXML(xml);
                if (!xmlDoc) {
                    // most likely a parse error
                    return false;
                }
            }
            catch (error) {
                return false;
            }
            // get all the 'actionlist' elements. We probably only have one, but its not restricted to that
            var nodeList = xmlDoc.getElementsByTagName('ActionList');
            var objectName = object.id;
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < nodeList.length; i++) {
                var node = nodeList[i];
                var actionNodeList = node.getElementsByTagName('Action');
                // tslint:disable-next-line:prefer-for-of
                for (var j = 0; j < actionNodeList.length; j++) {
                    var action = actionNodeList[j];
                    var actionType = this._getActionNodeAttribute(action, 'type');
                    var csResolveValue = this._getActionNodeAttribute(action, 'resolve-value');
                    // convert the resolve-value string from above to a boolean
                    var bResolveValue = csResolveValue.toLowerCase() === 'false' ? false : true;
                    this._interpretAction(chart, object, action, pick$$1, this._convertToActionType(actionType), bResolveValue);
                }
            }
            this._actionCallDepth--;
            return true;
        };
        FDSActionXMLDriver.prototype._getActionNodeAttribute = function (node, attribute) {
            if (node && typeof node.getAttribute === 'function') {
                var val = node.getAttribute(attribute);
                if (val != null) {
                    return val;
                }
            }
            return '';
        };
        FDSActionXMLDriver.prototype._interpretAction = function (chart, chartObject, actionNode, pick$$1, actionType, resolve) {
            if (!chart) {
                return;
            }
            var propInfo;
            if (isSeries(chartObject)) {
                var allowNL = false;
                var index = Number(pick$$1.accessDrilldown());
                if (index == null) {
                    index = 0;
                }
                propInfo = { allowNL: allowNL, seriesIndex: index };
            }
            switch (actionType) {
                case 1 /* ObjectAction */:
                    return this._interpretObjectAction(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 2 /* SetAttribute */:
                    return this._interpretSetAttribute(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 9 /* CallAction */:
                    return this._interpretCallAction(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 3 /* ClearObject */:
                    return this._interpretClearObject(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 4 /* DeleteObject */:
                    return this._interpretDeleteObject(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 5 /* Refresh */:
                    return this._interpretRefresh(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 6 /* ClearAll */:
                    return this._interpretClearAll(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 7 /* AddObject */:
                    return this._interpretAddObject(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 8 /* SetChild */:
                    return this._interpretSetChild(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 10 /* FireEvent */:
                    return this._interpretFireEvent(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
                case 11 /* Navigate */:
                    return this._interpretNavigate(chart, chartObject, actionNode, pick$$1, propInfo, resolve);
            }
        };
        // Fetches the passed in xml tag name and returns the value as a string
        FDSActionXMLDriver.prototype._retrieveValueXML = function (node, tag) {
            var nodeList = node.getElementsByTagName(tag);
            if (nodeList.length > 0) {
                return nodeList[0].textContent.trim();
            }
            return undefined;
        };
        // helper for value xml fetcher. This will handle properties in the xml string
        FDSActionXMLDriver.prototype._retrieveValueXMLHelper = function (object, actionNode, propInfo, query) {
            var _this = this;
            var getValue = function (value) {
                var retVal = _this._retrieveValueXML(actionNode, value);
                if (retVal) {
                    return object.properties.compilePropertyString(retVal).fromValue(propInfo);
                }
                return undefined;
            };
            if (query instanceof Array) {
                return query.map(getValue);
            }
            else {
                return getValue(query);
            }
        };
        // gets a value from the xml. If it is an array, it will be listed as <ValueArray> tag and this
        // function will return an array. Otherwise it will just return the string. If the value contains xml,
        // then we will serialize that xml to a string and return that. (In the case of some action that is setting
        // an attribute to some xml string)
        FDSActionXMLDriver.prototype._retrieveValueArray = function (actionNode, query) {
            var nodeList = actionNode.getElementsByTagName(query);
            var retVal = [];
            var serializer = new XMLSerializer();
            if (nodeList.length > 0) {
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < nodeList.length; i++) {
                    var node = nodeList[i];
                    var valueArray = node.getElementsByTagName('ValueArray');
                    if (valueArray.length > 0) {
                        var elementArray = node.getElementsByTagName('Element');
                        // tslint:disable-next-line:prefer-for-of
                        for (var j = 0; j < elementArray.length; j++) {
                            var element = elementArray[j];
                            retVal.push(element.textContent.trim());
                        }
                    }
                    else {
                        // tslint:disable-next-line:prefer-for-of
                        for (var k = 0; k < node.childNodes.length; k++) {
                            var child = node.childNodes[k];
                            if (Object.prototype.toString.call(child) === '[object Text]') {
                                retVal.push(child.textContent);
                            }
                            else {
                                retVal.push(serializer.serializeToString(child));
                            }
                        }
                    }
                }
                return retVal;
            }
            return undefined;
        };
        FDSActionXMLDriver.prototype._retrieveValueArrayHelper = function (object, actionNode, propInfo, query, resolve) {
            var arr = this._retrieveValueArray(actionNode, query);
            if (arr) {
                var el = void 0;
                for (var i = 0; i < arr.length; i++) {
                    el = arr[i];
                    if (resolve) {
                        arr[i] = object.properties.compilePropertyString(el).fromValue(propInfo);
                    }
                }
                return arr;
            }
            return undefined;
        };
        /*#
         * Step interpreters
         */ //
        FDSActionXMLDriver.prototype._interpretObjectAction = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var _a = this._retrieveValueXMLHelper(object, actionNode, propInfo, ['Name', 'Object', 'Flags']), actionName = _a[0], _b = _a[1], resObject = _b === void 0 ? object.id : _b, _c = _a[2], flags = _c === void 0 ? '0' : _c;
            if (!actionName) {
                return; // can't call object action without an action name
            }
            var values$$1 = this._retrieveValueArrayHelper(object, actionNode, propInfo, 'Value', resolve);
            if (chart) {
                chart.emptyInteractionList();
                chart.objectActionExternal(resObject, Number(flags), actionName, values$$1);
            }
        };
        FDSActionXMLDriver.prototype._interpretSetAttribute = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var _a = this._retrieveValueXMLHelper(object, actionNode, propInfo, ['Attribute', 'Object', 'Flags']), attribute = _a[0], _b = _a[1], objectName = _b === void 0 ? object.id : _b, _c = _a[2], flags = _c === void 0 ? '0' : _c;
            if (!attribute) {
                return; // can't set attribute without an attribute name
            }
            var values$$1 = this._retrieveValueArrayHelper(object, actionNode, propInfo, 'Value', resolve);
            var value = values$$1.length > 0 ? values$$1[0] : '';
            if (chart) {
                chart.emptyInteractionList();
                chart.setAttributeExternal(objectName, Number(flags), attribute, value);
            }
        };
        FDSActionXMLDriver.prototype._interpretCallAction = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var actionToCall = this._retrieveValueXMLHelper(object, actionNode, propInfo, 'Name');
            if (!actionToCall) {
                return; // no action to call? return
            }
            if (chart && actionToCall.length > 0) {
                chart.handleAction(object, actionToCall, this._point);
            }
        };
        FDSActionXMLDriver.prototype._interpretClearObject = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var objectName = this._retrieveValueXMLHelper(object, actionNode, propInfo, 'Object') || object.id;
            if (chart) {
                chart.emptyInteractionList();
                chart.clearObject(objectName);
            }
        };
        FDSActionXMLDriver.prototype._interpretDeleteObject = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var _a = this._retrieveValueXMLHelper(object, actionNode, propInfo, ['Object', 'Flags']), _b = _a[0], objectName = _b === void 0 ? object.id : _b, _c = _a[1], flags = _c === void 0 ? '0' : _c;
            if (chart) {
                chart.emptyInteractionList();
                chart.deleteObject(objectName, Number(flags));
            }
        };
        FDSActionXMLDriver.prototype._interpretRefresh = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (chart) {
                chart.emptyInteractionList();
                chart.invalidate();
            }
        };
        FDSActionXMLDriver.prototype._interpretClearAll = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (chart) {
                chart.emptyInteractionList();
                chart.clear();
            }
        };
        FDSActionXMLDriver.prototype._interpretAddObject = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var _a = this._retrieveValueXMLHelper(object, actionNode, propInfo, ['Name', 'ObjectType', 'Flags', 'Label']), objectName = _a[0], objectType = _a[1], label = _a[2], _b = _a[3], flags = _b === void 0 ? '0' : _b;
            if (!objectName || !objectType) {
                return;
            }
            var values$$1 = this._retrieveValueArrayHelper(object, actionNode, propInfo, 'Value', resolve);
            if (chart) {
                chart.emptyInteractionList();
                chart.addObject(objectName, Number(objectType), Number(flags), label, values$$1);
            }
        };
        FDSActionXMLDriver.prototype._interpretSetChild = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var parentName = this._retrieveValueXMLHelper(object, actionNode, propInfo, 'Parent');
            if (!parentName) {
                parentName = object.id;
            }
            var values$$1 = this._retrieveValueArrayHelper(object, actionNode, propInfo, 'Child', resolve);
            if (chart) {
                chart.emptyInteractionList();
                chart.setChildrenExternal(parentName, values$$1);
            }
        };
        FDSActionXMLDriver.prototype._interpretFireEvent = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var eventData = this._retrieveValueXMLHelper(object, actionNode, propInfo, 'EventData');
            if (!eventData) {
                return;
            }
            if (chart && eventData.length > 0) {
                chart.fireChartEvent('ActionEvent', this._point, eventData);
            }
        };
        FDSActionXMLDriver.prototype._interpretNavigate = function (chart, object, actionNode, pick$$1, propInfo, resolve) {
            if (!object) {
                return;
            }
            var url = this._retrieveValueXMLHelper(object, actionNode, propInfo, 'HRef');
            if (!url) {
                return;
            }
            if (chart && url.length > 0) {
                window.location.assign(url);
            }
        };
        return FDSActionXMLDriver;
    }());
    
    /**
     * Represents a 'set attribute' on a particular `FDSChartObject` instance.
     * @private
     */
    var Attribute = /** @class */ (function () {
        /**
         * Creates a new `Attribute` container for user and app set values.
         * @param id - The name of the attribute
         * @param type - The typeof the attribute. 'string'|'number'|'boolean'|'number[]' are valid
         * @param parentAttr - The name of the inherited attribute, or null if one is not defined
         * @param chartObject - The `FDSChartObject` the attribute is set on.
         * @param userVal? - Optionally set the user value on construction.
         * @param appVal? - Optionally set the user value on construction.
         * @constructor
         */
        function Attribute(id, type, parentAttr, chartObject, userVal, appVal) {
            if (type === void 0) { type = 'string'; }
            if (parentAttr === void 0) { parentAttr = null; }
            if (chartObject === void 0) { chartObject = null; }
            this.id = id;
            this._type = type;
            this._chartObject = chartObject;
            this._values = {
                user: userVal,
                app: appVal,
            };
        }
        /**
         * Gets the attribute value in order of precidence 'user'->'app'->undefined
         * @return the attribute's set value, or undefined if both 'user' and 'app' are unset
         */
        Attribute.prototype.get = function () {
            if (this._values.user !== undefined) {
                return this._values.user;
            }
            if (this._values.app !== undefined) {
                return this._values.app;
            }
            return undefined;
        };
        /**
         * Gets the level that the attribute is set at. Note, the return type is an enum `AttributeLevel` value rather than
         * the strings 'user'|'app'|def' This is done intentionally so that the result of `getLevel()` is comparable user >
         * app > default.
         * @return `AttributeLevel`
         */
        Attribute.prototype.getLevel = function () {
            if (this._values.user !== undefined) {
                return 2 /* USER */;
            }
            if (this._values.app !== undefined) {
                return 1 /* APP */;
            }
            return 0 /* DEF */;
        };
        /**
         * Gets the value of the attribute at a specific level only.
         * @param level - Which level to retrieve: 'user'|'app'.
         * @return the attribute value, or undefined if not set at the requested `level`
         */
        Attribute.prototype.getAt = function (level) {
            if (level === undefined) {
                return this.get();
            }
            return this._values[level];
        };
        /**
         * Sets the attribute's value at the level specified. 'value' coerced into the expected type of the attribute.
         * For example, 'false'->false if the target type is boolean.
         * @param level - 'user' or 'app' level.
         * @param value - The value to set.
         * @return true if the attribute was able to be set, false otherwise.
         */
        Attribute.prototype.setAt = function (level, value) {
            if (level !== 'user' && level !== 'app') {
                return false;
            }
            // JSON.stringify on arrays converts undefined to null and we have consumers that pull attr values from arrays.
            if (value === null) {
                value = undefined;
            }
            var invalid = false;
            // Only do this stuff if `value` isn't `undefined` because that is how
            // attributes are cleared.
            if (value !== undefined) {
                switch (this._type) {
                    case 'number[]':
                        if (_$1.isNumber(value)) {
                            invalid = isNaN(value);
                            value = [value];
                        }
                        else if (_$1.isString(value)) {
                            value = value.split(';');
                        }
                        if (_$1.isArray(value)) {
                            value = value.map(Number);
                            invalid = _$1.some(value, isNaN);
                        }
                        else {
                            invalid = true;
                        }
                        break;
                    case 'number':
                        if (value !== 'NaN' && value !== '') {
                            value = Number(value);
                            invalid = isNaN(value);
                        }
                        else {
                            invalid = true;
                        }
                        break;
                    case 'boolean':
                        // Handle boolean conversions
                        if (typeof value === 'string') {
                            value = value.toLowerCase();
                        }
                        if (value === 'true' || value === true || value === '1' || value === 1) {
                            value = true;
                        }
                        else if (value === 'false' || value === false || value === '0' || value === 0) {
                            value = false;
                        }
                        else {
                            invalid = true;
                        }
                        break;
                    case 'string[]':
                        // Convert json string arrays into arrays. This helps to / from xml serialization
                        if (_$1.isString(value)) {
                            if (value === '') {
                                value = [];
                            }
                            else {
                                var maybeArray = JSON.parse(value);
                                if (_$1.isArray(maybeArray)) {
                                    value = maybeArray;
                                }
                                else {
                                    invalid = true;
                                }
                            }
                        }
                        if (_$1.isArray(value)) {
                            invalid = _$1.some(value, function (v) { return !_$1.isString(v); });
                            value = value.map(String);
                        }
                        break;
                    case 'string':
                        if (typeof value !== 'string' && value !== null) {
                            value = value.toString();
                            if (ENABLE_DEBUG && this._chartObject.root.commonDebug) {
                                console.warn("Unexpected input format for '" + this.id + "'");
                            }
                        }
                        break;
                    default:
                        invalid = true;
                }
            }
            if (invalid) {
                if (ENABLE_DEBUG) {
                    console.error("Invalid type set for " + this.id);
                }
                return false;
            }
            if (this._chartObject && this._chartObject.root) {
                if (this._chartObject.root.isStateLoggingEnabled()) {
                    this._chartObject.root.stateLog.updateAttr(this._chartObject, this.id, level, value, this._values[level]);
                }
                if (this._chartObject.root.attributeUsageLog) {
                    this._chartObject.root.attributeUsageLog.log(this._chartObject, this.id, level, value, this._type);
                }
            }
            // Lastly, set the actual value.
            this._values[level] = value;
            return true;
        };
        return Attribute;
    }());
    /**
     * Represents a set of attribute values for a specific `FDSChartObject` instance.
     * Contains facilities for getting/setting attribute values and for walking the attribute inheritance chain.
     * For example, SeriesObject->SeriesStyle->ChartObject->ChartStyle.
     */
    var AttributeSet = /** @class */ (function () {
        function AttributeSet(parentObject, defaultMap) {
            /**
             * If this is set to true, the same attribute name will be used for attribute inheritance instead of
             * using the `parentAttr` alternate name. Generally, set to true for StyleSet objects, false otherwise.
             */
            this.inheritByIdOnly = false;
            this._values = {};
            this._dirty = false;
            this.defaultMap = defaultMap;
            this._parentObject = parentObject;
        }
        AttributeSet.prototype._getTypeString = function (value, typeConstructor) {
            if (_$1.isArray(value)) {
                if (typeConstructor === Number) {
                    return 'number[]';
                }
                else if (typeConstructor === String) {
                    return 'string[]';
                }
                else {
                    throw new Error('Invalid attribute type');
                }
            }
            else {
                return typeof value;
            }
        };
        AttributeSet.prototype.add = function (id, type, def, parentAttr) {
            // In theory, delegating to setAt is the correct thing because it does extra parameter validation in debug mode.
            // In practice, there are lot of places where our attribute inheritance needs to be revised, so we assert too
            // much atm. this.setAt(id, 'def', def, true, type, parentAttr);
            if (parentAttr === void 0) { parentAttr = null; }
            this.defaultMap.add(id, { value: def, parentAttr: parentAttr, type: this._getTypeString(def, type) });
        };
        /**
         * Add multiple attributes to the default map at once calling `AttributeSet::add` for each set of arguments passed
         * in.
         * @param args an array of function argument arrays to be passed to the `AttributeSet::add` method.
         */
        AttributeSet.prototype.addMultiple = function (args) {
            var _this = this;
            args.forEach(function (list) { return _this.add.apply(_this, list); });
        };
        AttributeSet.prototype.preserveCurrentDirtyState = function (callback) {
            var savedDirtyState = this._dirty;
            callback(this);
            this._dirty = savedDirtyState;
        };
        AttributeSet.prototype.setAt = function (id, level, value, type, parentAttr) {
            if (type === void 0) { type = String; }
            if (parentAttr === void 0) { parentAttr = null; }
            var setVal = false;
            if (level === 'def') {
                // TODO: attribute default setting should be more universally applied. add and setAt do different things.
                this.defaultMap.add(id, { value: value, parentAttr: parentAttr, type: this._getTypeString(value, type) });
                var root = this._parentObject.root;
                if (ENABLE_DEBUG && root.commonDebug && root !== this._parentObject && parentAttr != null) {
                    // if it has an override, check it matches the parent default (which should always be true)
                    var parVal = void 0;
                    if (typeof (parVal = root.attributeSet.getAt(parentAttr, 'def')) !== undefined) {
                        console.assert(value === parVal, parentAttr + " attribute on root has default value " + parVal + ", should be " + value + " to match " + id + " default on " + this._parentObject.constructor.selector + ".");
                    }
                    else {
                        console.warn("Attribute '" + parentAttr + "' is not defined on FC_CHART. Can not inherit " + this._parentObject.constructor.selector + " attribute '" + id + "'");
                    }
                }
                setVal = true;
            }
            else {
                // If this attribute doesnt exist yet it means it is currently defaulted
                // or it is being initialized
                if (this._values[id] === undefined) {
                    // if it is not being initialized and there is no entry in the defaultMap
                    // we want to bail out. Otherwise this would allow creating new attributes
                    // through the 'SetAttribute' API call, bad news
                    var dfltVal = void 0;
                    if ((dfltVal = this.defaultMap.lookup(id)) === undefined) {
                        return false;
                    }
                    else {
                        this._values[id] = new Attribute(id, dfltVal.type, dfltVal.parentAttr, this._parentObject);
                    }
                }
                setVal = this._values[id].setAt(level, value);
            }
            if (setVal) {
                this._dirty = true;
            }
            return setVal;
        };
        /**
         * Flags the current `AttributeSet` as dirty, signalling that cached attribute values may be stale.
         * @param dirty - if false, the dirty flag will be cleared.
         */
        AttributeSet.prototype.setDirty = function (dirty) {
            if (dirty === void 0) { dirty = true; }
            this._dirty = dirty;
        };
        /**
         * Returns whether or not attributes have changed since the last time the dirty flag was cleared.
         * @return true if dirty, false otherwise.
         */
        AttributeSet.prototype.isDirty = function () {
            return this._dirty;
        };
        /**
         * Gets the level that the attribute is set at. Note, the return type is an enum `AttributeLevel` value rather than
         * the strings 'user'|'app'|def' This is done intentionally so that the result of `getLevel()` is comparable user >
         * app > default.
         * @param id - The attribute name
         * @return `AttributeLevel`
         */
        AttributeSet.prototype.getLevel = function (id) {
            var attr = this._values[id];
            return (attr) ? attr.getLevel() : 0 /* DEF */;
        };
        AttributeSet.prototype._getImplementation = function (id, undefinedIfDefault) {
            var attributeValue = this._getValue(id);
            if (attributeValue !== undefined) {
                return attributeValue;
            }
            // If the attribute doesn't exist in the default map, we assume that the attribute does not exist.
            var defaultValue = this.defaultMap.lookup(id);
            if (defaultValue === undefined) {
                return undefined;
            }
            var isRootChart = this._parentObject === this._parentObject.root;
            if (!isRootChart) {
                attributeValue = this._getAttributeFromParents(id, defaultValue.parentAttr);
            }
            else {
                attributeValue = this._getAttributeFromRootChartInterleaved(id);
            }
            if (attributeValue === undefined && !undefinedIfDefault) {
                attributeValue = defaultValue.value;
            }
            return attributeValue;
        };
        AttributeSet.prototype._getValue = function (id) {
            var valueId = this._values[id];
            return valueId && valueId.get();
        };
        AttributeSet.prototype._getAttributeFromParents = function (id, parentAttributeId) {
            var attributeValue;
            var chartAttributeSet = this._parentObject.root.attributeSet;
            // First, we check the chart attribute set to see if the parent id has been set.
            if (chartAttributeSet) {
                attributeValue = chartAttributeSet._getValue(parentAttributeId);
                if (attributeValue !== undefined) {
                    return attributeValue;
                }
            }
            // Then, we check the style object to see if the id has been set.
            if (this.inheritByIdOnly && this.parentAttrSet) {
                attributeValue = this.parentAttrSet._getAttributeFromStyleChain(id);
                if (attributeValue !== undefined) {
                    return attributeValue;
                }
            }
            if (chartAttributeSet) {
                // Then, we check the chart style object to see if the parent id has been set.
                if (chartAttributeSet.inheritByIdOnly && chartAttributeSet.parentAttrSet) {
                    attributeValue = chartAttributeSet.parentAttrSet._getAttributeFromStyleChain(parentAttributeId);
                }
                // If our return value is still undefined, we will go through the rest of the attribute chain and search for
                // them on the chart and chart style.
                if (attributeValue === undefined) {
                    var defaultValue = chartAttributeSet.defaultMap.lookup(parentAttributeId);
                    if (defaultValue === undefined) {
                        return undefined;
                    }
                    attributeValue = chartAttributeSet._getAttributeFromRootChartInterleaved(defaultValue.parentAttr);
                }
            }
            return attributeValue;
        };
        AttributeSet.prototype._getAttributeFromStyleChain = function (id) {
            if (!this._parentObject.isStyleObject) {
                return undefined;
            }
            var currStyleAttributeSet = this;
            var attributeValue;
            // Traverse through a style object chain, e.g. a series style who's parent is another series style and so on,
            // and look for the attribute.
            while (currStyleAttributeSet && currStyleAttributeSet._parentObject.isStyleObject) {
                attributeValue = currStyleAttributeSet._getValue(id);
                if (attributeValue !== undefined) {
                    return attributeValue;
                }
                currStyleAttributeSet = currStyleAttributeSet.parentAttrSet;
            }
            return attributeValue;
        };
        // This function goes back and forth between the root chart and the root chart style's attribute set, looking for
        // set attributes in a given attribute's parent chain.
        AttributeSet.prototype._getAttributeFromRootChartInterleaved = function (id) {
            var chartAttributeSet = this._parentObject.root.attributeSet;
            if (!chartAttributeSet) {
                return undefined;
            }
            var currAttributeId = id;
            var currDefaultVal;
            var attributeValue;
            var chartHasStyleSet = chartAttributeSet.inheritByIdOnly && chartAttributeSet.parentAttrSet;
            // Until we find a set value, we traverse through the attribute's parent chain and
            // check whether or not a value is set on either the chart or the chart style.
            while (currAttributeId != null) {
                attributeValue = chartAttributeSet._getValue(currAttributeId);
                if (attributeValue !== undefined) {
                    return attributeValue;
                }
                if (chartHasStyleSet) {
                    attributeValue = chartAttributeSet.parentAttrSet._getAttributeFromStyleChain(currAttributeId);
                    if (attributeValue !== undefined) {
                        return attributeValue;
                    }
                }
                currDefaultVal = chartAttributeSet.defaultMap.lookup(currAttributeId);
                if (currDefaultVal === undefined) {
                    return undefined;
                }
                currAttributeId = currDefaultVal.parentAttr;
            }
            return attributeValue;
        };
        /**
         * Gets the current value of an attribute by traversing the attribute inheritance chain searching for a 'set' value.
         * If it is unable to find a set value, it will return the default value.
         * @param name - The name of the attribute to retrieve
         */
        AttributeSet.prototype.get = function (name) {
            return this._getImplementation(name, false);
        };
        AttributeSet.prototype.getWithFallback = function (name, fallback) {
            var result = this._getImplementation(name, true);
            if (result !== undefined) {
                return result;
            }
            return _$1.isFunction(fallback) ? fallback() : fallback;
        };
        /**
         * Gets the value of the attribute at a specific level only.
         * @param id - The name of the attribute
         * @param level - Which level to retrieve: 'user'|'app'.
         * @return the attribute value, or undefined if not set at the requested `level`
         */
        AttributeSet.prototype.getAt = function (id, level) {
            if (level === 'user' || level === 'app') {
                if (!(this._values[id] != null)) {
                    return undefined;
                }
                else {
                    return this._values[id].getAt(level);
                }
            }
            else if (level === 'def') {
                var dfltVal = this.defaultMap.lookup(id);
                if (dfltVal != null) {
                    return dfltVal.value;
                }
            }
            return undefined;
        };
        /**
         * Get whether or not the attribute has been set on this particular object.
         * @see `AttributeSet::isInheritedDefault` if you need to check for default throughout the entire inheritance chain.
         * @param id - the name of the attribute
         */
        AttributeSet.prototype.isDefault = function (id) {
            var attr;
            if (attr = this._values[id]) {
                return attr.get() == null;
            }
            return true;
        };
        /**
         * Get whether or not the attribute has been set at any level in the inheritance chain.
         * @see `AttributeSet::isDefault` if you only need to check for default on the current object.
         * @param id - the name of the attribute
         */
        AttributeSet.prototype.isInheritedDefault = function (id) {
            var ret = this.isDefault(id);
            if (ret && this.parentAttrSet !== undefined && this.parentAttrSet !== this) {
                if (!this.inheritByIdOnly) {
                    var dfltVal = this.defaultMap.lookup(id);
                    if (dfltVal !== undefined && dfltVal.parentAttr) {
                        ret = this.parentAttrSet.isInheritedDefault(dfltVal.parentAttr);
                    }
                }
                else {
                    ret = this.parentAttrSet.isInheritedDefault(id);
                }
            }
            return ret;
        };
        /**
         * Gets the FDSChartObject that this attribute set is associated with
         */
        AttributeSet.prototype.getParentObject = function () {
            return this._parentObject;
        };
        /**
         * Sets / Resets the parent attribute set. The general use-case here is when setting an attribute set to inherit
         * from a style object instead of the root `FDSChart` object.
         * @param parent - the new parent `AttributeSet`
         */
        AttributeSet.prototype.setParentAttrSet = function (parent) {
            this.parentAttrSet = parent;
        };
        /**
         * Clears the 'user' level attribute if it is set.
         * @param id - the name of the attribute
         */
        AttributeSet.prototype.resetAttribute = function (id) {
            var attr = this._values[id];
            if (attr == null) {
                return false;
            }
            attr.setAt('user', undefined);
            this._dirty = true;
            return true;
        };
        /**
         * returns an array of attribute names
         * @return {Array<string>}
         */
        AttributeSet.prototype.getList = function () {
            return this.defaultMap.getList();
        };
        /**
         * Returns an array containing all attributes set at the requested level in the form {name, value}
         * @param level The level to retrieve set parameters at.
         * @return {Array<{name, value}>}
         */
        AttributeSet.prototype.getValuesAtLevel = function (level) {
            var _this = this;
            return Object.keys(this._values)
                .map(function (key) { return _this._values[key]; })
                .filter(function (val) { return val.getAt(level) != null; })
                .map(function (val) { return ({
                name: val.id,
                value: val.getAt(level)
            }); });
        };
        /**
         * Returns a function wrapper around default attribute setting that binds prefix+attrName, and the optional parent
         * attribute name. The general purpose of this wrapper is to reduce code duplication at the call site:
         * `attrSet.setAt(prefix + 'Color', 'def', Colors.Black, true, Number, parentName + attrName)`
         * becomes:
         * `setDefault('Color', Colors.Black);
         * @param prefix? - If specified, the value of `prefix` will be prepended to the attribute name
         * @param parentName? - If specified along with prefix, the value of parentName will be used as the prefix for the
         *   interited attribute name.
         * @return a function object to be used for setting default values using the configured parameters {(attrName,
         *   value) => boolean}
         */
        AttributeSet.prototype.getDefaultSetter = function (prefix, parentName) {
            var _this = this;
            if (prefix && parentName) {
                return function (attrName, value) { return _this.setAt(prefix + attrName, 'def', value, value.constructor, parentName + attrName); };
            }
            else if (prefix && !parentName) {
                return function (attrName, value) { return _this.setAt(prefix + attrName, 'def', value, value.constructor); };
            }
            else if (!prefix && parentName) {
                return function (attrName, value) { return _this.setAt(attrName, 'def', value, value.constructor, parentName); };
            }
            else {
                return function (attrName, value, parentAttrName) { return _this.setAt(attrName, 'def', value, value.constructor, parentName); };
            }
        };
        return AttributeSet;
    }());
    
    /**
     * Encapsulates the default attribute values for a chart object type (FDSSeries, FDSPlot, etc)
     * `DefaultMap`'s are intended to be used statically across all chart instances on the page and
     * should be considered/treated immutable once finalized.
     */
    var DefaultMap = /** @class */ (function () {
        function DefaultMap() {
            this._initialized = false;
            this._values = {};
            this._initialized = false;
            this._values = {};
        }
        DefaultMap.prototype.isInitialized = function () {
            return this._initialized;
        };
        /**
         * gets the default value for an attribute.
         * @param id - The name of the attribute
         * @return the default value for the attribute
         */
        DefaultMap.prototype.lookup = function (id) {
            return this._values[id];
        };
        /**
         * Adds a new entry into the default map for an attribute.
         * When ENABLE_DEBUG is set, additional checks are performed to verify that the map hasn't been finalized,
         * and that we aren't setting the same attribute twice.
         * @param id
         * @param attr
         */
        DefaultMap.prototype.add = function (id, attr) {
            if (ENABLE_DEBUG) {
                if (this._initialized) {
                    throw Error('Default attribute map can not be manipulated once it has been initialized.');
                }
                if ((this._values[id] != null)) {
                    console.warn("Warning, Default value for Attribute '" + id + "' has been set twice.");
                }
            }
            this._values[id] = attr;
        };
        /**
         * Signals the start of `DefaultMap` initialization. If this function returns false,
         * the map has already been initialized and you should skip attribute creation.
         * @return Returns true if uninitialized, false otherwise.
         */
        DefaultMap.prototype.startInitialization = function () {
            return !this._initialized;
        };
        /**
         * Finalizes the `DefaultMap`, making it invalid / undefined behavior to add new defaults.
         */
        DefaultMap.prototype.finalizeInitialization = function () {
            this._initialized = true;
        };
        /**
         * Returns an array of attribute names.
         * @return {Array<string>}
         */
        DefaultMap.prototype.getList = function () {
            return Object.keys(this._values);
        };
        return DefaultMap;
    }());
    
    var MapFactory = /** @class */ (function () {
        function MapFactory() {
        }
        MapFactory.getDefMap = function (id) {
            var map$$1 = MapFactory._defaultMap[id];
            if (map$$1 == null) {
                map$$1 = MapFactory._defaultMap[id] = new DefaultMap();
            }
            return map$$1;
        };
        MapFactory.clearDefMap = function () {
            MapFactory._defaultMap = {};
        };
        MapFactory.addReference = function () {
            MapFactory._chartRefCount++;
            if (MapFactory._clearDefaultMapTimer !== undefined) {
                clearTimeout(MapFactory._clearDefaultMapTimer);
            }
        };
        MapFactory.releaseReference = function () {
            MapFactory._chartRefCount--;
            if (MapFactory._chartRefCount < 0) {
                console.warn('Reference count is less than 0 - something went wrong');
            }
            if (MapFactory._chartRefCount === 0) {
                MapFactory._clearDefaultMapTimer = window.setTimeout(function () {
                    MapFactory.clearDefMap();
                    MapFactory._clearDefaultMapTimer = undefined;
                }, 10000);
            }
        };
        MapFactory._defaultMap = {};
        MapFactory._chartRefCount = 0;
        return MapFactory;
    }());
    
    var FDSChartObject = /** @class */ (function () {
        function FDSChartObject(root, id, type, initArg) {
            this.root = root;
            this.id = id;
            this.type = type;
            this.isStyleObject = this.isDefaultStyleObject(this.id);
            // keep track of the objects that inherit from you
            this.styleChildren = {};
            this._defMapID = ''; // gets overridden in most derived class' _init method
            this._init(initArg);
        }
        // Array iterators work on array-like objects, too, if you call them
        // indirectly. Pretty neat.
        FDSChartObject._getChildElementsByTagName = function (element, tagName) {
            return Array.prototype.filter.call((element.getElementsByTagName(tagName)), function (childElement) { return childElement.parentNode === element; });
        };
        FDSChartObject.prototype._init = function (initArg) {
            this._defaultMap = MapFactory.getDefMap(this._defMapID);
            this.children = {};
            this.properties = new PropertySet(this);
            this.unparsedProperties = {}; // for writing to xml
            this.parsedProperties = {}; // for caching the parsed trees
            this.usedProperties = {};
            this.attributeSet = new AttributeSet(this, this._defaultMap);
            this.dynamicProperties = {
                'FDSLabel': true,
                'FDSObjectName': true
            };
            // `@isStyleObject` may have been set in the constructor if the object is
            // constructed with a default style object ID.
            this.isStyleObject = this.isStyleObject || false;
            this._isSelected = false;
            this.interactivityMode = -1 /* ALL */;
            this.interactivityStatus = 0 /* DISABLED */;
            if (this.parent === undefined) {
                this.parent = null;
            }
            this.labelText = this.id;
            this.compiledLabelText = this.properties.compilePropertyString(this.labelText);
            this.needsUpdate = false;
            this.attributeSet.setParentAttrSet(this.root.attributeSet);
        };
        FDSChartObject.prototype.getPrefix = function () {
            return '';
        };
        FDSChartObject.prototype.clearRenderCache = function () {
        };
        FDSChartObject.prototype._applyTheme = function () {
            if (this.isStyleObject) {
                return false;
            }
            var theme = this.root.getTheme();
            if (theme == null || (theme <= 0 /* NONE */ || theme > 2 /* CARBON */)) {
                return false;
            }
            var oldTheme = this._chartTheme;
            this._chartTheme = theme;
            return theme !== oldTheme;
        };
        FDSChartObject.prototype.processEventHandling = function (event, pick$$1, point) {
        }; // intentionally empty
        FDSChartObject.prototype.syncMembers = function () {
            // TODO: replace with virtual dispatch
            this._setLabelText();
            this.updateContextMenu();
            this.syncStyleSetMembers();
        };
        FDSChartObject.prototype._getMenuChildren = function () {
            return _$1.values(this.children);
        };
        FDSChartObject.prototype.updateContextMenu = function () {
            var oldContextMenuString = this.contextMenuString;
            var oldContextMenuXML = this.contextMenuXML;
            var getMenuAttr = function (attributes, attrName) {
                var value = attributes.get(attrName);
                return { value: value, isDefault: !value || attributes.isInheritedDefault(attrName) };
            };
            if (this.attributeSet.isDirty()) {
                this.contextMenuString = getMenuAttr(this.attributeSet, 'Menu');
                this.contextMenuXML = getMenuAttr(this.attributeSet, 'MenuXML');
            }
        };
        FDSChartObject.prototype.syncStyleSetMembers = function () {
            this._applyStyleObjects();
            for (var id in this.styleChildren) {
                // when i update my attributes, my style children should too
                var child = this.root.getTypedObject(id, isChartObject);
                if (child != null) {
                    child.attributeSet.setDirty();
                }
            }
        };
        FDSChartObject.prototype._setAttributes = function () {
            // We actually care about FDSChartStyle here because we are setting attributes.
            var isRoot = isRootChart(this) || (this.getStyleObjectName() === 'FC_CHART_STYLE');
            // Axes have their own Label attribute of type `Boolean`, so we
            // special-case this in accordance with the PC implementation.
            this._setLabelAttribute();
            this.attributeSet.add('Style', String, this.getStyleObjectName());
            // We only define Menu at the root level, empty values for child objects will inherit up a level until reaching
            // the chart.
            this.attributeSet.add('Menu', String, (isRoot ? GetDefaultMenuString(false, false) : ''));
            this.attributeSet.add('MenuXML', String, '');
            var defTooltipText = this._getDefaultTooltipText();
            this.attributeSet.add('TooltipText', String, defTooltipText);
            this.attributeSet.add('TooltipAltText', String, '');
            this.attributeSet.add('TooltipCenterText', String, '');
        };
        FDSChartObject.prototype._setLabelAttribute = function () {
            this.attributeSet.add('Label', String, '');
        };
        FDSChartObject.prototype._setLabelText = function () {
            var isLabelTextDefault = this.attributeSet.isInheritedDefault('Label');
            if (isLabelTextDefault) {
                this.labelText = this.id;
            }
            else {
                this.labelText = this.attributeSet.get('Label');
            }
            if (this.labelText != null) {
                this.compiledLabelText = this.properties.compilePropertyString(this.labelText);
            }
        };
        FDSChartObject.prototype._getDefaultTooltipText = function () {
            return '';
        };
        FDSChartObject.prototype._setDynamicProperties = function (properties) {
            _$1.assign(this.dynamicProperties, properties);
        };
        FDSChartObject.prototype._handleAttributesFromElement = function (element) {
            var appAttributes = FDSChartObject._getChildElementsByTagName(element, 'FDSAppAttributes');
            for (var _i = 0, appAttributes_1 = appAttributes; _i < appAttributes_1.length; _i++) {
                var appAttr = appAttributes_1[_i];
                this._parseAttributes(appAttr, 'app');
            }
            var userAttributes = FDSChartObject._getChildElementsByTagName(element, 'FDSAttributes');
            for (var _a = 0, userAttributes_1 = userAttributes; _a < userAttributes_1.length; _a++) {
                var userAttr = userAttributes_1[_a];
                this._parseAttributes(userAttr, 'user');
            }
        };
        FDSChartObject.prototype._getRedirectedAttrSet = function (key) {
            return {
                attrSet: this.attributeSet,
                attrKey: key
            };
        };
        FDSChartObject.prototype._onSetAttribute = function (key, level, value) { };
        FDSChartObject.prototype._setAttributeRedirected = function (key, level, value) {
            var _a = this._getRedirectedAttrSet(key), attrSet = _a.attrSet, attrKey = _a.attrKey;
            if (attrSet) {
                attrSet.getParentObject()._onSetAttribute(key, level, value);
                return attrSet.setAt(attrKey, level, value);
            }
            else {
                return false;
            }
        };
        FDSChartObject.prototype._getAttributeRedirected = function (key, level) {
            var _a = this._getRedirectedAttrSet(key), attrSet = _a.attrSet, attrKey = _a.attrKey;
            if (attrSet) {
                if (level) {
                    return attrSet.getAt(attrKey, level);
                }
                else {
                    return attrSet.get(attrKey);
                }
            }
            else {
                return undefined;
            }
        };
        FDSChartObject.prototype._isDefaultRedirected = function (key) {
            var _a = this._getRedirectedAttrSet(key), attrSet = _a.attrSet, attrKey = _a.attrKey;
            if (attrSet) {
                return attrSet.isDefault(attrKey);
            }
            else {
                return undefined;
            }
        };
        FDSChartObject.prototype._parseAttributes = function (attrElement, level) {
            var attrs = attrElement.getElementsByTagName('Attr');
            if (!attrs) {
                return;
            }
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var attrContent = attr.textContent;
                if (attrContent == null) {
                    continue;
                }
                var eqPosition = attrContent.indexOf('=');
                if (eqPosition === -1) {
                    return;
                }
                var attrKey = (attrContent.slice(0, eqPosition)).trim();
                var attrValue = (attrContent.slice(eqPosition + 1)).trim();
                if (this._getAttributeRedirected(attrKey) === undefined) {
                    if (ENABLE_DEBUG && this.root.commonDebug) {
                        console.warn("Unrecognized attribute " + attrKey + " on object " + this.id);
                    }
                    if (this.root && this.root.attributeUsageLog) {
                        this.root.attributeUsageLog.logUnrecognized(this, attrKey);
                    }
                }
                this._setAttributeRedirected(attrKey, level, attrValue);
            }
        };
        // `_handlePropertiesFromElement` initializes the FDSProperties internals
        // based on the presence of `<Property>` tags in `element`
        FDSChartObject.prototype._handlePropertiesFromElement = function (element) {
            var propertyTags = FDSChartObject._getChildElementsByTagName(element, 'FDSProperties');
            if (propertyTags.length !== 0) {
                for (var _i = 0, propertyTags_1 = propertyTags; _i < propertyTags_1.length; _i++) {
                    var propertyTag = propertyTags_1[_i];
                    this._parsePropertyTags(propertyTag);
                }
            }
        };
        // Parse the `<Property>` tag elements inside the parent `<FDSProperties>`
        // tag and add them to our own internal property key-value store
        FDSChartObject.prototype._parsePropertyTags = function (element) {
            var properties = element.getElementsByTagName('Property');
            if (properties.length === 0) {
                return;
            }
            // There's no real need for an abstraction around properties like we have
            // in `AttributeSet` for attributes, yet, so we just have a `properties`
            // member object with the values we want.
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i];
                var propertyContent = property.textContent;
                if (propertyContent == null) {
                    continue;
                }
                var eqPosition = propertyContent.indexOf('=');
                if (eqPosition === -1) {
                    continue;
                }
                var propertyKey = (propertyContent.slice(0, eqPosition)).trim();
                var tempPropValue = (propertyContent.slice(eqPosition + 1)).trim();
                this.setProperty(propertyKey, tempPropValue);
            }
        };
        FDSChartObject.prototype.setProperty = function (key, value) {
            var _this = this;
            value = String(value);
            this.unparsedProperties[key] = value;
            this.parsedProperties[key] = undefined;
            return this.properties.addProperty(key, function (valueContext, args) {
                if (_this.root.propertyUsageManager.isTrackingProperties()) {
                    _this.usedProperties[key] = true;
                }
                var parsedPropMap = _this.parsedProperties[key];
                if (!parsedPropMap) {
                    parsedPropMap = _this.parsedProperties[key] = {};
                }
                var object = valueContext.object;
                var objId = object.id;
                var parsedProp = parsedPropMap[objId];
                if (!parsedProp) {
                    parsedProp = parsedPropMap[objId] = object.properties.compilePropertyString(_this.unparsedProperties[key]);
                }
                return parsedProp;
            });
        };
        FDSChartObject.prototype.deleteProperty = function (key) {
            delete this.unparsedProperties[key];
            delete this.parsedProperties[key];
            var ret = this.properties.removeProperty(key);
            if (ret) {
                this.attributeSet.setDirty();
            }
            return ret;
        };
        FDSChartObject.prototype.getUnresolvedProperty = function (key) {
            return this.unparsedProperties[key];
        };
        FDSChartObject.prototype.getResolvedProperty = function (key, valueContextOptions) {
            var propertyArgs = PropertyArgs.Empty;
            // TODO this.parsedProperties[key]???
            var prop = this.properties.getProperty(key, propertyArgs);
            if (_$1.isFunction(prop)) {
                var valueContext = this.properties.getValueContextFromOptions(valueContextOptions);
                var result = prop(valueContext, propertyArgs);
                if (result instanceof CompiledPropertyString) {
                    return result.fromValue(valueContext);
                }
                else {
                    return result.toString();
                }
            }
            return prop;
        };
        FDSChartObject.prototype.resetUsedProperties = function () {
            this.usedProperties = {};
            for (var key in this.children) {
                var object = this.children[key];
                if (object.isStyleObject) {
                    continue;
                }
                object.resetUsedProperties();
            }
        };
        FDSChartObject.prototype.getPropertyUsage = function (usedPropertiesMap) {
            if (Object.keys(this.usedProperties).length !== 0) {
                usedPropertiesMap[this.id] = Object.keys(this.usedProperties);
            }
            for (var key in this.children) {
                var object = this.children[key];
                object.getPropertyUsage(usedPropertiesMap);
            }
        };
        // This method creates an object from its related element in the XML
        // DOM that we parse at creation
        FDSChartObject.prototype.initFromElement = function (element) {
            this._handlePropertiesFromElement(element);
            this._handleAttributesFromElement(element);
        };
        FDSChartObject.prototype.clearChildren = function (children) {
            return [true, ''];
        };
        FDSChartObject.prototype.setChildren = function (children) {
            // overriden by derived classes
            return [false, 'not implemented'];
        };
        FDSChartObject.prototype.addChildren = function () {
            // overriden by derived classes
        };
        FDSChartObject.prototype.processChildren = function () {
            // overriden by derived classes
        };
        FDSChartObject.prototype.addChild = function (child) {
            if (!child || !child.id || child === this || child.hasChild(this)) {
                return false;
            }
            var objlist;
            this.children[child.id] = child;
            if (this.objects) {
                objlist = this.objects;
            }
            else {
                objlist = this.root.objects;
            }
            if (objlist) {
                objlist[child.id] = child;
            }
            else {
                return false;
            }
            // Set the child's `attributeSet` parent to `this` to allow for attribute
            // parenting
            if (child.attributeSet != null) {
                child.properties.setParentPropertySet(this.properties);
            }
            child.parent = this;
            return true;
        };
        FDSChartObject.prototype.hasChild = function (child) {
            if (!this.children) {
                return false;
            }
            return this.children[child.id] != null;
        };
        FDSChartObject.prototype.getChild = function (childId) {
            if (childId === 'FC_CHART') {
                return this.root;
            }
            else {
                return this.children[childId];
            }
        };
        FDSChartObject.prototype.getChildList = function () {
            return {};
        };
        FDSChartObject.prototype.getDescendentOfClassList = function (type) {
            var ret = [];
            if (this.root != null) {
                var childList = this.getChildList();
                for (var id in childList) {
                    var child = childList[id];
                    if (child instanceof type) {
                        ret.push(child);
                    }
                    ret = ret.concat(child.getDescendentOfClassList(type));
                }
            }
            return ret;
        };
        FDSChartObject.prototype.removeChild = function (child) {
            if (this.children[child.id] === undefined) {
                return false;
            }
            child.parent = null;
            return delete this.children[child.id];
        };
        FDSChartObject.prototype._propFDSLabel = function () {
            return this.compiledLabelText;
        };
        FDSChartObject.prototype._propFDSObjectName = function () {
            return this.id;
        };
        FDSChartObject.prototype.isDefaultStyleObject = function (id) {
            // We're not checking object types for historical reasons - FDSChart relied on object ids for style sets instead
            // of a different type (so it used id:'FC_Plot', type: 'FDSPlot' as the plot style set). At some point (maybe
            // with some usage logging) we should revisit this and make sure the type is correct.
            switch (id) {
                case 'FC_PLOT':
                case 'FC_PLOT_X':
                case 'FC_PLOT_Y':
                case 'FC_PLOT_Y2':
                case 'FC_PLOT_Y3':
                case 'FC_PLOT_Y4':
                case 'FC_PLOT_Legend':
                case 'FC_SERIES':
                case 'FC_ANNOTATION':
                case 'FC_LAYER':
                case 'FC_DATA':
                    // case 'FC_CHART_STYLE': we don't include FC_CHART_STYLE in this list because that would generate
                    // <FDSChart> tags in the xml which is invalid.
                    return true;
                default:
                    return false;
            }
        };
        // Should be overriden
        FDSChartObject.prototype.getStyleObjectName = function () {
            return 'FC_NULL';
        };
        // Should be overriden
        FDSChartObject.prototype.getObjectTypeName = function () {
            return 'FDSChartObject';
        };
        FDSChartObject.prototype.getRoot = function () {
            return this.root;
        };
        // dumb helper function to check if a style object is valid for this object
        FDSChartObject.prototype._isValidStyleObject = function (obj) {
            // the style object has to be the same type as us, unless it's the root chart
            if (isRootChart(this)) {
                if (!(obj.getStyleObjectName() === 'FC_CHART_STYLE')) {
                    return false;
                }
            }
            else if (!(obj instanceof this.constructor)) {
                return false;
            }
            // Now check that none of the attribute sets in the object's parent chain are me
            // this prevents cycles
            var set = obj.attributeSet;
            while (set !== set.parentAttrSet) {
                if (set === this.root.attributeSet) {
                    return true;
                }
                // loop until we hit the top parent
                if (set === this.attributeSet) {
                    return false;
                }
                set = set.parentAttrSet;
            }
            return true;
        };
        FDSChartObject.prototype._applyStyleObjects = function () {
            // get style object from attribute, or get default style object
            var styleObject;
            if (!this.attributeSet.isDefault('Style')) {
                styleObject = this.root.getObject(this.attributeSet.get('Style'));
            }
            // First allow default style overrides
            if (!styleObject || !this._isValidStyleObject(styleObject)) {
                styleObject = this.root.getObject(this.getStyleObjectName());
            }
            // check again
            if (!styleObject || !this._isValidStyleObject(styleObject)) {
                this.attributeSet.setParentAttrSet(this.root.attributeSet);
                this.attributeSet.inheritByIdOnly = false;
                this._styleObject = undefined;
            }
            else {
                // Remove previous style object mapping.
                if (this._styleObject) {
                    delete this._styleObject.styleChildren[this.id];
                }
                styleObject.styleChildren[this.id] = true;
                this.attributeSet.setParentAttrSet(styleObject.attributeSet);
                this.attributeSet.inheritByIdOnly = true;
                this._styleObject = styleObject;
            }
            return this._styleObject;
        };
        // function to serialize an object
        // @return [String] the xml string describing this object
        FDSChartObject.prototype._serializeObject = function (objName, level, styleOverrideId) {
            if (objName === void 0) { objName = 'Object'; }
            if (level === void 0) { level = 0 /* GENERATE_FULL */; }
            var str = '';
            if (level === 0 /* GENERATE_FULL */) {
                // use a handful of functions so children can override part but not all if necessary
                str += this._serializeProperties();
                str += this._serializeAttributes(level, styleOverrideId);
                str += this._serializeData();
                str += this._serializeChildren();
            }
            else {
                str += this._serializeAttributes(level);
            }
            if (str === '') {
                return '';
            }
            if (this.isStyleObject && (!this.isDefaultStyleObject(this.id))) {
                objName += 'Style';
            }
            return "<FDS" + objName + " ID = '" + cleanString(this.id) + "'>" + str + "</FDS" + objName + ">";
        };
        FDSChartObject.prototype._getAttributesForSerialization = function (genApp, genUser, appAttrs, userAttrs) {
            var _this = this;
            var prefix = this.getPrefix();
            var genAttrs = function (level, result) {
                for (var _i = 0, _a = _this.attributeSet.getValuesAtLevel(level); _i < _a.length; _i++) {
                    var _b = _a[_i], name_1 = _b.name, value = _b.value;
                    result.push({ name: prefix + name_1, value: value });
                }
            };
            if (genApp) {
                genAttrs('app', appAttrs);
            }
            if (genUser) {
                genAttrs('user', userAttrs);
            }
        };
        FDSChartObject.prototype._serializeAttributes = function (level, styleOverride) {
            if (level === void 0) { level = 0 /* GENERATE_FULL */; }
            var str = '';
            var genApp = level === 0 /* GENERATE_FULL */ || level === 1;
            var genUser = level === 0 /* GENERATE_FULL */ || level === 2;
            var appAttrs = [];
            var userAttrs = [];
            this._getAttributesForSerialization(genApp, genUser, appAttrs, userAttrs);
            if (styleOverride != null) {
                appAttrs.push({ name: 'Style', value: styleOverride });
            }
            var serializeArray = function (arr) {
                if (arr.length === 0) {
                    return '';
                }
                else {
                    // TODO: Ugh... would be nice if number[] and string[] both serialized with JSON.stringify
                    if (_$1.isNumber(arr[0])) {
                        return arr.join(';');
                    }
                    else {
                        return JSON.stringify(arr);
                    }
                }
            };
            var toSafeString = function (val) {
                var stringVal = _$1.isArray(val) ? serializeArray(val) : val;
                return cleanString(stringVal);
            };
            var serializeImpl = function (tag, attrs) {
                if (attrs.length > 0) {
                    var attrString = attrs.map(function (attr) { return "<Attr>" + cleanString(attr.name) + " = " + toSafeString(attr.value) + "</Attr>"; })
                        .join('');
                    str += "<" + tag + ">" + attrString + "</" + tag + ">";
                }
            };
            serializeImpl('FDSAppAttributes', appAttrs);
            serializeImpl('FDSAttributes', userAttrs);
            return str;
        };
        FDSChartObject.prototype._serializeProperties = function () {
            if (Object.keys(this.unparsedProperties).length === 0) {
                return '';
            }
            var str = '<FDSProperties>';
            for (var key in this.unparsedProperties) {
                var value = this.unparsedProperties[key];
                str += "<Property>" + cleanString(key) + " = " + cleanString(value) + "</Property>";
            }
            str += '</FDSProperties>';
            return str;
        };
        FDSChartObject.prototype.serialize = function (level) {
        };
        FDSChartObject.prototype._serializeChildren = function () {
            var str = '';
            for (var id in this.children) {
                str += "<ChildId>" + cleanString(id) + "</ChildId>";
            }
            if (str === '') {
                return str;
            }
            return "<FDSChildren>" + str + "</FDSChildren>";
        };
        FDSChartObject.prototype._serializeData = function () {
            // can be overridden by children to add other stuff if necessary
            return '';
        };
        FDSChartObject.prototype._validateReservedTypeName = function (name, type) {
            var typeForName = this._getReservedType(name);
            if (typeForName !== -1 /* FC_NULL */) {
                // Fail out if the object already exists
                if (this.root.getObject(name) != null) {
                    return false;
                }
                switch (typeForName) {
                    case 11 /* FC_SERIES_STYLE */:
                        return _$1.includes([11 /* FC_SERIES_STYLE */, 2 /* FC_SERIES */], type);
                    case 13 /* FC_PLOT_STYLE */:
                        return _$1.includes([13 /* FC_PLOT_STYLE */, 4 /* FC_PLOT */], type);
                    case 10 /* FC_DATA_STYLE */:
                        return _$1.includes([10 /* FC_DATA_STYLE */, 1 /* FC_DATA */], type);
                    case 16 /* FC_AXIS_STYLE */:
                        return _$1.includes([16 /* FC_AXIS_STYLE */, 15 /* FC_AXIS */], type);
                    case 17 /* FC_CHART_STYLE */:
                        return _$1.includes([17 /* FC_CHART_STYLE */, 7 /* FC_ROOT */], type);
                    default:
                        return false;
                }
            }
            return true;
        };
        FDSChartObject.prototype._getReservedType = function (name) {
            if (name === null) {
                return 7 /* FC_ROOT */;
            }
            var objType = -1;
            if (name === '') {
                objType = 7 /* FC_ROOT */;
            }
            else if (name === 'FDSChart') {
                objType = 7 /* FC_ROOT */;
            }
            else if (name === 'Canvas') {
                objType = 7 /* FC_ROOT */;
            }
            else if (name === 'FC_PLOT') {
                objType = 13 /* FC_PLOT_STYLE */;
            }
            else if (name === 'FC_SERIES') {
                objType = 11 /* FC_SERIES_STYLE */;
            }
            else if (name === 'FC_ANNOTATION') {
                objType = 11 /* FC_SERIES_STYLE */;
            }
            else if (name === 'FC_DATA') {
                objType = 10 /* FC_DATA_STYLE */;
            }
            else if (name === 'FC_AXIS') {
                objType = 16 /* FC_AXIS_STYLE */;
            }
            else if (name === 'FC_CHART_STYLE') {
                objType = 17 /* FC_CHART_STYLE */;
            }
            return objType;
        };
        FDSChartObject.prototype.isReservedAxisType = function (name) {
            var re = /^FC_[\w]+_AXIS$/;
            return name.match(re);
        };
        FDSChartObject.prototype.clear = function () {
            this.removeChildren();
            this.notifyParents();
        };
        FDSChartObject.prototype.removeChildren = function () {
            for (var id in this.children) {
                var child = this.children[id];
                if ((child.parent != null) && child.parent === this) {
                    child.parent = null;
                }
            }
            this.children = {};
        };
        FDSChartObject.prototype.notifyParents = function (flags) {
            if (flags === void 0) { flags = 0 /* REMOVE */; }
            if (this.parent != null) {
                this.parent.onNotify(this, flags);
            }
        };
        FDSChartObject.prototype.onNotify = function (child, flags) {
            if (flags === void 0) { flags = 0 /* REMOVE */; }
            // to be overriden by children
        };
        FDSChartObject.prototype.resetAttributeInheritance = function () {
            this.attributeSet.setParentAttrSet(this.root.attributeSet);
        };
        FDSChartObject.prototype.setNeedUpdate = function (needsUpdate) {
            this.needsUpdate = needsUpdate;
        };
        FDSChartObject.prototype.adjust = function () {
        };
        FDSChartObject.prototype.objectAction = function (action, flags, args) {
            var _this = this;
            var handled = true;
            var ret;
            var errString = '';
            var getMenu = function () {
                return _this.getRoot().contextMenu;
            };
            switch (action) {
                case 'PrependAppMenu':
                    _a = getMenu().objectPrepend(args, this.id), ret = _a[0], errString = _a[1];
                    break;
                case 'SetAppMenu':
                    _b = getMenu().objectSet(args, this.id), ret = _b[0], errString = _b[1];
                    break;
                case 'AppendAppMenu':
                    _c = getMenu().objectAppend(args, this.id), ret = _c[0], errString = _c[1];
                    break;
                case 'ClearAppMenu':
                    _d = getMenu().objectClear(args, this.id), ret = _d[0], errString = _d[1];
                    break;
                case 'GetAppMenu':
                    _e = getMenu().objectGet(args, this.id), ret = _e[0], errString = _e[1];
                    break;
                case 'ExecuteHTTPLink':
                case 'ExecuteLink':
                    if (args.length >= 1) {
                        window.open(args[0]);
                    }
                    break;
                case 'ExecuteFDSUPLink':
                    if (args.length >= 1) {
                        location.href = args[0];
                    }
                    break;
                case 'GetInternalProperty':
                    ret = this.getResolvedProperty(args);
                    handled = true;
                    break;
                case 'ResolveString':
                    var pfs = this.properties.compilePropertyString(args[0]);
                    ret = pfs.fromValue();
                    handled = true;
                    break;
                case 'GetAttributeList':
                    ret = this.attributeSet.getList();
                    handled = true;
                    break;
                case 'GetPropertyList':
                    ret = this.properties.getList();
                    handled = true;
                    break;
                case 'UnsafeChartObject':
                    ret = this;
                    handled = true;
                    break;
                case 'ParseConditionalFormat':
                    var parser = new FormatParser();
                    ret = parser.parseConditionalFormat(args);
                    handled = true;
                    break;
                default:
                    handled = false;
            }
            return [handled, ret, errString];
            var _a, _b, _c, _d, _e;
        };
        FDSChartObject.prototype.areAnyChildObjectsOfClassDirty = function (type) {
            for (var id in this.children) {
                var child = this.children[id];
                if (child instanceof type && child.attributeSet.isDirty()) {
                    return true;
                }
            }
            return false;
        };
        FDSChartObject.prototype.hasChildren = function () {
            return Object.keys(this.children).length > 0;
        };
        FDSChartObject.prototype.getInteractivityMode = function () {
            return this.interactivityMode;
        };
        FDSChartObject.prototype.getInteractivityStatus = function () {
            return this.interactivityStatus;
        };
        FDSChartObject.prototype.isSelectable = function () {
            var rootSelectable = (this.root.getInteractivityMode() & 1 /* SELECTABLE */) !== 0;
            var thisSelectable = (this.interactivityMode & 1 /* SELECTABLE */) !== 0;
            return rootSelectable && thisSelectable && !this._isSelected &&
                this.root.isPermittedSelectableObject(this.getInteractivityObjectType());
        };
        FDSChartObject.prototype.setSelected = function (state) {
            if (state === void 0) { state = true; }
            this._isSelected = state;
        };
        FDSChartObject.prototype.isSelected = function () {
            if (this.root && this.root.getInteractivityMode() === 0 /* NONE */) {
                return false;
            }
            return this._isSelected;
        };
        FDSChartObject.prototype.isInteractive = function (mode) {
            if (mode != null) {
                return (this.interactivityMode & mode) !== 0;
            }
            else {
                var isInteractiveModeSet = (this.interactivityMode &
                    (2 /* DRAGGABLE */ | 4 /* RESIZABLE */ |
                        8 /* TEXTEDITABLE */)) !== 0;
                return isInteractiveModeSet && (this.isSelected() || this.isSelectable());
            }
        };
        FDSChartObject.prototype.setInteractivityMode = function (mode) {
            return this.interactivityMode = mode;
        };
        FDSChartObject.prototype.getInteractivityObjectType = function () {
            return 0 /* NONE */;
        };
        FDSChartObject.prototype.interact = function (point, event, message) {
            return false;
        };
        FDSChartObject.selector = 'FDSChartObject';
        return FDSChartObject;
    }());
    
    var ApiLogType;
    (function (ApiLogType) {
        ApiLogType[ApiLogType["Standard"] = 0] = "Standard";
        ApiLogType[ApiLogType["ResizeHeight"] = 1] = "ResizeHeight";
        ApiLogType[ApiLogType["ResizeWidth"] = 2] = "ResizeWidth";
        ApiLogType[ApiLogType["ResizeBoth"] = 3] = "ResizeBoth";
        ApiLogType[ApiLogType["InitializeStoredObjs"] = 4] = "InitializeStoredObjs";
        ApiLogType[ApiLogType["LookupChartObjFunction"] = 5] = "LookupChartObjFunction";
        ApiLogType[ApiLogType["ChartConstructor"] = 6] = "ChartConstructor";
    })(ApiLogType || (ApiLogType = {}));
    /**
     * @description This is used to indicate places where (because we have to) we have code stored as strings. Once
     * we stringify (because we stringify the arguments to the methods), we need to remove the quotes around the code
     * that needs to be executed as code and not stored as string.
     * @type {string}
     */
    var stringifiedCodeSignal = '@@';
    /**
     * @description Functions that don't help with reproducing issues and might be noisy, so we can skip them.
     */
    var _functionsToSkip = ['getObjectById', 'getData', 'getClientRect'];
    var interactionLogInProgress = false;
    function FDSChartObjectWrapperLogDecorator(constructor) {
        if (!_isApiLoggingEnabled()) {
            return;
        }
        _addLoggingToPrototypeMethods(constructor);
        var handler = {
            /**
             * @description We need this so calls to static members pass through, since those aren't defined on the
             * prototype.
             */
            get: function (target, name) {
                return target[name];
            },
            /**
             * @description Intercepts the constructor so we can log calls to FDSChartObjectWrapper constructors
             */
            construct: _logWrapperForConstructor
        };
        return new Proxy(constructor, handler);
    }
    function _isApiLoggingEnabled() {
        return !isHeadlessMode && (window.location.href.indexOf('fdschartjs-interaction-logging=true') !== -1 ||
            window['FDSChartJSInteractionLogging']) && window['Proxy'];
    }
    function _addLoggingToPrototypeMethods(constructor) {
        _$1.each(constructor.prototype, function (protoFunction, protoFunctionName) {
            if (_$1.isFunction(protoFunction) && !_$1.includes(_functionsToSkip, protoFunctionName)) {
                constructor.prototype[protoFunctionName] = _wrapFunctionInLogger(protoFunctionName, protoFunction);
            }
        });
    }
    function _wrapFunctionInLogger(protoFunctionName, protoFunction) {
        return function () {
            var didSetLogInProgress = false;
            if (!interactionLogInProgress) {
                didSetLogInProgress = true;
                interactionLogInProgress = true;
                var stringifiedArgs = _getArgsAsString(arguments);
                var logType = ApiLogType.Standard;
                if (protoFunctionName === 'triggerResize') {
                    var chartDiv = (this.chart.containingElement instanceof jQuery)
                        ? this.chart.containingElement[0]
                        : this.chart.containingElement;
                    var triggerResizeLogs = getLogsForResizingChart(this, chartDiv);
                    Inhouse.interactionLogs = Inhouse.interactionLogs.concat(triggerResizeLogs);
                }
                // We need to use storedObjs[<id>] for the cases where the object is created, but not yet added to
                // the chart. We fall back to getObjectById in cases where we're starting from a loadJSON and
                // storedObjs[<id>] hasn't been populated.
                var functionCallOnChartObject = "getChartObj('" + this.id + "')." + protoFunctionName + "(" + stringifiedArgs + ");";
                Inhouse.interactionLogs.push({
                    code: functionCallOnChartObject,
                    type: logType
                });
            }
            try {
                return protoFunction.apply(this, arguments);
            }
            finally {
                if (didSetLogInProgress) {
                    interactionLogInProgress = false;
                }
            }
        };
    }
    var constructorNameToPublicConstructor = {
        'FDSSeriesWrapper': 'models.series',
        'FDSDataWrapper': 'models.data',
        'FDSPlotWrapper': 'models.plot',
        'FDSAxisWrapper': 'models.axis',
        'FDSChartWrapper': 'FDSChartJS'
    };
    function _getPublicConstructorFromConstructorName(constructorName) {
        var publicConstructorName = constructorNameToPublicConstructor[constructorName];
        if (publicConstructorName) {
            return publicConstructorName;
        }
        else {
            throw 'Unexpected constructor:' + constructorName;
        }
    }
    function _logWrapperForConstructor(target, argumentsList, newTarget) {
        var isRootConstructor = target.selector === 'FDSChartWrapper';
        var id = isRootConstructor ? '' : argumentsList[0].id;
        var didSetLogInProgress = false;
        if (!interactionLogInProgress) {
            didSetLogInProgress = true;
            var constructorName = _getPublicConstructorFromConstructorName(target.selector);
            interactionLogInProgress = true;
            var stringifiedArgs = _getArgsAsString(argumentsList);
            if (!Inhouse.interactionLogs) {
                Inhouse.interactionLogs = [
                    {
                        code: 'var storedObjs = {};',
                        type: ApiLogType.InitializeStoredObjs
                    },
                    {
                        code: "function getChartObj(id) { return storedObjs[id] || storedObjs[''].getObjectById(id);}",
                        type: ApiLogType.LookupChartObjFunction
                    }
                ];
            }
            if (isRootConstructor) {
                var chartSizeLogs = _getChartDimensionLogs(argumentsList);
                Inhouse.interactionLogs = Inhouse.interactionLogs.concat(chartSizeLogs);
            }
            Inhouse.interactionLogs.push({
                code: "storedObjs['" + id + "'] = new " + constructorName + "(" + stringifiedArgs + ");",
                type: isRootConstructor ? ApiLogType.ChartConstructor : ApiLogType.Standard
            });
        }
        try {
            return new (target.bind.apply(target, [void 0].concat(argumentsList)))();
        }
        finally {
            if (didSetLogInProgress) {
                interactionLogInProgress = false;
            }
        }
    }
    function _getChartDimensionLogs(argumentsList) {
        var chartDimensionLogs = [];
        var constructorOptions = argumentsList[1] || {};
        var containingDomElement = argumentsList[0];
        var containingJQuery = $$1(containingDomElement);
        if (!constructorOptions.height) {
            var height = containingJQuery.height();
            chartDimensionLogs.push({
                code: _getDomElementAsString(containingDomElement) + (".css(\"height\", \"" + height + "px\");"),
                type: ApiLogType.ResizeHeight
            });
        }
        if (!constructorOptions.width) {
            var width = containingJQuery.width();
            chartDimensionLogs.push({
                code: _getDomElementAsString(containingDomElement) + (".css(\"width\", \"" + width + "px\");"),
                type: ApiLogType.ResizeWidth
            });
        }
        return chartDimensionLogs;
    }
    /**
     * @description Adds calls to change the height/width of the DOM element via css before we call triggerResize in
     * the reproducer, so that we end up resizing the chart to the same size as in the application.
     */
    function getLogsForResizingChart(obj, domElement) {
        var triggerResizeLogs = [];
        var triggerResizeOptions = arguments[2];
        if (!triggerResizeOptions || !triggerResizeOptions.userHeight) {
            var height = $$1(domElement).height();
            triggerResizeLogs.push({
                code: _getDomElementAsString(domElement) + (".css(\"height\", \"" + height + "px\"); // For triggerResize"),
                type: ApiLogType.ResizeHeight
            });
        }
        if (!triggerResizeOptions || !triggerResizeOptions.userWidth) {
            var width = $$1(domElement).width();
            triggerResizeLogs.push({
                code: _getDomElementAsString(domElement) + (".css(\"width\", \"" + width + "px\"); // For triggerResize"),
                type: ApiLogType.ResizeWidth
            });
        }
        return triggerResizeLogs;
    }
    /**
     * @description We can't stringify FDSChartObjectWrapper instances since we end up with circular json and we can't
     * stringify the DOM element passed into the FDSChartJS constructor. This modifies those cases into something that
     * we can stringify and reuse in JSBin.
     * @param args
     * @returns {string}
     */
    function _getArgsAsString(args) {
        var argsArray = Array.prototype.slice.call(args);
        var convertedArgs = [];
        for (var _i = 0, argsArray_1 = argsArray; _i < argsArray_1.length; _i++) {
            var arg = argsArray_1[_i];
            convertedArgs.push(_convertObjectToStringifiable(arg));
        }
        var stringifiedArgs = JSON.stringify(convertedArgs);
        stringifiedArgs = removeQuotesAroundCode(stringifiedArgs);
        // Since args stringifies as an array and we want myCall(param1, param2) instead of myCall([param1, param2]),
        // we're removing the leading [ and trailing ]
        return stringifiedArgs.substring(1, stringifiedArgs.length - 1);
    }
    function removeQuotesAroundCode(stringifiedArgs) {
        stringifiedArgs = stringifiedArgs.replace(new RegExp('"' + stringifiedCodeSignal, 'g'), '');
        return stringifiedArgs.replace(new RegExp(stringifiedCodeSignal + '"', 'g'), '');
    }
    function _getDomElementAsString(obj) {
        return _convertObjectToStringifiable(obj).replace(new RegExp(stringifiedCodeSignal, 'g'), '');
    }
    function isChartObjectWrapper(obj) {
        // Required to avoid a circular dependency on FDSChartObjectWrapper
        return obj !== undefined && obj !== null && _$1.isString(obj.id) && _$1.isObject(obj['_chartObject']) &&
            _$1.isObject(obj.chart);
    }
    function _convertObjectToStringifiable(obj) {
        if (isChartObjectWrapper(obj)) {
            return _wrapInStringifiedCodeSignal("getChartObj('" + obj.id + "')");
        }
        else if (obj instanceof jQuery || obj instanceof HTMLElement) {
            return _wrapInStringifiedCodeSignal("$('#chart')");
        }
        else if (_$1.isObject(obj) || _$1.isArray(obj)) {
            obj = _$1.clone(obj);
            _$1.each(obj, function (value, key) {
                obj[key] = _convertObjectToStringifiable(value);
            });
            return obj;
        }
        else {
            return obj;
        }
    }
    function _wrapInStringifiedCodeSignal(code) {
        return stringifiedCodeSignal + code + stringifiedCodeSignal;
    }
    function resetLogsToStartAtCurrentChart(chart) {
        if (!Inhouse.interactionLogs) {
            throw 'No API logs were found - do you have "fdschartjs-interaction-logging=true" in your url ' +
                'to turn on interaction logging?';
        }
        var json = chart.serializeChart();
        var oldLogs = Inhouse.interactionLogs;
        Inhouse.interactionLogs = [
            _$1.find(oldLogs, { type: ApiLogType.InitializeStoredObjs }),
            _$1.find(oldLogs, { type: ApiLogType.LookupChartObjFunction })
        ];
        var lastHeightResizeIndex = _$1.findLastIndex(oldLogs, { type: ApiLogType.ResizeHeight });
        var lastWidthResizeIndex = _$1.findLastIndex(oldLogs, { type: ApiLogType.ResizeWidth });
        var lastBothResizeIndex = _$1.findLastIndex(oldLogs, { type: ApiLogType.ResizeBoth });
        var lastHeightResize = oldLogs[(Math.max(lastHeightResizeIndex, lastBothResizeIndex))];
        var lastWidthResize = oldLogs[(Math.max(lastWidthResizeIndex, lastBothResizeIndex))];
        if (lastHeightResize) {
            Inhouse.interactionLogs.push(lastHeightResize);
        }
        if (lastWidthResize && lastWidthResize !== lastHeightResize) {
            Inhouse.interactionLogs.push(lastWidthResize);
        }
        Inhouse.interactionLogs.push(_$1.find(oldLogs, { type: ApiLogType.ChartConstructor }));
        Inhouse.interactionLogs.push({
            code: "storedObjs[''].loadJSON(" + json + ");",
            type: ApiLogType.Standard
        });
        Inhouse.interactionLogs.push({ code: "storedObjs[''].draw();", type: ApiLogType.Standard });
    }
    
    var FDSChartObjectWrapper = /** @class */ (function () {
        function FDSChartObjectWrapper(opts) {
            this.attached = false;
            this.chart = null;
            this.initHandlers();
            if (opts instanceof FDSChartObject) {
                this._chartObject = opts;
                this.id = this._chartObject.id;
                this.attached = true;
                this.chart = this._chartObject.root.wrapper;
            }
        }
        FDSChartObjectWrapper.unwrap = function (wrapper) {
            return wrapper && wrapper._chartObject;
        };
        FDSChartObjectWrapper.prototype.setId = function (id) {
            this.id = id;
            if (this.label == null) {
                this.label = this.id;
            }
        };
        FDSChartObjectWrapper.prototype.initHandlers = function () {
            this._handlers = {
                LButtonDown: [],
                LButtonDblClick: [],
                RButtonDown: [],
                RButtonDblClick: [],
                MButtonDown: [],
                MButtonDblClick: [],
                Trend: [],
                Pick: [],
                PickPoint: []
            };
        };
        /**
         * Returns whether or not the attribute id is declared in the default attribute map for this
         * object. This can be used for crude forms of feature detection to detect the presence of an
         * attribute. However, it does not tell you which values are supported for existing attributes,
         * etc.
         *
         * @param {string} id - The id of the attribute to detect.
         * @returns {boolean} Whether or not the attribute exists.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.isAttributeValid = function (id) {
            console.assert(this.attached, "Cannot get attributes on unattached chart object: " + this.id);
            return this._chartObject._getAttributeRedirected(id, 'def') !== undefined;
        };
        /**
         * Returns the value of the attribute at the specified level. If the level is null, then this
         * function returns the highest specified value.
         *
         * @param {string} id - The id of the attribute to retrieve.
         * @param {('user'|'app'|'def')} [level] - The level to retrieve the attribute at (user, app, or
         * def.) If unspecified, this function will return the highest specified value (in order of user,
         * app, and then def.)
         * @returns {(number|string|boolean|number[])} The value of the attribute.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.getAttribute = function (id, level) {
            console.assert(this.attached, "Cannot get attributes on unattached chart object: " + this.id);
            console.assert(this.isAttributeValid(id), this._chartObject.id + " has no attribute with id: " + id);
            return this._chartObject._getAttributeRedirected(id, level);
        };
        /**
         * Sets the attribute specified with id at a particular level.
         *
         * @param {string} id - The id of the attribute to set.
         * @param {('user'|'app')} level - The level at which to set the attribute.
         * @param {(number|string|boolean|number[])} newVal - The new value to set.
         * @returns {FDSChartObjectWrapper} The instance of the chart object wrapper, for chainability.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.setAttribute = function (id, level, newVal) {
            console.assert(this.attached, "Cannot set attributes on unattached chart object: " + this.id);
            console.assert(this.isAttributeValid(id), this._chartObject.id + " has no attribute with id: " + id);
            console.assert(level === 'user' || level === 'app', "level must be either 'user' or 'app'");
            if (level === 'user' || level === 'app') {
                this._chartObject._setAttributeRedirected(id, level, newVal);
            }
            return this;
        };
        FDSChartObjectWrapper.prototype.setAttributes = function (attributesOrLevelList, level) {
            if (level === void 0) { level = 'app'; }
            if (_$1.isArray(attributesOrLevelList)) {
                console.warn('This function overload has been deprecated in favor of the overload ' +
                    'which takes a map of {attributeName: value}.\n' +
                    'See: http://fdschartjs.factset.com/versions/10.16.0/docs/index.html#/fdschartjs/Basics/Chart_Object');
                for (var _i = 0, attributesOrLevelList_1 = attributesOrLevelList; _i < attributesOrLevelList_1.length; _i++) {
                    var _a = attributesOrLevelList_1[_i], listLevel = _a.level, attrs = _a.attrs;
                    if (listLevel !== 'user' && level !== 'app') {
                        continue;
                    }
                    for (var _b = 0, attrs_1 = attrs; _b < attrs_1.length; _b++) {
                        var attr = attrs_1[_b];
                        this._chartObject._setAttributeRedirected(attr.id, listLevel, attr.val);
                    }
                }
            }
            else if (level === 'user' || level === 'app') {
                for (var id in attributesOrLevelList) {
                    this._chartObject._setAttributeRedirected(id, level, attributesOrLevelList[id]);
                }
            }
            return this;
        };
        /**
         * Resets an attribute at a specified level.
         *
         * @param {string} id - Id of the attribute to clear.
         * @param {('user'|'app')} level - The level at which to clear the attribute.
         * @returns {FDSChartObjectWrapper} The instance of the chart object wrapper, for chainability.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.clearAttributeAt = function (id, level) {
            this._chartObject._setAttributeRedirected(id, level, undefined);
            return this;
        };
        /**
         * Resets an attribute to the default value.
         *
         * @param {string} id - The id of the attribute to reset to the default value.
         * @returns {FDSChartObjectWrapper} The instance of the chart object wrapper, for chainability.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.defaultAttribute = function (id) {
            this.clearAttributeAt(id, 'user');
            this.clearAttributeAt(id, 'app');
            return this;
        };
        FDSChartObjectWrapper.prototype.isAttributeDefault = function (id) {
            return this._chartObject._isDefaultRedirected(id);
        };
        /**
         * This is used to perform object ations on this object.
         *
         * @param {string} action - The name of the action to perform.
         * @param {*} [params] - An array of the parameters to pass to the object action call.
         * @returns {*} The return value of the object action call. Specific to each object action and
         * may be a void return type.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.objectAction = function (action, params) {
            var _a = this._chartObject.objectAction(action, 0 /* NONE */, params), handled = _a[0], ret = _a[1], errString = _a[2];
            if (errString !== '') {
                throw new Error(errString);
            }
            return ret;
        };
        /**
         * Sets a property on this object's internal property dictionary. Note that values are only
         * stored internally as strings.
         *
         * @param {string} key - The key of the property to add.
         * @param {string} value - The value of the property.
         * @returns {FDSChartObjectWrapper} The instance of the chart object wrapper, for chainability.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.setProperty = function (key, value) {
            this._chartObject.setProperty(key, value);
            return this;
        };
        /**
         * Deketes the property with the given key.
         *
         * @param {string} key - The key of the property to delete.
         * @returns {FDSChartObjectWrapper} The instance of the chart object wrapper, for chainability.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.removeProperty = function (key) {
            this._chartObject.deleteProperty(key);
            return this;
        };
        /**
         * This will return the api wrapper object for this object's parent.
         *
         * @returns {FDSChartObjectWrapper} An API wrapper object.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.getParent = function () {
            var parent = this._chartObject.parent;
            return parent != null ? parent.wrapper : undefined;
        };
        /**
         * Gets the raw value of the property. If this contains other properties, they should return in
         * their unreplaced state. In other words, if this property contains other properties inside of
         * angle brackets <>, then they will appear with the angle brackets and not be replaced.
         *
         * @param {string} key - The key of the property to get (Exclude angle brackets.)
         * @returns {string} The raw value of the property.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.getProperty = function (key) {
            return this._chartObject.getUnresolvedProperty(key);
        };
        /**
         * This will get the replaced version of the property, so any other properties that this
         * property contains will be replaced with the values of their properties and not simply be the
         * key in angle brackets.
         *
         * @param {string} key - The key of the property to get. (Exclude angle brackets.)
         * @returns {string} The fully resolved value of the property.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.getResolvedProperty = function (key) {
            return this._chartObject.getResolvedProperty(key);
        };
        /**
         * This will replace every property in the given string with its resolved value and return it.
         * The string can have 0 or more properties in it.
         *
         * @param {string} str - A string potentially containing properties. (Include angle brackets.)
         * @returns {string} The string with all properties fully resolved.
         *
         * @memberOf FDSChartObjectWrapper
         */
        FDSChartObjectWrapper.prototype.getResolvedPropertyString = function (str) {
            var pfs = this._chartObject.properties.compilePropertyString(str);
            return pfs.fromValue();
        };
        FDSChartObjectWrapper.prototype.on = function (type, cb) {
            var map$$1 = {
                leftclick: this._handlers.LButtonDown,
                leftdblclick: this._handlers.LButtonDblClick,
                rightclick: this._handlers.RButtonDown,
                rightdblclick: this._handlers.RButtonDblClick,
                middleclick: this._handlers.MButtonDown,
                middledblclick: this._handlers.MButtonDblClick,
            };
            var handlers = map$$1[type];
            if (handlers) {
                handlers.push(cb);
            }
            return this;
        };
        FDSChartObjectWrapper.prototype.handleEvent = function (type, args) {
            var _this = this;
            var handle = function (handler, args2) {
                return setTimeout(function () {
                    handler.apply(_this, args2);
                    return;
                }, 0);
            };
            for (var _i = 0, _a = this._handlers[type]; _i < _a.length; _i++) {
                var handler = _a[_i];
                handle(handler, args);
            }
        };
        FDSChartObjectWrapper.prototype.isStyleObject = function () {
            return this._chartObject.isStyleObject;
        };
        FDSChartObjectWrapper = __decorate([
            FDSChartObjectWrapperLogDecorator
        ], FDSChartObjectWrapper);
        return FDSChartObjectWrapper;
    }());
    
    var SharedAxisAnchor = /** @class */ (function () {
        function SharedAxisAnchor() {
        }
        SharedAxisAnchor.prototype.syncMembers = function (attributeSet) {
            this._dimension = attributeSet.get('SharedAxisAnchorDimension');
            this._valueX = attributeSet.get('SharedAxisAnchorValueX');
            this._valueY = attributeSet.get('SharedAxisAnchorValueY');
        };
        SharedAxisAnchor.prototype.writeToAttrSet = function (attributeSet) {
            attributeSet.addMultiple([
                ['SharedAxisAnchorDimension', Number, 0 /* NONE */],
                ['SharedAxisAnchorValueX', Number, 0],
                ['SharedAxisAnchorValueY', Number, 0],
            ]);
        };
        SharedAxisAnchor.prototype.isEnabledForDimension = function (dimension) {
            if (dimension === 1 /* X */) {
                return (this._dimension & 1 /* X */) !== 0;
            }
            else if (dimension === 2 /* Y */) {
                return (this._dimension & 2 /* Y */) !== 0;
            }
            else {
                return false;
            }
        };
        SharedAxisAnchor.prototype.computePositions = function (axes) {
            var _this = this;
            var _getAnchorPositionForDimension = function (dimension, axisAnchorValue) {
                var participatingAxes = axes.filter(function (axis) { return axis.dimension === dimension && _this.canAxisParticipateInAnchor(axis); });
                var locations = participatingAxes.map(function (axis) {
                    var scale = axis.getScale();
                    var anchorLocation = clamp(scale.getAnchorLocationRelativeToDataRange(axisAnchorValue), 0, 1);
                    var below = anchorLocation;
                    var above = 1 - anchorLocation;
                    return [below, above];
                });
                if (locations.length === 0) {
                    return undefined;
                }
                var _a = _$1.reduce(locations, function (prev, curr) {
                    return [Math.max(prev[0], curr[0]), Math.max(prev[1], curr[1])];
                }, [0, 0]), below = _a[0], above = _a[1];
                return below / (below + above);
            };
            if (this.isEnabledForDimension(1 /* X */)) {
                this._positionNdcX = _getAnchorPositionForDimension(1 /* X */, this._valueX);
            }
            else {
                this._positionNdcX = undefined;
            }
            if (this.isEnabledForDimension(2 /* Y */)) {
                this._positionNdcY = _getAnchorPositionForDimension(2 /* Y */, this._valueY);
            }
            else {
                this._positionNdcY = undefined;
            }
        };
        SharedAxisAnchor.prototype.getPositionAndValue = function (dimension) {
            if (dimension === 1 /* X */) {
                return { positionNdc: this._positionNdcX, axisAnchorValue: this._valueX };
            }
            else if (dimension === 2 /* Y */) {
                return { positionNdc: this._positionNdcY, axisAnchorValue: this._valueY };
            }
            else {
                return { positionNdc: undefined, axisAnchorValue: 0 };
            }
        };
        SharedAxisAnchor.getAxisFailureCode = function (axis) {
            if (!axis.scale) {
                return 1 /* SCALE_NOT_INITIALIZED */;
            }
            else {
                var failureCode = 0;
                if (!axis.isNumericScale()) {
                    failureCode |= 2 /* SCALE_NOT_NUMERIC */;
                }
                if (axis.scale.userThreshEnabled) {
                    failureCode |= 4 /* CUSTOM_THRESHOLDS_SET */;
                }
                if (axis.scale.threshConsider) {
                    failureCode |= 8 /* THRESH_CONSIDER_ENABLED */;
                }
                if (axis.scale.log) {
                    // note, we are checking scale.log directly instead of getLog() because changing the scales range could
                    // invalidate supportLog by pushing the scale into or out of negative numbers.
                    failureCode |= 16 /* LOG_SCALE_ENABLED */;
                }
                if (axis.scale.max <= axis.scale.min) {
                    failureCode |= 32 /* SCALE_EMPTY_RANGE */;
                }
                return failureCode;
            }
        };
        SharedAxisAnchor.prototype.canAxisParticipateInAnchor = function (axis) {
            return SharedAxisAnchor.getAxisFailureCode(axis) === 0 /* SUPPORTED */;
        };
        return SharedAxisAnchor;
    }());
    
    var FDSAxisWrapper = /** @class */ (function (_super) {
        __extends(FDSAxisWrapper, _super);
        function FDSAxisWrapper(opts) {
            if (opts === void 0) { opts = { dimension: -1 /* NONE */ }; }
            var _this = _super.call(this, opts) || this;
            _this.plot = null;
            if (optsAreAxis(opts)) {
                _this.initialize();
            }
            else {
                _this.id = (opts.id != null) ? opts.id : null;
                _this.label = (opts.label != null) ? opts.label : null;
                _this.dimension = (opts.dimension != null) ? opts.dimension : -1 /* NONE */;
            }
            return _this;
        }
        FDSAxisWrapper.prototype.initialize = function () {
        };
        /* BEGIN PUBLIC API */
        FDSAxisWrapper.prototype.on = function (type, cb) {
            if (ENABLE_DEBUG) {
                console.error('FDSAxisWrapper does not support event binding');
            }
            return this;
        };
        /**
         * Returns the prefix for this axis.
         *
         * @returns {string} The axis prefix.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.getPrefix = function () {
            return this.objectAction('GetPrefix');
        };
        /**
         * Checks whether the axis is bound to a series.
         *
         * @return {boolean} Indicates whether or not the axis is bound to a series.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.isBoundToSeries = function () {
            return this._chartObject && this._chartObject.isBoundToSeries();
        };
        /**
         * Returns the zoom extents of this axis. Note: works only on an axis with horizontal zooming enabled.
         *
         * @return {number[]} Contains the beginning and end data points zoomed to and the zoom index.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.getZoomExtents = function () {
            return this.objectAction('QueryZoomExtents');
        };
        /**
         * Set the zoom extents of this axis. Note: works only on an axis with horizontal zooming enabled.
         *
         * @param {number} begin - The start date for the axis to zoom to.
         * @param {number} end - The end date for the axis to zoom to.
         * @return {string} An empty string.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.setZoomExtents = function (begin, end) {
            this.objectAction('SetZoomExtents', [begin, end]);
        };
        /**
         * Resets zoom on this axis to show the entire axis. Note: works only on an axis with horizontal zooming enabled.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.resetZoom = function () {
            this.objectAction('ResetZoom');
        };
        /**
         * Returns the dimension of this axis.
         *
         * @return {number} An int showing the dimension of the axis, according to the DIM object, e.g., DIM.X = 1, so an x
         *   axis will return 1.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.getDimension = function () {
            return this.objectAction('QueryDimension');
        };
        /**
         * Returns the type of this axis.
         *
         * @return {string} Contains the type of the axis, e.g., "TIME", "INT", "FLOAT", etc.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.getAxisType = function () {
            return this.objectAction('QueryAxisType');
        };
        /**
         * @typedef {Object} Threshholds
         * @property {number} min - The min threshold of the axis scale.
         * @property {number} max - The max threshold of the axis scale.
         */
        /**
         * Returns the min and max thresholds of the axis scale.
         *
         * @return {Threshholds} An object containing the min and max scale thresholds.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.getThreshMinAndMax = function () {
            var scale = this._chartObject.getScale();
            if (scale) {
                return ({ min: scale.threshMin, max: scale.threshMax });
            }
            else {
                return undefined;
            }
        };
        /**
         * Returns true if the axis is one of the built-in axes (X, Y, Y2, Y3, Y4, Color, Size, etc.)
         *
         * @return {boolean} Indicates whether or not the axis is built-in.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.isBuiltInAxis = function () {
            return this._chartObject.isBuiltInAxis;
        };
        /**
         * @typedef {Object} LabelInfo
         * @property {Object} labelRect - A Rectangle object that contains the x and y-values defining the label's pixel
         *   location on the chart.
         * @property {number} labelRect.x1 - The x-coordinate of the left edge of the label area.
         * @property {number} labelRect.x2 - The x-coordinate of the right edge of the label area.
         * @property {number} labelRect.y1 - The y-coordinate of the top edge of the label area.
         * @property {number} labelRect.y2 - The y-coordinate of the bottom edge of the label area.
         * @property {string} labelText - Contains the text of the label.
         */
        /**
         * @typedef {Object} AxisLabelsInfo
         * @property {LabelInfo[]} major - Contains information about the major labels on the axis.
         * @property {LabelInfo[]} minor - Contains information about the minor labels on the axis.
         */
        /**
         * Returns the labels drawn on the axis.
         *
         * @return {AxisLabelsInfo} Contains information about all drawn minor and major labels.
         *
         * @memberOf FDSAxisWrapper;
         */
        FDSAxisWrapper.prototype.getLabels = function () {
            return this._chartObject.getLabels();
        };
        /**
         * Tests for whether or not SharedAxisAnchor is supported on this axis.
         * @return {SharedAxisAnchorCapability} returns whether or not SharedAxisAnchor is supported on this axis
         *   (SharedAxisAnchorCapability.IS_SUPPORTED = 0), and a failure reason when its not.
         */
        FDSAxisWrapper.prototype.getSharedAxisAnchorFailureCode = function () {
            if (this._chartObject === null) {
                return 1 /* SCALE_NOT_INITIALIZED */;
            }
            return SharedAxisAnchor.getAxisFailureCode(this._chartObject);
        };
        /* END PUBLIC API */
        FDSAxisWrapper.prototype.addToPlot = function (chart, plot) {
            console.assert(plot.attached, "Plot " + plot.id + " must be attached before adding axes!");
            this.addToChart(chart);
            FDSChartObjectWrapper.unwrap(plot).setChildren([this.id]);
            this.plot = plot;
        };
        FDSAxisWrapper.prototype.addToChart = function (chart) {
            if (this.attached) {
                return;
            }
            if (this.id == null) {
                this.setId(chart.getNextAxisId());
            }
            FDSChartObjectWrapper.unwrap(chart)
                .addObject(this.id, 15 /* FC_AXIS */, 0, this.label, null, this, { 'dimension': this.dimension });
            console.assert(chart.getObjectById(this.id) != null, "Axis " + this.id + " could not be added to the chart!");
            this._chartObject = FDSChartObjectWrapper.unwrap(chart).objects[this.id];
            this.attached = true;
            this.initialize();
            this.chart = chart;
        };
        FDSAxisWrapper.prototype.removeFromChart = function (chart, deleteChildren) {
            if (deleteChildren === void 0) { deleteChildren = false; }
            console.assert(this.attached && (chart.getObjectById(this.id) != null), "Axis " + this.id + " is not attached to the chart");
            FDSChartObjectWrapper.unwrap(chart).deleteObject(this.id, 0 /* NONE */);
            console.assert(chart.getObjectById(this.id) == null, "FDSAxisWrapper failed to delete plot " + this.id + " from the chart");
            this._chartObject = null;
            this.attached = false;
            this.chart = null;
            this.plot = null;
        };
        FDSAxisWrapper.prototype.isIndexScale = function () {
            return this._chartObject.scale.isIndexScale();
        };
        FDSAxisWrapper.selector = 'FDSAxisWrapper';
        FDSAxisWrapper = __decorate([
            FDSChartObjectWrapperLogDecorator
        ], FDSAxisWrapper);
        return FDSAxisWrapper;
    }(FDSChartObjectWrapper));
    var optsAreAxis = function (opts) {
        return isChartObject(opts) && isAxis(opts);
    };
    
    var createPointMap = function (seriesList, dim, otherDim) {
        if (dim === void 0) { dim = 2 /* Y */; }
        if (otherDim === void 0) { otherDim = 1 /* X */; }
        var pointMap = {};
        var stackIndex = 0;
        for (var _i = 0, seriesList_1 = seriesList; _i < seriesList_1.length; _i++) {
            var series = seriesList_1[_i];
            if (!series.isStacked) {
                continue;
            }
            var ds = series.getData(dim);
            var otherDs = series.getData(otherDim);
            for (var i = 0; i < otherDs.data.length; i++) {
                var otherPt = otherDs.data[i];
                if (IsSomeNAN(otherPt)) {
                    continue;
                }
                var pt = ds.getAt(i, 0);
                if (pointMap[otherPt] == null) {
                    pointMap[otherPt] = [];
                }
                pointMap[otherPt][stackIndex] = pt;
            }
            stackIndex++;
        }
        return pointMap;
    };
    var computeStackIndex = function (prm, thisSeries) {
        var index = 0;
        for (var _i = 0, _a = prm.plotSeries; _i < _a.length; _i++) {
            var series = _a[_i];
            if (series.getEffectiveDrawStyle() !== 9 /* AREA */ && series.isStacked) {
                continue;
            }
            if (series === thisSeries) {
                break;
            }
            if (series.isStacked) {
                index++;
            }
        }
        // save the index on the render cache
        if (prm.renderCache.stackIndexMap == null) {
            prm.renderCache.stackIndexMap = {};
        }
        prm.renderCache.stackIndexMap[thisSeries.id] = index;
        return index;
    };
    
    var FDSScale = /** @class */ (function () {
        function FDSScale(root, id, axis) {
            this.min = 0;
            this.max = 0;
            this.number = 0;
            this.delta = 1;
            this.maxDimensions = {
                width: 0,
                height: 0
            };
            this.minorMaxDimensions = {
                width: 0,
                height: 0
            };
            this.initialized = false;
            this.bin = false;
            this.log = false;
            this.logTickRangesValid = false;
            this.reverse = false;
            this.userLabel = false;
            this.labelBinned = false;
            this.format = new FDSFormat();
            this.subTickLogMin = 0;
            this.numLabels = 0;
            this.axisWidthHint = 1000;
            this.padLabels = false;
            this.padLength = -1;
            this.tolerance = FDSFudge;
            this.tickMode = 0 /* FLOATING */;
            this.oldFormat = '';
            this.userThreshEnabled = false;
            this.formatParser = new FormatParser();
            this.weekType = 0 /* FIVE_DAY */;
            this.scaleType = 3 /* DOUBLE */;
            this.tickUserOffset = NAN;
            this.subTickUserOffset = NAN;
            this.numTicksHint = 1;
            this.labelAnchor = NAN;
            this.labelFormatters = {};
            this.labelPrefix = RichTextString.Empty;
            this.labelPostfix = RichTextString.Empty;
            // Outlier stuff
            this.upperMarginControl = 0.9;
            this.lowerMarginControl = 0.1;
            this.outlierMarginMax = 0.1;
            this.outlierMarginMin = 0.1;
            this.outlierMin = (NAN * -1);
            this.outlierMax = NAN;
            this.outlierHandling = false;
            this.dynamicOutlierMax = NAN;
            this.dynamicOutlierMin = (NAN * -1);
            this.dynamicOutlierThreshold = 1; // Setting this to 1 because the PC-side default makes no sense.
            this.dynamicOutliers = false;
            this.outlierThreshMin = NAN;
            this.outlierThreshMax = NAN;
            this.upperRangeActive = false;
            this.lowerRangeActive = false;
            // used for caching the value of threshmin/threshmax prior to adjusting for fixed scales.
            this.floatThreshMin = NAN;
            this.floatThreshMax = NAN;
            this.threshConsider = false;
            this.threshConsiderValue = 0.0;
            this.threshConsiderFactor = 0.5;
            this.threshConsiderFactorEnabled = false;
            // make sure this exists so the axis can get at it, even if it's empty
            this.ticks = [];
            this.minorLabels = [];
            // Not previously in the constructor
            this.formatString = '';
            this.formatPrefix = '';
            this.formatPostfix = '';
            this.binLabelMode = 0 /* START */;
            this.isLabelFormatDefault = true;
            this.ticksResize = true;
            this.tickSafety = 500;
            this.outlierAxis = false;
            this.threshMin = NAN;
            this.threshMax = NAN;
            this.subTickLogOffset = 0;
            this.logTick = false;
            this.tickOffsetBase = 0;
            this.subTickOffsetBase = 0;
            this.tickOffset = 0;
            this.subTickOffset = 0;
            this.tickFactor = 0;
            this.tickMin = 0;
            this.subTickMin = 0;
            this.subTickLogMag = 0;
            this.logDelta = 1.0;
            this.logThreshMin = 0.0;
            this.parseList = null;
            this.compiledFormatString = null;
            this._label = 0;
            this.labels = [];
            this._tick = 0;
            this._subTick = 0;
            this.subTicks = [];
            this._goffset = 0;
            this._gwidth = 0;
            this._minMargin = 0.05;
            this._maxMargin = 0.05;
            this._tickBinned = false;
            this._userThreshMinEnabled = false;
            this._userThreshMaxEnabled = false;
            this._offset = 0;
            this._width = 1.0;
            this._binFactor = 0.8;
            this.shouldCheckLabelsForOverlap = false;
            // Numerical limits
            this.root = root;
            this.id = id;
            this.axis = axis;
            var attributes = this.axis.attributeSet;
            this.csTickDateBin = attributes.isDefault('TickDateBin') ? 'NONE' : attributes.get('TickDateBin');
            this.parentPropertySet = this.axis.properties;
            this._compiledLabelOverride = this._compiledLabelPrefix = this._compiledLabelPostfix
                = this.parentPropertySet.EmptyPropertyString;
            this._init();
        }
        FDSScale.prototype._init = function () {
        };
        /**
         * Determines if the scale needs to be reset based on changes in attributes / data / or other conditions.
         * For the base scale, changes in the "Bin" attribute result in the scale being reset so that the ranges are updated
         * correctly.
         * @returns true if the scale needs to be reset.
         */
        FDSScale.prototype.needsReset = function () {
            var attributes = this.axis.attributeSet;
            if (attributes.isDirty() && this.initialized) {
                if (this.bin !== attributes.get('Bin')) {
                    return true;
                }
            }
            return false;
        };
        FDSScale.prototype._setLog = function (log) {
            this.log = log;
            this._setRanges();
        };
        FDSScale.prototype.setBinned = function (bin) {
            this.bin = bin;
            this.setTickBinned(this.bin);
            this._setRanges();
        };
        FDSScale.prototype._setLabelBinned = function (labelBinned) {
            this.labelBinned = labelBinned;
        };
        FDSScale.prototype.getTickBinned = function () {
            return (this.getBinned() ? this._tickBinned : false) && this.tickMode !== 1 /* MINMAX */;
        };
        FDSScale.prototype.setTickBinned = function (tickBinned) {
            this._tickBinned = tickBinned;
        };
        FDSScale.prototype._setReverse = function (reverse) {
            this.reverse = reverse;
        };
        FDSScale.prototype._setBinFactor = function (f) {
            this._binFactor = f;
        };
        FDSScale.prototype._setTickMode = function (m) {
            this.tickMode = m;
            this._setTickRanges(1000);
        };
        FDSScale.prototype._getLabelAnchor = function () {
            var sharedAxisAnchor = this.axis.parent.sharedAxisAnchor;
            var axisDimension = this.axis.dimension;
            var defaultAnchor = 0.0;
            if (sharedAxisAnchor.isEnabledForDimension(axisDimension)) {
                defaultAnchor = sharedAxisAnchor.getPositionAndValue(axisDimension).axisAnchorValue;
            }
            return this.labelAnchor === NAN ? defaultAnchor : this.labelAnchor;
        };
        FDSScale.prototype.setTickOffset = function (f) {
            if (f > 0.0 || f === NAN) {
                return this.tickUserOffset = f;
            }
            else {
                return this.tickUserOffset = NAN;
            }
        };
        FDSScale.prototype._setSubTickOffset = function (f) {
            if (f > 0.0 || f === NAN) {
                return this.subTickUserOffset = f;
            }
            else {
                return this.subTickUserOffset = NAN;
            }
        };
        // copied from PC side
        FDSScale.prototype.getScaleMin = function () {
            return -Infinity;
        };
        FDSScale.prototype.getScaleMax = function () {
            return Infinity;
        };
        FDSScale.prototype.getAnchorLocationRelativeToDataRange = function (value, min$$1, max$$1) {
            if (min$$1 == null && max$$1 == null) {
                _a = this._applyMargins(this.min, this.max), min$$1 = _a[0], max$$1 = _a[1];
            }
            return (value - min$$1) / (max$$1 - min$$1);
            var _a;
        };
        /**
         * Returns true if the axis is being anchored by either ThreshConsiderFactor or SharedAxisAnchor
         */
        FDSScale.prototype._isAxisBeingAnchored = function () {
            if (this.threshConsider && this.threshConsiderFactorEnabled) {
                return true;
            }
            var sharedAxisAnchor = this.axis.parent.sharedAxisAnchor;
            if (sharedAxisAnchor.isEnabledForDimension(this.axis.dimension)) {
                return sharedAxisAnchor.canAxisParticipateInAnchor(this.axis);
            }
            return false;
        };
        FDSScale.prototype.syncMembers = function (hint) {
            if (hint === void 0) { hint = this.axisWidthHint; }
            // Saves on property access and minified file size
            var attributes = this.axis.attributeSet;
            var getAttribute = attributes.get.bind(attributes);
            var isInheritedDefault = attributes.isInheritedDefault.bind(attributes);
            this.threshConsider = getAttribute('ThreshConsider');
            this.threshConsiderValue = getAttribute('ThreshConsiderValue');
            this.threshConsiderFactorEnabled = !(isInheritedDefault('ThreshConsiderFactor'));
            this.threshConsiderFactor = getAttribute('ThreshConsiderFactor');
            this.reset();
            this.formatString = getAttribute('LabelFormat');
            this.formatPrefix = getAttribute('LabelPrefix');
            this.formatPostfix = getAttribute('LabelPostfix');
            var labelOverride = getAttribute('LabelOverride');
            if (labelOverride !== '') {
                this._compiledLabelOverride = this.parentPropertySet.compilePropertyString(labelOverride);
            }
            if (!isInheritedDefault('WeekType')) {
                this.setWeekType(getAttribute('WeekType'));
            }
            this.csTickDateBin = getAttribute('TickDateBin');
            this.binLabelMode = getAttribute('BinLabelMode');
            this._userThreshMinEnabled = !isInheritedDefault('ThreshMin');
            this._userThreshMaxEnabled = !isInheritedDefault('ThreshMax');
            this.userThreshEnabled = this._userThreshMinEnabled || this._userThreshMaxEnabled;
            var threshMin = this._userThreshMinEnabled ? getAttribute('ThreshMin') : NAN;
            var threshMax = this._userThreshMaxEnabled ? getAttribute('ThreshMax') : NAN;
            if (!isInheritedDefault('TickMode')) {
                var tickMode = getAttribute('TickMode');
                // If the threshMax and threshMin are both set, we do not allow the tick mode to be Fixed.
                if ((this._userThreshMinEnabled && this._userThreshMaxEnabled) && tickMode === 2 /* FIXED */) {
                    tickMode = 0 /* FLOATING */;
                }
                this._setTickMode(tickMode);
            }
            this._compiledLabelPrefix = this.parentPropertySet.compilePropertyString(this.formatPrefix);
            this.labelPrefix = this._compiledLabelPrefix.fromValueRT();
            this._compiledLabelPostfix = this.parentPropertySet.compilePropertyString(this.formatPostfix);
            this.labelPostfix = this._compiledLabelPostfix.fromValueRT();
            this.isLabelFormatDefault = isInheritedDefault('LabelFormat');
            // Some scales, `FDSTimeScale` notably, override the default binning
            // behavior.
            if (!isInheritedDefault('LabelCentered')) {
                this._setLabelBinned(!getAttribute('LabelCentered'));
            }
            if (!isInheritedDefault('Bin')) {
                this.setBinned(getAttribute('Bin'));
            }
            if (!isInheritedDefault('TickBin')) {
                this.setTickBinned(getAttribute('TickBin'));
            }
            if (!isInheritedDefault('Reverse')) {
                this._setReverse(getAttribute('Reverse'));
            }
            if (!isInheritedDefault('BinFactor')) {
                this._setBinFactor(getAttribute('BinFactor'));
            }
            if (!isInheritedDefault('HLBinsHint')) {
                this.numTicksHint = getAttribute('HLBinsHint');
            }
            this.ticksResize = getAttribute('TicksResize');
            // Outlier Stuff
            if (!isInheritedDefault('OutlierAxis')) {
                this.outlierAxis = getAttribute('OutlierAxis');
            }
            var isDynamic = this._setDynamicOutliers(getAttribute('OutlierAxisDynamic'));
            isDynamic = this._setDynamicOutlierThreshold(getAttribute('OutlierAxisDynamicThreshold')) || isDynamic;
            if (isDynamic && (!this.axis === undefined)) {
                this.dynamicOutlierMin = (NAN * -1);
                this.dynamicOutlierMax = NAN;
                if (this.dynamicOutliers) {
                    this.axis.refreshPlotAxes(true);
                }
            }
            if (!isInheritedDefault('Log')) {
                this._setLog(getAttribute('Log'));
            }
            this.tickSafety = getAttribute('TickSafety');
            {
                var outlierAxisThreshMin = void 0;
                var outlierAxisThreshMax = void 0;
                var isOutlierAxisThreshMin = isInheritedDefault('OutlierAxisThreshMin');
                if (!isOutlierAxisThreshMin) {
                    outlierAxisThreshMin = getAttribute('OutlierAxisThreshMin');
                }
                var isOutlierAxisThreshMax = isInheritedDefault('OutlierAxisThreshMax');
                if (!isOutlierAxisThreshMax) {
                    outlierAxisThreshMax = getAttribute('OutlierAxisThreshMax');
                }
                if ((!isOutlierAxisThreshMin) || (!isOutlierAxisThreshMax)) {
                    this._setOutlierThreshs(outlierAxisThreshMin, outlierAxisThreshMax);
                }
            }
            {
                var outlierAxisMarginMin = void 0;
                var outlierAxisMarginMax = void 0;
                var isOutlierAxisMarginMin = isInheritedDefault('OutlierAxisMarginMin');
                if (!isOutlierAxisMarginMin) {
                    outlierAxisMarginMin = getAttribute('OutlierAxisMarginMin');
                }
                var isOutlierAxisMarginMax = isInheritedDefault('OutlierAxisMarginMax');
                if (!isOutlierAxisMarginMax) {
                    outlierAxisMarginMax = getAttribute('OutlierAxisMarginMax');
                }
                if (!isOutlierAxisMarginMin || !isOutlierAxisMarginMax) {
                    this._setOutlierMargins(outlierAxisMarginMin, outlierAxisMarginMax);
                }
            }
            if (this.dynamicOutliers) {
                this._setRanges(threshMin, threshMax);
            }
            this.labelAnchor = this.axis.attributeSet.getWithFallback('LabelAnchor', NAN);
            if (!isInheritedDefault('TickOffset')) {
                this.setTickOffset(getAttribute('TickOffset'));
            }
            if (!isInheritedDefault('MinorTickOffset')) {
                this._setSubTickOffset(getAttribute('MinorTickOffset'));
            }
            var allowSetTick = this.tickMode !== 2;
            if (!this._isAxisBeingAnchored()) {
                allowSetTick = this.setFixedMode(threshMin, threshMax, hint);
            }
            if (this.userThreshEnabled) {
                this._setThreshold(threshMin, threshMax, false);
            }
            if (allowSetTick) {
                this._setTickRanges(hint);
            }
        };
        FDSScale.prototype._threshConsider = function (min$$1, max$$1) {
            if (!this.threshConsider) {
                if (min$$1 < max$$1) {
                    var sharedAxisAnchor = this.axis.parent.sharedAxisAnchor;
                    var _a = sharedAxisAnchor.getPositionAndValue(this.axis.dimension), positionNdc = _a.positionNdc, axisAnchorValue = _a.axisAnchorValue;
                    if (positionNdc !== undefined) {
                        return this._threshConsiderFactor(min$$1, max$$1, axisAnchorValue, positionNdc);
                    }
                }
                return [min$$1, max$$1];
            }
            if (min$$1 > max$$1) {
                _b = [max$$1, min$$1], min$$1 = _b[0], max$$1 = _b[1];
            }
            if (!this.threshConsiderFactorEnabled) {
                if (min$$1 < this.threshConsiderValue) {
                    max$$1 = Math.max(this.threshConsiderValue, max$$1);
                }
                else if (max$$1 > this.threshConsiderValue) {
                    min$$1 = Math.min(this.threshConsiderValue, min$$1);
                }
                return [min$$1, max$$1];
            }
            else {
                return this._threshConsiderFactor(min$$1, max$$1, this.threshConsiderValue, this.threshConsiderFactor);
            }
            var _b;
        };
        FDSScale.prototype._threshConsiderFactor = function (min$$1, max$$1, value, goalPos) {
            // abs value bigger than 1 means pixels
            if (this.axis.parent != null && (goalPos > 1 || goalPos < -1)) {
                // get plot width/height
                var pixelMin = this.axis.parent.subPlotFromNDC(0, this.axis.dimension);
                var pixelMax = this.axis.parent.subPlotFromNDC(1, this.axis.dimension);
                var axisLength = Math.abs(pixelMax - pixelMin);
                goalPos = clamp(goalPos / axisLength, -1, 1);
            }
            _a = this._applyMargins(min$$1, max$$1), min$$1 = _a[0], max$$1 = _a[1];
            // Expand the scale to include the value.
            if (value > max$$1) {
                max$$1 = value;
            }
            else if (value < min$$1) {
                min$$1 = value;
            }
            // negative value = dist from other side
            if (goalPos < 0) {
                goalPos = 1 + goalPos;
            }
            // if the scale is reversed, reverse the factor
            if (this.reverse) {
                goalPos = 1 - goalPos;
            }
            goalPos = clamp(goalPos, FDSFudge, 1 - FDSFudge);
            // doing my own lookup because @lookup is wacky here
            var vCurFrac = this.getAnchorLocationRelativeToDataRange(value, min$$1, max$$1);
            if (vCurFrac < goalPos) {
                var newMinNdc = (1 - (1 - vCurFrac) / (1 - goalPos));
                min$$1 = min$$1 + newMinNdc * (max$$1 - min$$1);
            }
            else if (vCurFrac > goalPos) {
                var newMaxNdc = (vCurFrac / goalPos);
                max$$1 = min$$1 + newMaxNdc * (max$$1 - min$$1);
            }
            var sMin = this.getScaleMin();
            var sMax = this.getScaleMax();
            min$$1 = clamp(min$$1, sMin, sMax);
            max$$1 = clamp(max$$1, sMin, sMax);
            return [min$$1, max$$1];
            var _a;
        };
        FDSScale.prototype._computeNiceRanges = function (min$$1, max$$1) {
            if (max$$1 < min$$1) {
                _a = [max$$1, min$$1], min$$1 = _a[0], max$$1 = _a[1];
            }
            var outMin = min$$1;
            var outMax = max$$1;
            if (this.axis.attributeSet.get('RoundMinMax')) {
                var order = 0;
                var factor = 0;
                var temp = 0;
                var delta = max$$1 - min$$1;
                if (delta > 0) {
                    var logdelta = (FDSLog10(delta, this.tolerance));
                    if (logdelta < 0) {
                        logdelta -= 0.5;
                    }
                    order = (~~logdelta) - 1;
                }
                factor = Math.pow(10, order);
                if (max$$1 < 0) {
                    outMax = -1 * Math.floor(Math.abs(max$$1) / factor) * factor;
                }
                else if (max$$1 === 0) {
                    outMax = 0;
                }
                else {
                    temp = max$$1 / factor;
                    if (temp - (~~temp) > 0) {
                        temp += 1;
                    }
                    outMax = Math.floor(temp) * factor;
                }
                if (min$$1 < 0) {
                    temp = Math.abs(min$$1) / factor;
                    if (temp - Math.floor(temp) > 0) {
                        temp += 1;
                    }
                    outMin = -1 * (~~temp) * factor;
                }
                else if (min$$1 === 0) {
                    outMin = 0;
                }
                else {
                    outMin = (Math.floor(min$$1 / factor)) * factor;
                    if (outMin === 0) {
                        order = (~~FDSLog10(min$$1, this.tolerance)) - 1;
                        factor = Math.pow(10, order);
                        outMin = Math.floor(min$$1 / factor) * factor;
                    }
                }
            }
            return [outMin, outMax];
            var _a;
        };
        FDSScale.prototype._getVisibleMinValue = function () {
            return this.outlierEnabled() && this.lowerOutlierActive() ? this.outlierMin : this.threshMin;
        };
        FDSScale.prototype._setLogTickRanges = function (markInvalid) {
            if (!markInvalid && this.logTickRangesValid) {
                return;
            }
            this.logTickRangesValid = !markInvalid;
            var lowOrder = 0.0;
            var highOrder = 0.0;
            this.logTick = false;
            if (this._getVisibleMinValue() > 0.0) {
                lowOrder = (FDSLog10(this.threshMin, this.tolerance));
                highOrder = (FDSLog10(this.threshMax, this.tolerance));
            }
            if (highOrder - lowOrder > 1.0) {
                this.logTick = true;
                this.subTickLogMin = Math.floor(lowOrder);
                this.subTickLogOffset = 0.0;
                var value = Math.pow(10, this.subTickLogMin);
                while (value + value * this.subTickLogOffset < this.threshMin) {
                    this.subTickLogOffset++;
                }
            }
        };
        FDSScale.prototype._setTickRanges = function (hint) {
            this._setLogTickRanges(true);
            var order = Math.floor(FDSLog10(this.delta, this.tolerance));
            var tickOffset = Math.ceil(this.delta / Math.pow(10, order));
            this._computeTickOffsets(tickOffset, order, false);
            this.adjustTickRanges(hint);
        };
        // Near-mirror of functionality in FDSScale::computeTickOffsets, minus
        // user tick offset options and penny subtick offsets.
        FDSScale.prototype._computeTickOffsets = function (tickOffset, order, isInt) {
            var subTickOffset = 1.0;
            if (tickOffset > 5) {
                tickOffset = 10;
                subTickOffset = 2;
            }
            else if (tickOffset > 2) {
                tickOffset = 5;
            }
            else if (tickOffset > 1) {
                tickOffset = 2;
            }
            else if (!isInt) {
                subTickOffset = 0.2;
            }
            var power = Math.pow(10, order - 1);
            this.tickOffsetBase = tickOffset * power;
            this.subTickOffsetBase = subTickOffset * power;
            if (this.tickUserOffset !== NAN) {
                this.tickOffsetBase = this.tickUserOffset;
                this.subTickOffsetBase = this.tickUserOffset / 2.0;
            }
            if (this.subTickUserOffset !== NAN) {
                this.subTickOffsetBase = this.subTickUserOffset;
            }
        };
        FDSScale.prototype._adjustedTickOffset = function () {
            return this.tickOffset * this.tickFactor;
        };
        FDSScale.prototype._adjustedSubTickOffset = function () {
            return this.subTickOffset * this.tickFactor;
        };
        FDSScale.prototype.adjustTickRanges = function (hint) {
            this.tickFactor = 1;
            var minLabels = 2; // Show at least 2 labels
            var maxLabels = 20; // taken from pc side
            if (hint < minLabels) {
                hint = minLabels;
            }
            if (this.logTick) {
                var delta = (FDSLog10(this.threshMax, this.tolerance)) - (FDSLog10(this.threshMin, this.tolerance));
                this.numLabels = 9;
                while ((this.numLabels + 1) * delta >= hint) {
                    this.numLabels--;
                }
                if (this.numLabels < 2) {
                    this.numLabels = 2;
                }
            }
            if (this.tickMode === 1 /* MINMAX */) {
                if (this.numTicksHint > 0 && this.numTicksHint < hint) {
                    hint = this.numTicksHint;
                }
                if (hint > 20) {
                    hint = maxLabels;
                }
                this.tickMin = this.subTickMin = this.threshMin;
                this.tickOffset = this.subTickOffset = this.delta / (hint > 0 ? hint : 1);
            }
            else {
                this.tickOffset = this.tickOffsetBase;
                this.subTickOffset = this.subTickOffsetBase;
                while (this.delta / this._adjustedTickOffset() > hint) {
                    this.tickFactor *= 2;
                }
                var tickOffset = this.tickOffset * this.tickFactor;
                var subTickOffset = this.subTickOffset * this.tickFactor;
                if (tickOffset <= 0) {
                    tickOffset = 1.0;
                }
                if (subTickOffset <= 0) {
                    subTickOffset = 1.0;
                }
                var labelAnchor = this._getLabelAnchor();
                var lastTickMin = void 0;
                if (this.threshMin < labelAnchor) {
                    this.tickMin = labelAnchor - Math.floor((labelAnchor - this.threshMin) / tickOffset) * tickOffset;
                    this.subTickMin = labelAnchor - Math.floor((labelAnchor - this.threshMin) / subTickOffset) * subTickOffset;
                    lastTickMin = NAN;
                    while (lastTickMin !== this.tickMin &&
                        fuzzyGTE(this.tickMin - tickOffset, this.threshMin, this.tolerance)) {
                        lastTickMin = this.tickMin;
                        this.tickMin -= tickOffset;
                    }
                    lastTickMin = NAN;
                    while (lastTickMin !== this.subTickMin &&
                        fuzzyGTE(this.subTickMin - subTickOffset, this.threshMin, this.tolerance)) {
                        lastTickMin = this.subTickMin;
                        this.subTickMin -= subTickOffset;
                    }
                }
                else {
                    this.tickMin = labelAnchor + Math.floor((this.threshMin - labelAnchor) / tickOffset) * tickOffset;
                    this.subTickMin = labelAnchor + Math.floor((this.threshMin - labelAnchor) / subTickOffset) * subTickOffset;
                    lastTickMin = NAN;
                    while (lastTickMin !== this.tickMin && fuzzyLT(this.tickMin, this.threshMin, this.tolerance)) {
                        lastTickMin = this.subTickMin;
                        this.tickMin += tickOffset;
                    }
                    lastTickMin = NAN;
                    while (lastTickMin !== this.subTickMin && fuzzyLT(this.subTickMin, this.threshMin, this.tolerance)) {
                        lastTickMin = this.subTickMin;
                        this.subTickMin += subTickOffset;
                    }
                }
            }
            if (this.tickMode === 2 /* FIXED */) {
                this._adjustTicksForFixed();
            }
        };
        // Mimics the behavior of FDSScale::applyMargins
        FDSScale.prototype._applyMargins = function (min$$1, max$$1) {
            if (max$$1 < min$$1) {
                _a = [max$$1, min$$1], min$$1 = _a[0], max$$1 = _a[1];
            }
            var maxMargin = this.axis.attributeSet.get('ThreshMaxMargin');
            var minMargin = this.axis.attributeSet.get('ThreshMinMargin');
            if (this.log && min$$1 > 0.0) {
                var logMax = FDSLog10(max$$1, this.tolerance);
                var logMin = FDSLog10(min$$1, this.tolerance);
                var temp = logMax - logMin;
                min$$1 = Math.pow(10.0, (logMin - temp * minMargin));
                max$$1 = Math.pow(10.0, (logMax + temp * maxMargin));
            }
            else {
                var temp = max$$1 - min$$1;
                var temp1 = 0;
                var labelAnchor = this._getLabelAnchor();
                if (max$$1 !== labelAnchor) {
                    temp1 = max$$1 + temp * maxMargin;
                    if (max$$1 <= 0 && temp1 >= 0) {
                        temp1 = 0;
                    }
                    max$$1 = temp1;
                }
                if (min$$1 !== labelAnchor) {
                    temp1 = min$$1 - temp * minMargin;
                    if (min$$1 >= 0 && temp1 <= 0) {
                        temp1 = 0;
                    }
                    min$$1 = temp1;
                }
            }
            return [min$$1, max$$1];
            var _a;
        };
        FDSScale.prototype._getFriendlyMinimum = function (min$$1, max$$1) {
            var order = Math.floor(FDSLog10(Math.abs(min$$1), this.tolerance));
            if (min$$1 !== 0) {
                if (max$$1 - min$$1 === 0) {
                    order = order - 1;
                }
                else {
                    order = order < -3 ? order - 1 : -5;
                }
                min$$1 += Math.pow(10, order); // equivalent to PC codes 'Round()' function
            }
            return min$$1;
        };
        FDSScale.prototype._setRanges = function (min$$1, max$$1) {
            if (min$$1 === void 0) { min$$1 = NAN; }
            if (max$$1 === void 0) { max$$1 = NAN; }
            if (ISNAN(min$$1)) {
                min$$1 = this.min;
            }
            if (ISNAN(max$$1)) {
                max$$1 = this.max;
            }
            _a = this._threshConsider(min$$1, max$$1), min$$1 = _a[0], max$$1 = _a[1];
            min$$1 = this._getFriendlyMinimum(min$$1, max$$1);
            // We store these so that the value ranges remain correct for dynamic outliers.
            var oldMin = min$$1;
            var oldMax = max$$1;
            if (this.dynamicOutliers) {
                if (this.dynamicOutlierMin !== NAN) {
                    if (this.dynamicOutlierMin > min$$1) {
                        min$$1 = this.dynamicOutlierMin;
                    }
                }
                if (this.dynamicOutlierMax !== NAN) {
                    if (this.dynamicOutlierMax < max$$1) {
                        max$$1 = this.dynamicOutlierMax;
                    }
                }
            }
            var canApplyMarginsAndNiceRanges = !this._isAxisBeingAnchored();
            if (canApplyMarginsAndNiceRanges) {
                _b = this._applyMargins(min$$1, max$$1), min$$1 = _b[0], max$$1 = _b[1];
            }
            var threshMin = min$$1;
            var threshMax = max$$1;
            if (canApplyMarginsAndNiceRanges) {
                _c = this._computeNiceRanges(min$$1, max$$1), threshMin = _c[0], threshMax = _c[1];
            }
            var tempMin = this.min;
            var tempMax = this.max;
            _d = this._applyMargins(tempMin, tempMax), tempMin = _d[0], tempMax = _d[1];
            _e = this._computeNiceRanges(tempMin, tempMax), this.outlierMin = _e[0], this.outlierMax = _e[1];
            this._applyOutlierMargins();
            this._applyOutlierLimits();
            this.setBinSize(this.min, this.max);
            this._setThreshold(threshMin, threshMax);
            var _a, _b, _c, _d, _e;
        };
        FDSScale.prototype._setThreshold = function (min$$1, max$$1, setTickRanges) {
            if (setTickRanges === void 0) { setTickRanges = true; }
            if (ISNAN(min$$1) && ISNAN(max$$1)) {
                return;
            }
            if (ISNAN(min$$1)) {
                min$$1 = this.threshMin;
            }
            if (ISNAN(max$$1)) {
                max$$1 = this.threshMax;
            }
            if (min$$1 > max$$1) {
                _a = [max$$1, min$$1], min$$1 = _a[0], max$$1 = _a[1];
            }
            this.delta = max$$1 - min$$1;
            if (this.delta === 0) {
                this.delta = 1;
                this.tolerance = FDSFudge;
            }
            else {
                var order = Math.floor(FDSLog10(this.delta, this.tolerance));
                order = order < -3 ? order - 2 : -5;
                this.tolerance = Math.pow(10, order);
            }
            this.threshMin = min$$1;
            this.threshMax = max$$1;
            // Outlier stuff
            this.upperRangeActive = fuzzyGT(this.max, this.threshMax, this.tolerance) &&
                fuzzyGT(this.outlierMax, this.threshMax, this.tolerance);
            this.lowerRangeActive = fuzzyLT(this.min, this.threshMin, this.tolerance) &&
                fuzzyLT(this.outlierMin, this.threshMin, this.tolerance);
            this.logDelta = 1.0;
            this.logThreshMin = 0.0;
            if (this.getLog()) {
                this.logThreshMin = FDSLog10(this.threshMin, this.tolerance);
                this.logDelta = (FDSLog10(this.threshMax, this.tolerance)) - this.logThreshMin;
            }
            if (setTickRanges) {
                this._setTickRanges(1000);
            }
            var _a;
        };
        FDSScale.prototype._formatLabel = function (value, plain) {
            if (plain === void 0) { plain = false; }
            var format = this.formatString;
            // conditional formatted label, needs to be dealt with on a case-by-case basis
            if ((this.parseList != null) && this.parseList.length > 0) {
                format = this.formatParser.applyParsedList(this.parseList, value);
            }
            // Process `LabelFormat` for property strings
            if (!this.isLabelFormatDefault) {
                this.compiledFormatString = this.parentPropertySet.compilePropertyString(format);
                format = this.compiledFormatString.fromValue();
            }
            if (this.padLength == null) {
                this.padLength = -1;
            }
            var formatter = this.labelFormatters[format];
            if (formatter != null) {
                return new RichTextString(formatter.formatAsNumber(value, this.padLength, plain));
            }
            return RichTextString.Empty;
        };
        FDSScale.prototype.computeLabelDimensions = function (ctx) {
            if (this.labels == null) {
                return;
            }
            this.maxDimensions.width = 0;
            this.maxDimensions.height = 0;
            this.minorMaxDimensions.width = 0;
            this.minorMaxDimensions.height = 0;
            if (!this.axis.labeled) {
                return;
            }
            var axisSeries = this.axis.lookupAxisSeries();
            // When an axis series is set, we need to allocate space for the prefix, data id, label and postfix.
            if (axisSeries !== undefined) {
                var vData = axisSeries.getData(0 /* VALUE */);
                var pScale = this.axis.getScale();
                var dataId = '';
                if ((axisSeries.getData(0 /* VALUE */)).dataId !== '') {
                    dataId = axisSeries.getData(0 /* VALUE */).dataId + ' ';
                }
                var prefixStr = pScale.labelPrefix;
                if (dataId !== '') {
                    prefixStr = prefixStr.concat(dataId);
                }
                var postfixStr = pScale.labelPostfix;
                for (var i = 0; i < axisSeries.size; i++) {
                    var labelStr = vData.printAt(i);
                    var completeString = RichTextString.join(prefixStr, labelStr, postfixStr);
                    var labelMetrics = RichTextRenderer.measureRichText(ctx, completeString, this.axis.axisFont)[0];
                    if (labelMetrics.width > this.maxDimensions.width) {
                        this.maxDimensions.width = labelMetrics.width;
                    }
                    if (labelMetrics.height > this.maxDimensions.height) {
                        this.maxDimensions.height = labelMetrics.height;
                    }
                }
            }
            else {
                for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                    var label = _a[_i];
                    var labelMetrics = RichTextRenderer.measureRichText(ctx, label[0], this.axis.axisFont)[0];
                    if (labelMetrics.width > this.maxDimensions.width) {
                        this.maxDimensions.width = labelMetrics.width;
                    }
                    if (labelMetrics.height > this.maxDimensions.height) {
                        this.maxDimensions.height = labelMetrics.height;
                    }
                }
                for (var _b = 0, _c = this.minorLabels; _b < _c.length; _b++) {
                    var label = _c[_b];
                    var labelMetrics = RichTextRenderer.measureRichText(ctx, label[0], this.axis.axisMinorFont)[0];
                    if (labelMetrics.width > this.minorMaxDimensions.width) {
                        this.minorMaxDimensions.width = labelMetrics.width;
                    }
                    if (labelMetrics.height > this.minorMaxDimensions.height) {
                        this.minorMaxDimensions.height = labelMetrics.height;
                    }
                }
            }
        };
        FDSScale.prototype._initLabelVector = function () {
            this.labels = [];
            this._label = 0;
            this.padLength = -1;
            // Parse the @formatString for properties, and go ahead and resolve it to a string with
            // the fromValue() call
            var formatString = (this.parentPropertySet.compilePropertyString(this.formatString)).fromValue();
            this.format.setNumberFormat(formatString);
            this.labelFormatters[formatString] = this.format;
            this.subTickLogMag = this.subTickLogMin;
            // reparse whenever the format changes
            if (this.formatString !== this.oldFormat) {
                this.oldFormat = this.formatString;
                this.parseList = this.formatParser.parseConditionalFormat(this.formatString);
                var formats = this.formatParser.getAllFormatsFromParsedList(this.parseList);
                this._createLabelFormatParsers(formats);
            }
        };
        // Takes in a list of formats and creates FormatParser objects
        // for them, which will be cached in a dictionary.
        // This is to hopefully increase performance for label parsing. It is also
        // possible that this list contains properties, so we must parse them
        //
        // @param formats [Array] list of the formats in the conditional parse list
        FDSScale.prototype._createLabelFormatParsers = function (formats) {
            var _this = this;
            _$1.forEach(formats, function (format) {
                // we already have a formatter for this format string, so continue
                if (_this.labelFormatters[format] != null) {
                    return;
                }
                _this.compiledFormatString = _this.parentPropertySet.compilePropertyString(format);
                format = _this.compiledFormatString.fromValue();
                _this.labelFormatters[format] = _this.getLabelFormatter(format);
            });
        };
        // returns [formatted label value, NDC offset]
        FDSScale.prototype._getNextLabel = function (plain) {
            if (plain === void 0) { plain = false; }
            this._setLogTickRanges(false);
            var value;
            if (this.logTick && this.getLog() && this.tickMode !== 1 /* MINMAX */ && this.numLabels > 0) {
                var rem = void 0;
                while ((rem = ((~~this.subTickLogOffset) + this._label) % 10) >= this.numLabels) {
                    this._label++;
                }
                if (rem === 0 && this._label > 0) {
                    this.subTickLogMag += 1;
                }
                value = Math.pow(10, this.subTickLogMag);
                value += value * rem;
            }
            else {
                value = this.tickMin + this._label * this._adjustedTickOffset();
            }
            this._label++;
            // We don't need ticks/labels to get bunched up after or before an outlier point.
            if ((this.upperOutlierActive() || this.lowerOutlierActive()) &&
                (fuzzyLT(value, this.threshMin) || fuzzyGT(value, this.threshMax))) {
                return null;
            }
            var f = this.lookup(value);
            if (this._boundToPlotFactors(f)) {
                var formattedLabel = this._formatLabel(value, plain);
                if (!this._compiledLabelOverride.isEmpty()) {
                    var overrideReturn = this._compiledLabelOverride.fromValueRT({ labelValue: value, formattedLabel: formattedLabel });
                    formattedLabel = overrideReturn;
                }
                if (plain) {
                    return [formattedLabel, f, undefined];
                }
                else {
                    return [RichTextString.join(this.labelPrefix, formattedLabel, this.labelPostfix), f, undefined];
                }
            }
            return null;
        };
        FDSScale.prototype.computeLabelVector = function () {
            this._initLabelVector();
            if (this.padLabels) {
                this._computeLabelVectorInternal(true);
                this.padLength = this._getPadLength();
                this.labels = [];
                this._label = 0;
                this.subTickLogMag = this.subTickLogMin;
            }
            this._computeLabelVectorInternal(false);
        };
        FDSScale.prototype._computeOutlierLabel = function (value, plain) {
            if (plain === void 0) { plain = false; }
            var f = this.lookup(value);
            if (!isBounded(f, 0.0, 1.0)) {
                return null;
            }
            // workaround to prevent infinite looping when the axis is shrunk to nothing
            if (this.getMinPlotFactor() === this.getMaxPlotFactor()) {
                return null;
            }
            var formattedLabel = this._formatLabel(value, plain);
            if (plain) {
                return [formattedLabel, f, undefined];
            }
            else {
                return [RichTextString.join(this.labelPrefix, formattedLabel, this.labelPostfix), f, undefined];
            }
        };
        FDSScale.prototype._computeLabelVectorInternal = function (plain) {
            if (plain === void 0) { plain = false; }
            var safety = 0;
            var label;
            if (this.lowerOutlierActive()) {
                label = this._computeOutlierLabel(this.outlierMin, plain);
                if (label) {
                    this.labels.push(label);
                }
            }
            while ((label = this._getNextLabel(plain)) && safety++ < this.tickSafety) {
                this.labels.push(label);
            }
            if (this.upperOutlierActive()) {
                label = this._computeOutlierLabel(this.outlierMax, plain);
                if (label) {
                    this.labels.push(label);
                }
            }
        };
        FDSScale.prototype._getPadLength = function () {
            if (this.labels.length <= 0) {
                return 0;
            }
            var labelTexts = this.labels.map(function (label) { return label[0]; });
            var postDecStrings = [];
            for (var _i = 0, labelTexts_1 = labelTexts; _i < labelTexts_1.length; _i++) {
                var richText = labelTexts_1[_i];
                var plainText = RichTextRenderer.convertToPlaintext(richText);
                var spArray = plainText.split(this.format.locale.decimalSeparator);
                postDecStrings.push((spArray.length === 1) ? '' : spArray[1]);
            }
            var lengths = postDecStrings.map(function (numStr) { return numStr.length; });
            return _$1.max(lengths);
        };
        FDSScale.prototype._initTickVector = function () {
            this.ticks = [];
            this._tick = 0;
            this.subTickLogMag = this.subTickLogMin;
        };
        FDSScale.prototype._getNextTick = function () {
            this._setLogTickRanges(false);
            var tickBinned = this.getTickBinned();
            var factor = tickBinned ? this.tickOffset : this._adjustedTickOffset();
            var value;
            if (this.logTick && this.getLog() && this.tickMode !== 1 /* MINMAX */ && this.numLabels > 0) {
                var rem = void 0;
                while ((rem = ((~~this.subTickLogOffset) + this._tick) % 10) >= this.numLabels) {
                    this._tick++;
                }
                if (rem === 0 && this._tick > 0) {
                    this.subTickLogMag += 1;
                }
                value = Math.pow(10, this.subTickLogMag);
                value += value * rem;
            }
            else {
                value = this.tickMin + this._tick * factor;
            }
            this._tick++;
            if (tickBinned) {
                if (this.reverse) {
                    value += this._goffset;
                }
                else {
                    value -= this._goffset;
                }
            }
            // We don't need ticks/labels to get bunched up after or before an outlier point.
            if ((this.upperOutlierActive() || this.lowerOutlierActive()) &&
                (fuzzyLT(value, this.threshMin) || fuzzyGT(value, this.threshMax))) {
                return null;
            }
            var f = this.lookup(value);
            if (this._boundToPlotFactors(f)) {
                return f;
            }
            return null;
        };
        FDSScale.prototype.computeTickVector = function () {
            this._initTickVector();
            if (this.lowerOutlierActive()) {
                var f = this.lookup(this.outlierMin);
                if (isBounded(f, 0.0, 1.0)) {
                    this.ticks.push(f);
                }
            }
            // Intentionally not incrementing @tick here because it messes up min label.
            var safety = 0;
            var nextTick;
            while ((nextTick = this._getNextTick()) != null && safety++ < this.tickSafety) {
                this.ticks.push(nextTick);
            }
            if (this.upperOutlierActive()) {
                var f = this.lookup(this.outlierMax);
                if (isBounded(f, 0.0, 1.0)) {
                    this.ticks.push(f);
                    this._tick++;
                }
            }
        };
        FDSScale.prototype._initSubTickVector = function () {
            this.subTicks = [];
            this._subTick = 0;
            this.subTickLogMag = this.subTickLogMin;
        };
        FDSScale.prototype._getNextSubTick = function () {
            this._setLogTickRanges(false);
            if (this.getTickBinned() && this.tickMode !== 1 /* MINMAX */) {
                return null;
            }
            var value;
            if (this.logTick && this.getLog() && this.tickMode !== 1 /* MINMAX */) {
                var rem = ((~~this.subTickLogOffset) + this._subTick) % 10;
                if (rem === 0 && this._subTick > 0) {
                    this.subTickLogMag += 1;
                }
                value = Math.pow(10.0, this.subTickLogMag);
                value += value * rem;
            }
            else {
                value = this.subTickMin + this._subTick * this._adjustedSubTickOffset();
            }
            this._subTick++;
            // We don't need ticks/labels to get bunched up after or before an outlier point.
            if ((this.upperOutlierActive() || this.lowerOutlierActive()) &&
                (fuzzyLT(value, this.threshMin) || fuzzyGT(value, this.threshMax))) {
                return null;
            }
            var f = this.lookup(value);
            if (this._boundToPlotFactors(f)) {
                return f;
            }
            return null;
        };
        // checks if an ndc is bound by the plot factors
        // done by both tick and subtick calculations
        FDSScale.prototype._boundToPlotFactors = function (ndc) {
            var minF = this.getMinPlotFactor();
            var maxF = this.getMaxPlotFactor();
            // workaround to prevent infinite looping when the axis is shrunk to nothing
            if (minF === maxF) {
                return false;
            }
            if (this.reverse) {
                var temp = 1 - maxF;
                maxF = 1 - minF;
                minF = temp;
            }
            if (isBounded(ndc, minF, maxF)) {
                return true;
            }
            else {
                return false;
            }
        };
        FDSScale.prototype.computeSubTickVector = function () {
            this._initSubTickVector();
            var safety = 0;
            var nextSubTick;
            while ((nextSubTick = this._getNextSubTick()) != null && safety++ < this.tickSafety) {
                this.subTicks.push(nextSubTick);
            }
        };
        FDSScale.prototype.reset = function (reinit) {
            if (reinit === void 0) { reinit = false; }
            this.initSettings();
            this._setRanges();
        };
        // This returns the minimum and maximum cumulative values across all stacked bars/columns. It is
        // primarily used for setting the minimum and maximum ranges on the scale.
        FDSScale.prototype._cumulativeDataSetSize = function (dim) {
            var otherDim;
            var drawstyleTest;
            if (dim === 1 /* X */) {
                otherDim = 2 /* Y */;
                drawstyleTest = isHorizonalBarType;
            }
            else if (dim === 2 /* Y */) {
                otherDim = 1 /* X */;
                drawstyleTest = isVerticalBarType;
            }
            else {
                return [0, 0];
            }
            // Storage for the sets of min and max values
            var mapmax = {};
            var mapmin = {};
            for (var _i = 0, _a = this.axis.associatedSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                var seriesDS = series.getEffectiveDrawStyle();
                if (!series.isStacked || !drawstyleTest(seriesDS)) {
                    continue;
                }
                // get the bucket number. If this is not a bar type then we set the bucket to 0 (assuming this is
                // stacked area we do not have any other 'buckets'
                var bucket = isBarType(seriesDS) ? series.barNumber : 0;
                // grab the datasets
                var ds = series.getData(dim);
                var ods = series.getData(otherDim);
                var minsize = Math.min(ds.getSize(), ods.getSize());
                // For now, we do not care about multiple dimensions of data.
                for (var j = 0; j < minsize; j++) {
                    var pt = ds.getAt(j, 0);
                    var opt = ods.getAt(j, 0);
                    // positive branch
                    if (pt > 0) {
                        // This bucket exists already
                        if (mapmax[bucket] != null) {
                            var tmp = mapmax[bucket];
                            // This value has a sum
                            if (tmp[opt] != null) {
                                tmp[opt] += pt;
                            }
                            else {
                                tmp[opt] = pt;
                            }
                        }
                        else {
                            var map$$1 = {};
                            map$$1[opt] = pt;
                            mapmax[bucket] = map$$1;
                        }
                    }
                    else {
                        if (!isBarType(seriesDS)) {
                            continue;
                        }
                        // This bucket exists already
                        if (mapmin[bucket] != null) {
                            var tmp = mapmin[bucket];
                            // This value has a sum
                            if (tmp[opt] != null) {
                                tmp[opt] += pt;
                            }
                            else {
                                tmp[opt] = pt;
                            }
                        }
                        else {
                            var map$$1 = {};
                            map$$1[opt] = pt;
                            mapmin[bucket] = map$$1;
                        }
                    }
                }
            }
            // Actually determine the max/min values across all of the buckets.
            var max$$1 = 0;
            var min$$1 = 0;
            _$1.forOwn(mapmax, function (buckets) {
                var bmax = 0;
                if (buckets != null) {
                    _$1.forOwn(buckets, function (pts) {
                        if (pts > bmax) {
                            bmax = pts;
                        }
                    });
                    if (bmax > max$$1) {
                        max$$1 = bmax;
                    }
                }
            });
            _$1.forOwn(mapmin, function (buckets) {
                var bmin = 0;
                if (buckets != null) {
                    _$1.forOwn(buckets, function (pts) {
                        if (pts < bmin) {
                            bmin = pts;
                        }
                    });
                    if (bmin < min$$1) {
                        min$$1 = bmin;
                    }
                }
            });
            return [min$$1, max$$1];
        };
        FDSScale.prototype._computeAreaStacking = function (dim) {
            if (dim === void 0) { dim = 2 /* Y */; }
            var otherDim;
            if (dim === 1 /* X */) {
                otherDim = 2 /* Y */;
            }
            else if (dim === 2 /* Y */) {
                otherDim = 1 /* X */;
            }
            else {
                return [0, 0];
            }
            var dataPoints = createPointMap(this.axis.associatedSeries, dim, otherDim);
            // now our map contains buckets of our points and we must sum through the buckets to find the cumulative min/max
            var min$$1 = 0;
            var max$$1 = 0;
            _$1.forOwn(dataPoints, function (bucket) {
                var sum$$1 = 0;
                for (var i = 0; i < bucket.length; i++) {
                    sum$$1 += bucket[i];
                    if (sum$$1 < min$$1) {
                        min$$1 = sum$$1;
                    }
                    if (sum$$1 > max$$1) {
                        max$$1 = sum$$1;
                    }
                }
            });
            for (var _i = 0, _a = this.axis.associatedSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series.isStacked) {
                    continue;
                }
                var ds = series.getData(dim);
                if (ds.statistics.min < min$$1) {
                    min$$1 = ds.statistics.min;
                }
                if (ds.statistics.max > max$$1) {
                    max$$1 = ds.statistics.max;
                }
            }
            return [min$$1, max$$1];
        };
        // Adjusts the scale to the series' data at the particular dimension
        FDSScale.prototype.adjust = function (dataset, minOverride, maxOverride) {
            if (!dataset || !dataset.statistics) {
                return false;
            }
            // the min of the dataset is not necessarily adjusting the bounds of the scale if we are
            // stacking an area drawstyle
            var dsMax = dataset.Max()[0];
            var dsMin = dataset.Min()[0];
            // If maxOverride or minOverride are specified, we use the max/min between dataset and override
            if (_$1.isFinite(maxOverride)) {
                dsMax = Math.max(dsMax, maxOverride);
            }
            if (_$1.isFinite(minOverride)) {
                dsMin = Math.min(dsMin, minOverride);
            }
            if (dsMax > this.max || !this.initialized) {
                this.max = dsMax;
            }
            if (dsMin < this.min || !this.initialized) {
                this.min = dsMin;
            }
            // We need to determine if there is a series that is either a bar or column drawstyle, and is stacked.
            var _a = this._validStacking(), isDrawBars = _a.isDrawBars, isDrawColumns = _a.isDrawColumns, isDrawArea = _a.isDrawArea, isStacked = _a.isStacked;
            // If a valid stacking is occuring, we then set the minimum and maximum scale values
            // to the negative and positive cumulative values across all stacked series.
            if (isDrawBars && isStacked && this.axis.dimension === 1 /* X */) {
                var _b = this._cumulativeDataSetSize(1 /* X */), minWidth = _b[0], maxWidth = _b[1];
                if (minWidth < this.min) {
                    this.min = minWidth;
                }
                if (maxWidth > this.max) {
                    this.max = maxWidth;
                }
            }
            else if (isDrawColumns && isStacked && this.axis.dimension === 2 /* Y */) {
                var _c = this._cumulativeDataSetSize(2 /* Y */), minHeight = _c[0], maxHeight = _c[1];
                if (minHeight < this.min) {
                    this.min = minHeight;
                }
                if (maxHeight > this.max) {
                    this.max = maxHeight;
                }
            }
            else if (isDrawArea && isStacked && this.axis.dimension === 2 /* Y */) {
                var _d = this._computeAreaStacking(2 /* Y */), minHeight = _d[0], maxHeight = _d[1];
                this.min = minHeight;
                this.max = maxHeight;
            }
            if (dataset.statistics.count > this.number) {
                this.number = dataset.statistics.count;
            }
            // This sets up the min and max scales when using dynamic outliers.
            if (this.dynamicOutliers) {
                var sumOutlierMin = dataset.outlierMin(this.dynamicOutlierThreshold);
                var sumOutlierMax = dataset.outlierMax(this.dynamicOutlierThreshold);
                if ((!IsNA(sumOutlierMin)) && (sumOutlierMin < this.dynamicOutlierMin)) {
                    this.dynamicOutlierMin = sumOutlierMin;
                }
                if ((!IsNA(sumOutlierMax)) && (sumOutlierMax > this.dynamicOutlierMax)) {
                    this.dynamicOutlierMax = sumOutlierMax;
                }
            }
            else {
                dataset.outlierMin(NAN);
                dataset.outlierMax(NAN);
            }
            this._setRanges();
            this.initialized = true;
            return true;
        };
        FDSScale.prototype.initSettings = function () {
            this._setLog(false);
            this.setBinned(false);
            this._setLabelBinned(false);
            this.setTickBinned(false);
            this._setReverse(false);
            this.outlierHandling = false;
            this.binLabelMode = 0 /* START */;
            this.labelAnchor = NAN;
            this.tickOffset = NAN;
            this.subTickOffset = NAN;
            this._setBinFactor(0.8);
            this.numTicksHint = 1;
            this.tickMode = 2 /* FIXED */;
            this._minMargin = this._maxMargin = 0.05;
            this.outlierThreshMin = this.outlierThreshMax = NAN;
            this.outlierMarginMin = this.outlierMarginMax = 0.1;
            this.userThreshEnabled = false;
            this._userThreshMinEnabled = false;
            this._userThreshMaxEnabled = false;
        };
        FDSScale.prototype.initialize = function (dataset) {
            if (dataset == null || dataset.statistics == null) {
                return false;
            }
            this.max = dataset.Max()[0];
            this.min = dataset.Min()[0];
            // We need to determine if there is a series that is either a bar or column drawstyle, and is stacked.
            var _a = this._validStacking(), isDrawBars = _a.isDrawBars, isDrawColumns = _a.isDrawColumns, isDrawArea = _a.isDrawArea, isStacked = _a.isStacked;
            // If a valid stacking is occuring, we then set the minimum and maximum scale values
            // to the negative and positive cumulative values across all stacked series.
            if (isDrawBars && isStacked && this.axis.dimension === 1 /* X */) {
                var _b = this._cumulativeDataSetSize(1 /* X */), minWidth = _b[0], maxWidth = _b[1];
                if (minWidth < this.min) {
                    this.min = minWidth;
                }
                if (maxWidth > this.max) {
                    this.max = maxWidth;
                }
            }
            else if (isDrawColumns && isStacked && this.axis.dimension === 2 /* Y */) {
                var _c = this._cumulativeDataSetSize(2 /* Y */), minHeight = _c[0], maxHeight = _c[1];
                if (minHeight < this.min) {
                    this.min = minHeight;
                }
                if (maxHeight > this.max) {
                    this.max = maxHeight;
                }
            }
            else if (isDrawArea && isStacked && this.axis.dimension === 2 /* Y */) {
                var _d = this._computeAreaStacking(2 /* Y */), minHeight = _d[0], maxHeight = _d[1];
                this.min = minHeight;
                this.max = maxHeight;
            }
            this.number = dataset.statistics.count;
            if (this.dynamicOutliers) {
                this.dynamicOutlierMin = dataset.outlierMin(this.dynamicOutlierThreshold);
                this.dynamicOutlierMax = dataset.outlierMax(this.dynamicOutlierThreshold);
            }
            else {
                dataset.outlierMin(NAN);
                dataset.outlierMax(NAN);
            }
            this.initialized = true;
            return true;
        };
        // Returns `[lookupValue, low, high, offset]`
        FDSScale.prototype.lookupRange = function (val, dateBin) {
            // We want to always use the FDSScale base implementation here instead of the derived behavior
            var FDSScaleLookup = FDSScale.prototype.lookup.bind(this);
            var v = FDSScaleLookup(val);
            var glow = FDSScaleLookup(val - this._goffset);
            var ghigh = FDSScaleLookup(val + this._goffset);
            var low = Math.min(glow, ghigh);
            var high = Math.max(glow, ghigh);
            var offset = ((high - low) * (1.0 - this.getBinFactor())) / 2.0;
            return [v, low, high, offset];
        };
        FDSScale.prototype.lookup = function (value, dateBin) {
            if (dateBin === void 0) { dateBin = 0 /* NONE */; }
            if (this.outlierEnabled()) {
                return this._lookupOutlier(value);
            }
            var _a = this.getBinned() ? {
                offset: this._offset,
                width: this._width
            } : {
                offset: 0.0,
                width: 1.0
            }, offset = _a.offset, width = _a.width;
            var ndc;
            if (this.getLog()) {
                ndc = offset + width * ((FDSLog10(value, this.tolerance)) - this.logThreshMin) / this.logDelta;
            }
            else {
                ndc = offset + width * (value - this.threshMin) / this.delta;
            }
            ndc = this.applyPlotFactorNDC(ndc);
            return this.reverse ? 1 - ndc : ndc;
        };
        FDSScale.prototype.computeValueUnbinned = function (ndc) {
            return this.computeValue(ndc);
        };
        FDSScale.prototype.computeValue = function (ndc) {
            // Outliers override this
            if (this.outlierEnabled()) {
                return this.computeOutlierValue(ndc);
            }
            var min$$1;
            var delta;
            if (this.getLog()) {
                min$$1 = FDSLog10(this.threshMin, this.tolerance);
                delta = FDSLog10(this.threshMax, this.tolerance) - min$$1;
            }
            else {
                min$$1 = this.threshMin;
                delta = this.threshMax - min$$1;
            }
            if (this.reverse) {
                ndc = 1.0 - ndc;
            }
            if (this.getLog()) {
                return Math.pow(10, (ndc * delta + min$$1));
            }
            else {
                return ndc * delta + min$$1;
            }
        };
        FDSScale.prototype.applyPlotFactorNDC = function (val) {
            var minPF = this.getMinPlotFactor();
            var maxPF = this.getMaxPlotFactor();
            return minPF + (val * Math.abs((maxPF - minPF)));
        };
        FDSScale.prototype.applyRevPlotFactorNDC = function (val) {
            return this._applyRevPlotFactorHelper(val, this.getMinPlotFactor(), this.getMaxPlotFactor());
        };
        FDSScale.prototype._applyRevPlotFactorHelper = function (val, min$$1, max$$1) {
            if (min$$1 === max$$1) {
                return 0;
            }
            else {
                return (val - min$$1) / Math.abs(max$$1 - min$$1);
            }
        };
        FDSScale.prototype.getMinPlotFactor = function () {
            return this.axis.minPlotFactor;
        };
        FDSScale.prototype.getMaxPlotFactor = function () {
            return this.axis.maxPlotFactor;
        };
        FDSScale.prototype.setWeekType = function (weekType) {
            this.weekType = weekType;
        };
        FDSScale.prototype.setBinSize = function (dMin, dMax) {
            var count = this.number > 0 ? this.number : 1;
            this._offset = 1.0 / count;
            this._width = 1.0 - this._offset;
            if (this._width <= 0) {
                this._width = 1.0;
            }
            this._offset *= 0.5;
            var delta = Math.max(dMax, dMin) - Math.min(dMax, dMin);
            if (delta <= 0.0) {
                delta = 1.0;
            }
            if (this.getBinned()) {
                this._goffset = delta / count;
            }
            else {
                this._goffset = delta / (2 * (count - 1));
            }
            this._gwidth = delta - this._goffset;
            if (this._gwidth <= 0.0) {
                this._gwidth = 1.0;
            }
            this._goffset *= (0.5 / this._width);
        };
        FDSScale.prototype.getLog = function () {
            return this.supportLog() ? this.log : false;
        };
        FDSScale.prototype.supportLog = function () {
            return this._getVisibleMinValue() > 0;
        };
        FDSScale.prototype.getBinned = function () {
            if (this.getLog()) {
                return false;
            }
            else {
                return this.bin;
            }
        };
        FDSScale.prototype.checkMinDateTickNeeded = function (tickBinned, dateTick, tickDateBin) {
            if (!tickBinned && this.getBinned()) {
                var nDays = 0;
                switch (tickDateBin) {
                    case 15 /* WEEK */:
                        nDays = 5;
                        break;
                    case 16 /* MONTH */:
                        nDays = 20;
                        break;
                    case 17 /* QUARTER */:
                        nDays = 45;
                        break;
                    case 18 /* HALFY */:
                        nDays = 100;
                        break;
                    case 19 /* YEAR */:
                        nDays = 200;
                        break;
                    case 22 /* TENY */:
                        nDays = 1900;
                        break;
                    case 20 /* TWOY */:
                        nDays = 380;
                        break;
                    case 21 /* FIVEY */:
                        nDays = 950;
                        break;
                    default:
                        nDays = 0;
                }
                if (dateTick - this.threshMin > nDays) {
                    return true;
                }
            }
            return false;
        };
        FDSScale.prototype.checkMaxDateTickNeeded = function (tickBinned, dateTick, tickDateBin) {
            if (!tickBinned && this.getBinned()) {
                var nDays = 0;
                switch (tickDateBin) {
                    case 15 /* WEEK */:
                        nDays = 5;
                        break;
                    case 16 /* MONTH */:
                        nDays = 14;
                        break;
                    case 17 /* QUARTER */:
                        nDays = 44;
                        break;
                    case 18 /* HALFY */:
                        nDays = 90;
                        break;
                    case 19 /* YEAR */:
                        nDays = 180;
                        break;
                    case 22 /* TENY */:
                        nDays = 1800;
                        break;
                    case 20 /* TWOY */:
                        nDays = 360;
                        break;
                    case 21 /* FIVEY */:
                        nDays = 900;
                        break;
                    default:
                        nDays = 0;
                }
                if (dateTick - this.threshMax > nDays) {
                    return true;
                }
            }
            return false;
        };
        FDSScale.prototype.getLabelBinned = function () {
            return this.getTickBinned() ? this.labelBinned : false;
        };
        FDSScale.prototype.getMinorLabelBinned = function () {
            return false;
        };
        FDSScale.prototype.getBinDataWidthFromPoint = function (pt) {
            if (this.bin &&
                _$1.includes([11 /* INTRADAY */, 8 /* DATETIME */, 5 /* DATE */, 7 /* TIME */], this.scaleType)) {
                var data = this.snapToFrequency(pt - FDSFudge);
                var _a = this.lookupRange(data), val = _a[0], low = _a[1], high = _a[2];
                return this.computeValue(high) - this.computeValue(low);
            }
            return 0;
        };
        FDSScale.prototype.updateFixedMode = function (hint) {
            var threshMin = this.floatThreshMin;
            var threshMax = this.floatThreshMax;
            this._setTickRanges(1000);
            var allowSetTick = false;
            if (!this._isAxisBeingAnchored()) {
                allowSetTick = this.setFixedMode(threshMin, threshMax, hint);
            }
            if (this.userThreshEnabled) {
                this._setThreshold(threshMin, threshMax, false);
            }
            if (allowSetTick) {
                this._setTickRanges(hint);
            }
        };
        FDSScale.prototype._adjustTicksForFixed = function () {
            if (this.tickMode !== 2 /* FIXED */ || this._isAxisBeingAnchored()) {
                return;
            }
            // If the difference between threshMax and threshMin is not divisible by tickOffset, the ticks neeed adjustment.
            var needTickAdjustment = !(fuzzyEQ((this.threshMax - this.threshMin) % this.tickOffset, 0));
            if (needTickAdjustment) {
                // If just threshMax was user defined, we can adjust the chart so that the bottom tick is aligned with the
                // bottom edge of the plot.
                if (this._userThreshMaxEnabled && !this._userThreshMinEnabled) {
                    // Find the closest multiple of tick offset that is below or equal to threshMin.
                    var newThreshMin = calculatePreviousMultiple(this.tickOffset, this.threshMin);
                    this._setThreshold(newThreshMin, this.threshMax, false);
                    this.tickMin = this.subTickMin = newThreshMin;
                    // If just threshMin was user defined, we adjust the chart so that the top tick is aligned with the top
                    // edge of the plot.
                }
                else if (this._userThreshMinEnabled && !this._userThreshMaxEnabled) {
                    // Find the closest multiple of tickOffset that is above or equal to threshMax.
                    if (!fuzzyEQ(this.threshMax % this.tickOffset, 0)) {
                        var newThreshMax = calculateNextMultiple(this.tickOffset, this.threshMax);
                        this._setThreshold(this.threshMin, newThreshMax, false);
                    }
                    // Find the closest multiple of tickOffset that is above or equal to threshMin.
                    this.tickMin = calculateNextMultiple(this.tickOffset, this.threshMin);
                    // Find the closest multiple of subTickOffset that is above or equal to threshMin.
                    this.subTickMin = calculateNextMultiple(this.subTickOffset, this.threshMin);
                }
            }
        };
        FDSScale.prototype.setFixedMode = function (threshMin, threshMax, hint) {
            if (this.tickMode !== 2 /* FIXED */) {
                return true;
            }
            if (threshMin === NAN) {
                threshMin = this.threshMin;
            }
            if (threshMax === NAN) {
                threshMax = this.threshMax;
            }
            if (threshMax < threshMin) {
                _a = [threshMax, threshMin], threshMin = _a[0], threshMax = _a[1];
            }
            this.floatThreshMin = threshMin;
            this.floatThreshMax = threshMax;
            if (threshMax === threshMin) {
                return false;
            }
            var labelAnchor = this._getLabelAnchor();
            var tickOffset = 0;
            var newTickOffset = 0;
            if (hint < 1000) {
                hint -= 1;
                this._setMinMaxTickOffset(hint);
            }
            tickOffset = this.tickOffsetBase;
            var count = 0;
            if (tickOffset > 0) {
                while ((newTickOffset !== tickOffset) && count < 3) {
                    var upper = Math.floor((threshMax - labelAnchor) / tickOffset) * tickOffset;
                    var lower = Math.floor((threshMin - labelAnchor) / tickOffset) * tickOffset;
                    while (fuzzyLT(labelAnchor + upper, threshMax, this.tolerance)) {
                        upper += tickOffset;
                    }
                    while (fuzzyGT(labelAnchor + lower, threshMin, this.tolerance)) {
                        lower -= tickOffset;
                    }
                    var tempMin = labelAnchor + lower;
                    if (this.getLog() && this.logTick && tempMin <= 0.0) {
                        tempMin = threshMin;
                    }
                    this._setThreshold(tempMin, labelAnchor + upper, false);
                    newTickOffset = tickOffset;
                    if (hint < 1000) {
                        this._setMinMaxTickOffset(hint);
                    }
                    tickOffset = this.tickOffsetBase;
                    count++;
                }
            }
            return false;
            var _a;
        };
        FDSScale.prototype._setMinMaxTickOffset = function (hint) {
            var order = Math.floor(FDSLog10(this.delta, this.tolerance));
            var factor = Math.pow(10, order);
            var tickOffset = Math.ceil(this.delta / factor);
            if (hint < 1) {
                hint = 1;
            }
            if (hint > 9) {
                hint = 9;
            }
            tickOffset = Math.ceil((tickOffset * 9.0) / hint);
            if (tickOffset > 10) {
                order++;
                tickOffset = Math.ceil(tickOffset / 10);
            }
            this._computeTickOffsets(tickOffset, order, false);
        };
        FDSScale.prototype.setPadLabels = function (padFlag) {
            this.padLabels = padFlag;
            this.computeLabelVector();
        };
        // Intended to be overriden by scales with actual binning
        FDSScale.prototype.snapToFrequency = function (value) {
            return value;
        };
        // ### Outlier Section ####
        // Determines if outliers are enabled on an axis.
        FDSScale.prototype.outlierEnabled = function () {
            if (!this.axis.outlierAxis || this.bin) {
                return false;
            }
            if (this.upperOutlierActive() || this.lowerOutlierActive()) {
                return true;
            }
            return false;
        };
        // Determines if there is an outlier past a maximum threshold.
        FDSScale.prototype.upperOutlierActive = function () {
            return this.axis && !this.root.horizontalZoomEnabled && fuzzyGT(this.max, this.threshMax, this.tolerance);
        };
        // Determines if there is an outlier past a minimum threshold.
        FDSScale.prototype.lowerOutlierActive = function () {
            return this.axis && !this.root.horizontalZoomEnabled && fuzzyLT(this.min, this.threshMin, this.tolerance);
        };
        // Sets up the upper and lower margin control for outliers.
        FDSScale.prototype._applyOutlierMargins = function () {
            if (this.outlierMarginMax >= 0.0) {
                this.upperMarginControl = 1.0 - clamp(this.outlierMarginMax, 0.0, 1.0);
            }
            if (this.outlierMarginMin >= 0.0) {
                this.lowerMarginControl = clamp(this.outlierMarginMin, 0.0, 1.0);
            }
            if (this.lowerMarginControl > this.upperMarginControl) {
                _a = [this.upperMarginControl, this.lowerMarginControl], this.lowerMarginControl = _a[0], this.upperMarginControl = _a[1];
            }
            var _a;
        };
        // Sets the Outlier-specific Min and Max thresholds. These are derived from attributes passed
        // in to the chart, and are not always supplied.
        FDSScale.prototype._applyOutlierLimits = function () {
            if (this.outlierThreshMin !== NAN) {
                this.outlierMin = this.outlierThreshMin;
            }
            if (this.outlierThreshMax !== NAN) {
                this.outlierMax = this.outlierThreshMax;
            }
        };
        FDSScale.prototype.getOutlierMaxNDC = function (factor) {
            var ndcThresh = this.lookup(this.threshMax);
            var ret = 1.0;
            if (this.reverse) {
                ret = 0.0;
                if (ndcThresh > 0.0) {
                    ret = ndcThresh - clamp(factor, 0.0, 1.0) * ndcThresh;
                }
            }
            else {
                ret = 1.0;
                if (ndcThresh < 1.0) {
                    ret = ndcThresh + clamp(factor, 0.0, 1.0) * (1.0 - ndcThresh);
                }
            }
            return ret;
        };
        FDSScale.prototype.getOutlierMinNDC = function (factor) {
            var ndcThresh = this.lookup(this.threshMin);
            var ret = 0.0;
            if (!this.reverse) {
                ret = 0.0;
                if (ndcThresh > 0.0) {
                    ret = ndcThresh - clamp(factor, 0.0, 1.0) * ndcThresh;
                }
            }
            else {
                ret = 1.0;
                if (ndcThresh < 1.0) {
                    ret = ndcThresh + clamp(factor, 0.0, 1.0) * (1.0 - ndcThresh);
                }
            }
            return ret;
        };
        FDSScale.prototype.computeOutlierValue = function (ndc) {
            var min$$1 = this.threshMin;
            var max$$1 = this.threshMax;
            if (this.upperRangeActive && (ndc > this.upperMarginControl)) {
                ndc = (ndc - this.upperMarginControl) / (1 - this.upperMarginControl);
                min$$1 = this.threshMax;
                max$$1 = this.outlierMax;
            }
            else if (this.lowerRangeActive && (ndc < this.lowerMarginControl)) {
                ndc = ndc / this.lowerMarginControl;
                min$$1 = this.outlierMin;
                max$$1 = this.threshMin;
            }
            else {
                var range = 1.0;
                var lowerOffset = 0.0;
                if (this.upperRangeActive) {
                    range = this.upperMarginControl;
                }
                if (this.lowerRangeActive) {
                    range -= this.lowerMarginControl;
                    lowerOffset = this.lowerMarginControl;
                }
                ndc = (ndc - lowerOffset) / range;
            }
            return this._calcWorld(ndc, min$$1, max$$1);
        };
        FDSScale.prototype._calcWorld = function (ndc, min$$1, max$$1) {
            var value = 0.0;
            var isLog = this.getLog();
            if (isLog) {
                min$$1 = FDSLog10(min$$1, this.tolerance);
                max$$1 = FDSLog10(max$$1, this.tolerance);
            }
            if (this.reverse) {
                value = ((1.0 - ndc) * (max$$1 - min$$1) + min$$1);
            }
            else {
                value = (ndc * (max$$1 - min$$1) + min$$1);
            }
            if (isLog) {
                value = Math.pow(10.0, value);
            }
            return value;
        };
        // This actually sets the outlier thresh min/max based on the axis outlier threshs
        // storied in the chart as attributes.
        FDSScale.prototype._setOutlierThreshs = function (min$$1, max$$1) {
            if (min$$1 === void 0) { min$$1 = NAN; }
            if (max$$1 === void 0) { max$$1 = NAN; }
            this.outlierThreshMax = max$$1;
            this.outlierThreshMin = min$$1;
        };
        // Same with this, all we're doing is setting the margins based on passed in attributes.
        FDSScale.prototype._setOutlierMargins = function (min$$1, max$$1) {
            if (min$$1 === void 0) { min$$1 = -1; }
            if (max$$1 === void 0) { max$$1 = -1; }
            if ((min$$1 >= 0.0) && (max$$1 >= 0.0)) {
                this.outlierMarginMin = min$$1;
                this.outlierMarginMax = max$$1;
            }
        };
        // Returns the ndc position based on a value on a scale where outliers are active.
        FDSScale.prototype._lookupOutlier = function (value) {
            var lowerOffset = 0.0;
            var range = 1.0;
            if (this.upperRangeActive) {
                range = this.upperMarginControl;
            }
            if (this.lowerRangeActive) {
                range -= this.lowerMarginControl;
                lowerOffset = this.lowerMarginControl;
            }
            var ndc = 0.0;
            if (this.upperRangeActive && (value > this.threshMax)) {
                ndc = this.upperMarginControl +
                    this._calcNDC(1.0 - this.upperMarginControl, value, this.threshMax, this.outlierMax);
            }
            else if (this.lowerRangeActive && (value < this.threshMin)) {
                ndc = this._calcNDC(this.lowerMarginControl, value, this.outlierMin, this.threshMin);
            }
            else {
                ndc = lowerOffset + this._calcNDC(range, value, this.threshMin, this.threshMax);
            }
            ndc = this.applyPlotFactorNDC(ndc);
            if (this.reverse) {
                return 1.0 - ndc;
            }
            return ndc;
        };
        FDSScale.prototype._calcNDC = function (range, value, min$$1, max$$1) {
            if (this.getLog()) {
                value = FDSLog10(value, this.tolerance);
                min$$1 = FDSLog10(min$$1, this.tolerance);
                max$$1 = FDSLog10(max$$1, this.tolerance);
            }
            var delta = max$$1 - min$$1;
            if (delta <= 0.0) {
                delta = 1.0;
            }
            return range * ((value - min$$1) / delta);
        };
        // Sets if dynamic outliers are active or not, and returns a bool
        // based on if anything actually changed.
        FDSScale.prototype._setDynamicOutliers = function (dynOut) {
            if (this.dynamicOutliers !== dynOut) {
                this.dynamicOutliers = dynOut;
                return true;
            }
            return false;
        };
        // Same as above, sets the dynamic outlier threshold value, and returns
        // a bool to notify us if anything actually did change.
        FDSScale.prototype._setDynamicOutlierThreshold = function (thresh) {
            if (this.dynamicOutlierThreshold !== thresh) {
                this.dynamicOutlierThreshold = thresh;
                return true;
            }
            return false;
        };
        // This is just for convenience. If true, outliers are active on an edge of the plot.
        FDSScale.prototype.outlierActive = function () {
            if (this.upperOutlierActive()) {
                return true;
            }
            if (this.lowerOutlierActive()) {
                return true;
            }
            return false;
        };
        FDSScale.prototype._validStacking = function () {
            // We need to determine if there is a series that is either a bar or column drawstyle, and is stacked.
            // If so, the maximum value for the scale then needs to be the maximum cumulative value of all series
            // sharing these attributes.
            for (var _i = 0, _a = this.axis.associatedSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                var ds = series.getEffectiveDrawStyle();
                var isDrawBars = isHorizonalBarType(ds);
                var isDrawColumns = isVerticalBarType(ds);
                var isDrawArea = ds === 9;
                var isStacked = series.isStacked;
                if (isStacked && (isDrawBars || isDrawColumns || isDrawArea)) {
                    return ({ isDrawBars: isDrawBars, isDrawColumns: isDrawColumns, isDrawArea: isDrawArea, isStacked: isStacked });
                }
            }
            // If we couldn't find a valid combo, just forget about the whole thing
            return ({
                isDrawBars: false,
                isDrawColumns: false,
                isDrawArea: false,
                isStacked: false
            });
        };
        // Just takes a value and compresses it to avoid copy-pasta.
        FDSScale.prototype.compressValue = function (value, compressLog) {
            if (compressLog === void 0) { compressLog = false; }
            return compressLog ? Math.log(value) : value;
        };
        // for fdsscale we don't need to do any decompression, just the identity fn
        FDSScale.prototype.decompressValue = function (value, decompressLog) {
            if (decompressLog === void 0) { decompressLog = false; }
            return decompressLog ? Math.exp(value) : value;
        };
        FDSScale.prototype._getBinFactorFromPixelValue = function () {
            var length = NAN;
            if (this.axis.parent) {
                var max$$1 = void 0;
                if (this.axis.dimension === 1 /* X */) {
                    max$$1 = this.axis.parent.plotRect.getWidth() + 0.5;
                }
                else if (this.axis.dimension === 2 /* Y */) {
                    max$$1 = this.axis.parent.plotRect.getHeight() + 0.5;
                }
                if (max$$1 !== undefined) {
                    length = Math.max(1.0, max$$1 - 0.5);
                }
            }
            if (this._binFactor > 1) {
                return this._binFactor / (length / this.number);
            }
            else if (this._binFactor < -1) {
                var calcBinFactor = 1 + this._binFactor / (length / this.number);
                // If we go negative past the size of the bin, we just want to use a binFactor of 0 to keep things sane.
                if (calcBinFactor < 0) {
                    return 0;
                }
                else {
                    return calcBinFactor;
                }
            }
            else {
                // if all else fails, just return a binfactor of 1
                return 1;
            }
        };
        FDSScale.prototype.getBinFactor = function () {
            if (0.0 <= this._binFactor && this._binFactor <= 1.0) {
                return this._binFactor;
            }
            else if (this._binFactor < 0 && this._binFactor >= -1) {
                return 1 + this._binFactor;
            }
            else {
                return this._getBinFactorFromPixelValue();
            }
        };
        FDSScale.prototype.getLabelFormatter = function (formatString) {
            var formatter = new FDSFormat();
            formatter.setNumberFormat(formatString);
            return formatter;
        };
        FDSScale.prototype.getEdgeMinorLabels = function () {
            return [this.minorLabels[0], this.minorLabels[this.minorLabels.length - 1]];
        };
        FDSScale.prototype.getEdgeMajorLabels = function () {
            return [this.labels[0], this.labels[this.labels.length - 1]];
        };
        // checks if there's a gap between these two data points
        // currently only implemented by IntradayScale
        FDSScale.prototype.gapBetweenDatapoints = function (p1, p2) {
            return false;
        };
        FDSScale.prototype.isIndexScale = function () {
            return false;
        };
        return FDSScale;
    }());
    
    var FDSLongScale = /** @class */ (function (_super) {
        __extends(FDSLongScale, _super);
        function FDSLongScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _super.prototype.reset.call(_this);
            return _this;
        }
        FDSLongScale.prototype.adjust = function (dataset) {
            if (dataset == null || dataset.statistics == null) {
                return false;
            }
            if (!this.initialized) {
                this.initialize(dataset);
            }
            else {
                var dsMin = dataset.Min()[0];
                var dsMax = dataset.Max()[0];
                var dsSize = dataset.getSize();
                if (dsMin < this.min) {
                    this.min = dsMin;
                }
                if (dsMax > this.max) {
                    this.max = dsMax;
                }
                if (dsSize > this.number) {
                    this.number = dsSize;
                }
                this._setRanges();
            }
            return true;
        };
        FDSLongScale.prototype.initialize = function (dataset) {
            if ((dataset != null) && dataset.getSize() > 0 && dataset.valid) {
                this.min = dataset.Min()[0];
                this.max = dataset.Max()[0];
                this.number = dataset.getSize();
                this._setRanges();
                this.initialized = true;
                return true;
            }
            return false;
        };
        FDSLongScale.prototype._setRanges = function (usermin, usermax) {
            if (usermin === void 0) { usermin = NAN; }
            if (usermax === void 0) { usermax = NAN; }
            var tempmin = this.min;
            var tempmax = this.max;
            if (!ISNAN(usermin)) {
                tempmin = usermin;
            }
            if (!ISNAN(usermax)) {
                tempmax = usermax;
            }
            var min$$1 = tempmin;
            var max$$1 = tempmax;
            _a = this._threshConsider(min$$1, max$$1), min$$1 = _a[0], max$$1 = _a[1];
            this.outlierMax = tempmax;
            this.outlierMin = tempmin;
            this.setBinSize(min$$1, max$$1);
            this._setThreshold(min$$1, max$$1, true);
            var _a;
        };
        FDSLongScale.prototype._setTickRanges = function (hint) {
            var lowOrder = 0.0;
            var highOrder = 0.0;
            this.logTick = false;
            if (this.supportLog()) {
                lowOrder = FDSLog10(this.threshMin);
                highOrder = FDSLog10(this.threshMax);
            }
            if (highOrder - lowOrder > 1.0) {
                this.logTick = true;
                this.subTickLogMin = Math.floor(lowOrder);
                this.subTickLogOffset = 0.0;
                var value = Math.pow(10.0, this.subTickLogMin);
                while ((value + value * this.subTickLogOffset) < this.threshMin) {
                    this.subTickLogOffset++;
                }
            }
            var order = Math.floor(FDSLog10(this.delta));
            if (order < 1) {
                order = 1;
            }
            var tickOffset = Math.ceil(this.delta / Math.pow(10, order));
            this._computeTickOffsets(tickOffset, order, true);
            this.adjustTickRanges(hint);
        };
        return FDSLongScale;
    }(FDSScale));
    
    var FDSBinScale = /** @class */ (function (_super) {
        __extends(FDSBinScale, _super);
        function FDSBinScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _this.reset();
            return _this;
        }
        /**
         * Determines if the scale needs to be reset based on changes in attributes / data / or other conditions.
         * For FDSBinScale, changes in the "Bin" attribute are ignored
         * @returns false
         */
        FDSBinScale.prototype.needsReset = function () {
            // don't call super since we have different default behavior for the bin attribute.
            return false;
        };
        FDSBinScale.prototype.reset = function () {
            this.initSettings();
            this.setBinned(true);
            this.setTickBinned(true);
            this._initialize(this.min, this.max);
        };
        FDSBinScale.prototype.initialize = function (dataset) {
            return this._initialize(0, Math.max(dataset.getSize() - 1, 0));
        };
        FDSBinScale.prototype._initialize = function (min$$1, max$$1) {
            if (min$$1 < max$$1) {
                this.min = min$$1;
                this.max = max$$1;
            }
            else {
                this.min = max$$1;
                this.max = min$$1;
            }
            this.number = this.max - this.min + 1;
            this._setRanges();
            this.initialized = true;
            return true;
        };
        FDSBinScale.prototype.adjust = function (dataset) {
            return this._adjust(0, Math.max(dataset.getSize() - 1, 0));
        };
        FDSBinScale.prototype.setFixedMode = function () {
            return true;
        };
        FDSBinScale.prototype.lookup = function (value) {
            var offset = 0.0;
            var width = 1.0;
            if (this.getBinned()) {
                offset = this._offset;
                width = this._width;
            }
            if (this.reverse) {
                return 1.0 - (offset + width * (value - this.threshMin) / this.delta);
            }
            else {
                return offset + width * (value - this.threshMin) / this.delta;
            }
        };
        FDSBinScale.prototype._adjust = function (min$$1, max$$1) {
            if (!this.initialized) {
                return this._initialize(min$$1, max$$1);
            }
            else {
                if (min$$1 < max$$1) {
                    if (min$$1 < this.min) {
                        this.min = min$$1;
                    }
                    if (max$$1 > this.max) {
                        this.max = max$$1;
                    }
                }
                else {
                    if (max$$1 < this.min) {
                        this.min = max$$1;
                    }
                    if (min$$1 > this.max) {
                        this.max = min$$1;
                    }
                }
                return this._initialize(this.min, this.max);
            }
        };
        return FDSBinScale;
    }(FDSLongScale));
    
    var HistogramScale = /** @class */ (function (_super) {
        __extends(HistogramScale, _super);
        function HistogramScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _super.prototype.reset.call(_this);
            _this.scaleType = 12 /* HISTOGRAM */;
            _this.shouldCheckLabelsForOverlap = true;
            return _this;
        }
        HistogramScale.prototype.initialize = function (dataset) {
            if (dataset == null || dataset.statistics == null) {
                return false;
            }
            if (dataset.getDimension() < 2) {
                return _super.prototype.initialize.call(this, dataset);
            }
            this.min = _$1.min(dataset.getDataAt(0));
            this.max = _$1.max(dataset.getDataAt(1));
            this.number = dataset.statistics.count;
            this.initialized = true;
            return true;
        };
        // Adjusts the scale to the series' data at the particular dimension
        HistogramScale.prototype.adjust = function (dataset, minOverride, maxOverride) {
            if (this.axis.dimension !== 1 /* X */ || this.axis.associatedSeries[0].drawStyle !== 62 /* HISTOGRAM */) {
                return _super.prototype.adjust.call(this, dataset, minOverride, maxOverride);
            }
            if (!dataset || !dataset.statistics) {
                return false;
            }
            var dim0Data = dataset.getDataAt(0);
            var dim1Data = dataset.getDataAt(1);
            if (!dim0Data || !dim1Data) {
                return _super.prototype.adjust.call(this, dataset, minOverride, maxOverride);
            }
            var dsMin = _$1.min(dim0Data);
            var dsMax = _$1.max(dim1Data);
            this.min = dsMin;
            this.max = dsMax;
            // If maxOverride or minOverride are specified, we use the max/min between dataset and override
            if (_$1.isFinite(maxOverride)) {
                dsMax = Math.max(dsMax, maxOverride);
            }
            if (_$1.isFinite(minOverride)) {
                dsMin = Math.min(dsMin, minOverride);
            }
            if (dsMax > this.max || !this.initialized) {
                this.max = dsMax;
            }
            if (dsMin < this.min || !this.initialized) {
                this.min = dsMin;
            }
            if (dataset.statistics.count > this.number) {
                this.number = dataset.statistics.count;
            }
            // This sets up the min and max scales when using dynamic outliers.
            if (this.dynamicOutliers) {
                var sumOutlierMin = dataset.outlierMin(this.dynamicOutlierThreshold);
                var sumOutlierMax = dataset.outlierMax(this.dynamicOutlierThreshold);
                if ((!IsNA(sumOutlierMin)) && (sumOutlierMin < this.dynamicOutlierMin)) {
                    this.dynamicOutlierMin = sumOutlierMin;
                }
                if ((!IsNA(sumOutlierMax)) && (sumOutlierMax > this.dynamicOutlierMax)) {
                    this.dynamicOutlierMax = sumOutlierMax;
                }
            }
            else {
                dataset.outlierMin(NAN);
                dataset.outlierMax(NAN);
            }
            this._setRanges();
            this.initialized = true;
            return true;
        };
        HistogramScale.prototype._computeLabelVectorInternal = function (plain) {
            if (plain === void 0) { plain = false; }
            if (this.axis.dimension !== 1 /* X */ || this.axis.associatedSeries[0].drawStyle !== 62 /* HISTOGRAM */) {
                _super.prototype._computeLabelVectorInternal.call(this, plain);
                return;
            }
            var histogramDataset = this.axis.associatedSeries[0].getData(1 /* X */);
            var labelValues = [];
            for (var _i = 0, _a = histogramDataset.data; _i < _a.length; _i++) {
                var val = _a[_i];
                labelValues.push(val);
            }
            for (var _b = 0, _c = histogramDataset.getDataAt(1); _b < _c.length; _b++) {
                var val = _c[_b];
                labelValues.push(val);
            }
            labelValues = _$1.uniq(labelValues);
            for (var _d = 0, labelValues_1 = labelValues; _d < labelValues_1.length; _d++) {
                var value = labelValues_1[_d];
                if (value < this.threshMin || value > this.threshMax) {
                    continue;
                }
                var formattedLabel = this._formatLabel(value, plain);
                if (!this._compiledLabelOverride.isEmpty()) {
                    var overrideReturn = this._compiledLabelOverride.fromValueRT({ labelValue: value, formattedLabel: formattedLabel });
                    formattedLabel = overrideReturn;
                }
                if (plain) {
                    this.labels.push([formattedLabel, this.lookup(value), undefined]);
                }
                else {
                    this.labels.push([RichTextString.join(this.labelPrefix, formattedLabel, this.labelPostfix), this.lookup(value), undefined]);
                }
            }
        };
        return HistogramScale;
    }(FDSScale));
    
    var FDSDataStats = /** @class */ (function () {
        function FDSDataStats(dataSet) {
            this.dataSet = dataSet;
            this.init = true;
            this.first = this.last = Number.NaN;
            this.min = this.minFrac = Number.POSITIVE_INFINITY;
            this.max = this.maxFrac = Number.NEGATIVE_INFINITY;
            this.minIndex = 0;
            this.maxIndex = 0;
            this.sum = 0.0;
            this.sumOfAbsoluteVals = 0.0;
            this.mean = 0.0;
            this.variance = Number.NaN;
            this.count = 0;
            this.countValid = 0;
            this.median = Number.NaN;
            this.stddev = Number.NaN;
            this.M2 = 0.0;
            this.computeStatistics();
        }
        FDSDataStats.prototype.computeStatistics = function () {
            if (this.dataSet == null) {
                return false;
            }
            if (this.dataSet.dataType === 'STRING') {
                this.count = this.countValid = this.dataSet.data.length;
                this.min = 0;
                this.max = this.count - 1;
                return true;
            }
            this.count = 0;
            this.countValid = 0;
            this.sum = 0;
            this.sumOfAbsoluteVals = 0;
            var data = (this.dataSet.data);
            var adjustWeekHint;
            if (this.dataSet.dataType === 'DATE' || this.dataSet.dataType === 'DATETIME') {
                adjustWeekHint = function (dataPoint, dataSet) {
                    if (dataSet.weekHint === 0 /* FIVE_DAY */ && FDSDate.isWeekend(dataPoint)) {
                        dataSet.weekHint = 1 /* SEVEN_DAY */;
                    }
                };
            }
            for (var j = 0; j < data.length; j++) {
                // We need to ensure that we're not allowing NAN values through here. Before, we
                // were letting them through and we almost never had correct values below.
                var dataPoint = data[j];
                if (!(IsNA(dataPoint) || ISNAN(dataPoint) || isNaN(dataPoint))) {
                    if (adjustWeekHint != null) {
                        adjustWeekHint(dataPoint, this.dataSet);
                    }
                    this.last = dataPoint;
                    if (dataPoint < this.min) {
                        this.minIndex = j;
                        this.min = dataPoint;
                    }
                    if (dataPoint > this.max) {
                        this.maxIndex = j;
                        this.max = dataPoint;
                    }
                    this.sum += dataPoint;
                    this.sumOfAbsoluteVals += Math.abs(dataPoint);
                    this.countValid++;
                    var frac = dataPoint % 1;
                    if (frac < this.minFrac) {
                        this.minFrac = frac;
                    }
                    if (frac > this.maxFrac) {
                        this.maxFrac = frac;
                    }
                }
                this.count++;
            }
            this.mean = this.sum / this.countValid;
            // calculate standard deviation
            this.M2 = 0;
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var dataPoint = data_1[_i];
                if (!(IsNA(dataPoint) || ISNAN(dataPoint) || isNaN(dataPoint))) {
                    var temp = dataPoint - this.mean;
                    this.M2 += temp * temp;
                }
            }
            this.variance = this.M2 / (this.countValid - 1);
            this.stddev = Math.sqrt(this.variance);
            return this.init = false;
        };
        FDSDataStats.prototype.outlierMax = function (threshold) {
            if (threshold === void 0) { threshold = 1.5; }
            if (this.count <= 0) {
                return NAN;
            }
            // Any threshold less than -1 is bound to -1
            if (threshold < -1) {
                threshold = -1;
            }
            // But any threshold over 1.6 causes dynamic outliers to be simply ignored.
            // We enforce this by returning the maximum statistic plus 1 so that it always bails out.
            if (threshold > 1.6) {
                return this.max + 1;
            }
            return this.mean + this._outlierHelper(threshold);
        };
        FDSDataStats.prototype.outlierMin = function (threshold) {
            if (threshold === void 0) { threshold = 1.5; }
            if (this.count <= 0) {
                return NAN;
            }
            // Any threshold less than -1 is bound to -1
            if (threshold < -1) {
                threshold = -1;
            }
            // But any threshold over 1.6 causes dynamic outliers to be simply ignored.
            // We enforce this by returning the minimum statistic minus 1 so that it always bails out.
            if (threshold > 1.6) {
                return this.min - 1;
            }
            return this.mean - this._outlierHelper(threshold);
        };
        FDSDataStats.prototype._outlierHelper = function (threshold) {
            if (this.count <= 0) {
                return NAN;
            }
            return threshold * Math.sqrt(this.variance);
        };
        FDSDataStats.prototype.update = function (pt) {
            if (!isNaN(pt)) {
                var last$$1 = pt;
                var frac = pt - ~~(pt);
                if (this.init) {
                    this.init = false;
                    this.minIndex = this.maxIndex = 0;
                    this.min = this.max = this.first = this.last = pt;
                    this.minFrac = this.maxFrac = frac;
                    this.mean = 0;
                    this.variance = 0;
                }
                else {
                    if (pt < this.min) {
                        this.min = pt;
                        this.minIndex = this.count + 1;
                    }
                    if (pt > this.max) {
                        this.max = pt;
                        this.maxIndex = this.count + 1;
                    }
                    if (frac < this.minFrac) {
                        this.minFrac = frac;
                    }
                    if (frac > this.maxFrac) {
                        this.maxFrac = frac;
                    }
                }
                this.countValid++;
                var delta = pt - this.mean;
                this.mean += delta / this.countValid;
                this.M2 += delta * delta;
                this.variance = this.M2 / (this.countValid - 1);
                this.sum += pt;
                this.sumOfAbsoluteVals += Math.abs(pt);
            }
            this.count++;
        };
        return FDSDataStats;
    }());
    
    var FDSDataWrapper = /** @class */ (function (_super) {
        __extends(FDSDataWrapper, _super);
        function FDSDataWrapper(opts) {
            if (opts === void 0) { opts = { dataType: null, data: null }; }
            var _this = _super.call(this, opts) || this;
            _this.childrenToCreate = [];
            _this.parents = [];
            if (optsAreDataSet(opts)) {
                _this.initialize();
            }
            else {
                _this._treatAsIndex = opts.treatAsIndex;
                _this._frequency = opts.frequency;
                _this.dataType = opts.dataType;
                console.assert(_this.dataType != null, 'FDSDataWrapper must specify a dataType in the constructor object');
                _this.data = opts.data;
                console.assert(_this.data != null, 'FDSDataWrapper must provide a data array in the constructor object');
                _this.id = (opts.id != null) ? opts.id : null;
                _this.label = (opts.label != null) ? opts.label : _this.id;
                console.assert(opts.children == null || opts.children instanceof Array, 'Children passed to FDSDataWrapper must be an array');
                if (opts.children != null) {
                    _this.childrenToCreate = opts.children;
                }
            }
            return _this;
        }
        FDSDataWrapper_1 = FDSDataWrapper;
        FDSDataWrapper.DataTypeToFlag = function (type) {
            if (typeof type === 'number' && type >= 1 && type <= 8) {
                return type;
            }
            else if (typeof type === 'string') {
                var strType = type.toLowerCase();
                var map$$1 = {
                    'int': 1 /* INT_DATA */,
                    'integer': 1 /* INT_DATA */,
                    'float': 2 /* FLOAT_DATA */,
                    'date': 3 /* DATE_DATA */,
                    'string': 4 /* STRING_DATA */,
                    'single': 5 /* SINGLE_DATA */,
                    'time': 7 /* TIME_DATA */,
                    'datetime': 8 /* DATETIME_DATA */
                };
                if (map$$1[strType] != null) {
                    return map$$1[strType];
                }
            }
            if (ENABLE_DEBUG) {
                console.error("FDSDataWrapper: type " + type + " is invalid!");
            }
            return undefined;
        };
        FDSDataWrapper.prototype._addParent = function (parent) {
            if (!_$1.includes(this.parents, parent)) {
                this.parents.push(parent);
            }
        };
        FDSDataWrapper.prototype._removeParent = function (parent) {
            if (_$1.includes(this.parents, parent)) {
                this.parents.splice(this.parents.indexOf(parent), 1);
            }
        };
        FDSDataWrapper.prototype.initialize = function () {
            if (this._frequency != null) {
                this.setAttribute('Frequency', 'app', this._frequency.toString());
            }
            if (this._treatAsIndex != null) {
                this.setAttribute('TreatAsIndex', 'app', Boolean(this._treatAsIndex));
            }
        };
        /* BEGIN PUBLIC API */
        /**
         * Adds another dimension to this dataset.
         * @param {string} label - Label of the new dimension to add.
         * @param {(number[]|string[])} newData - An array of new data to pass. Ideally, this should be the same length as
         *   data already in the dataset.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.addDimension = function (label, newData) {
            this._chartObject.add(label, newData);
            return this;
        };
        /**
         * Returns the number of dimensions that a dataset represents. For example, if a dataset contains 'open', 'high',
         * 'low', and 'close' values, getNumDimensions() will return '4'.
         * @return {number} The cardinality of the dataset.
         */
        FDSDataWrapper.prototype.getNumDimensions = function () {
            return this._chartObject.getDimension();
        };
        /**
         * Replaces the data in the internal array of given dimension. If newData is shorter then it only replaces the first
         * n items, where n is the length of newData.
         * @param {number} dimension - Which dimension to replace.
         * @param {(number[]|string[])} newData - An array to replace the internal array.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.replace = function (dimension, newData) {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            this._chartObject.objectAction('Replace', dimension, newData);
            return this;
        };
        /**
         * Replaces the last n points in the internal arrays of the dataset. n is the size of the newData.
         * @param {number} dimension - Which dimension to replace.
         * @param {(number[]|string[])} newData - New array of data.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.replaceLast = function (dimension, newData) {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            this._chartObject.objectAction('ReplaceLast', dimension, newData);
            return this;
        };
        /**
         * Appends new data to the end of the internal array.
         * @param {number} dimension - Which dimension to append to.
         * @param {(number[]|string[])} newData - Data to append.
         * @param {boolean} [replaceLast=false] - whether or not to replace the last point.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.append = function (dimension, newData, replaceLast) {
            if (replaceLast === void 0) { replaceLast = false; }
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            var action = replaceLast ? 'AppendLast' : 'Append';
            this._chartObject.objectAction(action, dimension, newData);
            return this;
        };
        /**
         * Prepends data to the specified dimension.
         * @param {number} dimension - Which dimension to prepend.
         * @param {(number[]|string[])} newData - Data to prepend.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.prepend = function (dimension, newData) {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            this._chartObject.objectAction('Prepend', dimension, newData);
            return this;
        };
        /**
         * Gets an array of data at the given dimention.
         * @param {number} dimension - Which dimension to fetch.
         * @returns {(number[]|string[])} An array of data corresponding to that dimension.
         */
        FDSDataWrapper.prototype.getData = function (dimension) {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            var ret = this._chartObject.getDataAt(dimension);
            return ret;
        };
        /**
         * Gets the value of each dimension of the dataset at the given index.
         * @param {number} index - The index of the dataset point to be retrieved.
         * @return {(number[]|string[])} An array where each index in the array corresponds to a dimension.
         */
        FDSDataWrapper.prototype.getPoint = function (index) {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            var _a = this._chartObject.objectAction('GetPoint', index), handled = _a[0], ret = _a[1], err = _a[2];
            return ret;
        };
        /**
         * Deletes the value of each dimension of the dataset at the given index.
         * @param {Number} index - The index of the dataset point to be deleted.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.deletePoint = function (index) {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            this._chartObject.objectAction('DeletePoint', index);
            return this;
        };
        /**
         * Replaces the value of each dimension of the dataset at the given index with the provided data.
         * @param {number} index - The index of the dataset point to be replaced.
         * @param {(number[]|string[])} point - The new array of values. Each index in the array corresponds to the
         *   dimension of the point to replace.
         * @param {boolean} [allowGrow=false] - Whether or not we should allow growing of the internal arrays.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.replacePoint = function (index, point, allowGrow) {
            if (allowGrow === void 0) { allowGrow = false; }
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            var action = allowGrow ? 'ReplacePointGrow' : 'ReplacePoint';
            this._chartObject.objectAction(action, index, point);
            return this;
        };
        /**
         * Empties the internal arrays of each dimension.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.deleteAll = function () {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            this._chartObject.objectAction('DeleteAll');
            return this;
        };
        /**
         * Empties the dataset's data array.
         * @return {Object} The dataset wrapper instance, for chainability.
         */
        FDSDataWrapper.prototype.deleteSelf = function () {
            console.assert((this._chartObject != null) && (this.attached != null), 'Dataset is not attached or in a bad state');
            this._chartObject.objectAction('DeleteSelf');
            return this;
        };
        FDSDataWrapper.prototype.getParents = function () {
            return this.parents.slice();
        };
        /* END PUBLIC API */
        FDSDataWrapper.prototype.addParent = function (series) {
            this.parents.push(series);
        };
        FDSDataWrapper.prototype.addToChart = function (chart) {
            if (this.attached) {
                return;
            }
            if (this.id == null) {
                this.setId(chart.getNextDataId());
            }
            FDSChartObjectWrapper.unwrap(chart)
                .addObject(this.id, 1 /* FC_DATA */, FDSDataWrapper_1.DataTypeToFlag(this.dataType), this.label, this.data, this);
            console.assert((chart.getObjectById(this.id) != null), "FDSDataWrapper failed to attach data " + this.id + " to the chart");
            this._chartObject = FDSChartObjectWrapper.unwrap(chart).objects[this.id];
            this.addChildrenToChart(chart);
            this.attached = true;
            this.initialize();
            this.chart = chart;
        };
        FDSDataWrapper.prototype.addChildrenToChart = function (chart) {
            var childrenIDs = [];
            var childArr;
            while (childArr = this.childrenToCreate.shift()) {
                var nextID = chart.getNextDataId();
                childrenIDs.push(nextID);
                FDSChartObjectWrapper.unwrap(chart)
                    .addObject(nextID, 1 /* FC_DATA */, FDSDataWrapper_1.DataTypeToFlag(this.dataType), this.label, childArr);
                console.assert(chart.getObjectById(this.id) != null, "FDSDataWrapper failed to attach data " + nextID + " to the chart");
            }
            this._chartObject.setChildren(childrenIDs);
        };
        FDSDataWrapper.prototype.removeFromChart = function (chart, deleteChildren) {
            if (deleteChildren === void 0) { deleteChildren = false; }
            var deleteFlag = deleteChildren ? 1 /* DELETE_WITH_CHILD */ : 0;
            FDSChartObjectWrapper.unwrap(chart).deleteObject(this.id, deleteFlag);
            this._chartObject = null;
            this.chart = null;
            this.attached = false;
            this.parents = [];
        };
        FDSDataWrapper.prototype.removeFromSeries = function (chart, series, deleteChildren) {
            if (deleteChildren === void 0) { deleteChildren = false; }
            console.assert(this.parents.indexOf(series) >= 0, "Cannot remove dataset " + this.id + " from series " + series.id + " because it is not a child of it!");
            ArrayUtils.remove(this.parents, series);
            FDSChartObjectWrapper.unwrap(chart).unsetChildren(series.id, this.id);
            var deleteFlag = deleteChildren ? 1 /* DELETE_WITH_CHILD */ : 0;
            if (this.parents.length === 0) {
                FDSChartObjectWrapper.unwrap(chart).deleteObject(this.id, deleteFlag);
            }
            if (this.parents.length === 0 && (chart.getObjectById(this.id) != null)) {
                this._chartObject = null;
                this.attached = false;
                this.chart = null;
            }
        };
        FDSDataWrapper.prototype.getSize = function () {
            return this._chartObject.getSize();
        };
        FDSDataWrapper.prototype.getDataChildren = function () {
            var objs = this._chartObject.getChildList();
            return Object.keys(objs).map(function (key) { return objs[key].wrapper; });
        };
        FDSDataWrapper.prototype.getChildDataById = function (id) {
            var child = this._chartObject.children[id];
            return child ? child.wrapper : undefined;
        };
        FDSDataWrapper.prototype.getChildDataByIndex = function (index) {
            var id = this._chartObject.childIds[index];
            return id != null ? this.getChildDataById(id) : undefined;
        };
        FDSDataWrapper.prototype.on = function (type, cb) {
            if (ENABLE_DEBUG) {
                console.error('FDSDataWrapper does not support event binding');
            }
            return this;
        };
        FDSDataWrapper.selector = 'FDSDataWrapper';
        FDSDataWrapper = FDSDataWrapper_1 = __decorate([
            FDSChartObjectWrapperLogDecorator
        ], FDSDataWrapper);
        return FDSDataWrapper;
        var FDSDataWrapper_1;
    }(FDSChartObjectWrapper));
    var optsAreDataSet = function (opts) {
        return isChartObject(opts) && isDataSet(opts);
    };
    
    var FDSIndexScale = /** @class */ (function (_super) {
        __extends(FDSIndexScale, _super);
        function FDSIndexScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _this.bin = true;
            _this.setTickBinned(true);
            _this.tickOffset = 1;
            return _this;
        }
        // Value here refers to the index of the data, not the value itself.
        FDSIndexScale.prototype._formatLabel = function (value, plain) {
            if (IsSomeInternalNAN(value)) {
                return null;
            }
            var format = this.formatString;
            // Process a conditional formatting string.
            if ((this.parseList != null) && this.parseList.length > 0) {
                format = this.formatParser.applyParsedList(this.parseList, value);
            }
            // Process a formatting property string.
            if (!this.isLabelFormatDefault) {
                format = this.parentPropertySet.compilePropertyString(format).fromValue();
            }
            var formatter = this.labelFormatters[format];
            if (formatter != null) {
                var formattedString = formatter.formatAsType(value, this._dataset.dataType);
                return new RichTextString(formattedString);
            }
            else {
                return new RichTextString(value.toString());
            }
        };
        FDSIndexScale.prototype.initialize = function (dataset) {
            this.init(dataset);
            return _super.prototype.initialize.call(this, dataset);
        };
        FDSIndexScale.prototype.init = function (dataset) {
            this._dataset = dataset;
            this.min = this.max = 0;
            this.number = 1;
            this._labelVec = [];
            this._initInternal(this._dataset);
        };
        FDSIndexScale.prototype._setTickRanges = function (hint) {
            this._setLogTickRanges(true);
            var order = ~~((FDSLog10(this.delta)));
            if (order < 1) {
                order = 1;
            }
            var tickOffset = Math.ceil(this.delta / Math.pow(10, order));
            this._computeTickOffsets(tickOffset, order, false);
            this.adjustTickRanges(hint);
        };
        FDSIndexScale.prototype._setRanges = function (usermin, usermax) {
            if (usermin === void 0) { usermin = NAN; }
            if (usermax === void 0) { usermax = NAN; }
            var min$$1 = usermin !== NAN ? usermin : this.min;
            var max$$1 = usermax !== NAN ? usermax : this.max;
            // thresh consider and outlier stuff
            this.setBinSize(min$$1, max$$1);
            this._setThreshold(min$$1, max$$1, true);
        };
        FDSIndexScale.prototype.computeLabelVector = function () {
            this._initLabelVector();
            this._computeMajorLabels();
            this._computeMinorLabels();
        };
        FDSIndexScale.prototype._initLabelVector = function () {
            this.labels = [];
            this.minorLabels = [];
            this._label = 0;
            this.padLength = -1;
            // Resolve any properties on the format string.
            var formatString = (this.parentPropertySet.compilePropertyString(this.formatString)).fromValue();
            this._setFormatByType(formatString);
            this.labelFormatters[formatString] = this.format;
            this.subTickLogMag = this.subTickLogMin;
            // Reparse the format and reformat the labels whenever the format changes.
            if (this.formatString !== this.oldFormat) {
                this.oldFormat = this.formatString;
                this.parseList = this.formatParser.parseConditionalFormat(this.formatString);
                var formats = this.formatParser.getAllFormatsFromParsedList(this.parseList);
                this._createLabelFormatParsers(formats);
                this._reformatLabels();
            }
        };
        FDSIndexScale.prototype._setFormatByType = function (formatString) {
            switch (this._dataset.dataType) {
                case 'INT':
                case 'SINGLE':
                case 'INTEGER':
                case 'FLOAT':
                    this.format.setNumberFormat(formatString);
                case 'DATE':
                    this.format.setDateFormat(formatString);
                    break;
                case 'DATETIME':
                    this.format.setDateTimeFormat(formatString);
                    break;
                case 'TIME':
                    this.format.setTimeFormat(formatString);
                    break;
                default:
                    break;
            }
        };
        FDSIndexScale.prototype._computeMajorLabels = function () {
            if ((this.axis.labelsLevelsMask & 2 /* MAJOR */) === 0) {
                return;
            }
            var placementInfo = this._getLabelPlacementInfo(this.tickMin, this._adjustedTickOffset());
            for (var _i = 0, placementInfo_1 = placementInfo; _i < placementInfo_1.length; _i++) {
                var _a = placementInfo_1[_i], index = _a.index, binStartNdc = _a.binStartNdc, binEndNdc = _a.binEndNdc;
                var formattedLabel = (this._labelVec[index]) ? this._labelVec[index].text : RichTextString.Empty;
                if (!this._compiledLabelOverride.isEmpty()) {
                    var overrideReturn = this._compiledLabelOverride.fromValueRT({ labelValue: index, formattedLabel: formattedLabel });
                    formattedLabel = overrideReturn;
                }
                var labelPosNdc = void 0;
                if (this.getLabelBinned()) {
                    labelPosNdc = binStartNdc;
                }
                else {
                    labelPosNdc = (binStartNdc + binEndNdc) / 2;
                }
                if (isBounded(labelPosNdc, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                    this.labels.push([formattedLabel, labelPosNdc, undefined]);
                }
            }
        };
        FDSIndexScale.prototype._getSubBinCount = function () {
            var _a = this.axis.parent.getXYBins(), horizontalBinCount = _a[0], verticalBinCount = _a[1];
            if (this.axis.dimension === 1 /* X */) {
                return horizontalBinCount;
            }
            else if (this.axis.dimension === 2 /* Y */) {
                return verticalBinCount;
            }
            else {
                return 0;
            }
        };
        FDSIndexScale.prototype._computeMinorLabels = function () {
            var subBinCount = this._getSubBinCount();
            if (subBinCount <= 0 || (this.axis.labelsLevelsMask & 1 /* MINOR */) === 0) {
                return;
            }
            var placementInfoArray = this._getLabelPlacementInfo(this.subTickMin, this._adjustedSubTickOffset());
            this.minorLabels = [];
            var subLabels = this.axis.subBinLabels;
            for (var _i = 0, placementInfoArray_1 = placementInfoArray; _i < placementInfoArray_1.length; _i++) {
                var labelPlacementInfo = placementInfoArray_1[_i];
                var padding = BaseRectangularDrawStyle.getInnerBinPaddingAsNdc(this.axis, labelPlacementInfo);
                for (var binNumber = 0; binNumber < subBinCount; binNumber++) {
                    var _a = BaseRectangularDrawStyle.getSubBinPosition(binNumber, subBinCount, labelPlacementInfo, padding), subBinStartNdc = _a.subBinStartNdc, subBinEndNdc = _a.subBinEndNdc;
                    var labelPositionNdc = (subBinStartNdc + subBinEndNdc) / 2;
                    var labelPropertyString = subLabels[binNumber] || this.axis.subBinLabelsDefault;
                    var labelText = labelPropertyString.fromValueRT({ labelValue: binNumber });
                    if (!labelText.isEmpty()) {
                        this.minorLabels.push([labelText, labelPositionNdc, undefined]);
                    }
                }
            }
        };
        FDSIndexScale.prototype._getLabelPlacementInfo = function (tickMin, tickOffset) {
            tickOffset = ~~Math.max(1, tickOffset);
            tickMin = ~~tickMin;
            var placementInfo = [];
            for (var count = 0; count < this.number; count++) {
                var index = tickMin + count * tickOffset;
                var _a = _super.prototype.lookupRange.call(this, index), ndc = _a[0], binStartNdc = _a[1], binEndNdc = _a[2], binFactorOffsetNdc = _a[3];
                if (isBounded(ndc, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                    placementInfo.push({ index: index, binStartNdc: binStartNdc, binEndNdc: binEndNdc, binFactorOffsetNdc: binFactorOffsetNdc });
                }
                else {
                    break;
                }
            }
            return placementInfo;
        };
        FDSIndexScale.prototype.reset = function () {
            this.initSettings();
            this.setBinned(true);
            this.setTickBinned(true);
            this.setTickOffset(1);
            this._setRanges();
        };
        FDSIndexScale.prototype._reformatLabels = function () {
            for (var _i = 0, _a = this._labelVec; _i < _a.length; _i++) {
                var label = _a[_i];
                var data = label.data;
                // We don't worry about string data here because LabelFormat does not affect them.
                if (_$1.isNumber(data)) {
                    label.text = this._formatLabel(data);
                }
            }
        };
        FDSIndexScale.prototype._addStringsFromData = function (dataset) {
            for (var i = 0; i < dataset.getSize(); i++) {
                var labelText = void 0;
                var dataVal = dataset.data[i];
                if (_$1.isNumber(dataVal)) {
                    labelText = this._formatLabel(dataVal);
                }
                else {
                    var str = dataset.printAt(i);
                    if (IsSomeInternalNAN(str)) {
                        return;
                    }
                    labelText = this.axis.properties.compilePropertyString(str).fromValueRT();
                }
                this._labelVec.push({ text: labelText, data: dataVal });
            }
        };
        FDSIndexScale.prototype._initInternal = function (dataset) {
            if (!dataset) {
                return false;
            }
            var size = dataset.getSize();
            if (size > 0 && dataset.valid) {
                this.min = 0;
                this._addStringsFromData(dataset);
                this.number = this._labelVec.length;
                this.max = this.number - 1;
                this.initialized = true;
            }
            this._setRanges();
            return this.initialized;
        };
        FDSIndexScale.prototype.setFixedMode = function (threshMin, threshMax, hint) {
            return true;
        };
        FDSIndexScale.prototype._shouldReInit = function (dataset) {
            // index scale needs to adjust to new dataset if its longer than our current dataset
            return this._dataset != null && this._dataset.getSize() < dataset.getSize();
        };
        FDSIndexScale.prototype.adjust = function (dataset) {
            if (!dataset) {
                return false;
            }
            var reinit = this._shouldReInit(dataset);
            if (!this.initialized) {
                this.init(dataset);
            }
            else if (reinit) {
                this._initInternal(dataset);
            }
            this.initialized = true;
            return true;
        };
        FDSIndexScale.prototype._setThreshold = function (min$$1, max$$1, ticks) {
            // The PC-side lookup scale truncates the threshold arguments when
            // it casts them to `long`s, so we'll do the same thing here.
            min$$1 = ~~min$$1;
            max$$1 = ~~max$$1;
            _super.prototype._setThreshold.call(this, min$$1, max$$1, ticks);
            this.setBinSize(min$$1, max$$1);
        };
        FDSIndexScale.prototype.computeValue = function (ndc) {
            if (this.outlierEnabled()) {
                return this.computeOutlierValue(ndc);
            }
            var offset = 0;
            var width = 1;
            if (this.bin) {
                offset = this._offset;
                width = this._width;
            }
            if (this.reverse) {
                ndc = 1.0 - ndc;
            }
            return Math.floor(ndc * this.delta / width + this.threshMin);
        };
        FDSIndexScale.prototype.setBinSize = function (dMin, dMax) {
            var count = ~~((dMax - dMin) + 1);
            this._offset = 1.0 / count;
            this._width = 1.0 - this._offset;
            if (this._width <= 0) {
                this._width = 1.0;
            }
            this._offset *= 0.5;
            var delta = Math.max(dMax, dMin) - Math.min(dMax, dMin);
            if (delta <= 0.0) {
                delta = 1.0;
            }
            this._goffset = delta / count;
            this._gwidth = delta - this._goffset;
            if (this._gwidth <= 0.0) {
                this._gwidth = 1.0;
            }
            this._goffset *= (0.5 / this._width);
        };
        FDSIndexScale.prototype.isIndexScale = function () {
            return true;
        };
        return FDSIndexScale;
    }(FDSLongScale));
    
    var FDSLookupScale = /** @class */ (function (_super) {
        __extends(FDSLookupScale, _super);
        function FDSLookupScale(root, id, axis) {
            return _super.call(this, root, id, axis) || this;
        }
        FDSLookupScale.prototype.getLog = function () {
            return false;
        };
        FDSLookupScale.prototype.supportLog = function () {
            return false;
        };
        FDSLookupScale.prototype.init = function (dataset) {
            this._dataset = dataset;
            this._labelMap = {};
            _super.prototype.init.call(this, this._dataset);
        };
        FDSLookupScale.prototype.getIndexFromString = function (key) {
            return this._labelMap[key];
        };
        FDSLookupScale.prototype.getStringFromIndex = function (index) {
            for (var key in this._labelMap) {
                var value = this._labelMap[key];
                if (value === index) {
                    return key;
                }
            }
            return null;
        };
        FDSLookupScale.prototype.lookup = function (value) {
            // External consumers of the scale might pass in a string value here,
            // e.g. an item from a dataset, in which case we need to convert it to an
            // index. Internal consumers, such as label and tick generation
            // functions, will use a value instead, which we don't want to convert.
            if (typeof value === 'string') {
                value = this._labelMap[value]; // type assertion needed since control flow dictates value is type never.
            }
            return _super.prototype.lookup.call(this, value);
        };
        FDSLookupScale.prototype.lookupRange = function (value) {
            var numVal;
            if (typeof value === 'string') {
                numVal = this._labelMap[value];
            }
            else {
                numVal = value;
            }
            return _super.prototype.lookupRange.call(this, numVal);
        };
        FDSLookupScale.prototype._shouldReInit = function (dataset) {
            // Lookup scale needs to always adjust to new dataset to add any new strings to the labelVec
            // its behavior aggregates strings across all datasets, so we return true here
            return true;
        };
        FDSLookupScale.prototype._addStringsFromData = function (dataset) {
            for (var _i = 0, _a = dataset.data; _i < _a.length; _i++) {
                var data = _a[_i];
                if (IsSomeInternalNAN(data)) {
                    continue;
                }
                var str = data.toString();
                if (this._labelMap[str] != null) {
                    continue;
                }
                this._labelMap[str] = this._labelVec.length;
                var label = this.axis.properties.compilePropertyString(str).fromValueRT();
                this._labelVec.push({ text: label, data: str });
            }
        };
        return FDSLookupScale;
    }(FDSIndexScale));
    
    var FDSTime = /** @class */ (function (_super) {
        __extends(FDSTime, _super);
        function FDSTime(weekType, clockType) {
            if (weekType === void 0) { weekType = 1 /* SEVEN_DAY */; }
            if (clockType === void 0) { clockType = 1 /* CT_12_HOUR */; }
            var _this = _super.call(this, weekType, clockType) || this;
            _this._dayBegins = 0.0;
            _this._dayEnds = 1.0;
            return _this;
        }
        FDSTime.prototype.getBeginningOfDay = function () {
            return this._dayBegins;
        };
        FDSTime.prototype.getEndOfDay = function () {
            return this._dayEnds;
        };
        FDSTime.getTimeFrac = function (daytime) {
            return (daytime === 1.0) ? 1.0 : daytime - (~~daytime);
        };
        FDSTime.makeTimeStd = function (hour, minute, second) {
            return (hour * 3600 + minute * 60 + second) / 86400.0;
        };
        FDSTime.makeDayTimeStd = function (date, hour, minute, second) {
            return ~~date + (FDSTime.makeTimeStd(hour, minute, second));
        };
        // For some reason, we need to alias these functions to maintain
        // parity with PC-side.
        // returns [week, start, end]
        FDSTime.prototype.getWeekStd = function (date) {
            return this.getWeekRange(~~date);
        };
        FDSTime.prototype.getMonthStd = function (date) {
            return this.getMonthRange(~~date);
        };
        FDSTime.prototype.getQuarterStd = function (date) {
            return this.getQuarterRange(~~date);
        };
        FDSTime.prototype.getHalfYearStd = function (date) {
            return this.getHalfYearRange(~~date);
        };
        FDSTime.prototype.getYearStd = function (date) {
            return this.getYearRange(~~date);
        };
        // returns [hour, minute, second]
        FDSTime._getTimeStd = function (daytime) {
            return [
                (this._getHourStd(daytime)),
                (this._getMinuteStd(daytime)),
                (this._getSecondStd(daytime))
            ];
        };
        FDSTime._getHourStd = function (daytime) {
            return ~~((FDSTime.getTimeFrac(daytime)) * 24 + 0.0001);
        };
        FDSTime._getMinuteStd = function (daytime) {
            return (~~((FDSTime.getTimeFrac(daytime)) * 24 * 60 + 0.001)) % 60;
        };
        FDSTime._getSecondStd = function (daytime) {
            return (~~((FDSTime.getTimeFrac(daytime)) * 24 * 3600 + 0.5)) % 60;
        };
        FDSTime.prototype.nHoursStd = function (dstart, dend) {
            return (~~(FDSTime.getTimeFrac(dend) - FDSTime.getTimeFrac(dstart))) * 24;
        };
        FDSTime.prototype.nMinutesStd = function (dstart, dend) {
            return ~~((FDSTime.getTimeFrac(dend) - FDSTime.getTimeFrac(dstart)) * 24 * 60);
        };
        FDSTime.prototype.nSecondsStd = function (dstart, dend) {
            return ~~((FDSTime.getTimeFrac(dend) - FDSTime.getTimeFrac(dstart)) * 24 * 3600);
        };
        FDSTime.prototype.convToTimeStd = function (time) {
            if (time > 1) {
                time = FDSTime.makeTimeStd(~~(time / 10000), (~~(time / 100.0)) % 100, (~~time) % 100);
            }
            return time;
        };
        // returns [day, start, end]
        FDSTime.prototype.getDayStd = function (datetime) {
            var start = this.adjustUp(~~datetime);
            var end = this.adjustUp((~~(start + 1)));
            return [(~~start), start, end];
        };
        FDSTime.prototype.adjustStd = function (dateTime) {
            var timeFrac = FDSTime.getTimeFrac(dateTime);
            var min$$1 = this.getBeginningOfDay();
            var max$$1 = this.getEndOfDay();
            timeFrac = timeFrac < min$$1 ? min$$1 : timeFrac;
            timeFrac = timeFrac > max$$1 ? max$$1 : timeFrac;
            var adjustedDate = this.adjust((~~dateTime));
            if (adjustedDate !== (~~dateTime)) {
                timeFrac = min$$1;
            }
            return adjustedDate + timeFrac;
        };
        FDSTime.prototype.adjustUpStd = function (dateTime) {
            var timeFrac = FDSTime.getTimeFrac(dateTime);
            var min$$1 = this.getBeginningOfDay();
            var max$$1 = this.getEndOfDay();
            timeFrac = timeFrac < min$$1 ? min$$1 : timeFrac;
            if (timeFrac > max$$1) {
                dateTime++;
                timeFrac = min$$1;
            }
            var adjustedDate = this.adjustUp(~~dateTime);
            if (adjustedDate !== (~~dateTime)) {
                timeFrac = min$$1;
            }
            return adjustedDate + timeFrac;
        };
        FDSTime.prototype.numericToJulianStd = function (daytime) {
            var day = this.numericToJulian((~~daytime));
            var tfrac = FDSTime.getTimeFrac(daytime);
            return day + tfrac;
        };
        FDSTime.prototype.julianStdToNumeric = function (daytime) {
            var day = this.julianToNumeric((~~daytime));
            var tfrac = FDSTime.getTimeFrac(daytime);
            return day + tfrac;
        };
        FDSTime.prototype.compressTimeStd = function (datetime, t_min, t_max) {
            var ctime = 0.0;
            var delta = Math.abs(t_max - t_min);
            if (delta !== 0.0) {
                ctime = (datetime - t_min) / delta;
            }
            return clamp(ctime, 0.0, 1.0);
        };
        FDSTime.prototype.decompressTimeStd = function (cdatetime, t_min, t_max) {
            var ctime = t_min;
            var delta = Math.abs(t_max - t_min);
            if (delta !== 0.0) {
                ctime = (cdatetime * delta + t_min);
            }
            return clamp(ctime, 0.0, 1.0);
        };
        FDSTime.prototype.compressStd = function (datetime) {
            var jdate = ~~datetime;
            var d_min = this.getBeginningOfDay();
            var d_max = this.getEndOfDay();
            var timefrac = this.compressTimeStd(FDSTime.getTimeFrac(datetime), d_min, d_max);
            if (this.weekType === 0 /* FIVE_DAY */) {
                if (FDSDate.isWeekend(jdate)) {
                    timefrac = 0.0;
                }
                jdate = this.compress(jdate);
            }
            return jdate + timefrac;
        };
        FDSTime.prototype.compressUpStd = function (datetime) {
            var jdate = ~~datetime;
            var d_min = this.getBeginningOfDay();
            var d_max = this.getEndOfDay();
            var timefrac = this.compressTimeStd(FDSTime.getTimeFrac(datetime), d_min, d_max);
            if (this.weekType === 0 /* FIVE_DAY */) {
                if (FDSDate.isWeekend(jdate)) {
                    timefrac = 0.0;
                }
                jdate = this.compressUp(jdate);
            }
            return jdate + timefrac;
        };
        FDSTime.prototype.decompressStd = function (datetime) {
            var jdate = ~~datetime;
            if (this.weekType === 0 /* FIVE_DAY */) {
                jdate = (~~(jdate / 5)) * 7 + jdate % 5 + 2;
            }
            var d_min = this.getBeginningOfDay();
            var d_max = this.getEndOfDay();
            var timefrac = this.decompressTimeStd(FDSTime.getTimeFrac(datetime), d_min, d_max);
            return jdate + timefrac;
        };
        FDSTime.prototype.setBeginningOfDay = function (time) {
            var dayBegins = 0.0;
            var dayEnds = this.getEndOfDay();
            if (NOTNAN(time)) {
                dayBegins = this.convToTimeStd(time);
            }
            if (dayEnds < dayBegins) {
                dayEnds = dayBegins;
            }
            this._dayBegins = dayBegins;
            return this._dayEnds = dayEnds;
        };
        FDSTime.prototype.setDay = function (dayBegins, dayEnds) {
            dayBegins = dayBegins != null ? this.convToTimeStd(dayBegins) : this.getBeginningOfDay();
            dayEnds = dayEnds != null ? this.convToTimeStd(dayEnds) : this.getEndOfDay();
            if (dayEnds < dayBegins) {
                _a = [dayBegins, dayEnds], dayEnds = _a[0], dayBegins = _a[1];
            }
            this._dayBegins = dayBegins;
            return this._dayEnds = dayEnds;
            var _a;
        };
        FDSTime.prototype.setEndOfDay = function (time) {
            var dayBegins = this.getBeginningOfDay();
            var dayEnds = 1.0;
            if (time != null) {
                dayEnds = this.convToTimeStd(time);
            }
            if (dayEnds < dayBegins) {
                dayBegins = dayEnds;
            }
            this._dayBegins = dayBegins;
            return this._dayEnds = dayEnds;
        };
        FDSTime.prototype.getTimeBinStd = function (day, bin) {
            var timeFrac = FDSTime.getTimeFrac(day);
            var daySeconds = this.nSecondsStd(0.0, timeFrac);
            var binSeconds = this.nSeconds(0, bin);
            return ~~(daySeconds / (binSeconds > 0 ? binSeconds : 1));
        };
        // returns [bin, start, end]
        FDSTime.prototype.getTimeBinStdRange = function (day, bin) {
            var ret = this.getTimeBinStd(day, bin);
            var binSeconds = this.nSeconds(0, bin);
            var start = FDSTime.makeDayTimeStd((~~day), 0, 0, ret * (binSeconds === 0 ? 1 : binSeconds));
            var end = FDSTime.makeDayTimeStd((~~day), 0, 0, (binSeconds === 0 ? ret : ret * binSeconds + binSeconds - 1));
            return [ret, start, end];
        };
        FDSTime.prototype.nTimeBinsStd = function (bin, dstart, dend) {
            var ret = 0.0;
            var start = ~~dstart;
            var end = ~~dend;
            if (end > start) {
                start++;
                ret = (this.getTimeBinStd(this.getEndOfDay(), bin)) - (this.getTimeBinStd(dstart, bin));
                ret += ((this.getTimeBinStd(this.getEndOfDay(), bin)) - (this.getTimeBinStd(this.getBeginningOfDay(), bin))) *
                    (end - start);
                ret += (this.getTimeBinStd(dend, bin)) - (this.getTimeBinStd(this.getBeginningOfDay(), bin));
            }
            else {
                ret = (this.getTimeBinStd(dend, bin)) - (this.getTimeBinStd(dstart, bin));
            }
            if (ret > Number.MAX_VALUE) {
                ret = 0.0;
            }
            return ~~ret;
        };
        FDSTime.prototype.adjustTimeStd = function (day, seconds) {
            return day + (seconds / 86400);
        };
        // Takes in a standard time and returns the amount of seconds.
        FDSTime.prototype.getSecondsFromTimeStd = function (time) {
            var _a = FDSTime._getTimeStd(time), hour = _a[0], minute = _a[1], second = _a[2];
            return (hour * 3600) + (minute * 60) + second;
        };
        // Returns HHMMSS time based on ndc position in max/min (HHMMSS) range.
        FDSTime.prototype.getTimeInRange = function (ndc, maxTime, minTime) {
            // Convert our times over to standard format.
            var stdMax = this.convToTimeStd(maxTime);
            var stdMin = this.convToTimeStd(minTime);
            // Find the amount of seconds in each time stamp.
            var maxSeconds = this.getSecondsFromTimeStd(stdMax);
            var minSeconds = this.getSecondsFromTimeStd(stdMin);
            // Find the amount of seconds at our point in the range.
            var finalTimeInSeconds = (ndc * (maxSeconds - minSeconds)) + minSeconds;
            // Finally, build back up the time in the original format, and return it.
            var finalHour = (~~(finalTimeInSeconds / 3600)) * 10000;
            var finalMinute = (~~(finalTimeInSeconds % 3600 / 60)) * 100;
            var finalSecond = ~~(finalTimeInSeconds % 60);
            return finalHour + finalMinute + finalSecond;
        };
        FDSTime.prototype.buildTimeFromSeconds = function (timeInSeconds) {
            var hour = (~~(timeInSeconds / 3600)) * 10000;
            var minute = (~~(timeInSeconds % 3600 / 60)) * 100;
            var second = ~~(timeInSeconds % 60);
            return hour + minute + second;
        };
        // helper function to add an offset datetime to an existant datetime
        // @param date [Number] the date being added to, represented in Julian format
        // @param offset [Number] the offset date being added, represented in Julian format
        // @return [Number] the resultant sum
        FDSTime.prototype.addOffsetNumber = function (date, offset) {
            var _a = FDSDate.getDate(offset), offY = _a[0], offM = _a[1], offD = _a[2];
            var offTime = offset % 1; // the decimal part
            return this.addOffsetVariables(date, offY, offM, offD, offTime);
        };
        FDSTime.prototype.addOffsetVariables = function (date, offY, offM, offD, offTime) {
            // get the decimal part because dateMath ignores it
            return FDSDate.dateMath(date, offY, offM, offD) + offTime;
        };
        // Expects an object with 'years', 'months', 'days', and 'time' fields
        FDSTime.prototype.addOffsetObject = function (date, obj) {
            return this.addOffsetVariables(date, obj.years, obj.months, obj.days, obj.time);
        };
        // function to make a datetime out of six bits of info
        FDSTime.makeDateTime = function (year, month, day, hour, min$$1, sec) {
            return FDSDate.getJulian(year, month, day) + FDSTime.makeTimeStd(hour, min$$1, sec);
        };
        // function to get an array [year, month, day, hour, min, second] out of one datetime number
        FDSTime.getDateTimeArray = function (datetime) {
            return FDSDate.getDate(datetime)
                .concat(FDSTime._getTimeStd(datetime));
        };
        return FDSTime;
    }(FDSDate));
    
    var FDSDataSet = /** @class */ (function (_super) {
        __extends(FDSDataSet, _super);
        function FDSDataSet(root, id, wrapper) {
            var _this = _super.call(this, root, id, 1 /* FC_DATA */) || this;
            _this._date = new FDSDate();
            _this._time = new FDSTime();
            _this.needTime = true;
            _this._dateBin = 14 /* DAY */;
            _this._timeBin = 0 /* NONE */;
            _this.weekHint = 0 /* FIVE_DAY */;
            _this._frequency = 'D';
            _this.compiledFormat = _this.properties.compilePropertyString('');
            _this._formatObject = new FDSFormat();
            _this.sorted = true;
            _this.ascending = true;
            _this.valid = false;
            _this.data = [];
            _this.childIds = [];
            _this.dataId = '';
            _this.boundSeries = [];
            _this.statistics = new FDSDataStats(_this);
            _this.hasNA = false;
            _this.allRepeatingValues = false;
            _this.isIndex = false;
            _this.useValueAsIndex = false;
            _this.dataType = 'NONE';
            _this.inTips = true;
            _this._setDynamicProperties({
                'FDSDataType': true
            });
            _this._outlierMaxCached = _this._outlierMinCached = NAN;
            _this._lastOutlierThresh = NAN;
            _this.wrapper = wrapper || new FDSDataWrapper(_this);
            _this._setAttributes();
            return _this;
        }
        FDSDataSet.prototype.getChild = function (childId) {
            return this.children[childId];
        };
        FDSDataSet.prototype._init = function () {
            this._defMapID = 'DEF_DATASET';
            _super.prototype._init.call(this);
        };
        FDSDataSet.prototype._setAttributes = function () {
            if (!this.attributeSet.defaultMap.startInitialization()) {
                return;
            }
            _super.prototype._setAttributes.call(this);
            this.attributeSet.addMultiple([
                ['Frequency', String, this._frequency],
                ['Format', String, ''],
                ['TimeOffset', Number, 0],
                ['TreatAsIndex', Boolean, false],
                ['ImageType', String, 'png'],
                ['InTips', Boolean, true]
            ]);
            this.attributeSet.defaultMap.finalizeInitialization();
        };
        FDSDataSet.prototype._checkDimension = function (dim) {
            return dim >= 0 && dim < this.getDimension();
        };
        FDSDataSet.prototype._updateDependentDataSets = function () {
            var _loop_1 = function (series) {
                var myDim = series.getDimensionOfDataChild(this_1);
                _$1.forIn(series.children, function (child) {
                    if (isSeries(child) && child.annotationFollowsParentValue) {
                        var childData = child.getData(myDim);
                        childData._dateBin = childData.getDateBinImmediate();
                    }
                });
            };
            var this_1 = this;
            for (var _i = 0, _a = this.boundSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                _loop_1(series);
            }
        };
        FDSDataSet.prototype.syncMembers = function () {
            _super.prototype.syncMembers.call(this);
            if (!this.attributeSet.isDirty()) {
                return;
            }
            this.compiledFormat = this.properties.compilePropertyString(this.attributeSet.get('Format'));
            this._dateBin = this.getDateBinImmediate();
            this.setIsIndex(this.attributeSet.get('TreatAsIndex'));
            this.inTips = this.attributeSet.get('InTips');
            var format = this.compiledFormat.fromValue();
            switch (this.dataType) {
                case 'INT':
                case 'INTEGER':
                case 'FLOAT':
                    this._formatObject.setNumberFormat(format);
                    break;
                case 'DATE':
                    this._formatObject.setDateFormat(format);
                    break;
                case 'TIME':
                    this._formatObject.setTimeFormat(format);
                    break;
                case 'DATETIME':
                    this._formatObject.setDateTimeFormat(format, undefined, this._timeBin, this.needTime);
                    break;
            }
            this._updateDependentDataSets();
        };
        FDSDataSet.prototype.getChildList = function () {
            var childList = {};
            if (this.hasChildren()) {
                for (var id in this.children) {
                    var child = this.children[id];
                    childList[id] = child;
                }
            }
            return childList;
        };
        FDSDataSet.prototype.getStyleObjectName = function () {
            if (this.isStyleObject) {
                return 'FDSChart';
            }
            else {
                return 'FC_DATA';
            }
        };
        FDSDataSet.prototype.getObjectTypeName = function () {
            return 'FDSData';
        };
        FDSDataSet.prototype.isFrequencyDefault = function () {
            return this.attributeSet.isInheritedDefault('Frequency');
        };
        // returns a functor that is used to parse the items in the
        // data set based on the dataType
        FDSDataSet.prototype._getDecorator = function () {
            var decorator;
            var YYYYMMDDThresh = 15000000;
            switch (this.dataType) {
                case 'INT':
                case 'INTEGER':
                case 'TIME':
                    // convert using Number so scientific notation is preserved, then floor it
                    decorator = function (input) { return Math.floor(Number(input)); };
                    break;
                case 'DATE':
                    var dateObj_1 = new FDSDate();
                    decorator = function (input, date) {
                        if (date === void 0) { date = dateObj_1; }
                        if (!_$1.isNumber(input)) {
                            input = Number(input);
                        }
                        // convert using Number so scientific notation is preserved, then floor it
                        var newInput = Math.round(input);
                        // PC side uses round-half-to-even so compensate here
                        if (input % 1 === 0.5 && newInput % 2 === 1) {
                            newInput -= 1;
                        }
                        input = newInput;
                        if (input > YYYYMMDDThresh) {
                            // Input is a YYYYMMDD value
                            input = date.numericToJulian(input);
                        }
                        return input;
                    };
                    break;
                case 'DATETIME':
                    dateObj_1 = new FDSDate();
                    decorator = function (input, date) {
                        if (date === void 0) { date = dateObj_1; }
                        if (!_$1.isNumber(input)) {
                            input = Number(input);
                        }
                        var dec = input % 1;
                        var datePart = Math.floor(input);
                        if (datePart > YYYYMMDDThresh) {
                            datePart = date.numericToJulian(datePart);
                        }
                        return datePart + dec;
                    };
                    break;
                case 'FLOAT':
                case 'SINGLE':
                    decorator = function (input) {
                        if (_$1.isNumber(input)) {
                            return input;
                        }
                        else {
                            return parseFloat(input);
                        }
                    };
                    break;
                case 'STRING':
                    decorator = function (input) { return input.toString(); };
                    break;
                default:
                    decorator = function (input) { return input; };
            }
            return decorator;
        };
        FDSDataSet.prototype._getNAConverter = function () {
            var t;
            switch (this.dataType) {
                case 'INT':
                case 'INTEGER':
                case 'DATE':
                case 'TIME':
                    t = 'integer';
                    break;
                case 'FLOAT':
                case 'DATETIME':
                case 'SINGLE':
                    t = 'number';
                    break;
                default:
                    t = 'string';
            }
            return function (value) {
                if (IsSomeNAN(value, t)) {
                    return Number.NaN;
                }
                else {
                    return value;
                }
            };
        };
        FDSDataSet.prototype.initFromElement = function (element) {
            if (this.isStyleObject) {
                _super.prototype.initFromElement.call(this, element);
                return;
            }
            var dataTypeElement = element.getElementsByTagName('DataType');
            if (!dataTypeElement || dataTypeElement.length === 0) {
                return;
            }
            var validDataType = _$1.includes([
                'FLOAT',
                'SINGLE',
                'INT',
                'INTEGER',
                'DATE',
                'DATETIME',
                'TIME',
                'STRING',
                'SVG',
                'NONE'
            ], dataTypeElement[0].textContent);
            if (validDataType) {
                // <any> should be safe as type is validated above
                this.dataType = dataTypeElement[0].textContent;
            }
            else {
                this.dataType = 'FLOAT';
            }
            var dataElement = element.getElementsByTagName('Data');
            var decorator = this._getDecorator();
            var convertNA = this._getNAConverter();
            var lastValue;
            var ascendNeutral = true;
            if (this.data.length !== 0) {
                this.data = [];
            }
            for (var i = 0; i < dataElement.length; i++) {
                var dataset = dataElement[i];
                var data = [];
                var dataItems = dataset.getElementsByTagName('DI');
                // tslint:disable-next-line:prefer-for-of
                for (var j = 0; j < dataItems.length; j++) {
                    var dataItem = dataItems[j];
                    var value = convertNA(decorator(dataItem.textContent));
                    if (typeof value === 'number' && !isNaN(value)) {
                        if ((lastValue != null) && !isNaN(lastValue)) {
                            if (value < lastValue) {
                                if (ascendNeutral) {
                                    this.ascending = false;
                                    ascendNeutral = false;
                                }
                                else if (this.ascending) {
                                    this.sorted = false;
                                }
                            }
                            else {
                                if (ascendNeutral) {
                                    this.ascending = true;
                                    ascendNeutral = false;
                                }
                                else if (!this.ascending) {
                                    this.sorted = false;
                                }
                            }
                        }
                        lastValue = value;
                    }
                    data.push(value);
                }
                var id = dataset.getAttribute('ID');
                if (i === 0) {
                    this.data = data;
                    // save the data ID which can be different from the dataset id
                    this.dataId = id || '';
                }
                else {
                    // create new dataset and make it a child
                    var newDataSet = new FDSDataSet(this.root, this.id + '_' + (id || i));
                    newDataSet.data = data;
                    newDataSet.dataId = id || '';
                    newDataSet.dataType = this.dataType;
                    newDataSet.adjust();
                    if (this.addChild(newDataSet)) {
                        this.childIds.push(newDataSet.id);
                    }
                }
            }
            var childrenElement = element.getElementsByTagName('FDSChildren');
            if (childrenElement.length > 0) {
                var childIds = childrenElement[0].getElementsByTagName('ChildId');
                // tslint:disable-next-line:prefer-for-of
                for (var k = 0; k < childIds.length; k++) {
                    // just store the string name now, it'll be replaced with the actual dataset in addChildren
                    var childItem = childIds[k];
                    var childContent = childItem.textContent;
                    if (childContent) {
                        this.childIds.push(childContent);
                    }
                }
            }
            // do the stats after the children are added so we can include their data in computations
            this.statistics = new FDSDataStats(this);
            // If we have some value for `min`, then we have valid data. Otherwise,
            // we're full of `@NA`s and should be treated as such.
            this.valid = this.statistics && this.statistics.countValid > 0;
            this._setRangeBasedData();
            _super.prototype.initFromElement.call(this, element);
        };
        FDSDataSet.prototype.getSize = function () {
            return this.statistics.count;
        };
        FDSDataSet.prototype.setSize = function (size) {
            if (size > 0) {
                this.statistics.count = size;
            }
        };
        FDSDataSet.prototype.addChildren = function () {
            for (var i = 0; i < this.childIds.length; i++) {
                var name_1 = this.childIds[i];
                var newChild = this.root.getObject(name_1);
                if (!newChild || !this.addChild(newChild)) {
                    // remove item from array
                    this.childIds.splice(i, 1);
                }
            }
            if (this.statistics) {
                this.statistics.computeStatistics();
            }
            this._checkForRepeatingData();
        };
        FDSDataSet.prototype.dataSetSum = function (index) {
            if (index < 0) {
                return 0;
            }
            if (index === 0 || this.childIds.length === 0) {
                if (this.statistics) {
                    return this.statistics.sum;
                }
            }
            return 0;
        };
        FDSDataSet.prototype.dataSetSumOfAbsoluteVals = function (index) {
            if (index === 0 || this.childIds.length === 0) {
                if (this.statistics) {
                    return this.statistics.sumOfAbsoluteVals;
                }
            }
            return 0;
        };
        FDSDataSet.prototype._setRangeBasedData = function () {
            if (this.dataType === 'DATE' || this.dataType === 'DATETIME') {
                var span = (this.statistics.max - this.statistics.min);
                var dayBin = span / Math.max(this.data.length - 1, 1);
                var freq = void 0;
                if (dayBin > 240) {
                    freq = 'Y';
                }
                else if (dayBin > 100) {
                    freq = 'HY';
                }
                else if (dayBin > 40) {
                    freq = 'Q';
                }
                else if (dayBin > 10) {
                    freq = 'M';
                }
                else if (dayBin > 2) {
                    freq = 'W';
                }
                else if (this.dataType === 'DATE' || dayBin >= 1 || span === 0.0) {
                    freq = 'D';
                }
                else {
                    freq = 'NONE';
                }
                if (this._frequency !== freq) {
                    this._frequency = freq;
                    this.attributeSet.setDirty();
                }
            }
        };
        FDSDataSet.prototype.getDateBinImmediate = function () {
            var freqIsDefault = this.attributeSet.isDefault('Frequency');
            if (_$1.some(this.boundSeries) && freqIsDefault) {
                var parentFrequency = void 0;
                for (var _i = 0, _a = this.boundSeries; _i < _a.length; _i++) {
                    var series = _a[_i];
                    if (!series.annotationFollowsParentValue) {
                        continue;
                    }
                    var dim = series.getDimensionOfDataChild(this);
                    console.assert(dim > -1 /* NONE */ && dim < 7 /* MEMBERS */);
                    if (dim > -1 /* NONE */ && dim < 7 /* MEMBERS */) {
                        var parent_1 = series.parent;
                        if (isSeries(parent_1)) {
                            var parentData = parent_1.getData(dim);
                            var freq_1 = parentData.getDateBinImmediate();
                            if (parentFrequency == null || freq_1 < parentFrequency) {
                                parentFrequency = freq_1;
                            }
                        }
                    }
                }
                if (parentFrequency != null) {
                    return parentFrequency;
                }
            }
            var freq = freqIsDefault ? this._frequency : this.attributeSet.get('Frequency');
            return this._date.lookupDateBin(freq);
        };
        FDSDataSet.prototype.getNeedTime = function () {
            return this.needTime;
        };
        FDSDataSet.prototype.getDateBin = function () {
            if (this.dataType === 'DATETIME') {
                return this.getDateBinImmediate();
            }
            else {
                return this._dateBin;
            }
        };
        FDSDataSet.prototype.getTimeBin = function () {
            if (this.dataType === 'DATETIME') {
                var freq = this.attributeSet.isDefault('Frequency') ? this._frequency : this.attributeSet.get('Frequency');
                return this._time.lookupTimeBin(freq);
            }
            else {
                return this._timeBin;
            }
        };
        // return the entire data array at this dimension
        FDSDataSet.prototype.getDataAt = function (dimension) {
            if (dimension === void 0) { dimension = 0; }
            if (dimension === 0) {
                return this.data;
            }
            else {
                var set = this.getChild(this.childIds[dimension - 1]);
                if (set != null) {
                    return set.data;
                }
            }
            return undefined;
        };
        FDSDataSet.prototype.getValueOrIndexAt = function (scale, index, dimension) {
            if (dimension === void 0) { dimension = 0; }
            if (this.dataType === 'STRING') {
                if (scale instanceof FDSLookupScale) {
                    return scale.getIndexFromString(this.getAtDirect(index, dimension));
                }
                else {
                    return index;
                }
            }
            else if (this.isIndex) {
                return index;
            }
            return this.getAtDirect(index, dimension);
        };
        FDSDataSet.prototype.getAt = function (index, dimension) {
            if (dimension === void 0) { dimension = 0; }
            if (this.isIndex) {
                return index;
            }
            if (dimension === 0) {
                if (index >= this.data.length) {
                    return index;
                }
                else {
                    return this.data[index];
                }
            }
            var set = this.getChild(this.childIds[dimension - 1]);
            if ((set != null) && set.data.length > index) {
                return set.data[index];
            }
            else {
                throw new Error('index or dimension is out of bounds');
            }
        };
        FDSDataSet.prototype.getAtDirect = function (index, dimension) {
            if (dimension === void 0) { dimension = 0; }
            if (dimension === 0) {
                return this.data[index];
            }
            var set = this.getChild(this.childIds[dimension - 1]);
            if (set == null) {
                throw new Error('dimension is out of bounds');
            }
            return set.data[index];
        };
        FDSDataSet.prototype.getDimension = function () {
            return this.childIds.length + 1;
        };
        FDSDataSet.prototype.getStringAt = function (index, dim) {
            if (dim === void 0) { dim = 0; }
            var set = this.getDimensionalDataset(dim);
            if (set && this.dataType === 'STRING') {
                return (index < set.data.length ? set.data[index].toString() : '');
            }
            else {
                return index.toString();
            }
        };
        FDSDataSet.prototype.getDimensionalDataset = function (dimension) {
            if (dimension === 0) {
                return this;
            }
            var set = this.getChild(this.childIds[dimension - 1]);
            if (set != null) {
                return set;
            }
            else {
                return undefined;
            }
        };
        FDSDataSet.prototype.printAt = function (index, dim) {
            return this._formatObject.formatAsType(this.data[index], this.dataType);
        };
        FDSDataSet.prototype.hasData = function () {
            return this.data.length > 0;
        };
        FDSDataSet.prototype.serialize = function (level) {
            return _super.prototype._serializeObject.call(this, 'Data', level);
        };
        FDSDataSet.prototype._serializeData = function () {
            if (!this.hasData()) {
                return '';
            }
            var dataType = cleanString(this.dataType);
            var dataId = cleanString(this.dataId);
            var str = "<DataType>" + dataType + "</DataType>";
            str += "<Data ID = \"" + dataId + "\">";
            var nan;
            // figure out how NaNs should be represented
            switch (this.dataType) {
                case 'DATE':
                case 'TIME':
                case 'DATETIME':
                case 'INT':
                case 'INTEGER':
                case 'FLOAT':
                case 'SINGLE':
                    nan = '-1e20';
                    break;
                default:
                    nan = '@NA';
            }
            for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
                var d = _a[_i];
                if (IsSomeNAN(d)) {
                    d = nan;
                }
                else {
                    d = cleanString(d);
                }
                str += "<DI>" + d + "</DI>";
            }
            str += '</Data>';
            return str;
        };
        FDSDataSet.prototype.adjust = function () {
            this.statistics = new FDSDataStats(this);
            this.valid = this.statistics && this.statistics.countValid > 0;
            this._setRangeBasedData();
            return true;
        };
        // If we are adding a dataset to this one. For multi-dimensional datasets
        // The new dataset is added as a child
        //
        // @param name [String] dataId of the dataset
        // @param data [Array] array of the data
        FDSDataSet.prototype.add = function (name, data, wrapper) {
            if (!data) {
                return [false, "No data to add to DataSet " + this.id + "!"];
            }
            var decorator = this._getDecorator();
            var convertNA = this._getNAConverter();
            var sorted = true;
            var ascending;
            var ascendNeutral = true;
            if (this.dataType !== 'STRING' && this.dataType !== 'SVG') {
                var lastValue = void 0;
                for (var i = 0; i < data.length; i++) {
                    var value = data[i] = convertNA(decorator(data[i]));
                    if (!isNaN(value)) {
                        if (lastValue != null && !isNaN(lastValue)) {
                            if (value < lastValue) {
                                if (ascendNeutral) {
                                    ascending = false;
                                    ascendNeutral = false;
                                }
                                else if (ascending) {
                                    sorted = false;
                                }
                            }
                            else {
                                if (ascendNeutral) {
                                    ascending = true;
                                    ascendNeutral = false;
                                }
                                else if (!ascending) {
                                    sorted = false;
                                }
                            }
                        }
                        lastValue = value;
                    }
                }
            }
            else {
                for (var i = 0; i < data.length; i++) {
                    data[i] = convertNA(decorator(data[i]));
                }
            }
            if (this.data.length !== 0) {
                var newDataSet = new FDSDataSet(this.root, this.id + "_" + name, wrapper);
                newDataSet.wrapper.id = this.id + "_" + name;
                newDataSet.data = data;
                newDataSet.dataId = name;
                newDataSet.dataType = this.dataType;
                newDataSet.ascending = !!ascending;
                newDataSet.sorted = sorted;
                if (this.addChild(newDataSet)) {
                    this.childIds.push(newDataSet.id);
                }
            }
            else {
                this.data = data;
                this.dataId = name;
                this.ascending = !!ascending;
                this.sorted = sorted;
            }
            this._checkForRepeatingData();
            // returns an array so we can have an error message if something
            // goes wrong
            return [this.adjust(), null];
        };
        // helper function to figure out if all the children are congruent
        FDSDataSet.prototype._checkForRepeatingData = function () {
            if (this.childIds.length === 0) {
                // if there are no children, they aren't congruent
                this.allRepeatingValues = false;
                return;
            }
            this.allRepeatingValues = true;
            for (var i = 0; i < this.data.length; i++) {
                var d = this.data[i];
                for (var _i = 0, _a = this.childIds; _i < _a.length; _i++) {
                    var id = _a[_i];
                    var child = this.getChild(id);
                    if (child.getAt(i) !== d) {
                        this.allRepeatingValues = false;
                        // at least one is different, so we can return
                        return;
                    }
                }
            }
        };
        // Sets the objects in `children` as children of this dataset
        //
        // @param children [Array] array of string IDs of objects to be parented
        FDSDataSet.prototype.setChildren = function (children) {
            if (!this.root) {
                var errString_1 = 'Invalid root during parenting';
                return [false, errString_1];
            }
            var ret = true;
            var needAdjust = false;
            var errString = null;
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                var dataSet = void 0;
                if (dataSet = this.root.getTypedObject(child, isDataSet)) {
                    if (dataSet.dataType === this.dataType) {
                        if (!this.addChild(dataSet)) {
                            errString = "DataSet " + this.id + " is unable to parent " + child;
                            ret = false;
                        }
                        else {
                            this.childIds.push(dataSet.id);
                            needAdjust = true;
                        }
                    }
                }
                else {
                    errString = "DataSet " + this.id + ": Child " + child + " is not a DataSet";
                    ret = false;
                }
            }
            if (needAdjust) {
                this.adjust();
            }
            return [ret, errString];
        };
        FDSDataSet.prototype.addSeries = function (parentSeries) {
            // Datasets can be bound to multiple series. When resolving properties,
            // we will just register the first series as the parent property set.
            if (this.boundSeries.length === 0) {
                this.properties.setParentPropertySet(parentSeries.properties);
            }
            if (!_$1.includes(this.boundSeries, parentSeries)) {
                this.boundSeries.push(parentSeries);
            }
            this.wrapper._addParent(parentSeries.wrapper);
        };
        // Removes parentSeries from the @boundSeries list
        //
        // @param parentSeries [FDSSeries] a former parent that we are removing
        FDSDataSet.prototype.removeSeries = function (parentSeries) {
            for (var _i = 0, _a = this.boundSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                if (series === parentSeries) {
                    if (_$1.includes(this.boundSeries, parentSeries)) {
                        this.boundSeries.splice(this.boundSeries.indexOf(parentSeries), 1);
                    }
                    var removedSeriesWasPropertyParent = this.properties.parentPropertySet === series.properties;
                    if (removedSeriesWasPropertyParent) {
                        var firstParentSeries = _$1.first(this.boundSeries);
                        if (firstParentSeries) {
                            this.properties.setParentPropertySet(firstParentSeries.properties);
                        }
                        else {
                            this.properties.setParentPropertySet(this.root.properties);
                        }
                    }
                    this.wrapper._removeParent(parentSeries.wrapper);
                    return true;
                }
            }
            return false;
        };
        // Override of FDSChartObject::notifyParents since we can have multiple parents
        //
        // @param flags [UpdateMessage] Update message
        FDSDataSet.prototype.notifyParents = function (flags) {
            if (flags === void 0) { flags = 0 /* REMOVE */; }
            var parents = this.boundSeries.slice();
            for (var _i = 0, parents_1 = parents; _i < parents_1.length; _i++) {
                var parent_2 = parents_1[_i];
                for (var _a = 0, _b = this.boundSeries; _a < _b.length; _a++) {
                    var series = _b[_a];
                    if (series === parent_2) {
                        parent_2.onNotify(this, flags);
                        break;
                    }
                }
            }
        };
        // Actions to perform when one of our children informs us of an update
        //
        // @param child [FDSChartObject] Child that notified us
        // @param flags [UpdateMessage] Message the child notified us of
        FDSDataSet.prototype.onNotify = function (child, flags) {
            if (flags === void 0) { flags = 0 /* REMOVE */; }
            var msg = 1;
            if (flags === 1 /* CHANGE */ || flags === 2 /* DATA */) {
                this.adjust();
                msg = flags;
            }
            else if (flags === 3 /* APPEND */) {
                // adjustFromChildren
                msg = flags;
            }
            else {
                this.removeChild(child);
                this.adjust();
            }
            this.notifyParents(msg);
        };
        // Gets the AddFlag type based on the string @dataType
        FDSDataSet.prototype.getDataType = function () {
            switch (this.dataType.toUpperCase()) {
                case 'INT':
                    return 1 /* INT_DATA */;
                case 'FLOAT':
                    return 2 /* FLOAT_DATA */;
                case 'DATE':
                    return 3 /* DATE_DATA */;
                case 'STRING':
                    return 4 /* STRING_DATA */;
                case 'SINGLE':
                    return 5 /* SINGLE_DATA */;
                case 'TIME':
                    return 7 /* TIME_DATA */;
                case 'DATETIME':
                    return 8 /* DATETIME_DATA */;
                case 'SVG':
                    return 9 /* KML_DATA */;
                default:
                    return 0 /* NO_FLAGS */;
            }
        };
        FDSDataSet.prototype.objectAction = function (action, flags, args) {
            if (flags === void 0) { flags = 0; }
            var handled = true;
            var errString = '';
            var ret = null;
            // If the args exists, then we assume it to be a number or an array of numbers
            if (args != null) {
                if (typeof args === 'number') {
                    args = [args];
                }
                else if (!(args instanceof Array)) {
                    errString = 'Arguments is expected to be a number or an array of numbers';
                }
            }
            switch (action) {
                case 'Replace':
                    this.replace(flags, args);
                    break;
                case 'Append':
                    this._append(flags, 1 /* DS_APPEND */, args);
                    break;
                case 'ReplaceLast':
                    this._append(flags, 2 /* DS_APPEND_LASTN */, args);
                    break;
                case 'AppendLast':
                    this._append(flags, 3 /* DS_APPEND_MINUS1 */, args);
                    break;
                case 'Prepend':
                    this._prepend(flags, args);
                    break;
                case 'GetPoint':
                    ret = this._getPoint(flags);
                    break;
                case 'DeletePoint':
                    this._deletePoint(flags);
                    break;
                case 'ReplacePoint':
                    this.replacePoint(flags, args);
                    break;
                case 'ReplacePointGrow':
                    this.replacePointGrow(flags, args);
                    break;
                case 'DeleteSelf':
                    this._deleteSelf();
                    break;
                case 'DeleteAll':
                    this._deleteAll();
                    break;
                default:
                    return _super.prototype.objectAction.call(this, action, flags, args);
            }
            return [handled, ret, errString];
        };
        FDSDataSet.prototype._append = function (dimension, mode, data, notifyParents) {
            if (notifyParents === void 0) { notifyParents = true; }
            if (this._checkDimension(dimension) && data instanceof Array) {
                var localData = this.getDimensionalDataset(dimension);
                var localSize = localData.data.length;
                var dataSize = data.length;
                var start = localSize;
                switch (mode) {
                    case 2 /* DS_APPEND_LASTN */:// replace last n items
                        start = Math.max(0, localSize - dataSize);
                        break;
                    case 3 /* DS_APPEND_MINUS1 */:
                        start = Math.max(0, localSize - 1);
                        break;
                }
                var naConverter = this._getNAConverter();
                var decorator = this._getDecorator();
                var totalSize = start + dataSize;
                for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                    var el = data_1[_i];
                    if (IsSomeNAN(el)) {
                        this.hasNA = true;
                        localData.data[start] = naConverter(el);
                    }
                    else {
                        localData.data[start] = decorator(el);
                    }
                    start++;
                }
                this.statistics.computeStatistics();
                this.adjust();
                if (notifyParents) {
                    this.notifyParents(3 /* APPEND */);
                }
            }
        };
        FDSDataSet.prototype._prepend = function (dimension, data) {
            var _this = this;
            if (this._checkDimension(dimension) && data instanceof Array) {
                var localData = this.getDimensionalDataset(dimension);
                data.map(function (di) {
                    if (IsSomeNAN(di)) {
                        _this.hasNA = true;
                    }
                });
                Array.prototype.unshift.apply(localData.data, data);
                this.adjust();
                this.notifyParents(2 /* DATA */);
            }
        };
        FDSDataSet.prototype._convertData = function (array) {
            if (this.dataType === 'STRING') {
                return array;
            }
            else {
                return array.map(function (n) { return Number(n); });
            }
        };
        FDSDataSet.prototype.replace = function (dimension, data, notifyParents) {
            if (notifyParents === void 0) { notifyParents = true; }
            if (this._checkDimension(dimension) && data instanceof Array) {
                data = this._convertData(data);
                var localData = this.getDimensionalDataset(dimension);
                // resize the local dataset to be the same as the passed in data
                // splice will return the first (data.length) elements or the entirety
                // of localData.data. The key thing here is that the size of localData.data
                // after this will be at most data.length
                localData.data = localData.data.slice(0, data.length);
                // We have to spin through anyway to check if any of these are NA values
                for (var i = 0; i < data.length; i++) {
                    var el = data[i];
                    if (IsSomeNAN(el)) {
                        this.hasNA = true;
                    }
                    localData.data[i] = el;
                }
                this.adjust();
                if (notifyParents) {
                    this.notifyParents(2 /* DATA */);
                }
            }
        };
        FDSDataSet.prototype.replacePoint = function (index, dataIn, notifyParents) {
            if (notifyParents === void 0) { notifyParents = true; }
            var data = ((dataIn instanceof Array) ? dataIn : [dataIn]);
            if (index >= 0 && data instanceof Array) {
                data = this._convertData(data);
                var dimension = data.length;
                var size = Math.min(dimension, this.getDimension());
                for (var i = 0; i < size; i++) {
                    var localData = this.getDimensionalDataset(i);
                    var localSize = localData.data.length;
                    if (index < localSize) {
                        if (IsSomeNAN(data[i])) {
                            this.hasNA = true;
                        }
                        localData.data[index] = data[i];
                    }
                }
                this.adjust();
                if (notifyParents) {
                    this.notifyParents(2 /* DATA */);
                }
            }
        };
        FDSDataSet.prototype.replacePointGrow = function (index, data, notifyParents) {
            if (notifyParents === void 0) { notifyParents = true; }
            if (index >= 0 && data instanceof Array) {
                data = this._convertData(data);
                var dimension = data.length;
                var size = Math.min(dimension, this.getDimension());
                for (var i = 0; i < size; i++) {
                    var localData = this.getDimensionalDataset(i);
                    if (IsSomeNAN(data[i])) {
                        this.hasNA = true;
                    }
                    var localSize = localData.data.length;
                    var naVec = [];
                    if (index >= localSize) {
                        var deltaSize = (index - localSize) + 1;
                        for (var j = 0; j < deltaSize - 1; j++) {
                            naVec.push(NAN);
                        }
                        naVec.push(data[i]);
                        this._append(i, 1 /* DS_APPEND */, naVec);
                    }
                    else {
                        localData.data[index] = data[i];
                    }
                }
                this.adjust();
                if (notifyParents) {
                    this.notifyParents(2 /* DATA */);
                }
            }
        };
        FDSDataSet.prototype.growWithNA = function (index, notifyParents) {
            if (notifyParents === void 0) { notifyParents = true; }
            if (index >= 0) {
                var size = this.getDimension();
                for (var i = 0; i < size; i++) {
                    var localData = this.getDimensionalDataset(i);
                    var localSize = localData.getSize();
                    if (index >= localSize) {
                        var deltaSize = (index - localSize) + 1;
                        var naVec = [];
                        for (var j = 0; j < size; j++) {
                            naVec.push(NAN);
                        }
                        this._append(i, 1 /* DS_APPEND */, naVec, notifyParents);
                    }
                }
                this.adjust();
                if (notifyParents) {
                    this.notifyParents(2 /* DATA */);
                }
            }
        };
        FDSDataSet.prototype._getPoint = function (index) {
            var size = this.data.length;
            if (index >= 0 && index < size) {
                var outArr = [];
                var dim = this.getDimension();
                for (var i = 0; i < dim; i++) {
                    outArr.push(this.getDimensionalDataset(i).data[index]);
                }
                return outArr;
            }
            return undefined;
        };
        FDSDataSet.prototype._deletePoint = function (index) {
            if (index < 0) {
                return false;
            }
            var dim = this.getDimension();
            for (var i = 0; i < dim; i++) {
                var localDataSet = this.getDimensionalDataset(i);
                var localSize = localDataSet.data.length;
                if (index < localSize) {
                    // typescript bug, doesn't find overload with second parameter for union of two array types
                    localDataSet.data.splice(index, 1);
                }
            }
            this.adjust();
            this.notifyParents(2 /* DATA */);
            return true;
        };
        FDSDataSet.prototype._deleteSelf = function () {
            this.data = [];
            this.adjust();
            this.notifyParents(2 /* DATA */);
        };
        FDSDataSet.prototype._deleteAll = function () {
            var dim = this.getDimension();
            for (var i = 0; i < dim; i++) {
                var dataset = this.getDimensionalDataset(i);
                dataset.data = [];
                dataset.adjust();
            }
            this.adjust();
            this.notifyParents(2 /* DATA */);
        };
        // Determines the max dynamic outlier
        FDSDataSet.prototype.outlierMax = function (threshold) {
            if (ISNAN(threshold)) {
                this._outlierMaxCached = this._lastOutlierThresh = NAN;
                return NAN;
            }
            if (this._outlierMaxCached !== NAN && this._lastOutlierThresh === threshold) {
                return this._outlierMaxCached;
            }
            this._lastOutlierThresh = threshold;
            // Maximum dynamic outlier threshold.
            this._outlierMaxCached = this._outlierMaxInRange(this.statistics, 0, this.getSize(), threshold);
            return this._outlierMaxCached;
        };
        FDSDataSet.prototype._outlierMaxInRange = function (stats, start, end, threshold) {
            if (!this.hasData || ISNAN(threshold)) {
                return NAN;
            }
            var thresh = stats.outlierMax(threshold);
            if (stats.max < thresh) {
                return stats.max;
            }
            var max$$1 = stats.min;
            for (var i = 0; i < this.getDimension(); i++) {
                for (var dataIndex = 0; dataIndex < end - 1; dataIndex++) {
                    var dataPoint = this.getAt(dataIndex, i);
                    if ((dataPoint !== NAN) && (dataPoint < thresh) && (dataPoint > max$$1)) {
                        max$$1 = dataPoint;
                    }
                }
            }
            return max$$1;
        };
        // Determines the minimum dynamic outlier
        FDSDataSet.prototype.outlierMin = function (threshold) {
            if (ISNAN(threshold)) {
                this._outlierMinCached = this._lastOutlierThresh = NAN;
                return NAN;
            }
            if (this._outlierMinCached !== NAN && this._lastOutlierThresh === threshold) {
                return this._outlierMinCached;
            }
            this._lastOutlierThresh = threshold;
            this._outlierMinCached = this._outlierMinInRange(this.statistics, 0, this.getSize(), threshold);
            return this._outlierMinCached;
        };
        FDSDataSet.prototype._outlierMinInRange = function (stats, start, end, threshold) {
            if (!this.hasData || ISNAN(threshold)) {
                return NAN;
            }
            var thresh = stats.outlierMin(threshold);
            if (stats.min > thresh) {
                return stats.min;
            }
            var min$$1 = stats.max;
            for (var i = 0; i < this.getDimension(); i++) {
                for (var dataIndex = 0; dataIndex < end - 1; dataIndex++) {
                    var dataPoint = this.getAt(dataIndex, i);
                    if ((dataPoint !== NAN) && (dataPoint > thresh) && (dataPoint < min$$1)) {
                        min$$1 = dataPoint;
                    }
                }
            }
            return min$$1;
        };
        FDSDataSet.prototype.median = function (dimension) {
            if (!this.valid || this.dataType === 'STRING') {
                return NAN;
            }
            if (this._isDimensionInvalid(dimension)) {
                dimension = 0;
            }
            var dataVals = _$1.filter(this.getDataAt(dimension), function (v) { return !ISNAN(v) && v !== undefined; });
            if (dataVals.length === 0) {
                return NAN;
            }
            var incSort = function (a, b) { return a - b; };
            dataVals.sort(incSort);
            var tempMedian = (dataVals.length % 2) === 1 ?
                (dataVals[~~(dataVals.length / 2)])
                :
                    (dataVals[(dataVals.length / 2) - 1] + dataVals[dataVals.length / 2]) / 2;
            return tempMedian;
        };
        FDSDataSet.prototype.harmonicMean = function (dimension) {
            if (!this.valid || this.dataType === 'STRING') {
                return NAN;
            }
            if (this._isDimensionInvalid(dimension)) {
                dimension = 0;
            }
            var dataVals = _$1.filter(this.getDataAt(dimension), function (v) { return !ISNAN(v) && v !== undefined; });
            if (dataVals.length === 0) {
                return NAN;
            }
            var harmonicMeanDiv = 0;
            for (var _i = 0, dataVals_1 = dataVals; _i < dataVals_1.length; _i++) {
                var val = dataVals_1[_i];
                // Harmonic mean is only defined for a set of positive numbers.
                if (val <= 0) {
                    return NaN;
                }
                harmonicMeanDiv += 1 / val;
            }
            return dataVals.length / harmonicMeanDiv;
        };
        FDSDataSet.prototype.Min = function (dimension) {
            if (dimension != null) {
                if (this._isDimensionInvalid(dimension)) {
                    dimension = 0;
                }
                var data = this.getDimensionalDataset(dimension).statistics;
                return [data.min, data.minIndex, dimension];
            }
            else {
                var minDim = 0;
                var min$$1 = Number.POSITIVE_INFINITY;
                var minIndex = 0;
                for (var i = 0; i < this.getDimension(); i++) {
                    var data = this.getDimensionalDataset(i).statistics;
                    if (data.min < min$$1) {
                        (min$$1 = data.min, minIndex = data.minIndex);
                        minDim = i;
                    }
                }
                return [min$$1, minIndex, minDim];
            }
        };
        FDSDataSet.prototype.Max = function (dimension) {
            if (dimension != null) {
                if (this._isDimensionInvalid(dimension)) {
                    dimension = 0;
                }
                var data = this.getDimensionalDataset(dimension).statistics;
                return [data.max, data.maxIndex, dimension];
            }
            else {
                var maxDim = 0;
                var max$$1 = Number.NEGATIVE_INFINITY;
                var maxIndex = 0;
                for (var i = 0; i < this.getDimension(); i++) {
                    var data = this.getDimensionalDataset(i).statistics;
                    if (data.max > max$$1) {
                        (max$$1 = data.max, maxIndex = data.maxIndex);
                        maxDim = i;
                    }
                }
                return [max$$1, maxIndex, maxDim];
            }
        };
        FDSDataSet.prototype.StdDev = function () {
            return this.statistics.stddev;
        };
        FDSDataSet.prototype.setIsIndex = function (isIndex) {
            this.isIndex = isIndex;
        };
        FDSDataSet.constructPartialDataSet = function (ds, startIndex, endIndex, outlierThreshold) {
            if (outlierThreshold === void 0) { outlierThreshold = NAN; }
            if (startIndex > endIndex) {
                _a = [endIndex, startIndex], startIndex = _a[0], endIndex = _a[1];
            }
            startIndex = Math.max(Math.min(startIndex, ds.getSize() - 1), 0);
            endIndex = Math.min(endIndex, ds.getSize() - 1);
            var partialDS = new FDSDataSet(ds.root, ds.id);
            if (ds.dataType !== 'STRING') {
                for (var j = 0; j < ds.getDimension(); j++) {
                    for (var i = startIndex; i <= endIndex; i++) {
                        partialDS.statistics.update(ds.getAt(i, j));
                    }
                }
            }
            partialDS._outlierMaxCached = ds._outlierMaxInRange(partialDS.statistics, startIndex, endIndex + 1, outlierThreshold);
            partialDS._outlierMinCached = ds._outlierMinInRange(partialDS.statistics, startIndex, endIndex + 1, outlierThreshold);
            partialDS.valid = partialDS.statistics.countValid > 0;
            return partialDS;
            var _a;
        };
        FDSDataSet.constructPartialDataSetFromUnsorted = function (baseDS, refDS, start, end) {
            if (start > end) {
                _a = [end, start], start = _a[0], end = _a[1];
            }
            var partialDS = new FDSDataSet(baseDS.root, baseDS.id);
            partialDS._outlierMaxCached = partialDS._outlierMinCached = partialDS._lastOutlierThresh = NAN;
            if (refDS != null) {
                for (var j = 0; j < baseDS.getDimension(); j++) {
                    for (var i = 0; i < baseDS.getSize(); i++) {
                        var xVal = refDS.getAt(i, j);
                        if (baseDS.dataType !== 'STRING' && !IsSomeNAN(xVal) && (start <= xVal && xVal <= end)) {
                            partialDS.statistics.update(baseDS.getAt(i, j));
                        }
                    }
                }
            }
            partialDS.valid = partialDS.statistics.countValid > 0;
            return partialDS;
            var _a;
        };
        FDSDataSet.prototype.getDataBounds = function (index, dimensionsMask) {
            var max$$1 = Number.NEGATIVE_INFINITY;
            var min$$1 = Number.POSITIVE_INFINITY;
            for (var d = 0; d < this.getDimension(); d++) {
                if (dimensionsMask & 1) {
                    max$$1 = Math.max(this.getAt(index, d), max$$1);
                    min$$1 = Math.min(this.getAt(index, d), min$$1);
                }
                dimensionsMask >>= 1;
            }
            return { min: min$$1, max: max$$1 };
        };
        FDSDataSet.prototype._propFDSDataType = function (propInfo, args) {
            return this.dataType;
        };
        FDSDataSet.prototype._isDimensionInvalid = function (dimension) {
            return this.childIds.length === 0 || dimension < 0 || dimension >= this.getDimension();
        };
        FDSDataSet.selector = 'FDSData';
        return FDSDataSet;
    }(FDSChartObject));
    var FDSDataStyle = /** @class */ (function (_super) {
        __extends(FDSDataStyle, _super);
        function FDSDataStyle(root, id) {
            return _super.call(this, root, id) || this;
        }
        FDSDataStyle.prototype._init = function () {
            this.isStyleObject = true;
            this.type = 10 /* FC_DATA_STYLE */;
            _super.prototype._init.call(this);
        };
        return FDSDataStyle;
    }(FDSDataSet));
    
    var FDSDateScale = /** @class */ (function (_super) {
        __extends(FDSDateScale, _super);
        function FDSDateScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _this.scaleType = 5 /* DATE */;
            _this.csTickDateBin = 'NONE';
            _this._date = new FDSDate();
            _this.bin = true;
            _this.setTickBinned(true);
            _this._dateBin = 14 /* DAY */;
            _this._subTickDateBin = 0 /* NONE */;
            _this._numTicks = 0;
            _this._labelShift = 0;
            _this._dateLabel = 0;
            _this._dateTick = 0;
            _this._dateSubTick = 0;
            _this._labelEndsWithFullBin = false;
            return _this;
        }
        FDSDateScale.prototype.getLog = function () {
            return false;
        };
        FDSDateScale.prototype.supportLog = function () {
            return false;
        };
        FDSDateScale.prototype._formatLabel = function (value) {
            var format = this.formatString;
            // conditional formatted label, needs to be dealt with on a case-by-case basis
            if ((this.parseList != null) && this.parseList.length > 0) {
                format = this.formatParser.applyParsedList(this.parseList, value);
            }
            // Process `LabelFormat` for property strings
            if (!this.isLabelFormatDefault) {
                this.compiledFormatString = this.parentPropertySet.compilePropertyString(format);
                format = this.compiledFormatString.fromValue();
            }
            var formatter = this.labelFormatters[format];
            if (formatter != null) {
                return new RichTextString(formatter.formatAsDate(value));
            }
            return RichTextString.Empty;
        };
        FDSDateScale.prototype.computeValue = function (ndc) {
            var min$$1 = this._date.compress(~~this.threshMin);
            var delta = (this._date.compress(~~this.threshMax)) - min$$1;
            if (this.reverse) {
                ndc = 1.0 - ndc;
            }
            return this._date.decompress(~~(ndc * delta + min$$1));
        };
        FDSDateScale.prototype.computeValueUnbinned = function (ndc) {
            var min$$1 = this._date.compress(~~this.threshMin);
            var delta = this._date.compress(~~this.threshMax) - min$$1;
            var temp = (this.reverse ? 1.0 - ndc : ndc) * delta + min$$1;
            return this._date.decompress(~~temp) + (temp - (~~temp));
        };
        FDSDateScale.prototype._localLookup = function (value) {
            var min$$1 = this._date.compress(~~this.threshMin);
            var delta = (this._date.compress(~~this.threshMax)) - min$$1;
            if (delta === 0.0) {
                delta = 1.0;
            }
            value = this._date.compress(value);
            var rval = ((value - min$$1) / delta);
            if (this.reverse) {
                return this.applyPlotFactorNDC(1.0 - rval);
            }
            else {
                return this.applyPlotFactorNDC(rval);
            }
        };
        FDSDateScale.prototype.lookup = function (value, dateBin) {
            if (dateBin === void 0) { dateBin = this._dateBin; }
            var rval;
            if (this.getBinned()) {
                _a = this.lookupRange(value, dateBin), rval = _a[0];
            }
            else {
                rval = this._localLookup(value);
            }
            return rval;
            var _a;
        };
        FDSDateScale.prototype.adjust = function (dataset) {
            // this needs to happen before super because it sets @initialized to true
            if (!this.initialized) {
                this._dateBin = 14 /* DAY */;
            }
            var d = dataset.getDateBinImmediate();
            if (d > this._dateBin) {
                this._dateBin = d;
            }
            return _super.prototype.adjust.call(this, dataset);
        };
        FDSDateScale.prototype.reset = function () {
            this.initSettings();
            this.setWeekType(0 /* FIVE_DAY */);
            this.setBinned(true);
            this.setTickBinned(true);
            this._setRanges();
        };
        FDSDateScale.prototype._weekBin = function (jdate) {
            return this._date.getWeekRange(jdate);
        };
        FDSDateScale.prototype._monthBin = function (jdate) {
            return this._date.getMonthRange(jdate);
        };
        FDSDateScale.prototype._quarterBin = function (jdate) {
            return this._date.getQuarterRange(jdate);
        };
        FDSDateScale.prototype._fquarterBin = function (jdate) {
            return this._date.getQuarterRange(jdate, this.min);
        };
        FDSDateScale.prototype._halfYearBin = function (jdate) {
            return this._date.getHalfYearRange(jdate);
        };
        FDSDateScale.prototype._yearBin = function (jdate) {
            return this._date.getYearRange(jdate);
        };
        FDSDateScale.prototype._fyearBin = function (jdate) {
            return this._date.getYearRange(jdate, this.min);
        };
        FDSDateScale.prototype._tenYearBin = function (jdate) {
            return this._date.getNYear(jdate, 10);
        };
        FDSDateScale.prototype._twoYearBin = function (jdate) {
            return this._date.getNYear(jdate, 2);
        };
        FDSDateScale.prototype._fiveYearBin = function (jdate) {
            return this._date.getNYear(jdate, 5);
        };
        FDSDateScale.prototype._noBin = function (jdate) {
            return [jdate, jdate, jdate];
        };
        FDSDateScale.prototype._getDateBinRange = function (dateBin, jdate) {
            if (dateBin === void 0) { dateBin = this._dateBin; }
            switch (dateBin) {
                case 15 /* WEEK */:
                    return this._weekBin(jdate);
                case 16 /* MONTH */:
                    return this._monthBin(jdate);
                case 17 /* QUARTER */:
                    return this._quarterBin(jdate);
                case 18 /* HALFY */:
                    return this._halfYearBin(jdate);
                case 19 /* YEAR */:
                    return this._yearBin(jdate);
                case 22 /* TENY */:
                    return this._tenYearBin(jdate);
                case 20 /* TWOY */:
                    return this._twoYearBin(jdate);
                case 21 /* FIVEY */:
                    return this._fiveYearBin(jdate);
                default:
                    return this._noBin(jdate);
            }
        };
        // Returns [rval, lowdate, highdate, offset]
        FDSDateScale.prototype.lookupRange = function (val, dateBin) {
            if (dateBin === void 0) { dateBin = this._dateBin; }
            var value;
            var lowdate;
            var highdate;
            _a = this._getDateBinRange(dateBin, val), value = _a[0], lowdate = _a[1], highdate = _a[2];
            highdate = this._date.adjustUp(++highdate);
            var low = this._localLookup(lowdate);
            var high = this._localLookup(highdate);
            if (high < low) {
                _b = [high, low], low = _b[0], high = _b[1];
            }
            var offset = ((high - low) * (1.0 - this.getBinFactor())) / 2.0;
            var rval = this.getBinned() ? (low + high) / 2.0 : low;
            return [rval, low, high, offset];
            var _a, _b;
        };
        FDSDateScale.prototype.setWeekType = function (weekType) {
            _super.prototype.setWeekType.call(this, weekType);
            this._date.setWeekType(weekType);
            this._setRanges();
        };
        FDSDateScale.prototype.getLabelBinned = function () {
            if (!this.userLabel) {
                if (_$1.includes([17 /* QUARTER */, 15 /* WEEK */, 20 /* TWOY */, 21 /* FIVEY */, 22 /* TENY */], this._tickDateBin)) {
                    return true;
                }
                else {
                    return _super.prototype.getLabelBinned.call(this);
                }
            }
            return false;
        };
        FDSDateScale.prototype._setThreshold = function (min$$1, max$$1, ticks) {
            if (ISNAN(min$$1)) {
                min$$1 = this.threshMin;
            }
            if (ISNAN(max$$1)) {
                max$$1 = this.threshMax;
            }
            _super.prototype._setThreshold.call(this, min$$1, max$$1, ticks);
            this.setNumber(min$$1, max$$1);
        };
        FDSDateScale.prototype.setNumber = function (min$$1, max$$1, defaultOverride) {
            switch (this._dateBin) {
                case 15 /* WEEK */:
                    this.number = (this._date.nWeeks(min$$1, max$$1)) + 1;
                    break;
                case 16 /* MONTH */:
                    this.number = (this._date.nMonths(min$$1, max$$1)) + 1;
                    break;
                case 17 /* QUARTER */:
                    this.number = (this._date.nQuarters(min$$1, max$$1)) + 1;
                    break;
                case 18 /* HALFY */:
                    this.number = (this._date.nHalfYears(min$$1, max$$1)) + 1;
                    break;
                case 19 /* YEAR */:
                    this.number = (this._date.nYears(min$$1, max$$1)) + 1;
                    break;
                default:
                    if (defaultOverride != null) {
                        defaultOverride.call(this, min$$1, max$$1);
                    }
                    else {
                        this.number = this._date.nDays(min$$1, max$$1) + 1;
                    }
            }
            this.setBinSize(min$$1, max$$1);
        };
        FDSDateScale.prototype._setRanges = function (usermin, usermax) {
            if (usermin === void 0) { usermin = NAN; }
            if (usermax === void 0) { usermax = NAN; }
            var tempmin = !ISNAN(usermin) ? usermin : this.min;
            var tempmax = !ISNAN(usermax) ? usermax : this.max;
            _a = this._threshConsider(tempmin, tempmax), tempmin = _a[0], tempmax = _a[1];
            var min$$1 = ~~tempmin;
            var max$$1 = ~~tempmax;
            this.outlierMax = tempmax;
            this.outlierMin = tempmin;
            _b = this._getBinnedMinMax(tempmin, tempmax), min$$1 = _b[0], max$$1 = _b[1];
            this._setThreshold(min$$1, max$$1, true);
            var _a, _b;
        };
        // returns [outMin, outMax]
        FDSDateScale.prototype._getBinnedMinMax = function (inMin, inMax) {
            var intMin = ~~inMin;
            var intMax = ~~inMax;
            var outMin;
            var outMax;
            switch (this._dateBin) {
                case 15 /* WEEK */:
                    outMin = this._weekBin(intMin)[1];
                    outMax = this._weekBin(intMax)[2];
                    break;
                case 16 /* MONTH */:
                    outMin = this._monthBin(intMin)[1];
                    outMax = this._monthBin(intMax)[2];
                    break;
                case 17 /* QUARTER */:
                    outMin = this._quarterBin(intMin)[1];
                    outMax = this._quarterBin(intMax)[2];
                    break;
                case 18 /* HALFY */:
                    outMin = this._halfYearBin(intMin)[1];
                    outMax = this._halfYearBin(intMax)[2];
                    break;
                case 19 /* YEAR */:
                    outMin = this._yearBin(intMin)[1];
                    outMax = this._yearBin(intMax)[2];
                    break;
                default:
                    outMax = intMax;
                    outMin = intMin;
            }
            outMax = this._date.adjustUp((this.getBinned() ? ++outMax : outMax));
            return [outMin, outMax];
        };
        FDSDateScale.prototype.snapToFrequency = function (value) {
            var _a = this._getDateBinRange(this._dateBin, ~~value), lowdate = _a[1];
            return lowdate;
        };
        FDSDateScale.prototype.setFixedMode = function (threshMin, threshMax, hint) {
            return true;
        };
        FDSDateScale.prototype._setTickRanges = function (hint) {
            var min$$1 = ~~this.threshMin;
            var max$$1 = ~~this.threshMax;
            var dateBin = this._date.lookupDateBin(this.csTickDateBin);
            var rangeMin;
            var rangeMax;
            var subRangeMin;
            var subRangeMax;
            if (this.tickMode === 1 /* MINMAX */) {
                rangeMin = rangeMax = subRangeMax = subRangeMin = min$$1;
            }
            else {
                if (dateBin !== 0 /* NONE */) {
                    switch (dateBin) {
                        case 22 /* TENY */:
                            this._tickDateBin = 22 /* TENY */;
                            break;
                        case 21 /* FIVEY */:
                            this._tickDateBin = 21 /* FIVEY */;
                            break;
                        case 20 /* TWOY */:
                            this._tickDateBin = 20 /* TWOY */;
                            break;
                        case 19 /* YEAR */:
                            this._tickDateBin = 19 /* YEAR */;
                            break;
                        case 18 /* HALFY */:
                            this._tickDateBin = 18 /* HALFY */;
                            break;
                        case 17 /* QUARTER */:
                            this._tickDateBin = 17 /* QUARTER */;
                            break;
                        case 16 /* MONTH */:
                            this._tickDateBin = 16 /* MONTH */;
                            break;
                        case 15 /* WEEK */:
                            this._tickDateBin = 15 /* WEEK */;
                            break;
                        default:
                            this._tickDateBin = 14 /* DAY */;
                    }
                }
                else {
                    this._tickDateBin = 19 /* YEAR */;
                    var numDays = this._date.nDays(min$$1, max$$1);
                    var numQuarters = this._date.nQuarters(min$$1, max$$1);
                    if (numQuarters > 16) {
                        this._tickDateBin = 19 /* YEAR */;
                    }
                    else if (numDays > 425) {
                        this._tickDateBin = 17 /* QUARTER */;
                    }
                    else {
                        this._numTicks = this._date.nMonths(min$$1, max$$1);
                        if (this._numTicks > 3) {
                            this._tickDateBin = 16 /* MONTH */;
                        }
                        else {
                            this._numTicks = this._date.nWeeks(min$$1, max$$1);
                            if (this._numTicks > 2) {
                                this._tickDateBin = 15 /* WEEK */;
                            }
                            else {
                                this._tickDateBin = 14 /* DAY */;
                            }
                        }
                    }
                    if (this._dateBin > this._tickDateBin) {
                        this._tickDateBin = this._date.mapToSimpleBin(this._dateBin);
                    }
                }
            }
            switch (this._tickDateBin) {
                case 22 /* TENY */:
                    this._subTickDateBin = 19 /* YEAR */;
                    this._numTicks = ~~((this._date.nYears(min$$1, max$$1)) / 10) + 1;
                    _a = this._date.getNYear(min$$1, 10), rangeMin = _a[1], rangeMax = _a[2];
                    _b = this._date.getYearRange(min$$1), subRangeMin = _b[1], subRangeMax = _b[2];
                    break;
                case 20 /* TWOY */:
                    this._subTickDateBin = 19 /* YEAR */;
                    this._numTicks = ~~((this._date.nYears(min$$1, max$$1)) / 2) + 1;
                    _c = this._date.getNYear(min$$1, 2), rangeMin = _c[1], rangeMax = _c[2];
                    _d = this._date.getYearRange(min$$1), subRangeMin = _d[1], subRangeMax = _d[2];
                    break;
                case 21 /* FIVEY */:
                    this._subTickDateBin = 19 /* YEAR */;
                    this._numTicks = ~~((this._date.nYears(min$$1, max$$1)) / 5) + 1;
                    _e = this._date.getNYear(min$$1, 5), rangeMin = _e[1], rangeMax = _e[2];
                    _f = this._date.getYearRange(min$$1), subRangeMin = _f[1], subRangeMax = _f[2];
                    break;
                case 19 /* YEAR */:
                    this._numTicks = this._date.nYears(min$$1, max$$1);
                    this._subTickDateBin = this._numTicks > 10 ? 0 /* NONE */ : 17 /* QUARTER */;
                    _g = this._date.getYearRange(min$$1), rangeMin = _g[1], rangeMax = _g[2];
                    _h = this._date.getQuarterRange(min$$1), subRangeMin = _h[1], subRangeMax = _h[2];
                    break;
                case 18 /* HALFY */:
                    this._subTickDateBin = 16 /* MONTH */;
                    this._numTicks = this._date.nHalfYears(min$$1, max$$1);
                    _j = this._date.getHalfYearRange(min$$1), rangeMin = _j[1], rangeMax = _j[2];
                    _k = this._date.getMonthRange(min$$1), subRangeMin = _k[1], subRangeMax = _k[2];
                    break;
                case 17 /* QUARTER */:
                    this._subTickDateBin = 16 /* MONTH */;
                    this._numTicks = this._date.nQuarters(min$$1, max$$1);
                    _l = this._date.getQuarterRange(min$$1), rangeMin = _l[1], rangeMax = _l[2];
                    _m = this._date.getMonthRange(min$$1), subRangeMin = _m[1], subRangeMax = _m[2];
                    break;
                case 16 /* MONTH */:
                    this._subTickDateBin = 0 /* NONE */;
                    this._numTicks = this._date.nMonths(min$$1, max$$1);
                    _o = this._date.getMonthRange(min$$1), rangeMin = _o[1], rangeMax = _o[2];
                    subRangeMin = subRangeMax = min$$1;
                    break;
                case 15 /* WEEK */:
                    this._subTickDateBin = 0 /* NONE */;
                    this._numTicks = this._date.nWeeks(min$$1, max$$1);
                    _p = this._date.getWeekRange(min$$1), rangeMin = _p[1], rangeMax = _p[2];
                    subRangeMin = subRangeMax = min$$1;
                    break;
                default:
                    this._subTickDateBin = 0 /* NONE */;
                    this._numTicks = this._date.nDays(min$$1, max$$1);
                    subRangeMin = subRangeMax = rangeMin = rangeMax = min$$1;
            }
            if (rangeMin < min$$1) {
                this.tickMin = this._date.adjustUp(++rangeMax);
            }
            else {
                this.tickMin = rangeMin;
            }
            if (subRangeMin < min$$1) {
                this.subTickMin = this._date.adjustUp(++subRangeMax);
            }
            else {
                this.subTickMin = subRangeMin;
            }
            this.adjustTickRanges(hint);
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        };
        FDSDateScale.prototype._nextHint = function (hint) {
            if (hint > 10) {
                return 10;
            }
            else if (hint > 5) {
                return 5;
            }
            else if (hint > 3) {
                return 3;
            }
            else if (hint > 3) {
                return 2;
            }
            else if (hint > 1) {
                return 1;
            }
            else {
                return 0;
            }
        };
        FDSDateScale.prototype.adjustTickRanges = function (hint) {
            if (hint < 1) {
                hint = 1;
            }
            this.numLabels = Math.ceil(this._numTicks / hint);
            if (this.numLabels < 1) {
                this.numLabels = 1;
            }
            if (this.numTicksHint > 0 && this.numTicksHint < hint) {
                hint = this.numTicksHint;
            }
            if (hint > 20) {
                hint = 20;
            }
            this.tickOffset = this.subTickOffset = this.delta / hint;
            if (this.axis.ticksResize) {
                hint = this._nextHint(hint);
                while (this.tickOffset < 5 && hint > 0) {
                    this.tickOffset = this.subTickOffset = this.delta / hint;
                    hint = this._nextHint(hint);
                }
            }
        };
        FDSDateScale.prototype._initTickHelper = function (tickBinned, refObject, dateTickMin, tickDateBin) {
            if (refObject.tick) {
                refObject.tick.set(0);
            }
            if (refObject.dateTick) {
                refObject.dateTick.set(dateTickMin);
            }
            var dateTick = dateTickMin;
            if (this.tickMode === 1 /* MINMAX */) {
                return;
            }
            else {
                if (this.checkMinDateTickNeeded(tickBinned, dateTick, tickDateBin)) {
                    if (this._labelEndsWithFullBin) {
                        _a = this._date.getCalendarRange(tickDateBin, dateTickMin), dateTick = _a[1];
                        dateTick = this._date.adjust((dateTick - 1));
                        if (this.binLabelMode === 0 /* START */) {
                            _b = this._date.getCalendarRange(tickDateBin, dateTick), dateTick = _b[1];
                        }
                    }
                    else {
                        dateTick = this.threshMin;
                    }
                    refObject.dateTick.set(dateTick);
                }
            }
            var _a, _b;
        };
        // This (admittedly rather clumsy) refObj syntax is required in order to
        // pass values by reference in JavaScript, since we can't do that in a
        // way that isn't quite so verbose. Closures are really the only way,
        // unfortunately.
        FDSDateScale.prototype._initTickVector = function () {
            var _this = this;
            var refObj = {
                tick: {
                    get: function () {
                        return _this._tick;
                    },
                    set: function (val) {
                        _this._tick = val;
                    }
                },
                dateTick: {
                    get: function () {
                        return _this._dateTick;
                    },
                    set: function (val) {
                        _this._dateTick = val;
                    }
                }
            };
            this.ticks = [];
            this._initTickHelper(this.getTickBinned(), refObj, this.tickMin, this._tickDateBin);
        };
        FDSDateScale.prototype._initSubTickVector = function () {
            var _this = this;
            var refObj = {
                tick: {
                    get: function () {
                        return _this._subTick;
                    },
                    set: function (val) {
                        _this._subTick = val;
                    }
                },
                dateTick: {
                    get: function () {
                        return _this._dateSubTick;
                    },
                    set: function (val) {
                        _this._dateSubTick = val;
                    }
                }
            };
            this.subTicks = [];
            this._initTickHelper(this.getTickBinned(), refObj, this.subTickMin, this._subTickDateBin);
        };
        FDSDateScale.prototype._initLabelVector = function () {
            var _this = this;
            var refObj = {
                tick: {
                    get: function () {
                        return _this._label;
                    },
                    set: function (val) {
                        _this._label = val;
                    }
                },
                dateTick: {
                    get: function () {
                        return _this._dateLabel;
                    },
                    set: function (val) {
                        _this._dateLabel = val;
                    }
                }
            };
            var formatString = (this.parentPropertySet.compilePropertyString(this.formatString)).fromValue();
            this.format.setDateFormat(formatString, this._tickDateBin);
            this.labelFormatters[formatString] = this.format;
            this.labels = [];
            this._initTickHelper(this.getLabelBinned(), refObj, this.tickMin, this._tickDateBin);
            if (this.formatString !== this.oldFormat) {
                this.oldFormat = this.formatString;
                this.parseList = this.formatParser.parseConditionalFormat(this.formatString);
                var formats = this.formatParser.getAllFormatsFromParsedList(this.parseList);
                this._createLabelFormatParsers(formats);
            }
        };
        FDSDateScale.prototype._getNextTickHelper = function (refObj, tickDateBin) {
            var threshMax = ~~this.threshMax;
            var dateTick = refObj.dateTick.get();
            var f;
            var bin1;
            var max$$1;
            var min$$1;
            var tickBinned = this.getTickBinned();
            if (dateTick <= threshMax) {
                if (this.tickMode === 1 /* MINMAX */) {
                    f = this._localLookup(dateTick);
                    this._tick++;
                    dateTick = this._date.adjust(Math.round(this._tick * this.tickOffset + this.tickMin));
                }
                else {
                    var dateBin = tickBinned ? 14 /* DAY */ : tickDateBin;
                    _a = this.lookupRange(dateTick, dateBin), f = _a[0], bin1 = _a[1];
                    switch (tickDateBin) {
                        case 15 /* WEEK */:
                            _b = this._date.getWeekRange(dateTick), min$$1 = _b[1], max$$1 = _b[2];
                            break;
                        case 16 /* MONTH */:
                            _c = this._date.getMonthRange(dateTick), min$$1 = _c[1], max$$1 = _c[2];
                            break;
                        case 17 /* QUARTER */:
                            _d = this._date.getQuarterRange(dateTick), min$$1 = _d[1], max$$1 = _d[2];
                            break;
                        case 18 /* HALFY */:
                            _e = this._date.getHalfYearRange(dateTick), min$$1 = _e[1], max$$1 = _e[2];
                            break;
                        case 19 /* YEAR */:
                            _f = this._date.getYearRange(dateTick), min$$1 = _f[1], max$$1 = _f[2];
                            break;
                        case 22 /* TENY */:
                            _g = this._date.getNYear(dateTick, 10), min$$1 = _g[1], max$$1 = _g[2];
                            break;
                        case 20 /* TWOY */:
                            _h = this._date.getNYear(dateTick, 2), min$$1 = _h[1], max$$1 = _h[2];
                            break;
                        case 21 /* FIVEY */:
                            _j = this._date.getNYear(dateTick, 5), min$$1 = _j[1], max$$1 = _j[2];
                            break;
                        default:
                            max$$1 = dateTick;
                            if (this.getBinned() && !tickBinned && this._date.adjustUp(max$$1 + 1) === threshMax) {
                                max$$1 = this._date.adjustUp(max$$1 + 1);
                            }
                    }
                    switch (tickDateBin) {
                        case 15 /* WEEK */:
                        case 22 /* TENY */:
                        case 20 /* TWOY */:
                        case 21 /* FIVEY */:
                            if (this.getBinned() && !tickBinned && this._date.adjustUp(max$$1 + 1) === threshMax) {
                                max$$1 = this._date.adjustUp(max$$1 + 1);
                            }
                            break;
                    }
                    dateTick = this._date.adjustUp(max$$1 + 1);
                    if (tickBinned) {
                        f = bin1;
                    }
                }
                if (!isBounded(f, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                    return null;
                }
            }
            else {
                return null;
            }
            // Set the outval for dateTick and return
            refObj.dateTick.set(dateTick);
            return f;
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        };
        FDSDateScale.prototype._getNextTick = function () {
            var _this = this;
            var refObj = {
                dateTick: {
                    get: function () {
                        return _this._dateTick;
                    },
                    set: function (val) {
                        return _this._dateTick = val;
                    }
                }
            };
            return this._getNextTickHelper(refObj, this._tickDateBin);
        };
        FDSDateScale.prototype._getNextSubTick = function () {
            var _this = this;
            if (this.tickMode === 1 /* MINMAX */ || this._subTickDateBin === 0 /* NONE */) {
                return null;
            }
            var refObj = {
                dateTick: {
                    get: function () {
                        return _this._dateSubTick;
                    },
                    set: function (val) {
                        _this._dateSubTick = val;
                    }
                }
            };
            return this._getNextTickHelper(refObj, this._subTickDateBin);
        };
        FDSDateScale.prototype._getNextLabel = function (plain) {
            var threshMax = ~~this.threshMax;
            var f;
            var labelString;
            if (this._dateLabel <= threshMax) {
                if (this.tickMode === 1 /* MINMAX */) {
                    f = this._localLookup(this._dateLabel);
                    var tempDate = this._dateLabel;
                    labelString = this._formatLabel(tempDate);
                    if (!this._compiledLabelOverride.isEmpty()) {
                        var overrideReturn = this._compiledLabelOverride.fromValueRT({
                            labelValue: tempDate,
                            formattedLabel: labelString
                        });
                        labelString = overrideReturn;
                    }
                    this._label++;
                    this._dateLabel = this._date.adjust(Math.round(this._label * this.tickOffset + this.tickMin));
                }
                else {
                    var dateBin = this._tickDateBin;
                    var low = void 0;
                    var high = void 0;
                    if (this.numLabels === 0) {
                        return null;
                    }
                    var _a = this._date.getCalendarRange(this._tickDateBin, this._dateLabel), rangeMax = _a[2];
                    if (this.checkMaxDateTickNeeded(this.getLabelBinned(), rangeMax, this._tickDateBin)) {
                        return null;
                    }
                    _b = this.lookupRange(this._dateLabel, dateBin), f = _b[0], low = _b[1], high = _b[2];
                    if (this.reverse) {
                        // these are backwards for reversed scales
                        _c = [low, high], high = _c[0], low = _c[1];
                    }
                    var lLabel = this._dateLabel;
                    if (this.getBinned()) {
                        if (this.binLabelMode === 1 /* END */) {
                            if (!this.getLabelBinned()) {
                                lLabel = rangeMax;
                                if (!this._labelEndsWithFullBin && lLabel > threshMax) {
                                    lLabel = threshMax;
                                }
                            }
                            else {
                                lLabel = this._date.adjust(lLabel - 1);
                            }
                        }
                    }
                    if (this._labelShift > 0.0) {
                        lLabel = this._date.adjustUp((lLabel + this._labelShift));
                    }
                    else if (this._labelShift < 0.0) {
                        lLabel = this._date.adjust((lLabel + this._labelShift));
                    }
                    labelString = this._formatLabel(lLabel);
                    if (!this._compiledLabelOverride.isEmpty()) {
                        var overrideReturn = this._compiledLabelOverride.fromValueRT({
                            labelValue: lLabel,
                            formattedLabel: labelString
                        });
                        labelString = overrideReturn;
                    }
                    this._dateLabel = this._date.adjustUp((rangeMax + 1));
                    for (var i = 1; i < this.numLabels; i++) {
                        _d = this._date.getCalendarRange(this._tickDateBin, this._dateLabel), rangeMax = _d[2];
                        this._dateLabel = this._date.adjustUp((rangeMax + 1));
                    }
                    if (this.getLabelBinned()) {
                        f = low;
                    }
                }
                if (f != null && !isBounded(f, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                    return null;
                }
            }
            else {
                return null;
            }
            return [RichTextString.join(this.labelPrefix, labelString, this.labelPostfix), f, undefined];
            var _b, _c, _d;
        };
        // Outliers do not work on this scale.
        FDSDateScale.prototype.upperOutlierActive = function () {
            return false;
        };
        FDSDateScale.prototype.lowerOutlierActive = function () {
            return false;
        };
        FDSDateScale.prototype.computeLabelVector = function () {
            this._initLabelVector();
            if (this.padLabels) {
                this._computeLabelVectorInternal(true);
                this.padLength = this._getPadLength();
                this.labels = [];
                this._label = 0;
            }
            this._computeLabelVectorInternal(false);
        };
        FDSDateScale.prototype._computeLabelVectorInternal = function (plain) {
            if (plain === void 0) { plain = false; }
            var label;
            var safety = 0;
            while ((label = this._getNextLabel(plain)) && safety++ < this.tickSafety) {
                this.labels.push(label);
            }
        };
        FDSDateScale.prototype.getLabelFormatter = function (formatString) {
            var formatter = new FDSFormat();
            formatter.setDateFormat(formatString);
            return formatter;
        };
        FDSDateScale.prototype.compressValue = function (value) {
            var date = new FDSDate();
            date.setWeekType(this.weekType);
            return ~~(date.compress(value));
        };
        FDSDateScale.prototype.decompressValue = function (value) {
            var date = new FDSDate();
            date.setWeekType(this.weekType);
            return ~~(date.decompress(value));
        };
        return FDSDateScale;
    }(FDSScale));
    
    var FDSDateTimeScale = /** @class */ (function (_super) {
        __extends(FDSDateTimeScale, _super);
        function FDSDateTimeScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _this._date = new FDSDate();
            _this._time = new FDSTime(0 /* FIVE_DAY */);
            _this._timeBin = 0;
            _this.scaleType = 8 /* DATETIME */;
            _this._dateBin = 14 /* DAY */;
            _this._minFrac = _this._maxFrac = NAN;
            _this._subThreshMaxMax = _this._subThreshMaxMin = _this._subThreshMinMax = _this._subThreshMinMin = NAN;
            _this._compressedThreshMin = _this._compressedThreshMax = NAN;
            _this._tickTimeBin = _this._subTickTimeBin = 0;
            _this._tickDateBin = _this._subTickDateBin = 0 /* NONE */;
            _this._numTicks = 0;
            _this._compressedTickOffset = 0;
            _this._dateTick = _this._dateTimeLabel = _this._dateTimeTick = _this._dateTimeSubTick = 0;
            return _this;
        }
        FDSDateTimeScale.prototype.getLog = function () {
            return false;
        };
        FDSDateTimeScale.prototype.supportLog = function () {
            return false;
        };
        FDSDateTimeScale.prototype._formatLabel = function (value) {
            var format = this.formatString;
            // conditional formatted label, needs to be dealt with on a case-by-case basis
            if ((this.parseList != null) && this.parseList.length > 0) {
                format = this.formatParser.applyParsedList(this.parseList, value);
            }
            // Process `LabelFormat` for property strings
            if (!this.isLabelFormatDefault) {
                this.compiledFormatString = this.parentPropertySet.compilePropertyString(format);
                format = this.compiledFormatString.fromValue();
            }
            var formatter = this.labelFormatters[format];
            if (formatter != null) {
                return new RichTextString(formatter.formatAsDateTime(value));
            }
            return RichTextString.Empty;
        };
        FDSDateTimeScale.prototype._setBeginningOfDay = function (time) {
            this._time.setBeginningOfDay(time);
        };
        FDSDateTimeScale.prototype._getBeginningOfDay = function () {
            return this._time.getBeginningOfDay();
        };
        FDSDateTimeScale.prototype._setEndOfDay = function (time) {
            this._time.setEndOfDay(time);
        };
        FDSDateTimeScale.prototype._getEndOfDay = function () {
            return this._time.getEndOfDay();
        };
        FDSDateTimeScale.prototype._setRanges = function (usermin, usermax) {
            if (usermin === void 0) { usermin = NAN; }
            if (usermax === void 0) { usermax = NAN; }
            var tempmin = ISNAN(usermin) ? this.min : usermin;
            var tempmax = ISNAN(usermax) ? this.max : usermax;
            var min$$1 = this.min;
            var max$$1 = this.max;
            _a = this._threshConsider(tempmin, tempmax), tempmin = _a[0], tempmax = _a[1];
            this.outlierMax = tempmax;
            this.outlierMin = tempmin;
            _b = this._getBinnedMinMax(tempmin, tempmax), min$$1 = _b[0], max$$1 = _b[1];
            this._setThreshold(min$$1, max$$1, true);
            var _a, _b;
        };
        FDSDateTimeScale.prototype.setFixedMode = function (threshMin, threshMax, hint) {
            return true;
        };
        // returns [outMin, outMax]
        FDSDateTimeScale.prototype._getBinnedMinMax = function (inMin, inMax) {
            var outMin;
            var outMax;
            switch (this._dateBin) {
                case 14 /* DAY */:
                    outMin = this._time.getDayStd(inMin)[1];
                    outMax = this._time.getDayStd(inMax)[2];
                    break;
                case 15 /* WEEK */:
                    outMin = this._date.getWeekRange(inMin)[1];
                    outMax = this._date.getWeekRange(inMax)[2];
                    break;
                case 16 /* MONTH */:
                    outMin = this._date.getMonthRange(inMin)[1];
                    outMax = this._date.getMonthRange(inMax)[2];
                    break;
                case 17 /* QUARTER */:
                    outMin = this._date.getQuarterRange(inMin)[1];
                    outMax = this._date.getQuarterRange(inMax)[2];
                    break;
                case 18 /* HALFY */:
                    outMin = this._date.getHalfYearRange(inMin)[1];
                    outMax = this._date.getHalfYearRange(inMax)[2];
                    break;
                case 19 /* YEAR */:
                    outMin = this._date.getYearRange(inMin)[1];
                    outMax = this._date.getYearRange(inMax)[2];
                    break;
                default:
                    if (this._timeBin > 0) {
                        outMin = (this._time.getTimeBinStdRange(inMin, this._timeBin))[1];
                        outMax = (this._time.getTimeBinStdRange(inMax, this._timeBin))[2];
                        outMax = this._time.adjustTimeStd(outMax, 1);
                        var frac = FDSTime.getTimeFrac(outMin);
                        if (frac < this._getBeginningOfDay()) {
                            this._setBeginningOfDay(frac);
                        }
                        frac = FDSTime.getTimeFrac(outMax);
                        if (frac > this._getEndOfDay()) {
                            this._setEndOfDay(frac);
                        }
                    }
                    else {
                        outMax = inMax;
                        outMin = inMin;
                    }
            }
            if (outMin == null) {
                outMin = inMin;
            }
            if (outMax == null) {
                outMax = inMax;
            }
            if (this._dateBin > 14 /* DAY */) {
                outMax = this._time.adjustUp(~~(this.getBinned ? ++outMax : outMax));
            }
            return [outMin, outMax];
        };
        FDSDateTimeScale.prototype.reset = function () {
            this.setWeekType(0 /* FIVE_DAY */);
            this.setTickBinned(true);
            if (this._minFrac < 0.05 && this._maxFrac > 0.95) {
                this._time.setBeginningOfDay(NAN);
                this._time.setEndOfDay(NAN);
            }
            else {
                this._time.setBeginningOfDay(this._minFrac);
                this._time.setEndOfDay(this._minFrac);
            }
            this._setRanges();
        };
        FDSDateTimeScale.prototype.adjust = function (dataset) {
            var stats = dataset.statistics;
            if (!this.initialized) {
                return this.initialize(dataset);
            }
            else {
                if (stats.min < this.min) {
                    this.min = stats.min;
                }
                if (stats.max > this.max) {
                    this.max = stats.max;
                }
                if (dataset.getNeedTime()) {
                    if (isNaN(this._minFrac) || stats.minFrac < this._minFrac) {
                        this._minFrac = stats.minFrac;
                    }
                    if (isNaN(this._maxFrac) || stats.maxFrac > this._maxFrac) {
                        this._maxFrac = stats.maxFrac;
                    }
                }
                if (dataset.getDateBin() < this._dateBin) {
                    this._dateBin = dataset.getDateBin();
                }
                if (dataset.getTimeBin() < this._timeBin) {
                    this._timeBin = dataset.getTimeBin();
                }
                this._setRanges();
                return true;
            }
        };
        FDSDateTimeScale.prototype.initialize = function (dataset) {
            var stats = dataset.statistics;
            if (stats.count > 0) {
                this.min = stats.min;
                this.max = stats.max;
                this._dateBin = dataset.getDateBin();
                this._timeBin = dataset.getTimeBin();
                if (dataset.getNeedTime()) {
                    this._minFrac = stats.minFrac;
                    this._maxFrac = stats.maxFrac;
                }
                this._setRanges();
                return this.initialized = true;
            }
            else {
                return false;
            }
        };
        FDSDateTimeScale.prototype._snapToFrequencyHelper = function (value, dateBin, timeBin) {
            var todo = timeBin > 0 ? 0 /* NONE */ : dateBin;
            var lowdate;
            var highdate;
            switch (todo) {
                case 14 /* DAY */:
                    _a = this._time.getDayStd(value), lowdate = _a[1], highdate = _a[2];
                    break;
                case 15 /* WEEK */:
                    _b = this._time.getWeekStd(value), lowdate = _b[1], highdate = _b[2];
                    break;
                case 16 /* MONTH */:
                    _c = this._time.getMonthStd(value), lowdate = _c[1], highdate = _c[2];
                    break;
                case 17 /* QUARTER */:
                    _d = this._time.getQuarterStd(value), lowdate = _d[1], highdate = _d[2];
                    break;
                case 18 /* HALFY */:
                    _e = this._time.getHalfYearStd(value), lowdate = _e[1], highdate = _e[2];
                    break;
                case 19 /* YEAR */:
                    _f = this._time.getYearStd(value), lowdate = _f[1], highdate = _f[2];
                    break;
                default:
                    if (timeBin > 0) {
                        _g = this._time.getTimeBinStdRange(value, timeBin), lowdate = _g[1], highdate = _g[2];
                    }
                    else {
                        lowdate = highdate = value;
                    }
            }
            return [lowdate, highdate];
            var _a, _b, _c, _d, _e, _f, _g;
        };
        FDSDateTimeScale.prototype.lookup = function (value) {
            var retval;
            if (this.getBinned()) {
                _a = this.lookupRange(value), retval = _a[0];
            }
            else {
                retval = this._localLookup(value);
            }
            return this.applyPlotFactorNDC(retval);
            var _a;
        };
        // returns [value, low, high, offset]
        FDSDateTimeScale.prototype.lookupRange = function (value, dateBin, timeBin) {
            if (dateBin === void 0) { dateBin = this._dateBin; }
            if (timeBin === void 0) { timeBin = this._timeBin; }
            /* tslint:disable-next-line:prefer-const */
            var _a = this._snapToFrequencyHelper(value, dateBin, timeBin), lowdate = _a[0], highdate = _a[1];
            if (dateBin > 14 /* DAY */) {
                highdate = this._time.adjustUp((~~(++highdate)));
            }
            else {
                highdate = this._time.adjustTimeStd(highdate, 1);
            }
            var low = this._localLookup(lowdate);
            var high = this._localLookup(highdate);
            var offset = ((high - low) * (1.0 - this.getBinFactor())) / 2.0;
            var rval = this.getBinned() ? (low + high) / 2.0 : low;
            return [rval, low, high, offset];
        };
        FDSDateTimeScale.prototype.computeValue = function (ndc) {
            var min$$1 = this._compressedThreshMin;
            var delta = this._compressedThreshMax - min$$1;
            if (this.reverse) {
                return this._time.decompressStd(((1.0 - ndc) * delta + min$$1));
            }
            else {
                return this._time.decompressStd((ndc * delta + min$$1));
            }
        };
        FDSDateTimeScale.prototype.snapToFrequency = function (value) {
            var lowDate = this._snapToFrequencyHelper(value, this._dateBin, this._timeBin)[0];
            return lowDate;
        };
        FDSDateTimeScale.prototype._localLookup = function (value) {
            var min$$1 = this._compressedThreshMin;
            var delta = this._compressedThreshMax - min$$1;
            if (delta === 0.0) {
                delta = 1.0;
            }
            var val = this._time.compressUpStd(value);
            var scaledBins = (val - min$$1) / delta;
            if (this.reverse) {
                return 1.0 - scaledBins;
            }
            else {
                return scaledBins;
            }
        };
        FDSDateTimeScale.prototype._setNumber = function (min$$1, max$$1) {
            var defaultOverride = function (_min, _max) {
                if (this._timeBin > 0) {
                    this.number = (this._time.nTimeBinsStd(this._timeBin, _min, _max)) + 1;
                }
                else {
                    this.number = (this._time.nCompressedDays(_min, _max)) + 1;
                }
                return;
            };
            // Since the FDSDateScaleNamespace equivalent call is pretty much the same thing
            // modulo the default case, we do this, which basically calls it s
            // setNumber function in our execution context. Pretty neat, JS.
            FDSDateScale.prototype.setNumber.call(this, min$$1, max$$1, defaultOverride);
        };
        FDSDateTimeScale.prototype._setThreshold = function (min$$1, max$$1, ticks) {
            if (ISNAN(min$$1)) {
                min$$1 = this.threshMin;
            }
            if (ISNAN(max$$1)) {
                max$$1 = this.threshMax;
            }
            var frac = FDSTime.getTimeFrac(min$$1);
            if (frac < this._getBeginningOfDay()) {
                this._setBeginningOfDay(frac);
            }
            frac = FDSTime.getTimeFrac(max$$1);
            if (frac > this._getEndOfDay()) {
                this._setEndOfDay(frac);
            }
            _super.prototype._setThreshold.call(this, min$$1, max$$1, ticks);
            this._setNumber(min$$1, max$$1);
            this._compressedThreshMin = this._time.compressUpStd(this.threshMin);
            this._compressedThreshMax = this._time.compressUpStd(this.threshMax);
        };
        FDSDateTimeScale.prototype._checkInCompressionZone = function (tick, timeBin) {
            var frac = FDSTime.getTimeFrac(tick);
            if (this._time.weekType === 0 /* FIVE_DAY */) {
                if (FDSDate.isWeekend((~~tick))) {
                    return true;
                }
            }
            if (!(this._getBeginningOfDay() <= frac && frac <= this._getEndOfDay())) {
                if (timeBin > 0) {
                    return false;
                }
            }
            return false;
        };
        FDSDateTimeScale.prototype._checkInDayMin = function (tick, min$$1) {
            if (tick < min$$1) {
                if (~~tick === ~~min$$1 && FDSTime.getTimeFrac(min$$1) < this._getBeginningOfDay()) {
                    return false;
                }
                else {
                    return true;
                }
            }
            return false;
        };
        FDSDateTimeScale.prototype._checkInDayMax = function (tick, max$$1) {
            if (tick < max$$1) {
                return true;
            }
            else {
                if (~~tick < ~~(max$$1 + 1) && FDSTime.getTimeFrac(max$$1) > this._getEndOfDay()) {
                    return true;
                }
            }
            return false;
        };
        FDSDateTimeScale.prototype._computeTimeBinSize = function () {
            var numTicks = this._time.nTimeBinsStd(1, this.threshMin, this.threshMax);
            if (numTicks > 54000) {
                return 30000;
            }
            else if (numTicks > 36000) {
                return 20000;
            }
            else if (numTicks > 18000) {
                return 10000;
            }
            else if (numTicks > 7200) {
                return 3000;
            }
            else if (numTicks > 3600) {
                return 1000;
            }
            else if (numTicks > 1800) {
                return 500;
            }
            else if (numTicks > 600) {
                return 200;
            }
            else if (numTicks > 300) {
                return 100;
            }
            else if (numTicks > 180) {
                return 30;
            }
            else if (numTicks > 60) {
                return 10;
            }
            else if (numTicks > 20) {
                return 5;
            }
            else if (numTicks > 10) {
                return 2;
            }
            else {
                return 0;
            }
        };
        FDSDateTimeScale.prototype._setTickRanges = function (hint) {
            var min$$1 = this.threshMin;
            var max$$1 = this.threshMax;
            var dateBin = this._date.lookupDateBin(this.csTickDateBin);
            this._tickTimeBin = this._date.lookupTimeBin(this.csTickDateBin);
            this._subTickTimeBin = 0;
            var rangeMin;
            var rangeMax;
            var subRangeMin;
            var subRangeMax;
            if (this._tickTimeBin > 0) {
                dateBin = 14 /* DAY */;
            }
            if (this.tickMode === 1 /* MINMAX */) {
                rangeMin = rangeMax = subRangeMax = subRangeMin = min$$1;
            }
            else {
                if (dateBin !== 0 /* NONE */) {
                    switch (dateBin) {
                        case 22 /* TENY */:
                            this._tickDateBin = 22 /* TENY */;
                            break;
                        case 21 /* FIVEY */:
                            this._tickDateBin = 21 /* FIVEY */;
                            break;
                        case 20 /* TWOY */:
                            this._tickDateBin = 20 /* TWOY */;
                            break;
                        case 19 /* YEAR */:
                            this._tickDateBin = 19 /* YEAR */;
                            break;
                        case 18 /* HALFY */:
                            this._tickDateBin = 18 /* HALFY */;
                            break;
                        case 17 /* QUARTER */:
                            this._tickDateBin = 17 /* QUARTER */;
                            break;
                        case 16 /* MONTH */:
                            this._tickDateBin = 16 /* MONTH */;
                            break;
                        case 15 /* WEEK */:
                            this._tickDateBin = 15 /* WEEK */;
                            break;
                        default:
                            this._tickDateBin = 14 /* DAY */;
                    }
                }
                else {
                    this._tickDateBin = 14 /* DAY */;
                    var numDays = this._time.nCompressedDays(min$$1, max$$1);
                    var numQuarters = this._time.nQuarters(min$$1, max$$1);
                    if (numDays >= 1) {
                        if (numQuarters > 16) {
                            this._tickDateBin = 19 /* YEAR */;
                        }
                        else if (numDays > 425) {
                            this._tickDateBin = 17 /* QUARTER */;
                        }
                        else {
                            this._numTicks = this._date.nMonths(min$$1, max$$1);
                            if (this._numTicks > 3) {
                                this._tickDateBin = 16 /* MONTH */;
                            }
                            else {
                                this._numTicks = this._date.nWeeks(min$$1, max$$1);
                                if (this._numTicks > 2) {
                                    this._tickDateBin = 15 /* WEEK */;
                                }
                                else {
                                    this._tickDateBin = 14 /* DAY */;
                                    if (numDays < 5) {
                                        if (numDays > 2) {
                                            this._tickTimeBin = 120000;
                                        }
                                        else if (numDays > 1) {
                                            this._tickTimeBin = 60000;
                                        }
                                        else {
                                            this._tickTimeBin = this._computeTimeBinSize();
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        this._tickTimeBin = this._computeTimeBinSize();
                    }
                    if (this._dateBin > this._tickDateBin) {
                        this._tickDateBin = this._date.mapToSimpleBin(this._dateBin);
                    }
                }
                switch (this._tickDateBin) {
                    case 22 /* TENY */:
                        this._subTickDateBin = 19 /* YEAR */;
                        this._numTicks = (this._date.nYears(min$$1, max$$1)) / 10 + 1;
                        _a = this._date.getNYear(min$$1, 10), rangeMin = _a[1], rangeMax = _a[2];
                        _b = this._date.getYearRange(min$$1), subRangeMin = _b[1], subRangeMax = _b[2];
                        break;
                    case 20 /* TWOY */:
                        this._subTickDateBin = 19 /* YEAR */;
                        this._numTicks = (this._date.nYears(min$$1, max$$1)) / 2 + 1;
                        _c = this._date.getNYear(min$$1, 2), rangeMin = _c[1], rangeMax = _c[2];
                        _d = this._date.getYearRange(min$$1), subRangeMin = _d[1], subRangeMax = _d[2];
                        break;
                    case 21 /* FIVEY */:
                        this._subTickDateBin = 19 /* YEAR */;
                        this._numTicks = (this._date.nYears(min$$1, max$$1)) / 5 + 1;
                        _e = this._date.getNYear(min$$1, 5), rangeMin = _e[1], rangeMax = _e[2];
                        _f = this._date.getYearRange(min$$1), subRangeMin = _f[1], subRangeMax = _f[2];
                        break;
                    case 19 /* YEAR */:
                        this._numTicks = this._date.nYears(min$$1, max$$1);
                        this._subTickDateBin = this._numTicks > 10 ? 0 /* NONE */ : 17 /* QUARTER */;
                        _g = this._date.getYearRange(min$$1), rangeMin = _g[1], rangeMax = _g[2];
                        _h = this._date.getQuarterRange(min$$1), subRangeMin = _h[1], subRangeMax = _h[2];
                        break;
                    case 18 /* HALFY */:
                        this._numTicks = this._date.nHalfYears(min$$1, max$$1);
                        this._subTickDateBin = this._numTicks > 10 ? 0 /* NONE */ : 16 /* MONTH */;
                        _j = this._date.getHalfYearRange(min$$1), rangeMin = _j[1], rangeMax = _j[2];
                        _k = this._date.getMonthRange(min$$1), subRangeMin = _k[1], subRangeMax = _k[2];
                        break;
                    case 17 /* QUARTER */:
                        this._subTickDateBin = 16 /* MONTH */;
                        this._numTicks = this._date.nQuarters(min$$1, max$$1);
                        _l = this._date.getQuarterRange(min$$1), rangeMin = _l[1], rangeMax = _l[2];
                        _m = this._date.getMonthRange(min$$1), subRangeMin = _m[1], subRangeMax = _m[2];
                        break;
                    case 16 /* MONTH */:
                        this._subTickDateBin = 0 /* NONE */;
                        this._numTicks = this._date.nMonths(min$$1, max$$1);
                        _o = this._date.getMonthRange(min$$1), rangeMin = _o[1], rangeMax = _o[2];
                        subRangeMin = subRangeMax = ~~min$$1;
                        break;
                    case 15 /* WEEK */:
                        this._subTickDateBin = 0 /* NONE */;
                        this._numTicks = this._date.nWeeks(min$$1, max$$1);
                        _p = this._date.getWeekRange(min$$1), rangeMin = _p[1], rangeMax = _p[2];
                        subRangeMin = subRangeMax = ~~min$$1;
                        break;
                    default:
                        this._subTickDateBin = 0 /* NONE */;
                        this._numTicks = this._time.nCompressedDays(min$$1, max$$1);
                        if (this._numTicks > 0) {
                            this._subTickTimeBin = 30000;
                        }
                        rangeMin = rangeMax = subRangeMin = subRangeMax = ~~min$$1;
                }
            }
            if (this._tickDateBin <= 14 /* DAY */ && this._tickTimeBin > 0) {
                this._numTicks = this._time.nTimeBinsStd(this._tickTimeBin, min$$1, max$$1);
                _q = this._time.getTimeBinStdRange(min$$1, this._tickTimeBin), rangeMin = _q[1], rangeMax = _q[2];
                if (rangeMin < min$$1) {
                    this.tickMin = this._time.adjustTimeStd(rangeMax, 1);
                }
                else {
                    this.tickMin = rangeMin;
                }
                this._subTickTimeBin = 0;
            }
            else {
                if (this._checkInDayMin(rangeMin, min$$1)) {
                    this.tickMin = this._time.adjustUp(++rangeMax);
                }
                else {
                    this.tickMin = rangeMin;
                }
                if (this._checkInDayMin(subRangeMin, min$$1)) {
                    this.subTickMin = this._time.adjustUp(++subRangeMax);
                }
                else {
                    this.subTickMin = subRangeMin;
                }
            }
            this.adjustTickRanges(hint);
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        };
        FDSDateTimeScale.prototype.adjustTickRanges = function (hint) {
            if (hint < 1) {
                hint = 1;
            }
            this.numLabels = Math.ceil(this._numTicks / hint);
            if (this.numLabels < 1) {
                this.numLabels = 1;
            }
            if (this.numTicksHint > 0 && this.numTicksHint < hint) {
                hint = this.numTicksHint;
            }
            if (hint > 20) {
                hint = 20;
            }
            this.tickOffset = this.subTickOffset = this.delta / hint;
            this._compressedTickOffset = 1.0 / hint;
        };
        FDSDateTimeScale.prototype._initTickHelper = function (tickBinned, refObj, dateTickMin, tickDateBin, tickTimeBin) {
            var _this = this;
            refObj.tick.set(0);
            var dateTick = dateTickMin;
            refObj.dateTick.set(dateTick);
            var threshMin;
            var rangeFunc;
            if (this.tickMode === 1 /* MINMAX */) {
                return;
            }
            else {
                switch (tickDateBin) {
                    case 16 /* MONTH */:
                        threshMin = 20;
                        rangeFunc = function () {
                            return _this._date.getMonthRange(dateTickMin);
                        };
                        break;
                    case 19 /* YEAR */:
                        threshMin = 200;
                        rangeFunc = function () {
                            return _this._date.getYearRange(dateTickMin);
                        };
                        break;
                    case 22 /* TENY */:
                        threshMin = 1900;
                        rangeFunc = function () {
                            return _this._date.getNYear(_this.threshMin, 10);
                        };
                        break;
                    case 21 /* FIVEY */:
                        threshMin = 950;
                        rangeFunc = function () {
                            return _this._date.getNYear(_this.threshMin, 5);
                        };
                        break;
                    case 20 /* TWOY */:
                        threshMin = 380;
                        rangeFunc = function () {
                            return _this._date.getNYear(_this.threshMin, 2);
                        };
                        break;
                    default:
                        return;
                }
                if (!tickBinned && this.getBinned && dateTick - this.threshMin > threshMin) {
                    _a = rangeFunc(), dateTick = _a[1];
                    dateTick = this._time.adjust((dateTick - 1));
                }
                refObj.dateTick.set(dateTick);
            }
            var _a;
        };
        FDSDateTimeScale.prototype._initTickVector = function () {
            var _this = this;
            var refObj = {
                tick: {
                    get: function () {
                        return _this._tick;
                    },
                    set: function (val) {
                        _this._tick = val;
                    }
                },
                dateTick: {
                    get: function () {
                        return _this._dateTimeTick;
                    },
                    set: function (val) {
                        _this._dateTimeTick = val;
                    }
                }
            };
            this.ticks = [];
            this._initTickHelper(this.getTickBinned(), refObj, this.tickMin, this._tickDateBin, this._tickTimeBin);
        };
        FDSDateTimeScale.prototype._initSubTickVector = function () {
            var _this = this;
            var refObj = {
                tick: {
                    get: function () {
                        return _this._subTick;
                    },
                    set: function (val) {
                        _this._subTick = val;
                    }
                },
                dateTick: {
                    get: function () {
                        return _this._dateTimeSubTick;
                    },
                    set: function (val) {
                        _this._dateTimeSubTick = val;
                    }
                }
            };
            this.subTicks = [];
            this._initTickHelper(this.getTickBinned(), refObj, this.subTickMin, this._subTickDateBin, this._tickTimeBin);
        };
        FDSDateTimeScale.prototype._initLabelVector = function () {
            var _this = this;
            var refObj = {
                tick: {
                    get: function () {
                        return _this._label;
                    },
                    set: function (val) {
                        _this._label = val;
                    }
                },
                dateTick: {
                    get: function () {
                        return _this._dateTimeLabel;
                    },
                    set: function (val) {
                        _this._dateTimeLabel = val;
                    }
                }
            };
            var formatString = (this.parentPropertySet.compilePropertyString(this.formatString)).fromValue();
            this.format.setDateTimeFormat(formatString, this._tickDateBin, this._tickTimeBin, true);
            this.labelFormatters[formatString] = this.format;
            this.labels = [];
            this._initTickHelper(this.getLabelBinned(), refObj, this.tickMin, this._tickDateBin, this._tickTimeBin);
            if (this.formatString !== this.oldFormat) {
                this.oldFormat = this.formatString;
                this.parseList = this.formatParser.parseConditionalFormat(this.formatString);
                var formats = this.formatParser.getAllFormatsFromParsedList(this.parseList);
                this._createLabelFormatParsers(formats);
            }
        };
        FDSDateTimeScale.prototype._getNextTickHelper = function (refObj, tickDateBin, tickTimeBin) {
            var _this = this;
            var threshMax = this.threshMax;
            var dateTick = refObj.dateTick.get();
            var f;
            var bin1;
            var max$$1;
            var min$$1;
            var frangeMax;
            var tickBinned = this.getTickBinned();
            if (this._checkInDayMax(dateTick, threshMax)) {
                if (this.tickMode === 1 /* MINMAX */) {
                    f = this._localLookup((this.computeValue(this._tick * this._compressedTickOffset)));
                    this._tick++;
                }
                else {
                    var dateBin = tickBinned ? 14 /* DAY */ : tickDateBin;
                    _a = this.lookupRange(dateTick, dateBin, tickTimeBin), f = _a[0], bin1 = _a[1];
                    var nYearHelper_1 = function (jdate, n) {
                        var value;
                        _a = _this._date.getNYear(jdate, n), value = _a[0], min$$1 = _a[1], max$$1 = _a[2];
                        if (_this.getBinned && !tickBinned && (_this._time.adjustUp(max$$1 + 1) === threshMax)) {
                            max$$1 = _this._time.adjustUp((max$$1 + 1));
                        }
                        return [value, min$$1, max$$1];
                        var _a;
                    };
                    var rangeFunc = void 0;
                    switch (tickDateBin) {
                        case 15 /* WEEK */:
                            rangeFunc = function (jdate) {
                                var week;
                                _a = _this._date.getWeekRange(jdate), week = _a[0], min$$1 = _a[1], max$$1 = _a[2];
                                if (_this.getBinned() && !tickBinned && (_this._time.adjustUp(max$$1 + 1) === threshMax)) {
                                    max$$1 = _this._time.adjustUp(max$$1 + 1);
                                }
                                return [week, min$$1, max$$1];
                                var _a;
                            };
                            break;
                        case 16 /* MONTH */:
                            rangeFunc = function (jdate) {
                                return _this._date.getMonthRange(jdate);
                            };
                            break;
                        case 17 /* QUARTER */:
                            rangeFunc = function (jdate) {
                                return _this._date.getQuarterRange(jdate);
                            };
                            break;
                        case 18 /* HALFY */:
                            rangeFunc = function (jdate) {
                                return _this._date.getHalfYearRange(jdate);
                            };
                            break;
                        case 19 /* YEAR */:
                            rangeFunc = function (jdate) {
                                return _this._date.getYearRange(jdate);
                            };
                            break;
                        case 22 /* TENY */:
                            rangeFunc = function (jdate) {
                                return nYearHelper_1.call(_this, jdate, 10);
                            };
                            break;
                        case 21 /* FIVEY */:
                            rangeFunc = function (jdate) {
                                return nYearHelper_1.call(_this, jdate, 5);
                            };
                            break;
                        case 20 /* TWOY */:
                            rangeFunc = function (jdate) {
                                return nYearHelper_1.call(_this, jdate, 2);
                            };
                            break;
                        default:
                            max$$1 = dateTick;
                            if (tickTimeBin === 0) {
                                if (this.getBinned && !tickBinned && this._time.adjustUp(max$$1 + 1) === threshMax) {
                                    max$$1 = this._time.adjustUp((max$$1 + 1));
                                }
                            }
                            else {
                                frangeMax = (this._time.getTimeBinStdRange(dateTick, tickTimeBin))[2];
                                if (this.getBinned && !tickBinned && (this._time.adjustTimeStd(frangeMax, 1)) === threshMax) {
                                    frangeMax = this._time.adjustTime(frangeMax, 1);
                                }
                            }
                    }
                    if (rangeFunc) {
                        _b = rangeFunc(dateTick), min$$1 = _b[1], max$$1 = _b[2];
                    }
                    if (tickTimeBin === 0 && max$$1 != null) {
                        dateTick = this._time.adjustUp(max$$1 + 1);
                    }
                    else if (frangeMax != null) {
                        dateTick = this._time.adjustTimeStd(frangeMax, 1);
                    }
                }
                f = this.applyPlotFactorNDC(f);
                if (!isBounded(f, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                    return null;
                }
            }
            else {
                return null;
            }
            refObj.dateTick.set(dateTick);
            return f;
            var _a, _b;
        };
        FDSDateTimeScale.prototype._getNextTick = function () {
            var _this = this;
            var refObj = {
                dateTick: {
                    get: function () {
                        return _this._dateTimeTick;
                    },
                    set: function (val) {
                        _this._dateTimeTick = val;
                    }
                }
            };
            return this._getNextTickHelper(refObj, this._tickDateBin, this._tickTimeBin);
        };
        FDSDateTimeScale.prototype._getNextSubTick = function () {
            var _this = this;
            if (this.tickMode === 1 /* MINMAX */ || this._subTickDateBin === 0 /* NONE */) {
                return null;
            }
            var refObj = {
                dateTick: {
                    get: function () {
                        return _this._dateTimeSubTick;
                    },
                    set: function (val) {
                        _this._dateTimeSubTick = val;
                    }
                }
            };
            return this._getNextTickHelper(refObj, this._subTickDateBin, this._subTickTimeBin);
        };
        FDSDateTimeScale.prototype._getNextLabel = function (plain) {
            var _a = this, threshMin = _a.threshMin, threshMax = _a.threshMax;
            var f = 0;
            var low = 0;
            var labelString = RichTextString.Empty;
            if (this._checkInDayMax(this._dateTimeLabel, threshMax)) {
                if (this.tickMode === 1 /* MINMAX */) {
                    var ndays = (~~threshMax) - (~~threshMin);
                    var decompressedTick = this.computeValue((this._label * this._compressedTickOffset));
                    f = this._localLookup(decompressedTick);
                    if (f === 1.0) {
                        decompressedTick = threshMax;
                    }
                    labelString = this._formatLabel(decompressedTick);
                    if (!this._compiledLabelOverride.isEmpty()) {
                        var overrideReturn = this._compiledLabelOverride.fromValueRT({
                            labelValue: decompressedTick,
                            formattedLabel: labelString
                        });
                        labelString = overrideReturn;
                    }
                    this._label++;
                }
                else {
                    var threshDiff = void 0;
                    var rangeMin = void 0;
                    var rangeMax = void 0;
                    for (var i = 0; i < this.numLabels; i++) {
                        switch (this._tickDateBin) {
                            case 15 /* WEEK */:
                                _b = this._time.getWeekRange(this._dateTimeLabel), rangeMin = _b[1], rangeMax = _b[2];
                                threshDiff = 0;
                                break;
                            case 16 /* MONTH */:
                                _c = this._time.getMonthRange(this._dateTimeLabel), rangeMin = _c[1], rangeMax = _c[2];
                                threshDiff = 14;
                                break;
                            case 17 /* QUARTER */:
                                _d = this._time.getQuarterRange(this._dateTimeLabel), rangeMin = _d[1], rangeMax = _d[2];
                                threshDiff = 44;
                                break;
                            case 18 /* HALFY */:
                                _e = this._time.getHalfYearRange(this._dateTimeLabel), rangeMin = _e[1], rangeMax = _e[2];
                                threshDiff = 90;
                                break;
                            case 19 /* YEAR */:
                                _f = this._time.getYearRange(this._dateTimeLabel), rangeMin = _f[1], rangeMax = _f[2];
                                threshDiff = 180;
                                break;
                            case 22 /* TENY */:
                                _g = this._time.getNYear(this._dateTimeLabel, 10), rangeMin = _g[1], rangeMax = _g[2];
                                threshDiff = 1800;
                                break;
                            case 20 /* TWOY */:
                                _h = this._time.getNYear(this._dateTimeLabel, 2), rangeMin = _h[1], rangeMax = _h[2];
                                threshDiff = 360;
                                break;
                            case 21 /* FIVEY */:
                                _j = this._time.getNYear(this._dateTimeLabel, 5), rangeMin = _j[1], rangeMax = _j[2];
                                threshDiff = 900;
                                break;
                            default:
                                if (this._tickTimeBin > 0) {
                                    _k = this._time.getTimeBinStdRange(this._dateTimeLabel, this._tickTimeBin), rangeMax = _k[2];
                                    if (rangeMax > threshMax && i !== 0 && !this.getLabelBinned() && this.getBinned()) {
                                        return null;
                                    }
                                }
                                else {
                                    if (this._dateTimeLabel > threshMax && i !== 0 && !this.getLabelBinned() && this.getBinned()) {
                                        return null;
                                    }
                                    rangeMax = ~~this._dateTimeLabel;
                                }
                        }
                        if (threshDiff != null) {
                            if ((rangeMax - threshMax) > threshDiff && i === 0 && !this.getLabelBinned() && this.getBinned()) {
                                return null;
                            }
                        }
                        if (i === 0) {
                            _l = this.lookupRange(this._dateTimeLabel, this._tickDateBin, this._tickTimeBin), f = _l[0], low = _l[1];
                            if (!this._checkInCompressionZone(this._dateTimeLabel, this._tickTimeBin)) {
                                labelString = this._formatLabel(this._dateTimeLabel);
                                if (!this._compiledLabelOverride.isEmpty()) {
                                    var overrideReturn = this._compiledLabelOverride.fromValueRT({
                                        labelValue: this._dateTimeLabel,
                                        formattedLabel: labelString
                                    });
                                    labelString = overrideReturn;
                                }
                            }
                        }
                        if (this._tickTimeBin === 0) {
                            this._dateTimeLabel = this._time.adjustUp(rangeMax + 1);
                        }
                        else {
                            this._dateTimeLabel = this._time.adjustTimeStd(rangeMax, 1);
                        }
                    }
                    if (this.getLabelBinned()) {
                        f = low;
                    }
                }
                f = this.applyPlotFactorNDC(f);
                if (!isBounded(f, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                    return null;
                }
            }
            else {
                return null;
            }
            return [RichTextString.join(this.labelPrefix, labelString, this.labelPostfix), f, undefined];
            var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        };
        FDSDateTimeScale.prototype.setWeekType = function (weekType) {
            _super.prototype.setWeekType.call(this, weekType);
            this._time.setWeekType(this.weekType);
            this._setRanges();
        };
        // Outliers do not work on this scale.
        FDSDateTimeScale.prototype.upperOutlierActive = function () {
            return false;
        };
        FDSDateTimeScale.prototype.lowerOutlierActive = function () {
            return false;
        };
        FDSDateTimeScale.prototype.computeLabelVector = function () {
            this._initLabelVector();
            if (this.padLabels) {
                this._computeLabelVectorInternal(true);
                this.padLength = this._getPadLength();
                this.labels = [];
                this._label = 0;
            }
            this._computeLabelVectorInternal(false);
        };
        FDSDateTimeScale.prototype._computeLabelVectorInternal = function (plain) {
            if (plain === void 0) { plain = false; }
            var label;
            while (label = this._getNextLabel(plain)) {
                this.labels.push(label);
            }
        };
        FDSDateTimeScale.prototype.getLabelFormatter = function (formatString) {
            var formatter = new FDSFormat();
            formatter.setDateTimeFormat(formatString);
            return formatter;
        };
        FDSDateTimeScale.prototype.compressValue = function (value) {
            var date = new FDSDate();
            date.setWeekType(this.weekType);
            return ~~(date.compress(value));
        };
        FDSDateTimeScale.prototype.decompressValue = function (value) {
            var date = new FDSDate();
            date.setWeekType(this.weekType);
            return ~~(date.decompress(value));
        };
        return FDSDateTimeScale;
    }(FDSScale));
    
    var SEC_FRAC = 1 / (60 * 60 * 24); // 1/seconds-per-day
    var MIN_FRAC = SEC_FRAC * 60;
    var HOUR_FRAC = MIN_FRAC * 60;
    var FDSIntradayScale = /** @class */ (function (_super) {
        __extends(FDSIntradayScale, _super);
        function FDSIntradayScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _this._dsFrequencyCache = {};
            _this._time = new FDSTime(0 /* FIVE_DAY */);
            _this.scaleType = 11 /* INTRADAY */;
            _this._startOfDay = 1.0;
            _this._endOfDay = 0.0;
            _this._refStart = _this._startDate = Infinity;
            _this._refEnd = _this._endDate = -Infinity;
            _this._majorLabelInfoDirty = _this._minorLabelInfoDirty = true;
            _this._majorLabelSizesComputed = _this._minorLabelSizesComputed = false;
            _this.majorLabelPositionsComputed = _this.minorLabelPositionsComputed = false;
            _this._tickVectorDirty = _this._subTickVectorDirty = true;
            _this._intervals = [];
            _this._holidays = [];
            _this._dataSections = [];
            _this._addOffsetDateDatasets = 0;
            _this._lowerBoundCache = null;
            _this._weekHint = 0 /* FIVE_DAY */;
            _this._axisSubType = 0 /* NONE */;
            _this.labels = _this.minorLabels = _this.ticks = _this.subTicks = [];
            _this._parseLists = {};
            return _this;
        }
        FDSIntradayScale.prototype.getLog = function () {
            return false;
        };
        FDSIntradayScale.prototype.supportLog = function () {
            return false;
        };
        /**
         * Determines if the scale needs to be reset based on changes in attributes / data / or other conditions.
         * For FDSIntradayScale, the scale needs to be reset for a number of extra conditions such as:
         *   1) Associated DataSet frequency changing
         *   2) Change in `axisSubType` (date vs datetime)
         *   3) Additional intraday specific attributes that would effect the interval/range computation. (hypothetical)
         * @returns true if the scale needs to be reset
         */
        FDSIntradayScale.prototype.needsReset = function () {
            if (_super.prototype.needsReset.call(this)) {
                return true;
            }
            var expectedAxisType = 0;
            for (var _i = 0, _a = this.axis.associatedSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                var dataset = series.getData(this.axis.dimension);
                if (dataset.needsUpdate || dataset.attributeSet.isDirty()) {
                    // The first series determines the axisSubType binding. If that changes, we need to reset the scale
                    if (expectedAxisType === 0 /* NONE */) {
                        expectedAxisType = (dataset.getDataType() === 3 /* DATE_DATA */) ? 5 /* DATE */ : 8 /* DATETIME */;
                        if (this._axisSubType !== expectedAxisType) {
                            return true;
                        }
                    }
                    // Check the dataset frequency cache to see if the frequency has changed since the last time the scale
                    // was initialized. We are resetting anytime the frequency changes, though technically, we'd only have to
                    // reset if the scale's frequency changed. For example, date-type scales use the largest dataset frequency
                    // as the scale frequency. If one of the series changed, but the series with the largest frequency didn't,
                    // we could get away without resetting.
                    var dsDateBin = dataset.getDateBinImmediate();
                    var dsTimeBin = dataset.getTimeBin();
                    if (!_$1.isEqual({ dsDateBin: dsDateBin, dsTimeBin: dsTimeBin }, this._dsFrequencyCache[dataset.id])) {
                        return true;
                    }
                }
            }
            return false;
        };
        FDSIntradayScale.prototype.syncMembers = function (hint) {
            if (hint === void 0) { hint = this.axisWidthHint; }
            // Saves on property access and minified file size
            var attributes = this.axis.attributeSet;
            var getAttribute = attributes.get.bind(attributes);
            var isDefault = attributes.isDefault.bind(attributes);
            var isInheritedDefault = attributes.isInheritedDefault.bind(attributes);
            // get all intraday variables from the axis
            this.bin = getAttribute('Bin');
            this._displayHolidays = getAttribute('DisplayHolidays');
            this._holidayDataset = getAttribute('HolidayDataset');
            this._automaticStartEndDayDetection = getAttribute('AutomaticStartEndDayDetection');
            this._automaticHolidayDetection = getAttribute('AutomaticHolidayDetection');
            this._treatWeekendsAsHolidays = getAttribute('TreatWeekendsAsHolidays');
            this._secondaryFrequency = getAttribute('SecondaryFrequency');
            this._baseRangesOnIntervals = getAttribute('BaseRangesOnIntervals');
            this._ignoreLeastVisibleInterval = getAttribute('IgnoreIntradayScaleLeastVisibleInterval');
            this._intradayLabeling = getAttribute('IntradayLabeling');
            this._intradayLabelingMask = getAttribute('IntradayLabelingMask');
            // major attributes
            this._removeGapsFromMajorIntervals = getAttribute('RemoveGapsFromMajorIntervals');
            this._majorUnitStart = getAttribute('MajorUnitStart');
            this._majorTickMultiplier = getAttribute('MajorTickMultiplier');
            this._majorTickDateBin = getAttribute('TickDateBin');
            this._majorTickSnapToDate = getAttribute('MajorTickSnapToDate');
            this._majorLabelCentered = getAttribute('LabelCentered');
            this._majorLabelFormat = getAttribute('LabelFormat');
            this._majorBinLabelMode = getAttribute('BinLabelMode');
            this._forceMajorEndLabels = getAttribute('ForceEndLabels');
            this._endLabelMajorLeftFormat = getAttribute('EndLabelLeftFormat');
            this._endLabelMajorLeftPosition = getAttribute('EndLabelLeftPosition');
            this._endLabelMajorRightFormat = getAttribute('EndLabelRightFormat');
            this._endLabelMajorRightPosition = getAttribute('EndLabelRightPosition');
            this._majorDateLabelShift = getAttribute('DateLabelShift');
            // minor attributes
            this._removeGapsFromMinorIntervals = getAttribute('RemoveGapsFromMinorIntervals');
            this._minorUnitStart = getAttribute('MinorUnitStart');
            this._minorUnitEnd = getAttribute('MinorUnitEnd');
            this._minorTickMultiplier = getAttribute('MinorTickMultiplier');
            this._minorTickDateBin = getAttribute('MinorTickDateBin');
            this._minorTickSnapToDate = getAttribute('MinorTickSnapToDate');
            this._minorLabelCentered = getAttribute('LabelCentered2');
            this._minorLabelFormat = getAttribute('LabelFormat2');
            this._minorBinLabelMode = getAttribute('BinMinorLabelMode');
            this._forceMinorEndLabels = getAttribute('ForceMinorEndLabels');
            this._endLabelMinorLeftFormat = getAttribute('EndLabelMinorLeftFormat');
            this._endLabelMinorLeftPosition = getAttribute('EndLabelMinorLeftPosition');
            this._endLabelMinorRightFormat = getAttribute('EndLabelMinorRightFormat');
            this._endLabelMinorRightPosition = getAttribute('EndLabelMinorRightPosition');
            this._endLabelSnapToDatapoint = getAttribute('EndLabelSnapToDatapoint');
            this._endMinorLabelSnapToDatapoint = getAttribute('EndMinorLabelSnapToDatapoint');
            this._minorLabelPadding = getAttribute('LabelMinorPadding');
            this._minorDateLabelShift = getAttribute('DateMinorLabelShift');
            this._minorFormatPrefix = getAttribute('LabelPrefix2');
            this._minorFormatPostfix = getAttribute('LabelPostfix2');
            this._intradayScaleLengthForPartialDays = getAttribute('IntradayScaleLengthForPartialDays');
            // minor label pre/postfixes
            this._compiledMinorLabelPrefix = this.parentPropertySet.compilePropertyString(this._minorFormatPrefix);
            this._minorLabelPrefix = this._compiledMinorLabelPrefix.fromValueRT();
            this._compiledMinorLabelPostfix = this.parentPropertySet.compilePropertyString(this._minorFormatPostfix);
            this._minorLabelPostfix = this._compiledMinorLabelPostfix.fromValueRT();
            // defaults
            this._threshMinDefault = isDefault('ThreshMin');
            this._threshMaxDefault = isDefault('ThreshMax');
            this._secondaryFrequencyDefault = isDefault('SecondaryFrequency');
            // major
            this._majorUnitStartDefault = isDefault('MajorUnitStart');
            this._majorTickDateBinDefault = isDefault('TickDateBin');
            this._majorLabelCenteredDefault = isDefault('LabelCentered');
            this._endLabelMajorLeftFormatDefault = isDefault('EndLabelLeftFormat');
            this._endLabelMajorLeftPositionDefault = isDefault('EndLabelLeftPosition');
            this._endLabelMajorRightFormatDefault = isDefault('EndLabelRightFormat');
            this._endLabelMajorRightPositionDefault = isDefault('EndLabelRightPosition');
            // minor
            this._minorTickDateBinDefault = isDefault('MinorTickDateBin');
            this._minorLabelCenteredDefault = isDefault('LabelCentered2');
            this._endLabelMinorLeftFormatDefault = isDefault('EndLabelMinorLeftFormat');
            this._endLabelMinorLeftPositionDefault = isDefault('EndLabelMinorLeftPosition');
            this._endLabelMinorRightFormatDefault = isDefault('EndLabelMinorRightFormat');
            this._endLabelMinorRightPositionDefault = isDefault('EndLabelMinorRightPosition');
            this._showMajorUnitWhenNoTicks = isDefault('ShowMajorUnitWhenNoTicks');
            // tables
            this._minorRangeTable = [];
            this._majorRangeTable = [];
            this._majorLabelFormats = [];
            this._minorLabelFormats = [];
            this._majorLabelFormatsDefault = [];
            this._minorLabelFormatsDefault = [];
            for (var i = 0; i < DateTimeBinArray.length; i++) {
                this._majorRangeTable[i] = this.axis.attributeSet.get("IntradayScaleRange" + DateTimeBinArray[i]);
                this._minorRangeTable[i] = this.axis.attributeSet.get("IntradayScaleMinorRange" + DateTimeBinArray[i]);
                this._majorLabelFormats[i]
                    = this.axis.attributeSet.get("IntradayScaleLabelFormat" + DateTimeBinArray[i]);
                this._minorLabelFormats[i]
                    = this.axis.attributeSet.get("IntradayScaleMinorLabelFormat" + DateTimeBinArray[i]);
                this._majorLabelFormatsDefault[i]
                    = this.axis.attributeSet.isInheritedDefault("IntradayScaleLabelFormat" + DateTimeBinArray[i]);
                this._minorLabelFormatsDefault[i]
                    = this.axis.attributeSet.isInheritedDefault("IntradayScaleMinorLabelFormat" + DateTimeBinArray[i]);
            }
            // this needs to be called last because it calls setTickRanges and setThreshold, so it needs the attrs
            // set. BUT it calls reset() so we have to re-check some attributes
            _super.prototype.syncMembers.call(this, hint);
            this._majorTickDateBin = getAttribute('TickDateBin');
            this._minorTickDateBin = getAttribute('MinorTickDateBin');
            this._majorBinLabelMode = getAttribute('BinLabelMode');
            // bin needs to be updated again to avoid being entirely overwritten by the attribute
            this._updateBin();
            // threshholds need to be updated because updateBin resets them.
            this._threshMinAttr = getAttribute('ThreshMin');
            this._threshMaxAttr = getAttribute('ThreshMax');
            this._setThreshold(this._threshMinAttr, this._threshMaxAttr);
            this._majorLabelInfoDirty = this._minorLabelInfoDirty = true;
        };
        FDSIntradayScale.prototype.getAxisSubType = function () {
            return this._axisSubType;
        };
        // sync just the threshold attributes
        FDSIntradayScale.prototype.resyncThresholds = function () {
            this._setThreshold(this._threshMinAttr, this._threshMaxAttr);
        };
        FDSIntradayScale.prototype.setFixedMode = function (threshMin, threshMax, hint) {
            return true;
        };
        FDSIntradayScale.prototype.adjust = function (dataset) {
            if (dataset.getSize() > 0 && dataset.valid) {
                if (!this.initialized) {
                    this._weekHint = 0 /* FIVE_DAY */;
                    this._refStart = this._startDate = Infinity;
                    this._refEnd = this._endDate = -Infinity;
                    this._startOfDay = 1;
                    this._endOfDay = 0;
                    _a = this._setupDateAndTimeBins(dataset), this._dsFrequency = _a[0], this._dsTimeBin = _a[1];
                    this._leastVisibleInterval = 22 /* TENY */;
                    this.min = dataset.Min()[0];
                    this.max = dataset.Max()[0];
                    this.initialize(dataset);
                    this._setRanges();
                }
                else {
                    this.min = Math.min(this.min, dataset.Min()[0]);
                    this.max = Math.max(this.max, dataset.Max()[0]);
                    this.initialize(dataset);
                    this._setRanges();
                    this.axis.intradayDirty = false;
                }
                return true;
            }
            return false;
            var _a;
        };
        // function to sort out date and time bins without setting both to the same thing
        FDSIntradayScale.prototype._setupDateAndTimeBins = function (dataset) {
            this._dsFrequencyCache = {};
            var dateBin = dataset.getDateBinImmediate();
            var timeBin = dataset.getTimeBin();
            if ((dateBin === 1 /* SECOND */ && timeBin === 1) ||
                (dateBin === 2 /* TWOSECOND */ && timeBin === 2) ||
                (dateBin === 3 /* FIVESECOND */ && timeBin === 5) ||
                (dateBin === 4 /* TENSECOND */ && timeBin === 10) ||
                (dateBin === 5 /* HALFMINUTE */ && timeBin === 30) ||
                (dateBin === 6 /* MINUTE */ && timeBin === 100) ||
                (dateBin === 7 /* TWOMINUTE */ && timeBin === 200) ||
                (dateBin === 8 /* FIVEMINUTE */ && timeBin === 500) ||
                (dateBin === 9 /* TENMINUTE */ && timeBin === 1000) ||
                (dateBin === 10 /* HALFHOUR */ && timeBin === 3000) ||
                (dateBin === 11 /* HOUR */ && timeBin === 10000) ||
                (dateBin === 12 /* TWOHOUR */ && timeBin === 20000) ||
                (dateBin === 13 /* SIXHOUR */ && timeBin === 60000)) {
                timeBin = 0;
            }
            return [dateBin, timeBin];
        };
        // figures out time bins. Note that time bins are in seconds when less than 100 secs, and HHMMSS
        // when greater than 100 secs.
        // Returns [H,M,S] offsets. [0,0,0] is a bad result to be checked for
        FDSIntradayScale.prototype._getOffsetFromTimeBin = function (timeBin) {
            var offM;
            var offS;
            var offH;
            offH = offM = offS = 0;
            if (timeBin > 0) {
                // Lets treat this like a microwave, if its less than 3 digits long, its seconds, otherwise, parse as hhmmss
                if (timeBin < 100) {
                    offM = timeBin / 60;
                    offS = timeBin % 60;
                }
                else {
                    offH = this._time.getHour(timeBin);
                    offM = this._time.getMinute(timeBin);
                    offS = this._time.getSecond(timeBin);
                }
            }
            return [offH, offM, offS];
        };
        // function to set up all the variables for this scale
        FDSIntradayScale.prototype.initialize = function (dataset) {
            if ((!dataset.valid) || dataset.getSize() <= 0) {
                return false;
            }
            this._dsType = dataset.dataType;
            if (this._axisSubType === 0 /* NONE */) {
                if (dataset.getDataType() === 3 /* DATE_DATA */) {
                    this._axisSubType = 5 /* DATE */;
                }
                else {
                    this._axisSubType = 8 /* DATETIME */;
                }
            }
            var binned = this.axis.attributeSet.isDefault('Bin') ?
                this._axisSubType === 5 /* DATE */ :
                this.axis.attributeSet.get('Bin');
            this._setBinned(binned);
            this._endDate = Math.max(this._endDate, dataset.statistics.last);
            var weekHint = dataset.weekHint;
            if (!this.axis.attributeSet.isDefault('WeekType')) {
                weekHint = this.axis.attributeSet.get('WeekType');
            }
            // if any dataset is 7-day, this scale is too
            if (weekHint === 1 /* SEVEN_DAY */ && this.weekType === 0 /* FIVE_DAY */) {
                this.setWeekType(this._weekHint = 1 /* SEVEN_DAY */);
            }
            // When loading a chart, we don't have the right BIN status at this point.
            this._updateBin();
            var holidays = this._detectParameters(dataset);
            if (!this.initialized) {
                // this is the first dataset. just keep these holidays
                this._holidays = holidays;
            }
            else {
                // now we have multiple datasets so we need to merge their holidays
                // we pass in the start and end dates of each set - the last holiday starts the day after the data ends
                this._holidays = this._mergeHolidaySets(this._holidays, this._startDate, this._endDate + 1, holidays, dataset.Min()[0], dataset.Max()[0] + 1);
            }
            _a = this._setupMembers(dataset, this._removeGapsFromMajorIntervals), this._startDate = _a[0], this._endDate = _a[1], this._refStart = _a[2], this._refEnd = _a[3], this._intervals = _a[4];
            // remove gaps from minor intervals
            this._adjustIntervalsWithMinorIntervalParameters();
            // remove holidays from the intervals list
            this._subtractHolidaysFromIntervals(this._holidays);
            // make sure @holidays is ok for the future
            this._holidays.sort((function (a, b) { return a.start - b.start; }));
            this._holidays = this._mergeOverlappingHolidays(this._holidays);
            this._setupNDCArrays();
            var intLen = this._intervals.length;
            this._oldBin = 0 /* NONE */; // save bin for comparison later
            this.initialized = true;
            return true;
            var _a;
        };
        // function to reset built-in variables to a default state
        // logic copied from PC function of the same name
        FDSIntradayScale.prototype.reset = function (reinit) {
            if (reinit === void 0) { reinit = false; }
            if (reinit) {
                this.initialized = false;
                this._axisSubType = 0 /* NONE */;
            }
            this.log = this._labelBin = this._tickBin = this.bin = this.reverse = false;
            this._majorTickDateBin = this._minorTickDateBin = 'NONE';
            this.labelAnchor = this.tickOffset = this.subTickOffset = NAN;
            this._binFactor = 0.8;
            this.numTicksHint = 1;
            this.tickMode = 0 /* FLOATING */;
            this._majorBinLabelMode = 0;
            this.setWeekType(this._weekHint);
            this._updateBin();
            this._setRanges();
        };
        // a helper function to do this which is required multiple places
        FDSIntradayScale.prototype._updateBin = function () {
            // Right now we are forcing date scales to be binned
            this._setBinned((this._dsType === 'DATE') || this.bin);
        };
        // a function to take in two sets of holidays and return one merged one - a day is only
        // a holiday if it is a holiday in both sets
        FDSIntradayScale.prototype._mergeHolidaySets = function (oldSet, oldStart, oldEnd, newSet, newStart, newEnd) {
            var newHolidays = [];
            // if one of the sets is empty, there are no holidays in common
            if ((newSet.length === 0) || (oldSet.length === 0)) {
                return newHolidays;
            }
            // add new holidays at the beginning and end for "non-data" times
            newSet.unshift((new Interval(-Infinity, newStart)));
            newSet.push((new Interval(newEnd, Infinity)));
            oldSet.unshift((new Interval(-Infinity, oldStart)));
            oldSet.push((new Interval(oldEnd, Infinity)));
            // sort both sets
            oldSet.sort((function (a, b) { return a.start - b.start; }));
            newSet.sort((function (a, b) { return a.start - b.start; }));
            var i = 0;
            var h2 = newSet[i];
            for (var _i = 0, oldSet_1 = oldSet; _i < oldSet_1.length; _i++) {
                var h1 = oldSet_1[_i];
                while ((h2.end <= h1.start) && (i < newSet.length - 1)) {
                    // if h2 ends before h1 starts, no overlap, so we don't care
                    h2 = newSet[++i];
                }
                // now we have the first h2 that does end before h1
                if (h2.start >= h1.end) {
                    // no overlap
                    continue;
                }
                else {
                    // here we know h2.start <= h2.end and h1.start <= h2.end
                    // loop because there could be many
                    while (h2.start < h1.end) {
                        var holStart = Math.max(h1.start, h2.start);
                        var holEnd = Math.min(h1.end, h2.end);
                        newHolidays.push(new Interval(holStart, holEnd));
                        if (i === newSet.length - 1) {
                            // no more h2s
                            break;
                        }
                        // we need to ensure there is actually a next thing to check
                        if (i + 1 < oldSet.length && oldSet[i + 1].start < h2.end) {
                            // the next h1 is still within this h2
                            break;
                        }
                        else {
                            // we have another h2 and it ends before the next h1 starts
                            // increment and do another loop to see if it's inside this h1
                            h2 = newSet[++i];
                        }
                    }
                }
            }
            // merging is over, remove any wacko infinity intervals
            if (newHolidays[0].start === -Infinity) {
                newHolidays = newHolidays.slice(1);
            }
            if (newHolidays[newHolidays.length - 1].end === Infinity) {
                newHolidays = newHolidays.slice(0, newHolidays.length - 1);
            }
            return newHolidays;
        };
        FDSIntradayScale.prototype.outlierEnabled = function () {
            // outliers not allowed on intraday scale
            return false;
        };
        // function to set the thresholds of the scale based on the passed in min and max
        // logic copied from PC function of the same name
        FDSIntradayScale.prototype._setRanges = function (tempmin, tempmax) {
            // check for NANs here in addition to undefined's just in case
            if ((tempmin == null) || IsNA(tempmin)) {
                tempmin = this._refStart;
            }
            if ((tempmax == null) || IsNA(tempmax)) {
                tempmax = this._refEnd;
            }
            this.bin = (this._axisSubType === 5 /* DATE */) || this.getBinned();
            this.setTickBinned(this.bin);
            if (this._intervals.length === 0) {
                return;
            }
            _a = this._threshConsider(tempmin, tempmax), tempmin = _a[0], tempmax = _a[1];
            _b = this._getBinnedMinMax(tempmin, tempmax), tempmin = _b[0], tempmax = _b[1];
            this._majorLabelInfoDirty = this._minorLabelInfoDirty = true;
            this._majorLabelSizesComputed = this._minorLabelSizesComputed = false;
            this.majorLabelPositionsComputed = this.minorLabelPositionsComputed = false;
            this._tickVectorDirty = this._subTickVectorDirty = true;
            this._setThreshold(tempmin, tempmax);
            var _a, _b;
        };
        // updates m_visibleScale and m_horizontalTranslation based on the axis threshmin and threshmax
        // logic copied from PC function of same name
        FDSIntradayScale.prototype._updateVisibleScale = function (min$$1, max$$1) {
            this._visibleScale = 1;
            this._horizontalTranslation = 0;
            var tmpmin = this._lookupInternal(min$$1, false);
            var tmpmax = this._lookupInternal(max$$1, false);
            if (tmpmin > tmpmax) {
                _a = [tmpmax, tmpmin], tmpmin = _a[0], tmpmax = _a[1];
            }
            if (tmpmin !== tmpmax) {
                this._visibleScale = 1 / (tmpmax - tmpmin);
            }
            this._horizontalTranslation = tmpmin;
            var _a;
        };
        // logic copied from PC function of the same name
        FDSIntradayScale.prototype._setThreshold = function (min$$1, max$$1) {
            var intLen = this._intervals.length;
            if (intLen === 0) {
                return;
            }
            var start = this._intervals[0];
            var end = this._intervals[intLen - 1];
            var tmpmin = min$$1;
            var updateMin = false;
            var foundStart = false;
            var foundEnd = false;
            // basically this just steps through and assigns start to the last interval starting before min
            // and end to the last interval starting before max.
            // the special case with updateMin is if min is between intervals, tmpmin (and later min itself)
            // get set to the next interval's start.
            // Note: if min or max is NAN it just won't ever find it because no interval starts before NAN
            for (var _i = 0, _a = this._intervals; _i < _a.length; _i++) {
                var it_1 = _a[_i];
                if (it_1.start <= min$$1) {
                    updateMin = (it_1.end < min$$1);
                    start = it_1;
                    foundStart = true;
                }
                else if (foundStart && updateMin) {
                    // this is the special case described above
                    // at this point we're past the first interval and need to set min
                    tmpmin = it_1.start;
                    updateMin = false;
                }
                if (it_1.start <= max$$1) {
                    end = it_1;
                    foundEnd = true;
                }
            }
            min$$1 = tmpmin;
            if (!foundStart) {
                start = this._intervals[0];
                min$$1 = start.start;
            }
            if (!foundEnd) {
                end = this._intervals[intLen - 1];
                max$$1 = end.end;
            }
            // note that if min and max were NANs, they would have been set to start.start and end.end,
            // which is the entire range, which means updateVisibleScale will set VS to 1 and HT to 0,
            // as expected for unzoomed behavior. So this all works out great.
            var leastVisibleRange = this._getRangeFromDateTimeBin(this._leastVisibleInterval);
            if (leastVisibleRange > Math.abs(max$$1 - min$$1)) {
                // Improve this detection... min should be the first snap to the interval
                min$$1 = ~~min$$1;
                max$$1 = leastVisibleRange + min$$1;
            }
            this._updateVisibleScale(min$$1, max$$1);
            this.threshMin = min$$1;
            this.threshMax = max$$1;
            if (this.threshMin > this.threshMax) {
                _b = [this.threshMax, this.threshMin], this.threshMin = _b[0], this.threshMax = _b[1];
            }
            this._tickVectorDirty = this._subTickVectorDirty = true;
            var _b;
        };
        // takes in a data point and returns ndc coord for it.
        // logic copied from PC function of the same name
        FDSIntradayScale.prototype._lookupInternal = function (value, applyScale) {
            var _this = this;
            if (applyScale === void 0) { applyScale = true; }
            var retValInNdc = 0;
            var extrapolate = function (_value) {
                _this._time.setWeekType(_this.weekType);
                _this._time.setBeginningOfDay(_this._startOfDay);
                _this._time.setEndOfDay(_this._endOfDay);
                var min$$1 = _this._time.compressUpStd(_this._intervals[0].start);
                var delta = _this._time.compressUpStd(_this._intervals[_this._intervals.length - 1].end) - min$$1;
                if (delta === 0) {
                    delta = 1;
                }
                var val = _this._time.compressUpStd(_value);
                return (val - min$$1) / delta;
            };
            var intLen = this._intervals.length;
            if (intLen >= 1) {
                // deal with values outside the intervals
                if (value < this._intervals[0].start && value !== 0) {
                    retValInNdc = extrapolate(value);
                }
                else {
                    var found = this._intervalLowerBound(value);
                    if (!found) {
                        retValInNdc = extrapolate(value);
                    }
                    else {
                        var int = found[0];
                        if (value >= int.start && value <= int.end) {
                            var pctOfInterval = 1;
                            if (!fuzzyEQ(int.end, int.start)) {
                                // percentage of the way into the interval
                                pctOfInterval = (value - int.start) / (int.end - int.start);
                            }
                            // convert to ndc
                            pctOfInterval *= (int.ndcRight - int.ndcLeft);
                            retValInNdc = int.ndcLeft + pctOfInterval;
                        }
                        else {
                            // it's before the beginning of this interval
                            retValInNdc = int.ndcLeft;
                        }
                    }
                }
            }
            if (applyScale) {
                return this.applyPlotFactorNDC(this._reverseNdc(this._scaledNdc(retValInNdc)));
            }
            return retValInNdc;
        };
        // helper function to deal with reversed scales and also with the plotFactor
        FDSIntradayScale.prototype._applyReverseNdc = function (ndc, applyScale) {
            if (applyScale === void 0) { applyScale = true; }
            // pretty sure you have to call reverse first since the left and right ends might be scaled differently
            ndc = this._reverseNdc(ndc);
            if (applyScale) {
                ndc = this.applyPlotFactorNDC(ndc);
            }
            return ndc;
        };
        // helper function to deal with potentially reversed scales
        FDSIntradayScale.prototype._reverseNdc = function (ndc) {
            if (this.reverse) {
                return 1 - ndc;
            }
            return ndc;
        };
        // scales the ndc to fit the visible scale
        FDSIntradayScale.prototype._scaledNdc = function (ndc) {
            return (ndc - this._horizontalTranslation) * this._visibleScale;
        };
        // Function to remove holidays from @intervals list
        FDSIntradayScale.prototype._subtractHolidaysFromIntervals = function (holidays) {
            if (this._intervals.length < 1) {
                return;
            }
            // add user-defined holidays to the list
            holidays = this._addHolidaysAndWeekends(holidays);
            if (holidays.length < 1) {
                return;
            }
            // sort holidays (on PC side it's a set which is auto-sorted)
            holidays.sort((function (a, b) { return a.start - b.start; }));
            // get rid of overlapping holidays (they cause problems)
            holidays = this._mergeOverlappingHolidays(holidays);
            // step through both arrays
            var holLen = holidays.length;
            var intLen = this._intervals.length;
            var i = 0;
            var h = 0;
            var curInterval = this._intervals[i];
            var curHoliday = holidays[h];
            var newIntervals = [];
            var intStart = curInterval.start;
            var state = 0;
            while (i < intLen) {
                // this loop implements a state machine with four states depending on whether the current interval
                // being considered is a holiday, an interval, both, or neither. Intervals start at interval beginnings
                // and holiday ends and go until interval ends and holiday beginnings.
                if (!curHoliday) {
                    // out of holidays. make a dummy holiday that will never be reached (so all intervals remaining can be
                    // added)
                    curHoliday = new Interval(Infinity, Infinity);
                }
                switch (state) {
                    case 1 /* HOL */:
                        if (curHoliday.end < curInterval.start) {
                            curHoliday = holidays[++h];
                            state = 0 /* NONE */;
                        }
                        else {
                            state = 3 /* BOTH */;
                        }
                        break;
                    case 2 /* INT */:
                        if (curInterval.end <= curHoliday.start) {
                            if (!fuzzyEQ(curInterval.end, intStart)) {
                                newIntervals.push((new Interval(intStart, curInterval.end)));
                            }
                            curInterval = this._intervals[++i];
                            state = 0 /* NONE */;
                        }
                        else {
                            if (!fuzzyEQ(curHoliday.start, intStart)) {
                                newIntervals.push((new Interval(intStart, curHoliday.start)));
                            }
                            state = 3 /* BOTH */;
                        }
                        break;
                    case 3 /* BOTH */:
                        if (curInterval.end === curHoliday.end) {
                            intStart = curHoliday.end;
                            curHoliday = holidays[++h];
                            curInterval = this._intervals[++i];
                            state = 0 /* NONE */;
                        }
                        else if (curInterval.end < curHoliday.end) {
                            curInterval = this._intervals[++i];
                            state = 1 /* HOL */;
                        }
                        else {
                            intStart = curHoliday.end;
                            curHoliday = holidays[++h];
                            state = 2 /* INT */;
                        }
                        break;
                    default:// NONE
                        if (curHoliday.start === curInterval.start) {
                            state = 3 /* BOTH */;
                        }
                        else if (curHoliday.start < curInterval.start) {
                            state = 1 /* HOL */;
                        }
                        else {
                            intStart = curInterval.start;
                            state = 2 /* INT */;
                        }
                }
            }
            this._intervals = newIntervals;
            this._lowerBoundCache = null;
        };
        FDSIntradayScale.prototype._mergeOverlappingHolidays = function (holidays) {
            var holLen = holidays.length;
            if (holLen < 2) {
                return holidays;
            }
            var mergedHols = [];
            var i = 0;
            var H = holidays[0];
            var start = H.start;
            var end = H.end;
            while (i < holLen - 1) {
                H = holidays[i + 1];
                var H2 = holidays[i];
                if (H.start <= end) {
                    // overlap
                    end = Math.max(H.end, H2.end);
                }
                else {
                    // there's a gap, save the old one
                    mergedHols.push(new Interval(start, end));
                    start = H.start;
                    end = H.end;
                }
                i = i + 1;
            }
            // deal with the last interval
            H = holidays[holLen - 1];
            if (H.start <= end) {
                end = Math.max(end, H.end);
                mergedHols.push(new Interval(start, end));
            }
            else {
                mergedHols.push(new Interval(start, end));
                mergedHols.push(H);
            }
            return mergedHols;
        };
        // Function to add user-defined holidays and weekends to the holidays list
        // logic copied from PC side function of the same name
        FDSIntradayScale.prototype._addHolidaysAndWeekends = function (holidays) {
            // store holidays for hiding if necessary
            if (!this._displayHolidays) {
                var dataset = this.root.getTypedObject(this._holidayDataset, isDataSet);
                if (dataset) {
                    var s = dataset.getSize();
                    switch (dataset.getDimension()) {
                        case 1:
                            for (var i = 0; i < s; i++) {
                                // 1D datasets store dates only, not a range
                                var start = dataset.getAt(i, 0);
                                if (NOTNAN(start)) {
                                    holidays.push(new Interval(start, (start + 1) - (SEC_FRAC / 1000)));
                                }
                            }
                            break;
                        case 2:
                            for (var i = 0; i < s; i++) {
                                var start = dataset.getAt(i, 0);
                                var end = dataset.getAt(i, 1) - (SEC_FRAC / 1000);
                                if ((NOTNAN(start)) && (NOTNAN(end))) {
                                    holidays.push(new Interval(start, end));
                                }
                            }
                            break;
                    }
                }
            }
            // store weekends for hiding if necessary
            if (this.weekType === 0 /* FIVE_DAY */) {
                var start = void 0;
                var weekendStart = start = ~~this._refStart; // just the date part
                while (start <= this._refEnd) {
                    // 0 = Saturday and 1 = Sunday
                    if (FDSDate.isWeekend(start)) {
                        if (FDSDate.getDayOfWeek(start) === 0) {
                            // saturday. weekend starts here.
                            weekendStart = start;
                            // special case - if this is the last datapoint, add just this as a weekend
                            if (start === this._refEnd) {
                                holidays.push(new Interval(start, (start + 1) - (SEC_FRAC / 1000)));
                            }
                        }
                        else {
                            // sunday. add interval from previous date til end of this date
                            holidays.push(new Interval(weekendStart, (start + 1) - (SEC_FRAC / 1000)));
                        }
                    }
                    // increment start by one day
                    start += 1;
                }
            }
            return holidays;
        };
        // Function to remove gaps from minor intervals
        // This doesn't return anything, but makes changes to the intervals array
        // logic based on PC side function of the same name
        // @param heMajor [HorizontalEnd] what end (if any) to remove major gaps from
        FDSIntradayScale.prototype._adjustIntervalsWithMinorIntervalParameters = function () {
            var heMajor = this._removeGapsFromMajorIntervals;
            var heMinor = this._removeGapsFromMinorIntervals;
            if (heMinor === 2 /* NONE */) {
                return;
            }
            var _minorUnitStart = this._minorUnitStart;
            var _minorUnitEnd = this._minorUnitEnd;
            // first get the time parts of the minor start and end offsets
            var goalStart, goalEnd;
            if (this._automaticStartEndDayDetection) {
                goalStart = FDSTime.getTimeFrac(this._startOfDay);
                goalEnd = FDSTime.getTimeFrac(this._endOfDay);
            }
            else {
                // in this case the start and end of the minor unit are given by attribute
                var args = _minorUnitStart.split('-');
                var argsEnd = _minorUnitEnd.split('-');
                if (args.length < 6 || argsEnd.length < 6) {
                    return;
                }
                // ...and make those numbers into a time fraction
                goalStart = FDSTime.makeTimeStd(Number(args[3]), Number(args[4]), Number(args[5]));
                goalEnd = 1 - (FDSTime.makeTimeStd(Number(argsEnd[3]), Number(argsEnd[4]), Number(argsEnd[5])));
            }
            // now adjust minor intervals to these times
            for (var i = 0; i < this._intervals.length; i++) {
                var interval = this._intervals[i];
                var curStart = interval.start;
                var curEnd = interval.end;
                // logic to deal with first and last intervals, which are also impacted
                // by the RemoveGapsFromMajorIntervals
                if (i === 0 && this._isLeftEnd(heMajor)) {
                    curStart = this._refStart;
                }
                if (i === this._intervals.length - 1 && this._isRightEnd(heMajor)) {
                    curEnd = this._refEnd;
                }
                // set up the start and end times with the gaps removed
                if (FDSTime.getTimeFrac(curStart) < goalStart) {
                    curStart = (~~curStart) + goalStart;
                }
                var timeEnd = FDSTime.getTimeFrac(curEnd);
                // a day that ends at 0 really ends a tiny bit before midnight
                if (timeEnd === 0) {
                    // go back one day
                    curEnd -= 1;
                    // make the time just before midnight
                    timeEnd = 1 - SEC_FRAC;
                    curEnd += timeEnd;
                }
                if (timeEnd > goalEnd) {
                    curEnd = (~~curEnd) + goalEnd;
                }
                // prevent "negative gaps"
                if (curStart > curEnd) {
                    // makes the interval empty
                    interval.end = interval.start;
                }
                // if an interval edge needs to be adjusted for minor parameters, one of three cases must be true:
                // 1) the interval edge is interior (ie, not the right-most or left-most edge)
                // 2) the major adjustments left it alone
                // 3) the major adjustments didn't move it enough (ie the current point is smaller than
                //    the new one would be when adjusting right, etc)
                // make sure we're supposed to be adjusting left
                if (this._isLeftEnd(heMinor)) {
                    // check the three cases
                    if (i !== 0 || (!this._isLeftEnd(heMajor)) || interval.start <= curStart) {
                        interval.start = curStart;
                    }
                }
                // make sure we're supposed to be adjusting right
                if (this._isRightEnd(heMinor)) {
                    // check the three cases
                    if (i !== this._intervals.length - 1 || !this._isRightEnd(heMajor) || interval.end >= curEnd) {
                        interval.end = curEnd;
                    }
                }
            }
        };
        // sets up various member variables and the intervals of the scale
        // logic semi-copied from PC side function decomposeStartDateTemplateIntoDateParts
        //
        // Note about variables: to make this function a bit more transparent, I am returning the startDate etc values
        // which then get set to @startDate etc in the caller. So while the PC side might deal with this.startDate etc,
        // I am not saving any @startDate type vars here. The @ vars are just used here to keep track of global state
        //
        // @param dataset [FDSDataSet] the dataset for this scale
        // @param removeGaps [HorizontalEnd] which end of the scale (if any) to remove gaps from
        // @return [Array] pair of data endpoints, pair of reference points, and array of Intervals [dsStart, dsEnd,
        // refStart, refEnd, intervals]
        FDSIntradayScale.prototype._setupMembers = function (dataset, removeGaps) {
            var binned = this.getBinned();
            // # set up the date and time bins for this dataset, adjusting for axis type ##
            var dsDateBin = dataset.getDateBinImmediate();
            if (dataset.attributeSet.isDefault('Frequency')) {
                dsDateBin = 0 /* NONE */;
            }
            var dsTimeBin = dataset.getTimeBin();
            this._dsFrequencyCache[dataset.id] = { dsDateBin: dsDateBin, dsTimeBin: dsTimeBin };
            // store the frequency of the dataset.
            this._dsSecondaryFrequency = this._time.lookupDateBin(this._secondaryFrequency);
            this._dsSecondaryTimeFrequency = this._time.lookupTimeBin(this._secondaryFrequency);
            if (!this._secondaryFrequencyDefault) {
                dsDateBin = this._dsSecondaryFrequency;
                dsTimeBin = this._dsSecondaryTimeFrequency;
            }
            // FDSDate uses largest frequency, and FDSDateTime uses smallest
            if (this._axisSubType === 5 /* DATE */) {
                if (dsDateBin > this._dsFrequency) {
                    this._dsFrequency = dsDateBin;
                }
                this._dsTimeBin = 0;
            }
            else {
                if (dsDateBin < this._dsFrequency) {
                    this._dsFrequency = dsDateBin;
                }
                if (dsTimeBin < this._dsTimeBin) {
                    this._dsTimeBin = dsTimeBin;
                }
            }
            // now use these date/time bins to get the offset variables
            var lookupDateBin = dsDateBin;
            if (dsDateBin === 0 /* NONE */ && dsTimeBin === 0) {
                lookupDateBin = this._leastVisibleInterval;
            }
            this._freqOffset = this._getOffsetVariables(lookupDateBin, dsTimeBin);
            // # find and adjust the start and end points for the data ##
            var dsStart = dataset.Min()[0];
            var dsEnd = dataset.Max()[0];
            // find start here
            // note: this function contains check for bad values, and also check if MUS is default
            var refStart = this._decomposeStartDateTemplate(dsStart);
            var refEnd;
            // Loop refStart backwards until we're past dsStart
            while (refStart > dsStart && dsStart >= 1) {
                refStart = this._time.addOffsetVariables(refStart, -this._freqOffset.years, -this._freqOffset.months, -this._freqOffset.days, -this._freqOffset.time);
            }
            // don't overwrite previous data
            refStart = Math.min(refStart, this._refStart);
            var startDate = Math.min(dsStart, this._startDate);
            // find end here
            // DATE datasets have their datapoints at midnight, and then we shift them 0.5
            // We have to add one more day at the end of the intervals, so the last datapoint doesn't disappear
            if (this._axisSubType === 5 /* DATE */ || (this.getBinned() && dsDateBin >= 14 /* DAY */)) {
                dsEnd = this._time.addOffsetVariables(dsEnd, 0, 0, 1, 0);
            }
            else if (this._axisSubType === 8 /* DATETIME */) {
                if (this.getBinned() && (dsDateBin !== 0 /* NONE */ || dsTimeBin > 0)) {
                    dsEnd = this._time.addOffsetObject(dsEnd, this._freqOffset);
                }
                else {
                    dsEnd = this._time.addOffsetVariables(dsEnd, 0, 0, 0, SEC_FRAC);
                }
            }
            var _a = FDSTime.getDateTimeArray(dsEnd), year = _a[0], month = _a[1], day = _a[2], hour = _a[3], min$$1 = _a[4], sec = _a[5];
            if (year < 1900 || month < 1 || day < 1 || hour < 0 || min$$1 < 0 || sec < 0) {
                refEnd = 1;
            }
            else {
                refEnd = dsEnd;
            }
            if (this._majorUnitStartDefault) {
                var _b = this._getDateRange(dataset.Max()[0], this._dsFrequency, this._dsTimeBin), newEnd = _b[1];
                if (newEnd > dataset.Max()[0]) {
                    refEnd = newEnd;
                }
            }
            if (!this._threshMinDefault && this._threshMinAttr < refStart && this._threshMinAttr < startDate) {
                refStart = startDate = this._threshMinAttr;
            }
            var intervals = [];
            refEnd = Math.max(refEnd, this._refEnd);
            dsEnd = Math.max(dsEnd, this._endDate);
            if (!this._threshMaxDefault && fuzzyGT(this._threshMaxAttr, refEnd)) {
                refEnd = this._threshMaxAttr;
            }
            // # SETTING UP INTERVALS ##
            // note: the PC side moves @refEnd itself from start to refEnd. I find this really confusing
            // so I am incrementing currentDate instead.
            // find the starting point for making intervals
            var previous = refStart;
            if (!this.bin && this._isLeftEnd(this._removeGapsFromMajorIntervals)) {
                // adjust left edge for removing major gaps
                previous = startDate;
            }
            // increment currentDate by offset til it's past the last data point
            // make one giant interval if it's not days (to be split up by holidays later).
            // if it is days, or if we need to do daily things like start/end day stuff,
            // make one interval per day
            if (this._dsFrequency >= 14 /* DAY */ || this.weekType === 0 /* FIVE_DAY */ ||
                this._automaticStartEndDayDetection || this._removeGapsFromMinorIntervals !== 2 /* NONE */) {
                // make sure the intervals (after the first one) line up with days
                // start at the day before refStart, and the first step of the following loop is to add a day
                var currentDate = this._getDateRange(refStart, 14 /* DAY */, 0)[0];
                currentDate = this._time.addOffsetVariables(currentDate, 0, 0, 1, 0);
                // make one interval per day
                while (currentDate < refEnd) {
                    if (this.weekType !== 0 /* FIVE_DAY */ || !FDSDate.isWeekend(~~previous)) {
                        intervals.push(new Interval(previous, currentDate));
                    }
                    previous = currentDate;
                    // add 0 years, 0 months, 1 day, and 0 time
                    currentDate = this._time.addOffsetVariables(currentDate, 0, 0, 1, 0);
                }
                if (this.weekType !== 0 /* FIVE_DAY */ || !FDSDate.isWeekend(~~previous)) {
                    intervals.push(new Interval(previous, refEnd));
                }
            }
            else {
                intervals.push(new Interval(refStart, refEnd));
            }
            // adjust right edge
            var intLen = intervals.length;
            var _endDate = this._endDate;
            if ((!binned) && this._isRightEnd(removeGaps) && this._threshMaxDefault) {
                if (intLen > 0) {
                    intervals[intLen - 1].end = dsEnd;
                }
                _endDate = dsEnd;
            }
            return [startDate, _endDate, refStart, refEnd, intervals];
        };
        // Decompose the date/time template from the attribute into an actual date
        FDSIntradayScale.prototype._decomposeStartDateTemplate = function (dsStart) {
            var args = this._majorUnitStart.split('-');
            // offsetStart is a temp value computed based off dsStart
            var offsetStart;
            if (!this._majorUnitStartDefault && args.length > 5) {
                // offsetStart is dsStart modified by user input
                // turn dsStart into an array of date/time
                var arr = FDSTime.getDateTimeArray(dsStart);
                // replace everything in the date with the user specified info if necessary
                for (var i = 0; i < args.length; i++) {
                    var item = args[i];
                    if (item === '') {
                        continue;
                    }
                    var itemNum = Number(item);
                    if (isNaN(itemNum)) {
                        continue;
                    }
                    arr[i] = itemNum;
                }
                offsetStart = FDSTime.makeDateTime(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]);
            }
            else {
                offsetStart = this._getDateRange(dsStart, this._dsFrequency, this._dsTimeBin)[0];
            }
            // make sure our start value is valid
            var _a = FDSTime.getDateTimeArray(offsetStart), year = _a[0], month = _a[1], day = _a[2], hour = _a[3], min$$1 = _a[4], sec = _a[5];
            if (year < 1900 || month < 1 || day < 1 || hour < 0 || min$$1 < 0 || sec < 0) {
                offsetStart = 1;
            }
            return offsetStart;
        };
        // sets up the built in interval arrays to include NDC information
        FDSIntradayScale.prototype._setupNDCArrays = function () {
            // Loop through the intervals and find the ndcs.
            // First we need to calculate the sum of the date/time ranges of all intervals
            var total = 0;
            for (var _i = 0, _a = this._intervals; _i < _a.length; _i++) {
                var it_2 = _a[_i];
                total += (it_2.end - it_2.start);
            }
            if (total === 0) {
                if (ENABLE_DEBUG) {
                    console.warn("Total length of all intervals is 0.0. This shouldn't happen.");
                }
                return;
            }
            var scale = 1 / total;
            var intLen = this._intervals.length;
            var accumulatedNdc = 0;
            // for each interval, adjust the interval's ndc coords
            for (var _b = 0, _c = this._intervals; _b < _c.length; _b++) {
                var it_3 = _c[_b];
                it_3.ndcLeft = accumulatedNdc;
                var ndc = roundToMaxPrecision(((scale * (it_3.end - it_3.start)) + accumulatedNdc));
                accumulatedNdc = it_3.ndcRight = Math.min(ndc, 1);
            }
        };
        // Turn a bin into a number of years, months, days, and time
        // returns an object because returning date numbers for offsets doesn't work
        // imitates PC side's getIncrementVariables
        // This also uses a multiplier for unusual periods such as biweekly or whatever
        // @return [Object] the offset in four parts: year,month,day, and time
        FDSIntradayScale.prototype._getOffsetVariables = function (dateBin, timeBin, mult) {
            if (timeBin === void 0) { timeBin = 0; }
            if (mult === void 0) { mult = 1; }
            if (mult < 1) {
                mult = 1;
            }
            var month, day, hour, min$$1, sec, year;
            year = month = day = hour = min$$1 = sec = 0;
            // if we have both a time bin and a date bin set to a time, use the time bin
            if (dateBin < 14 /* DAY */ && timeBin > 0) {
                dateBin = 0 /* NONE */;
            }
            switch (dateBin) {
                case 22 /* TENY */:
                    year = 10 * mult;
                    break;
                case 21 /* FIVEY */:
                    year = 5 * mult;
                    break;
                case 20 /* TWOY */:
                    year = 2 * mult;
                    break;
                case 19 /* YEAR */:
                    year = 1 * mult;
                    break;
                case 18 /* HALFY */:
                    month = 6 * mult;
                    break;
                case 17 /* QUARTER */:
                    month = 3 * mult;
                    break;
                case 16 /* MONTH */:
                    month = 1 * mult;
                    break;
                case 15 /* WEEK */:
                    day = 7 * mult;
                    break;
                case 14 /* DAY */:
                    day = 1 * mult;
                    break;
                case 13 /* SIXHOUR */:
                    hour = 6 * mult;
                    break;
                case 12 /* TWOHOUR */:
                    hour = 2 * mult;
                    break;
                case 11 /* HOUR */:
                    hour = 1 * mult;
                    break;
                case 10 /* HALFHOUR */:
                    min$$1 = 30 * mult;
                    break;
                case 9 /* TENMINUTE */:
                    min$$1 = 10 * mult;
                    break;
                case 8 /* FIVEMINUTE */:
                    min$$1 = 5 * mult;
                    break;
                case 7 /* TWOMINUTE */:
                    min$$1 = 2 * mult;
                    break;
                case 6 /* MINUTE */:
                    min$$1 = 1 * mult;
                    break;
                case 5 /* HALFMINUTE */:
                    sec = 30 * mult;
                    break;
                case 4 /* TENSECOND */:
                    sec = 10 * mult;
                    break;
                case 3 /* FIVESECOND */:
                    sec = 5 * mult;
                    break;
                case 2 /* TWOSECOND */:
                    sec = 2 * mult;
                    break;
                case 1 /* SECOND */:
                    sec = 1 * mult;
                    break;
                default:
                    if (timeBin === 0) {
                        day = 1;
                    }
                    else {
                        _a = this._getOffsetFromTimeBin(timeBin), hour = _a[0], min$$1 = _a[1], sec = _a[2];
                        if ((hour === min$$1 && min$$1 === sec) && sec === 0) {
                            day = 1;
                        }
                    }
            }
            var time = FDSTime.makeTimeStd(hour, min$$1, sec);
            return { years: year, months: month, days: day, time: time };
            var _a;
        };
        // helper function to set up binning variables and ranges
        // @param binned [Boolean] whether or not binning is enabled on this scale
        FDSIntradayScale.prototype._setBinned = function (binned) {
            this.bin = binned;
            this.setTickBinned(binned);
            this._setRanges();
        };
        // Detect holidays, least visible interval and start and end of days
        // logic copied from PC side
        // @return [Array<Interval>] list of intervals detected as holidays
        FDSIntradayScale.prototype._detectParameters = function (dataset) {
            // start these opposite so that we can min/max them with the data
            var startDay = 1;
            var endDay = 0;
            var dataPtAdjustment = 0;
            var holidays = [];
            if (this._axisSubType === 5 /* DATE */) {
                this._addOffsetDateDatasets = 0.5;
            }
            else {
                this._addOffsetDateDatasets = 0;
            }
            // dataPtAdjustment is a fraction of a day, but TimeOffset is in hours
            // remember, in DateTime format, 1/24 represents one hour, since 1 is one day
            dataPtAdjustment = dataset.attributeSet.get('TimeOffset') / 24;
            this._dataSections = [];
            var dataStart = 0;
            var minSection = Math.max(0, dataset.Max()[0] - dataset.Min()[0]);
            var previous = 0;
            var dataFitsInSingleDay = false;
            if (!this._automaticStartEndDayDetection) {
                if (((~~this.max) - (~~this.min)) > 1) {
                    startDay = 0;
                    endDay = 1;
                }
                else {
                    dataFitsInSingleDay = true;
                }
            }
            for (var i = 0; i < dataset.data.length; i++) {
                var dataPt = dataset.data[i];
                if (isNaN(dataPt)) {
                    continue;
                }
                var difference = dataPt - previous;
                if (difference < minSection) {
                    minSection = difference;
                }
                // both holiday detection and start/end day calculation affect intervals up to and including DAY
                if (this._dsFrequency <= 14 /* DAY */) {
                    // adjust day so it matches with other time zones
                    if (this._automaticStartEndDayDetection || dataFitsInSingleDay) {
                        var adjustedDataPt = dataPt - dataPtAdjustment;
                        var decimal = adjustedDataPt % 1;
                        startDay = Math.min(startDay, decimal);
                        // End of day needs to be offset by the bin width.
                        // If the last datapoint is a at 4:00 with 30 min bins, the actual "end of day" should be 4:30.
                        if ((this._dsTimeBin > 0) && (this._dsFrequency === 0 /* NONE */) && this.getBinned()) {
                            var _a = this._getOffsetFromTimeBin(this._dsTimeBin), offH = _a[0], offM = _a[1], offS = _a[2];
                            var offsetSec = (offS / (60 * 60 * 24)) + (offM / (60 * 24)) + (offH / 24);
                            var offsetDecimal = decimal + offsetSec;
                            endDay = Math.max(endDay, Math.min(1, offsetDecimal));
                        }
                        else {
                            endDay = Math.max(endDay, decimal);
                        }
                    }
                    // this.dataSections stores the sections that have data
                    if ((~~dataPt) - (~~previous) > 0) {
                        // ...assuming it isn't the first day
                        if (dataStart !== 0) {
                            this._dataSections.push(new Interval(dataStart, previous));
                        }
                        // ... and save the current day
                        dataStart = dataPt;
                    }
                    // holiday detection
                    if (i > 0) {
                        // Encoding '1' into something more programmatical could make this work for any frequency
                        if (this._automaticHolidayDetection && !isNaN(dataPt) && difference > 1) {
                            // there is a holiday when the data pts differ by more than 1 day (meaning there's an
                            // entire data-free day in between them)
                            var iPrevious = (~~previous);
                            var iDP = (~~dataPt);
                            while (iDP - iPrevious >= 2) {
                                var start = ++iPrevious;
                                var end = start + 1;
                                if (!FDSDate.isWeekend(start) || this._treatWeekendsAsHolidays) {
                                    holidays.push(new Interval(start, end));
                                }
                            }
                        }
                    }
                }
                previous = dataPt;
            }
            if (dataset.getSize() > 1) {
                var minSecBin = this._getDateTimeBinFromRange(Math.abs(minSection));
                this._leastVisibleInterval = Math.min(minSecBin, this._leastVisibleInterval);
            }
            else {
                this._leastVisibleInterval = Math.min(this._dsFrequency, this._leastVisibleInterval);
            }
            // save the last section
            if (this._dsFrequency === 14 /* DAY */) {
                this._dataSections.push(new Interval(dataStart, previous));
            }
            this._startOfDay = Math.min(this._startOfDay, startDay);
            this._endOfDay = Math.max(this._endOfDay, endDay);
            if (this._endOfDay > 1 || this._startOfDay < 0 || fuzzyLTE(this._endOfDay, this._startOfDay)) {
                // error checking
                this._startOfDay = 0.0;
                this._endOfDay = 1.0;
            }
            return holidays;
        };
        // Calculates start/end dates of dateBin period based on a given date/time
        // @param dateBin [DateTimeBin] the DateTimeBin to find
        // @param val [Number] The value to find the bin of
        // @return [Array<Number>] [startDate, endDate] the start and end dates of the bin around val
        FDSIntradayScale.prototype._getDateRange = function (val, dateBin, timeBin) {
            var startDate = 0;
            var endDate = 0;
            var intVal = ~~val;
            var timePart = val - intVal;
            switch (dateBin) {
                case 1 /* SECOND */:
                    startDate = val - (SEC_FRAC / 2);
                    endDate = val + (SEC_FRAC / 2);
                    break;
                case 2 /* TWOSECOND */:
                    startDate = val - SEC_FRAC;
                    endDate = val + SEC_FRAC;
                    break;
                case 3 /* FIVESECOND */:
                    startDate = val - (SEC_FRAC * 2.5);
                    endDate = val + (SEC_FRAC * 2.5);
                    break;
                case 4 /* TENSECOND */:
                    startDate = val - (SEC_FRAC * 5);
                    endDate = val + (SEC_FRAC * 5);
                    break;
                case 5 /* HALFMINUTE */:
                    startDate = val - (SEC_FRAC * 15);
                    endDate = val + (SEC_FRAC * 15);
                    break;
                case 6 /* MINUTE */:
                    startDate = val - (MIN_FRAC / 2);
                    endDate = val + (MIN_FRAC / 2);
                    break;
                case 7 /* TWOMINUTE */:
                    startDate = val - MIN_FRAC;
                    endDate = val + MIN_FRAC;
                    break;
                case 8 /* FIVEMINUTE */:
                    startDate = val - (MIN_FRAC * 2.5);
                    endDate = val + (MIN_FRAC * 2.5);
                    break;
                case 9 /* TENMINUTE */:
                    startDate = val - (MIN_FRAC * 5);
                    endDate = val + (MIN_FRAC * 5);
                    break;
                case 10 /* HALFHOUR */:
                    startDate = val - (MIN_FRAC * 15);
                    endDate = val + (MIN_FRAC * 15);
                    break;
                case 11 /* HOUR */:
                    startDate = val - (HOUR_FRAC / 2);
                    endDate = val + (HOUR_FRAC / 2);
                    break;
                case 12 /* TWOHOUR */:
                    startDate = val - HOUR_FRAC;
                    endDate = val + HOUR_FRAC;
                    break;
                case 13 /* SIXHOUR */:
                    startDate = val - (HOUR_FRAC * 3);
                    endDate = val + (HOUR_FRAC * 3);
                    break;
                case 14 /* DAY */:
                    startDate = intVal;
                    endDate = intVal + 1;
                    break;
                case 15 /* WEEK */:
                    this._time.setWeekType(this.weekType);
                    _a = this._time.getWeekRange(intVal), startDate = _a[1], endDate = _a[2];
                    break;
                case 16 /* MONTH */:
                    _b = this._time.getMonthRange(intVal), startDate = _b[1], endDate = _b[2];
                    break;
                case 17 /* QUARTER */:
                    _c = this._time.getQuarterRange(intVal), startDate = _c[1], endDate = _c[2];
                    break;
                case 18 /* HALFY */:
                    _d = this._time.getHalfYearRange(intVal, this.min), startDate = _d[1], endDate = _d[2];
                    break;
                case 19 /* YEAR */:
                    _e = this._time.getYearRange(intVal), startDate = _e[1], endDate = _e[2];
                    break;
                case 20 /* TWOY */:
                    _f = this._time.getNYear(intVal, 2), startDate = _f[1], endDate = _f[2];
                    break;
                case 21 /* FIVEY */:
                    _g = this._time.getNYear(intVal, 5), startDate = _g[1], endDate = _g[2];
                    break;
                case 22 /* TENY */:
                    _h = this._time.getNYear(intVal, 10), startDate = _h[1], endDate = _h[2];
                    break;
                default:// DateTimeBin.NONE
                    if (this._isTimeFrequency(dateBin, timeBin)) {
                        _j = this._getRoundingTimeBinStdRange(val, timeBin), startDate = _j[1], endDate = _j[2];
                    }
                    else {
                        startDate = intVal;
                        endDate = intVal + 1;
                    }
            }
            return [startDate, endDate];
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        };
        // helper function to replace a calculation done inside lookupRangeWithBin
        // so I don't have to pass it around constantly
        // @return [Boolean] true if the frequency is a time frequency, false if it's otherwise (aka a date one)
        FDSIntradayScale.prototype._isTimeFrequency = function (dateBin, timeBin) {
            return dateBin === 0 /* NONE */ &&
                (timeBin !== 0 || !this._secondaryFrequencyDefault || this._dsSecondaryFrequency !== 0);
        };
        // helper function that copies the functionality in FDSTime.getTimeBinStdRange, but does some
        // rounding to prevent values from overlapping when they shouldn't
        FDSIntradayScale.prototype._getRoundingTimeBinStdRange = function (value, bin) {
            // copied from getTimeBinStd
            var timeFrac = FDSTime.getTimeFrac(value);
            var daySeconds = Math.round(timeFrac * 24 * 3600); // instead of nSecondsStd
            var binSeconds = this._time.nSeconds(0, bin);
            var ret = ~~(daySeconds / (binSeconds > 0 ? binSeconds : 1));
            // copied from getTimeBinStdRange
            var start = FDSTime.makeDayTimeStd((~~value), 0, 0, ret * (binSeconds === 0 ? 1 : binSeconds));
            var end = FDSTime.makeDayTimeStd((~~value), 0, 0, (binSeconds === 0 ? ret : ((ret * binSeconds) + binSeconds) - 1));
            return [ret, start, end];
        };
        // helper function to go from a bin to a number range
        FDSIntradayScale.prototype._getRangeFromDateTimeBin = function (bin) {
            switch (bin) {
                case 0 /* NONE */:
                    return 0;
                case 1 /* SECOND */:
                    return SEC_FRAC;
                case 2 /* TWOSECOND */:
                    return (2 * SEC_FRAC);
                case 3 /* FIVESECOND */:
                    return (5 * SEC_FRAC);
                case 4 /* TENSECOND */:
                    return (10 * SEC_FRAC);
                case 5 /* HALFMINUTE */:
                    return (30 * SEC_FRAC);
                case 6 /* MINUTE */:
                    return MIN_FRAC;
                case 7 /* TWOMINUTE */:
                    return (2 * MIN_FRAC);
                case 8 /* FIVEMINUTE */:
                    return (5 * MIN_FRAC);
                case 9 /* TENMINUTE */:
                    return (10 * MIN_FRAC);
                case 10 /* HALFHOUR */:
                    return (30 * MIN_FRAC);
                case 11 /* HOUR */:
                    return HOUR_FRAC;
                case 12 /* TWOHOUR */:
                    return (2 * HOUR_FRAC);
                case 13 /* SIXHOUR */:
                    return (6 * HOUR_FRAC);
                case 14 /* DAY */:
                    return 1;
                case 15 /* WEEK */:
                    return 7;
                case 16 /* MONTH */:
                    return 30;
                case 17 /* QUARTER */:
                case 18 /* HALFY */:
                    return 120;
                case 19 /* YEAR */:
                    return 360;
                case 20 /* TWOY */:
                case 21 /* FIVEY */:
                case 22 /* TENY */:
                    return 3600;
            }
            return 0;
        };
        // helper function to go from a number length to a date/time bin
        // logic copied from PC function of same name
        FDSIntradayScale.prototype._getDateTimeBinFromRange = function (length) {
            if (length < (2 * SEC_FRAC)) {
                return 1 /* SECOND */;
            }
            if (length < (5 * SEC_FRAC)) {
                return 2 /* TWOSECOND */;
            }
            if (length < (10 * SEC_FRAC)) {
                return 3 /* FIVESECOND */;
            }
            if (length < (30 * SEC_FRAC)) {
                return 4 /* TENSECOND */;
            }
            if (length < MIN_FRAC) {
                return 5 /* HALFMINUTE */;
            }
            if (length < (2 * MIN_FRAC)) {
                return 6 /* MINUTE */;
            }
            if (length < (5 * MIN_FRAC)) {
                return 7 /* TWOMINUTE */;
            }
            if (length < (10 * MIN_FRAC)) {
                return 8 /* FIVEMINUTE */;
            }
            if (length < (30 * MIN_FRAC)) {
                return 9 /* TENMINUTE */;
            }
            if (length < HOUR_FRAC) {
                return 10 /* HALFHOUR */;
            }
            if (length < (2 * HOUR_FRAC)) {
                return 11 /* HOUR */;
            }
            if (length < (6 * HOUR_FRAC)) {
                return 12 /* TWOHOUR */;
            }
            if (length < 1) {
                return 13 /* SIXHOUR */;
            }
            if (length < 7) {
                return 14 /* DAY */;
            }
            if (length < 30) {
                return 15 /* WEEK */;
            }
            if (length < (3 * 30)) {
                return 16 /* MONTH */;
            }
            if (length < 180) {
                return 17 /* QUARTER */;
            }
            if (length < 365) {
                return 18 /* HALFY */;
            }
            if (length < (2 * 365)) {
                return 19 /* YEAR */;
            }
            if (length < (5 * 365)) {
                return 20 /* TWOY */;
            }
            if (length < (10 * 365)) {
                return 21 /* FIVEY */;
            }
            // A lot
            return 22 /* TENY */;
        };
        FDSIntradayScale.prototype.lookup = function (value, dateBin) {
            if (dateBin === void 0) { dateBin = this._dsFrequency; }
            if (this.getBinned()) {
                var _a = this.lookupRange(value, dateBin), high = _a[1], low = _a[2];
                // lookuprange just returns the actual value as the first return
                return (high + low) / 2;
            }
            else {
                return this._localLookup(value);
            }
        };
        // returns [value, low, high, offset]
        // NOTE: I decided (after discussions with everyone involved) to get rid of the whole baseRangesOnIntervals idea
        // until we can better decide what to use it for/how to use it. So for now lookupRange just does the logic found
        // in the PC-side function lookupRange(value, dateBin, etc...) (our old function lookupRangeWithBin)
        FDSIntradayScale.prototype.lookupRange = function (value, dateBin) {
            if (dateBin === void 0) { dateBin = this._dsFrequency; }
            var finalDateBin = this._secondaryFrequencyDefault ? dateBin : this._dsSecondaryFrequency;
            var finalTimeBin = this._secondaryFrequencyDefault ? this._dsTimeBin : this._dsSecondaryTimeFrequency;
            /* tslint:disable-next-line:prefer-const */
            var _a = this._getDateRange(value, finalDateBin, finalTimeBin), lowdate = _a[0], highdate = _a[1];
            if (this._dsFrequency > 14 /* DAY */) {
                lowdate = this._adjustUp(lowdate + 1);
            }
            var low = this._lookupInternal(lowdate);
            var high = this._lookupInternal(highdate);
            if (high < low) {
                _b = [high, low], low = _b[0], high = _b[1];
            }
            var offset = ((high - low) * (1 - this.getBinFactor())) / 2;
            var val = this.getBinned() ? (low + high) / 2 : low;
            return [val, low, high, offset];
            var _b;
        };
        // mimics logic in PC function getLabelVector()
        // this overrides the default FDSScale computeLabelVector() function
        // fills in @labels array instead of returning it
        FDSIntradayScale.prototype.computeLabelVector = function () {
            var _this = this;
            var clearMajorLabels = function () {
                _this.labels = [];
                _this._majorLabelInfo = [];
                return _this.maxDimensions = {
                    width: 0,
                    height: 0
                };
            };
            var clearMinorLabels = function () {
                _this.minorLabels = [];
                _this._minorLabelInfo = [];
                return _this.minorMaxDimensions = {
                    width: 0,
                    height: 0
                };
            };
            // skip labels if they aren't being shown
            if (!this.axis.labeled || !this.initialized) {
                clearMajorLabels();
                clearMinorLabels();
                return;
            }
            // set up the formatting before we create all the labels
            if (this.axis.labelsLevelsMask & 1 /* MINOR */) {
                if (this._minorLabelFormatsDefault[this._minorDateTimeBin]) {
                    this.formatString = this._minorLabelFormat;
                }
                else {
                    this.formatString = this._minorLabelFormats[this._minorDateTimeBin];
                }
                this._setupFormatter(this.formatString);
                this._computeMinorLabels();
            }
            else {
                clearMinorLabels();
            }
            if (this.axis.labelsLevelsMask & 2 /* MAJOR */) {
                if (this._majorLabelFormatsDefault[this._majorDateTimeBin]) {
                    this.formatString = this._majorLabelFormat;
                }
                else {
                    this.formatString = this._majorLabelFormats[this._majorDateTimeBin];
                }
                this._setupFormatter(this.formatString);
                this._computeMajorLabels();
            }
            else {
                clearMajorLabels();
            }
        };
        FDSIntradayScale.prototype._computeMinorLabels = function () {
            if (!(this.axis.labelsLevelsMask & 1 /* MINOR */)) {
                return;
            }
            // Intraday labeling has precedence over "LabelCentered2"
            this._fillMinorLabelInfo();
        };
        FDSIntradayScale.prototype.computeLabelPositions = function () {
            if (!this.axis.parent) {
                return;
            }
            // wait and do this later if the plot is in the middle of adjusting itself
            if (this.axis.parent.computingDimensions || !this.initialized) {
                return;
            }
            if (this.axis.labelsLevelsMask & 1 /* MINOR */) {
                this._computeMinorLabelPositions();
            }
            if (this.axis.labelsLevelsMask & 2 /* MAJOR */) {
                this._computeMajorLabelPositions();
            }
        };
        FDSIntradayScale.prototype._adjustIfNecessary = function (desc, positive) {
            if (desc == null || !desc.needsAdjust || !this.axis.parent) {
                return;
            }
            var adjAmount = desc.width / 2;
            if (!positive) {
                adjAmount = -adjAmount;
            }
            desc.needsAdjust = false;
            var plotRect = this.axis.parent.plotRect;
            var plotWidth = plotRect.getWidth() * Math.abs(this.axis.maxPlotFactor - this.axis.minPlotFactor);
            desc.ndc += adjAmount / plotWidth;
        };
        // copied from computeMinorLabels on PC side
        FDSIntradayScale.prototype._computeMinorLabelPositions = function () {
            if (!this.axis.parent) {
                return;
            }
            // we need the label sizes and the plot size to do this
            var plotRect = this.axis.parent.plotRect;
            var plotRectNull = (!plotRect) ||
                (plotRect.x1 <= 0 && plotRect.x2 <= 0 && plotRect.y1 <= 0 && plotRect.y2 <= 0);
            if (this.minorLabelPositionsComputed || (!this._minorLabelSizesComputed) || plotRectNull) {
                return;
            }
            var widthReduction = 0;
            this.minorLabels = [];
            var hitShapes = [];
            if (this._isLeftEnd(this._forceMinorEndLabels)) {
                switch (this._endLabelMinorLeftPosition) {
                    case 0 /* INSIDE */:
                        this._adjustIfNecessary(this._leftMinorLabelDesc, true);
                        break;
                    case 1 /* OUTSIDE */:
                        widthReduction = this._leftMinorLabelDesc.width;
                        this._adjustIfNecessary(this._leftMinorLabelDesc, false);
                        break;
                    default:// EndLabelPosition.BETWEEN
                        widthReduction = Math.round(this._leftMinorLabelDesc.width / 2.0);
                }
                this._checkAndAddLabel(this._leftMinorLabelDesc, hitShapes, this.minorLabels);
            }
            if (this._isRightEnd(this._forceMinorEndLabels)) {
                switch (this._endLabelMinorRightPosition) {
                    case 0 /* INSIDE */:
                        this._adjustIfNecessary(this._rightMinorLabelDesc, false);
                        break;
                    case 1 /* OUTSIDE */:
                        widthReduction += this._rightMinorLabelDesc.width;
                        this._adjustIfNecessary(this._rightMinorLabelDesc, true);
                        break;
                    default:// EndLabelPosition.BETWEEN
                        widthReduction += Math.round(this._rightMinorLabelDesc.width / 2.0);
                }
                this._checkAndAddLabel(this._rightMinorLabelDesc, hitShapes, this.minorLabels);
            }
            var labelPadding = Math.abs(this._minorLabelPadding);
            if (!this._intradayLabelingOn()) {
                var plotWidth = plotRect.getWidth() * Math.abs(this.axis.maxPlotFactor - this.axis.minPlotFactor);
                // double check here because sometimes the plotWidth isn't updated (is there a better way to get it?)
                var chartWidth = this.axis.root.chartRect.getWidth();
                if (plotWidth > chartWidth) {
                    // chartWidth is still bigger than plot width but it's closer
                    plotWidth = chartWidth;
                }
                if (plotWidth === 0) {
                    return;
                } // no room for labels
                var maxwidth = 1;
                for (var _i = 0, _a = this._minorLabelInfo; _i < _a.length; _i++) {
                    var minor = _a[_i];
                    if (minor.left) {
                        maxwidth = Math.max(maxwidth, minor.left.width);
                    }
                }
                if (labelPadding < 1) {
                    maxwidth += Math.round(maxwidth * labelPadding);
                }
                else {
                    maxwidth += Math.round(labelPadding);
                }
                if (plotWidth < maxwidth) {
                    return;
                } // no room for labels!
                var numLabels = ~~((plotWidth - widthReduction) / maxwidth);
                if (numLabels < 1) {
                    numLabels = 1;
                }
                var skipEvery = Math.ceil(this._minorLabelInfo.length / numLabels);
                if (skipEvery < 1 || (!this.axis.ticksResize)) {
                    skipEvery = 1;
                }
                for (var k = 0; k < this._minorLabelInfo.length; k += skipEvery) {
                    var minor = this._minorLabelInfo[k];
                    this._checkAndAddLabel(minor.left, hitShapes, this.minorLabels);
                }
            }
            else {
                // this is if intradayLabeling is on
                for (var _b = 0, _c = this._minorLabelInfo; _b < _c.length; _b++) {
                    var minor = _c[_b];
                    // add in the x info since we can calculate it now
                    this._adjustIfNecessary(minor.left, true);
                    this._adjustIfNecessary(minor.right, false);
                    this._checkAndAddLabel(minor.left, hitShapes, this.minorLabels);
                    this._checkAndAddLabel(minor.right, hitShapes, this.minorLabels);
                    this._checkAndAddLabel(minor.firstDatapoint, hitShapes, this.minorLabels);
                    for (var _d = 0, _e = minor.rem; _d < _e.length; _d++) {
                        var label = _e[_d];
                        this._checkAndAddLabel(label, hitShapes, this.minorLabels);
                    }
                }
            }
            this.minorLabelPositionsComputed = true;
        };
        // return the left and rightmost major labels
        FDSIntradayScale.prototype.getEdgeMajorLabels = function () {
            if ((this.labels == null) || this.labels.length === 0) {
                return [null, null];
            }
            // end labels make the labels not necessarily in ndc order
            if (this._forceMajorEndLabels === 2 /* NONE */) {
                // the labels are in order
                return [this.labels[0], this.labels[this.labels.length - 1]];
            }
            // find the left and rightmost labels
            var minx = Infinity;
            var maxx = -Infinity;
            var first$$1 = null;
            var last$$1 = null;
            for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                if (label[1] < minx) {
                    first$$1 = label;
                    minx = label[1];
                }
                if (label[1] > maxx) {
                    last$$1 = label;
                    maxx = label[1];
                }
            }
            return [first$$1, last$$1];
        };
        // return the left and rightmost minor labels
        FDSIntradayScale.prototype.getEdgeMinorLabels = function () {
            if ((this.minorLabels == null) || this.minorLabels.length === 0) {
                return [null, null];
            }
            // end labels or intraday labeling make the labels not necessarily in ndc order
            if (!this._intradayLabelingOn() && this._forceMinorEndLabels === 2 /* NONE */) {
                // the labels are in order
                return [this.minorLabels[0], this.minorLabels[this.minorLabels.length - 1]];
            }
            // find the left and rightmost labels
            var minx = Infinity;
            var maxx = -Infinity;
            var first$$1 = null;
            var last$$1 = null;
            for (var _i = 0, _a = this.minorLabels; _i < _a.length; _i++) {
                var label = _a[_i];
                if (label[1] < minx) {
                    first$$1 = label;
                    minx = label[1];
                }
                if (label[1] > maxx) {
                    last$$1 = label;
                    maxx = label[1];
                }
            }
            return [first$$1, last$$1];
        };
        // logic copied from PC side fillAllMinorLabelVector
        FDSIntradayScale.prototype._fillMinorLabelInfo = function () {
            var _this = this;
            if (!this._minorLabelInfoDirty) {
                return;
            }
            // have to call this here because if we're zoomed, the thresholds are currently wrong
            this._setTickRanges();
            var centered = this.getMinorLabelBinned();
            this.computeSubTickVector();
            this._minorLabelInfo = [];
            if (this._intradayLabelingOn()) {
                var firstSection = void 0;
                var lastSection = void 0;
                // We need the major ticks because there should be two labels for each major tick, one on each side
                this.computeTickVector();
                // find first and last data sections
                for (var _i = 0, _a = this._dataSections; _i < _a.length; _i++) {
                    var sec = _a[_i];
                    if (sec.start > this.threshMin && firstSection == null) {
                        firstSection = sec;
                    }
                    if (sec.start < this.threshMax) {
                        lastSection = sec;
                    }
                    else {
                        // we've passed threshMax, short-circuit
                        break;
                    }
                }
                var MTIlen = this.majorTickInfo.length;
                var minorIndex = 0;
                // this padding amount matches the PC side charts
                var labelPadding_1 = 0.005;
                // some helper functions because these get done a ton
                var addRight = function (mls, tick) {
                    if (tick.prev) {
                        var ndc = tick.ndc - labelPadding_1;
                        var alignment = _this._adjustedTextPosition(1 /* RIGHT */);
                        var label = _this._getFormattedLabel(tick.prev, 0 /* MINOR */);
                        mls.right = new LabelDesc(label, ndc, alignment);
                    }
                };
                var addLeft = function (mls, tick) {
                    if (tick.next) {
                        var ndc = tick.ndc + labelPadding_1;
                        var alignment = _this._adjustedTextPosition(0 /* LEFT */);
                        var label = _this._getFormattedLabel(tick.next, 0 /* MINOR */);
                        mls.left = new LabelDesc(label, ndc, alignment);
                    }
                };
                var addFirst = function (mls, section) {
                    if (section) {
                        var ndc = _this._lookupInternal(section.start);
                        var label = _this._getFormattedLabel(section.start, 0 /* MINOR */);
                        var alignment = 2;
                        mls.firstDatapoint = new LabelDesc(label, ndc, alignment);
                    }
                };
                var fillREM = function (mls, ind, end) {
                    while (_this.subTicks[ind] < end) {
                        var ndc = _this.subTicks[ind];
                        var subTickVal = _this.computeValue(_this.subTicks[ind]);
                        var label = _this._getFormattedLabel(subTickVal, 0 /* MINOR */);
                        mls.rem.push(new LabelDesc(label, ndc));
                        ind++;
                    }
                };
                // add stuff before the first major tick
                var mls = new MinorLabelStruct();
                var nextTick = this.majorTickInfo[0];
                if ((firstSection != null) && fuzzyLTE(firstSection.start, nextTick.value)) {
                    addFirst(mls, firstSection);
                }
                if (fuzzyGTE(nextTick.ndc, 0)) {
                    addRight(mls, nextTick);
                }
                fillREM(mls, minorIndex, nextTick.ndc);
                this._minorLabelInfo.push(mls);
                // this loop creates the minorLabelStructs inside minorLabelInfo and fills in their left and right bits
                for (var i = 0; i < this.majorTickInfo.length; i++) {
                    var tick_1 = this.majorTickInfo[i];
                    if (i === MTIlen - 1) {
                        break;
                    } // don't need to do anything for the last tick
                    mls = new MinorLabelStruct();
                    nextTick = this.majorTickInfo[i + 1];
                    var found = false;
                    var section = void 0;
                    for (var j = 0; j < this._dataSections.length; j++) {
                        section = this._dataSections[j];
                        if (section.start >= tick_1.value && section.start < nextTick.value) {
                            found = true;
                            break;
                        }
                    }
                    if (found) {
                        addFirst(mls, section);
                    }
                    // for now, save the right and left labels as the tick position
                    // they'll be shifted later when we know the label width
                    addLeft(mls, tick_1);
                    addRight(mls, nextTick);
                    // fill in the REM array
                    // first find the first subtick *after* the current major tick
                    while (this.subTicks[minorIndex] <= tick_1.ndc) {
                        minorIndex++;
                    }
                    // fill in all the ticks in between this one and the next major tick
                    fillREM(mls, minorIndex, nextTick.ndc);
                    // Insert the bin into the list
                    this._minorLabelInfo.push(mls);
                }
                // add stuff after the last tick
                mls = new MinorLabelStruct();
                var tick = this.majorTickInfo[MTIlen - 1];
                if (lastSection != null && fuzzyGTE(lastSection.start, tick.value)) {
                    addFirst(mls, lastSection);
                }
                if (fuzzyLTE(tick.ndc, 1)) {
                    addLeft(mls, tick);
                }
                // add minor labels up til an ndc of 1 (this should hit all reminaing minor ticks)
                fillREM(mls, minorIndex, 1);
                this._minorLabelInfo.push(mls);
            }
            else {
                // non-intraday labeling
                var value = void 0;
                if (centered) {
                    // centered labels
                    var prevNdc = 0;
                    // try to fill space before first tick
                    if (fuzzyGT(this._reverseNdc(this.minorTickInfo[0].ndc), 0)) {
                        var prevVal = this._lastMinorTickLessThanThreshMin;
                        prevNdc = this._lookupInternal(prevVal);
                        if (fuzzyLTE(this._reverseNdc(prevNdc), 0)) {
                            if (this._minorBinLabelMode === 1 /* END */ && this._minorDateTimeBin >= 14 /* DAY */) {
                                value = this._adjust(prevVal - 1);
                            }
                            else {
                                value = this._adjustUp(prevVal);
                            }
                            // find the average of the last minor tick before threshmin and the first tick
                            var currNdc = (this.minorTickInfo[0].ndc + prevNdc) / 2;
                            if (fuzzyGT(currNdc, 0)) {
                                var mls = new MinorLabelStruct();
                                mls.left = new LabelDesc(this._getFormattedLabel(value, 0 /* MINOR */), currNdc);
                                this._minorLabelInfo.push(mls);
                            }
                        }
                    }
                    prevNdc = this.minorTickInfo[0].ndc;
                    // then one for each space between ticks
                    for (var i = 0; i < this.subTicks.length; i++) {
                        var tick = this.subTicks[i];
                        if (i === 0) {
                            continue;
                        } // skip first tick
                        if (this._minorBinLabelMode === 1 /* END */ && this._minorDateTimeBin >= 14 /* DAY */) {
                            value = this._adjust(this.minorTickInfo[i].value - 1);
                        }
                        else {
                            value = this._adjustUp(this.minorTickInfo[i - 1].value);
                        }
                        var currNdc = (this.minorTickInfo[i].ndc + prevNdc) / 2;
                        var mls = new MinorLabelStruct();
                        mls.left = new LabelDesc(this._getFormattedLabel(value, 0 /* MINOR */), currNdc);
                        this._minorLabelInfo.push(mls);
                        prevNdc = tick;
                    }
                    // lastly, try to fill the space after the tick
                    if (fuzzyLT(this._reverseNdc(prevNdc), 1)) {
                        var endNdc = this._lookupInternal(this._firstMinorTickGreaterThanThreshMax);
                        if (this._minorBinLabelMode === 1 /* END */ && this._minorDateTimeBin >= 14 /* DAY */) {
                            value = this._adjust(this._firstMinorTickGreaterThanThreshMax - 1);
                        }
                        else {
                            value = this._adjustUp(this.minorTickInfo[this.minorTickInfo.length - 1].value);
                        }
                        var currNdc = (endNdc + prevNdc) / 2;
                        if (fuzzyLT(this._reverseNdc(currNdc), 1)) {
                            var mls = new MinorLabelStruct();
                            mls.left = new LabelDesc(this._getFormattedLabel(value, 0 /* MINOR */), currNdc);
                            this._minorLabelInfo.push(mls);
                        }
                    }
                }
                else {
                    // Minor label on ticks
                    // tslint:disable-next-line:prefer-for-of
                    for (var i = 0; i < this.subTicks.length; i++) {
                        var tick = this.subTicks[i];
                        if (this.minorTickInfo[i].artificial || fuzzyLT(tick, 0) || fuzzyGT(tick, 1)) {
                            continue;
                        }
                        if (this._minorBinLabelMode === 1 /* END */ && this._minorDateTimeBin >= 14 /* DAY */) {
                            value = this._adjust(this.minorTickInfo[i].value - 1);
                        }
                        else {
                            value = this._adjustUp(this.minorTickInfo[i].value);
                            var mls = new MinorLabelStruct();
                            mls.left = new LabelDesc(this._getFormattedLabel(value, 0 /* MINOR */), tick);
                            this._minorLabelInfo.push(mls);
                        }
                    }
                }
            }
            this._minorLabelInfoDirty = this._minorLabelSizesComputed = false;
        };
        // logic copied from PC function with same name
        FDSIntradayScale.prototype._computeMajorLabels = function () {
            if (!(this.axis.labelsLevelsMask & 2 /* MAJOR */)) {
                return;
            }
            this._fillMajorLabelInfo();
        };
        // logic copied from PC function computeMajorLabels
        FDSIntradayScale.prototype._computeMajorLabelPositions = function () {
            if (!this.axis.parent) {
                return;
            }
            // If the relevant info hasn't been filled in (by computelabelSizes), or if the plot size
            // hasn't been filled in, skip everything
            var plotRect = this.axis.parent.plotRect;
            var plotRectNull = (!plotRect) ||
                (plotRect.x1 <= 0 && plotRect.x2 <= 0 && plotRect.y1 <= 0 && plotRect.y2 <= 0);
            if (this.majorLabelPositionsComputed || (!this._majorLabelSizesComputed) || plotRectNull) {
                return;
            }
            var hitShapes = [];
            this.labels = [];
            var widthReduction = 0;
            if (this._isLeftEnd(this._forceMajorEndLabels)) {
                // fill this in now since now we know the plot info exists
                switch (this._leftMajorLabelDesc.alignment) {
                    case 0 /* LEFT */:
                        this._adjustIfNecessary(this._leftMajorLabelDesc, true);
                        break;
                    case 1 /* RIGHT */:
                        widthReduction = this._leftMajorLabelDesc.width;
                        this._adjustIfNecessary(this._leftMajorLabelDesc, false);
                        break;
                    default:// TextPosition.CENTER
                        widthReduction = Math.round(this._leftMajorLabelDesc.width / 2.0);
                }
                this._checkAndAddLabel(this._leftMajorLabelDesc, hitShapes, this.labels);
            }
            if (this._isRightEnd(this._forceMajorEndLabels)) {
                // fill this in now since now we know the plot info exists
                switch (this._endLabelMajorRightPosition) {
                    case 0 /* INSIDE */:
                        this._adjustIfNecessary(this._rightMajorLabelDesc, false);
                        break;
                    case 1 /* OUTSIDE */:
                        widthReduction += this._rightMajorLabelDesc.width;
                        this._adjustIfNecessary(this._rightMajorLabelDesc, true);
                        break;
                    default:// EndLabelPosition.BETWEEN
                        widthReduction += Math.round(this._rightMajorLabelDesc.width / 2.0);
                }
                this._checkAndAddLabel(this._rightMajorLabelDesc, hitShapes, this.labels);
            }
            var maxwidth = 1;
            for (var _i = 0, _a = this._majorLabelInfo; _i < _a.length; _i++) {
                var info = _a[_i];
                maxwidth = Math.max(maxwidth, info.width);
            }
            // on PC side this stuff is passed into computeLabelSizes by the axis and saved
            plotRect = this.axis.parent.plotRect;
            var plotWidth = plotRect.getWidth() * Math.abs(this.axis.maxPlotFactor - this.axis.minPlotFactor);
            if (plotWidth === 0) {
                // no room for any labels!
                this.labels = [];
                return;
            }
            var numVisibleLabels = ~~((plotWidth - widthReduction) / maxwidth);
            var skipEvery = Math.ceil(this._majorLabelInfo.length / Math.max(1, numVisibleLabels));
            if (skipEvery < 1 || (!this.axis.ticksResize)) {
                skipEvery = 1;
            }
            for (var j = 0; j < this._majorLabelInfo.length; j += skipEvery) {
                var label = this._majorLabelInfo[j];
                this._checkAndAddLabel(label, hitShapes, this.labels);
            }
            this.majorLabelPositionsComputed = true;
        };
        // wrapper function to add a label to an array if it fits
        FDSIntradayScale.prototype._checkAndAddLabel = function (desc, hitArray, addArray, add) {
            if (add === void 0) { add = true; }
            if (desc == null || (desc.label === undefined) || (desc.ndc === undefined) || (desc.width === undefined) ||
                (desc.ndc === Infinity) || (desc.ndc === -Infinity) || (desc.x === Infinity) || (desc.x === -Infinity)) {
                return;
            }
            if (desc.alignment === undefined) {
                desc.alignment = 2 /* CENTER */; // default
            }
            if (!this.axis.ticksResize || this._addLabel(desc, hitArray, add)) {
                // minor labels carry alignment with them
                addArray.push([desc.label, desc.ndc, desc.alignment]);
            }
        };
        // function to determine if a label fits the axis
        // @param desc [LabelDesc] contains information about the label
        // @param hitShapes [Array<Interval>] an array for keeping track of where the labels are
        // @param add [Boolean] whether or not to actually add the label to hitShapes if it fits
        // @return [Boolean] whether or not the label fits in the axis
        FDSIntradayScale.prototype._addLabel = function (desc, hitShapes, add) {
            if (add === void 0) { add = false; }
            if (!this.axis.parent) {
                return false;
            }
            // this wouldn't be necessary if we calculated everything using subplots correctly,
            // but in FDSChartJS at this time, we use plot space for everything and then
            // recalculate into subplot space and axis expects plot space NDC
            var plotRect = this.axis.parent.plotRect;
            var plotWidth = plotRect.getWidth() * Math.abs(this.axis.maxPlotFactor - this.axis.minPlotFactor);
            var plotWidthAdj = plotWidth;
            var plotStart = 0;
            if (this.axis.parent.leftQuickLabelOffsets != null) {
                plotStart = this.axis.parent.leftQuickLabelOffsets.inside;
                plotWidthAdj -= this.axis.parent.leftQuickLabelOffsets.inside;
            }
            if (this.axis.parent.rightQuickLabelOffsets != null) {
                plotWidthAdj -= this.axis.parent.rightQuickLabelOffsets.inside;
            }
            // this is the subplot adjusted pixel which we'll use for intervals
            var pixel = (desc.ndc * plotWidthAdj) + plotStart;
            var left = (pixel - (desc.width / 2)) / plotWidthAdj;
            var right = (pixel + (desc.width / 2)) / plotWidthAdj;
            var leftNDC = this.axis.parent.normSubPlot(left, this.axis.dimension, false);
            var rightNDC = this.axis.parent.normSubPlot(right, this.axis.dimension, false);
            // sanity check - don't add a label that's outside the bounds
            if (rightNDC < 0 || leftNDC > 1) {
                return false;
            }
            // the interval that represents the new label
            var li = new Interval(left, right);
            // check if any hitshapes overlap it
            for (var _i = 0, hitShapes_1 = hitShapes; _i < hitShapes_1.length; _i++) {
                var shape = hitShapes_1[_i];
                if (this._overlap(shape, li)) {
                    return false;
                }
            }
            if (add) {
                hitShapes.push(li);
            }
            return true;
        };
        // helper function to check if two intervals overlap
        FDSIntradayScale.prototype._overlap = function (int1, int2) {
            return int2.end > int1.start && int2.start < int1.end;
        };
        // returns true if label is binned/centered
        FDSIntradayScale.prototype.getLabelBinned = function () {
            // not in datetime scale, but nice behavior - before, if binned = false, we didn't allow centered labels.
            // Presumably because, with a major unit of day, and daily data, the data is now on the tick, rather than
            // centered in the bin. But for larger bins, such as a major unit of day, and 5min data, the day is still
            // essentially binned. This change allows for that.
            if ((!this.getBinned()) && (this._majorDateTimeBin <= this._leastVisibleInterval)) {
                return false;
            }
            if (!this._majorLabelCenteredDefault) {
                return this._majorLabelCentered;
            }
            if (this._majorDateTimeBin === 15 /* WEEK */ || this._majorDateTimeBin === 20 /* TWOY */ ||
                this._majorDateTimeBin === 21 /* FIVEY */ || this._majorDateTimeBin === 22 /* TENY */) {
                return false;
            }
            if (this._majorDateTimeBin < 14 /* DAY */) {
                return false;
            }
            if (this._intradayLabelingOn()) {
                return false;
            }
            if (this._majorDateTimeBin === 17 /* QUARTER */) {
                return this._getQuarterIsBinned(this._majorLabelFormat, this._majorLabelFormatsDefault, this._majorLabelFormats);
            }
            return true;
        };
        // returns true if label is binned/centered
        FDSIntradayScale.prototype.getMinorLabelBinned = function () {
            if ((!this.getBinned()) && (this._minorDateTimeBin <= this._leastVisibleInterval)) {
                return false;
            }
            if (!this._minorLabelCenteredDefault) {
                return this._minorLabelCentered;
            }
            if (this._minorDateTimeBin === 15 /* WEEK */ || this._minorDateTimeBin === 20 /* TWOY */ ||
                this._minorDateTimeBin === 21 /* FIVEY */ || this._minorDateTimeBin === 22 /* TENY */) {
                return false;
            }
            if (this._minorDateTimeBin < 14 /* DAY */) {
                return false;
            }
            if (this._intradayLabelingOn()) {
                return false;
            }
            if (this._minorDateTimeBin === 17 /* QUARTER */) {
                return this._getQuarterIsBinned(this._minorLabelFormat, this._minorLabelFormatsDefault, this._minorLabelFormats);
            }
            return true;
        };
        FDSIntradayScale.prototype._getQuarterIsBinned = function (labelFormat, labelFormatsDefault, labelFormats) {
            var quarterlyFormat = labelFormats[17 /* QUARTER */] ||
                this.format.locale.getDefaultDateFormatString(17 /* QUARTER */);
            if (quarterlyFormat.match(/m|d|c/i)) {
                return false;
            }
            return true;
        };
        // function to fill in the majorLabelInfo vector, which contains detailed info about the labels
        // besides just their label and ndc
        // logic copied from PC function fillAllMajorLabelVector
        // @return [Array<LabelDesc>] descriptions for each label containing the label text
        FDSIntradayScale.prototype._fillMajorLabelInfo = function () {
            var bin = this.getLabelBinned();
            if (!this._majorLabelInfoDirty && bin === this._majorLabelBinned) {
                return;
            }
            this._majorLabelBinned = bin;
            // this will return if the tickvector isn't dirty so this isn't too overworky
            this.computeTickVector();
            this._majorLabelInfo = [];
            var numRealTicks = 0;
            for (var _i = 0, _a = this.majorTickInfo; _i < _a.length; _i++) {
                var tick = _a[_i];
                if (!tick.artificial) {
                    numRealTicks++;
                }
            }
            if (this._showMajorUnitWhenNoTicks && numRealTicks === 0) {
                var _b = this._getDateRange(this.computeValueUnbinned(0.5), this._majorDateTimeBin, 0), low = _b[0], high = _b[1];
                var value = (this._majorBinLabelMode === 1 /* END */) ? high : low;
                var desc = new LabelDesc(this._getFormattedLabel(value, 1 /* MAJOR */), bin ? 0.5 : 0);
                this._majorLabelInfo.push(desc);
            }
            else if (bin) {
                var value = void 0;
                if (this.majorTickInfo.length > 0) {
                    var prevNdc_1 = 0;
                    // try to fill the space before the first tick (in case the center of the first bin is visible)
                    if (fuzzyGT(this._reverseNdc(this.ticks[0]), 0)) {
                        var prevVal = this.threshMin;
                        if (this._majorTickSnapToDate) {
                            prevVal = this._getDateRange(this.threshMin, this._majorDateTimeBin, 0)[0];
                        }
                        prevNdc_1 = this._lookupInternal(prevVal);
                        // find if edge of bin is before 0 and average is after 0
                        if (fuzzyLT(this._reverseNdc(prevNdc_1), 0)) {
                            if ((this._majorBinLabelMode === 1 /* END */) && (this._majorDateTimeBin >= 14 /* DAY */)) {
                                value = this._adjust(prevVal - 1);
                            }
                            else {
                                value = this._adjustUp(prevVal);
                            }
                            var avgNdc = (this.ticks[0] + prevNdc_1) / 2;
                            if (fuzzyGT(avgNdc, 0)) {
                                // if average is after 0, label the bin
                                var desc = new LabelDesc((this._getFormattedLabel(value, 1 /* MAJOR */)), avgNdc);
                                this._majorLabelInfo.push(desc);
                            }
                        }
                    }
                }
                var prevNdc = this.ticks[0];
                // now one label for each space between ticks
                for (var i = 0; i < this.majorTickInfo.length; i++) {
                    var tickInfo = this.majorTickInfo[i];
                    if (i === 0) {
                        continue;
                    }
                    if ((this._majorBinLabelMode === 1 /* END */) && (this._majorDateTimeBin >= 14 /* DAY */)) {
                        value = this._adjust(this.majorTickInfo[i].value - 1);
                    }
                    else {
                        value = this._adjustUp(this.majorTickInfo[i - 1].value);
                    }
                    var currNdc = (this.majorTickInfo[i].ndc + prevNdc) / 2;
                    // @majorLabelInfo stores LabelDesc objects
                    var desc = new LabelDesc((this._getFormattedLabel(value, 1 /* MAJOR */)), currNdc);
                    this._majorLabelInfo.push(desc);
                    prevNdc = this.majorTickInfo[i].ndc;
                }
                // now fill in the space after the tick, if the center of the last bin is visible
                if (fuzzyLT(this._reverseNdc(prevNdc), 1)) {
                    var endNdc = this._lookupInternal(this._firstMajorTickGreaterThanThreshMax);
                    if ((this._majorBinLabelMode === 1 /* END */) && (this._majorDateTimeBin >= 14 /* DAY */)) {
                        value = this._adjust(this._firstMajorTickGreaterThanThreshMax);
                    }
                    else {
                        value = this._adjustUp(this.majorTickInfo[this.majorTickInfo.length - 1].value);
                    }
                    var avgNdc = (endNdc + prevNdc) / 2;
                    if (fuzzyLT(this._reverseNdc(avgNdc), 1)) {
                        var desc = new LabelDesc((this._getFormattedLabel(value, 1 /* MAJOR */)), avgNdc);
                        this._majorLabelInfo.push(desc);
                    }
                }
            }
            else {
                var value = void 0;
                for (var _c = 0, _d = this.majorTickInfo; _c < _d.length; _c++) {
                    var tickInfo = _d[_c];
                    if (!isBounded(tickInfo.ndc, 0, 1)) {
                        continue;
                    }
                    if (tickInfo.artificial) {
                        continue;
                    }
                    if ((this._majorBinLabelMode === 1 /* END */) && (this._majorDateTimeBin >= 14 /* DAY */)) {
                        value = this._adjust(tickInfo.value - 1);
                    }
                    else {
                        value = this._adjustUp(tickInfo.value);
                    }
                    var desc = new LabelDesc((this._getFormattedLabel(value, 1 /* MAJOR */)), tickInfo.ndc);
                    this._majorLabelInfo.push(desc);
                }
            }
            // the vector isn't dirty anymore, but we also need to recompute the sizes
            this._majorLabelInfoDirty = this._majorLabelSizesComputed = false;
        };
        // overrides FDSScale's version of this function.
        // computes the sizes of both major and minor label vectors
        // Logic copied from the PC function computeLabelSizes
        FDSIntradayScale.prototype.computeLabelDimensions = function (ctx) {
            if (!this.initialized) {
                return;
            }
            var formatString;
            var oldString;
            // only compute the sizes if the info has been set up and the sizes aren't already computed
            if (!this._majorLabelInfoDirty && !this._majorLabelSizesComputed) {
                // end labels
                // left end label - only do all this work if necessary
                if (this._isLeftEnd(this._forceMajorEndLabels)) {
                    if (!this._endLabelMajorLeftFormatDefault) {
                        formatString = this._endLabelMajorLeftFormat;
                    }
                    else {
                        formatString = '';
                    }
                    oldString = formatString;
                    this._setupFormatter(formatString);
                    var leftLabelValue = this.threshMin;
                    if (this._isLeftEnd(this._endLabelSnapToDatapoint)) {
                        leftLabelValue = this._startDate;
                    }
                    var labelText = this._formatString(formatString, leftLabelValue, this._majorDateTimeBin, 0 /* NONE */);
                    var ndc = this._applyReverseNdc(0);
                    if (this._isLeftEnd(this._endLabelSnapToDatapoint)) {
                        ndc = this._lookupInternal(this._startDate);
                    }
                    var alignment = void 0;
                    switch (this._endLabelMajorLeftPosition) {
                        case 0 /* INSIDE */:
                            alignment = 0 /* LEFT */;
                            break;
                        case 1 /* OUTSIDE */:
                            alignment = 1 /* RIGHT */;
                            break;
                        default:// EndLabelPosition.BETWEEN
                            alignment = 2 /* CENTER */;
                    }
                    this._leftMajorLabelDesc = new LabelDesc(labelText, ndc, alignment);
                    this._measureText(ctx, this._leftMajorLabelDesc, this.maxDimensions, this.axis.axisFont);
                }
                // right end label
                if (this._isRightEnd(this._forceMajorEndLabels)) {
                    if (!this._endLabelMajorRightFormatDefault) {
                        formatString = this._endLabelMajorRightFormat;
                    }
                    else {
                        formatString = '';
                    }
                    if (formatString !== oldString) {
                        // only re-set-up the formatter if something's changed
                        this._setupFormatter(formatString);
                    }
                    var rightLabelValue = this.threshMax;
                    if (this._isRightEnd(this._endLabelSnapToDatapoint)) {
                        rightLabelValue = this._endDate;
                    }
                    var labelText = this._formatString(formatString, rightLabelValue, this._majorDateTimeBin, 0 /* NONE */);
                    var ndc = this._applyReverseNdc(1);
                    if (this._isRightEnd(this._endLabelSnapToDatapoint)) {
                        ndc = this._lookupInternal(this._endDate);
                    }
                    var alignment = void 0;
                    switch (this._endLabelMajorRightPosition) {
                        case 0 /* INSIDE */:
                            alignment = 1 /* RIGHT */;
                            break;
                        case 1 /* OUTSIDE */:
                            alignment = 0 /* LEFT */;
                            break;
                        default:// EndLabelPosition.BETWEEN
                            alignment = 2 /* CENTER */;
                    }
                    this._rightMajorLabelDesc = new LabelDesc(labelText, ndc, alignment);
                    this._measureText(ctx, this._rightMajorLabelDesc, this.maxDimensions, this.axis.axisFont);
                }
                // rest of the labels
                for (var _i = 0, _a = this._majorLabelInfo; _i < _a.length; _i++) {
                    var desc = _a[_i];
                    this._measureText(ctx, desc, this.maxDimensions, this.axis.axisFont);
                }
                this._majorLabelSizesComputed = true;
                this.majorLabelPositionsComputed = false;
            }
            if ((!this._minorLabelInfoDirty) && (!this._minorLabelSizesComputed)) {
                // left end label
                if (!this._endLabelMinorLeftFormatDefault) {
                    formatString = this._endLabelMinorLeftFormat;
                }
                else {
                    formatString = '';
                }
                oldString = formatString;
                this._setupFormatter(formatString);
                var leftMinorLabelValue = this.threshMin;
                if (this._isLeftEnd(this._endMinorLabelSnapToDatapoint)) {
                    leftMinorLabelValue = this._startDate;
                }
                var labelText = this._formatString(formatString, leftMinorLabelValue, this._minorDateTimeBin, 0 /* NONE */);
                var ndc = this._applyReverseNdc(0);
                if (this._isLeftEnd(this._endMinorLabelSnapToDatapoint)) {
                    ndc = this._lookupInternal(this._startDate);
                }
                var alignment = void 0;
                switch (this._endLabelMinorLeftPosition) {
                    case 0 /* INSIDE */:
                        alignment = 0 /* LEFT */;
                        break;
                    case 1 /* OUTSIDE */:
                        alignment = 1 /* RIGHT */;
                        break;
                    default:// EndLabelPosition.BETWEEN
                        alignment = 2 /* CENTER */;
                }
                this._leftMinorLabelDesc = new LabelDesc(labelText, ndc, alignment);
                this._measureText(ctx, this._leftMinorLabelDesc, this.minorMaxDimensions, this.axis.axisMinorFont);
                // right end label
                if (!this._endLabelMinorRightFormatDefault) {
                    formatString = this._endLabelMinorRightFormat;
                }
                else {
                    formatString = '';
                }
                if (formatString !== oldString) {
                    this._setupFormatter(formatString);
                }
                var rightMinorLabelValue = this.threshMax;
                if (this._isRightEnd(this._endMinorLabelSnapToDatapoint)) {
                    rightMinorLabelValue = this._endDate;
                }
                labelText = this._formatString(formatString, rightMinorLabelValue, this._minorDateTimeBin, 0 /* NONE */);
                ndc = this._applyReverseNdc(1);
                if (this._isRightEnd(this._endMinorLabelSnapToDatapoint)) {
                    ndc = this._lookupInternal(this._endDate);
                }
                switch (this._endLabelMinorRightPosition) {
                    case 0 /* INSIDE */:
                        alignment = 1 /* RIGHT */;
                        break;
                    case 1 /* OUTSIDE */:
                        alignment = 0 /* LEFT */;
                        break;
                    default:// EndLabelPosition.BETWEEN
                        alignment = 2 /* CENTER */;
                }
                this._rightMinorLabelDesc = new LabelDesc(labelText, ndc, alignment);
                this._measureText(ctx, this._rightMinorLabelDesc, this.minorMaxDimensions, this.axis.axisMinorFont);
                // rest of the labels
                for (var _b = 0, _c = this._minorLabelInfo; _b < _c.length; _b++) {
                    var mls = _c[_b];
                    this._measureText(ctx, mls.left, this.minorMaxDimensions, this.axis.axisMinorFont);
                    if (this._intradayLabelingOn()) {
                        this._measureText(ctx, mls.right, this.minorMaxDimensions, this.axis.axisMinorFont);
                        this._measureText(ctx, mls.firstDatapoint, this.minorMaxDimensions, this.axis.axisMinorFont);
                        for (var _d = 0, _e = mls.rem; _d < _e.length; _d++) {
                            var label = _e[_d];
                            this._measureText(ctx, label, this.minorMaxDimensions, this.axis.axisMinorFont);
                        }
                    }
                }
                this._minorLabelSizesComputed = true;
                this.minorLabelPositionsComputed = false;
            }
        };
        // function to measure text in a label description and update a max width/height
        // @param ctx [Context] the context on which to do the measuring
        // @param desc [LabelDesc] the label descriptor containing the label info and which will store the width
        // @param maxdims [Array<Number>] the max dimension info to compare this width/height against
        FDSIntradayScale.prototype._measureText = function (ctx, desc, maxdims, font) {
            if (!desc || !desc.label) {
                return;
            }
            var _a = RichTextRenderer.measureRichText(ctx, desc.label, font), dims = _a[0], richtext = _a[1];
            desc.width = dims.width;
            desc.richtext = richtext;
            if (dims.width > maxdims.width) {
                maxdims.width = dims.width;
            }
            if (dims.height > maxdims.height) {
                maxdims.height = dims.height;
            }
        };
        // meant to be called in tandem with _formatString whenever the PC side calls formatString.
        // Sets up the formatObj to format strings according to the passed in bins
        // @param formatString [String] the string used to set the format
        // @param dateBin,timeBin [DateTimeBin] the bins used to set the datetime format
        FDSIntradayScale.prototype._setupFormatter = function (formatString) {
            if (this._parseLists[formatString] === undefined && formatString !== '') {
                var parseList = this.formatParser.parseConditionalFormat(formatString);
                this._parseLists[formatString] = parseList;
                var formats = this.formatParser.getAllFormatsFromParsedList(parseList);
                this._createLabelFormatParsers(formats);
            }
        };
        // meant to be called in tandem with _setupFormatter whenever the PC side calls formatString
        // takes in a format string and a value and returns a formatted value string
        FDSIntradayScale.prototype._formatString = function (formatString, value, dateBin, timeBin) {
            var format;
            // find the parse list for this format and step through to find the correct format for this value
            if (this._parseLists[formatString] !== undefined) {
                format = this.formatParser.applyParsedList(this._parseLists[formatString], value);
            }
            else {
                format = formatString;
            }
            // process the format for property strings
            var compiledFormatString = this.parentPropertySet.compilePropertyString(format);
            format = compiledFormatString.fromValue();
            // find the correct format object for this format string and apply it
            var formatObj = this.labelFormatters[format];
            if (formatObj === undefined) {
                formatObj = this.format;
            }
            formatObj.setDateTimeFormat(format, dateBin, timeBin, true);
            var labelString = new RichTextString(formatObj.formatAsDateTime(value));
            if (!this._compiledLabelOverride.isEmpty()) {
                var overrideReturn = this._compiledLabelOverride.fromValueRT({
                    labelValue: value,
                    formattedLabel: labelString
                });
                labelString = overrideReturn;
            }
            return labelString;
        };
        // helper function to format the string and also concat the pre/postfixes
        // uses the global formatString
        FDSIntradayScale.prototype._getFormattedLabel = function (value, level, dateBin, timeBin) {
            if (timeBin === void 0) { timeBin = 0; }
            if (level === 0 /* MINOR */) {
                if (dateBin == null) {
                    dateBin = this._minorDateTimeBin;
                }
                var label = this._formatString(this.formatString, value + this._minorDateLabelShift, dateBin, timeBin);
                return RichTextString.join(this._minorLabelPrefix, label, this._minorLabelPostfix);
            }
            else {
                if (dateBin == null) {
                    dateBin = this._majorDateTimeBin;
                }
                var label = this._formatString(this.formatString, value + this._majorDateLabelShift, dateBin, timeBin);
                return RichTextString.join(this.labelPrefix, label, this.labelPostfix);
            }
        };
        // mimics logic in PC function getSubTickVector()
        // this overrides the default FDSScale computeSubTickVector() function
        // fills in @subTicks array instead of returning it
        // note: this vector contains NDC values
        FDSIntradayScale.prototype.computeSubTickVector = function () {
            if (!this._subTickVectorDirty || !this.initialized) {
                return;
            }
            // this will return if the tickvector isn't dirty so this isn't too overworky
            this.computeTickVector();
            this._setTickRanges();
            this.subTicks = [];
            this.minorTickInfo = [];
            var dtOffset = this._getOffsetVariables(this._minorDateTimeBin, 0 /* NONE */, this._minorTickMultiplier);
            if (this._minorTickSnapToDate || this._minorDateTimeBin === 15 /* WEEK */) {
                // snap to date
                this.subTicks = this._snapSubTicksToDate(dtOffset);
            }
            else {
                // snap to intervals
                this.subTicks = this._snapSubTicksToMajorTicks(dtOffset);
            }
            var maxNumberOfTicks = this.root.chartRect.x2 - this.root.chartRect.x1;
            if (this.subTicks.length > maxNumberOfTicks && maxNumberOfTicks > 0) {
                var skipEvery = ~~(this.subTicks.length / maxNumberOfTicks);
                if (!this.axis.ticksResize) {
                    skipEvery = 1;
                }
                var newSubTicks = [];
                for (var i = 0; i < this.subTicks.length; i += skipEvery) {
                    var tick = this.subTicks[i];
                    newSubTicks.push(tick);
                }
                this.subTicks = newSubTicks;
            }
            this._subTickVectorDirty = false;
            this._minorLabelInfoDirty = true;
            this._minorLabelSizesComputed = false;
            this.minorLabelPositionsComputed = false;
        };
        FDSIntradayScale.prototype._snapSubTicksToMajorTicks = function (dtOffset) {
            var ticks = [];
            var start;
            var end;
            for (var i = 0; i < this.majorTickInfo.length; i++) {
                // align the minor ticks with each of the major ticks
                var tick = this.majorTickInfo[i];
                if (i === 0) {
                    start = this._lastMajorTickLessThanThreshMin;
                }
                else {
                    // when i is 1, go from tick 0 to tick 1, etc
                    start = this.majorTickInfo[i - 1].value;
                }
                // start = @time.addOffsetObject start, dtOffset
                end = this.majorTickInfo[i].value;
                while (fuzzyLT(this._adjustUp(start), end)) {
                    this._insertMinorTick(ticks, start);
                    start = this._time.addOffsetObject(start, dtOffset);
                }
            }
            // Add ticks that fall after the last major tick, or if there were no major ticks,
            // fill the space between ThreshMin and ThreshMax with subticks aligned with ThreshMin
            var mtiLength = this.majorTickInfo.length;
            var lastValue = (mtiLength > 0) ? this.majorTickInfo[mtiLength - 1].value : this.threshMin;
            if (fuzzyLT(lastValue, this.threshMax)) {
                start = lastValue;
                end = this.threshMax;
                while (fuzzyLT(this._adjustUp(start), end)) {
                    this._insertMinorTick(ticks, start);
                    start = this._time.addOffsetObject(start, dtOffset);
                }
            }
            return ticks;
        };
        // function to store ndc in the ticks array
        // @param ticks [Array<Number>] the array to add the tick ndc to
        // @param value [Number] the value of the tick being added
        FDSIntradayScale.prototype._insertMinorTick = function (ticks, value) {
            // avoid precision errors
            value = roundToMaxPrecision(value);
            if (!isBounded(value, this.threshMin, this.threshMax)) {
                return;
            }
            var ndc = this._lookupInternal(value);
            if (isBounded(ndc, 0, 1) && (!fuzzyEQ(ndc, ticks[ticks.length - 1]))) {
                ticks.push(ndc);
                this.minorTickInfo.push(new TickDesc(ndc, value));
            }
        };
        FDSIntradayScale.prototype._snapSubTicksToDate = function (dtOffset) {
            var _this = this;
            var newDate = this._getDateRange(this._refStart, this._minorDateTimeBin, 0)[0];
            var incrementAndAdjust = function (date, offset) {
                date = _this._time.addOffsetObject(date, offset);
                var adj = _this._adjustUp(date);
                return [date, adj];
            };
            // if minor tick is WEEK, snap the date to the start of the week
            if (this._minorDateTimeBin === 15 /* WEEK */) {
                while (~~FDSDate.getDayOfWeek(newDate) !== 1) {
                    newDate = this._time.addOffsetVariables(newDate, 0, 0, -1, 0);
                }
            }
            else {
                newDate = this._adjustUp(newDate);
            }
            var adjustedNewDate = this._adjustUp(newDate);
            // We need to truncate the time portion of the day because our time-base should be 00:00
            // and not whatever the start of day is. If we don't truncate here, you will get labels
            // like 9:34 11:34 13:34 etc instead of 9:34 10:00 12:00 14:00.
            // It also has to happen after the above adjustUp because adjustUp returns a value bounded
            // by startOfDay/endOfDay
            newDate = ~~newDate;
            this._lastMinorTickLessThanThreshMin = newDate;
            var beforeFirstInterval = true;
            var ticks = [];
            for (var _i = 0, _a = this._intervals; _i < _a.length; _i++) {
                var int = _a[_i];
                if (fuzzyGT(newDate, int.end)) {
                    // we're past the end of this interval
                    continue;
                }
                while (fuzzyLT(adjustedNewDate, int.start)) {
                    if (beforeFirstInterval) {
                        this._insertMinorTick(ticks, adjustedNewDate);
                    }
                    else {
                        this._insertMinorTick(ticks, int.start);
                    }
                    _b = incrementAndAdjust(newDate, dtOffset), newDate = _b[0], adjustedNewDate = _b[1];
                }
                // this gets set to false after we reach int.start of the first interval
                beforeFirstInterval = false;
                // OK that was all the weird edge cases. Now draw all the ticks for this interval
                while (fuzzyLTE(adjustedNewDate, int.end)) {
                    this._insertMinorTick(ticks, adjustedNewDate);
                    _c = incrementAndAdjust(newDate, dtOffset), newDate = _c[0], adjustedNewDate = _c[1];
                }
            }
            // fill in any we missed
            while (fuzzyLTE(adjustedNewDate, this.threshMax)) {
                this._insertMinorTick(ticks, adjustedNewDate);
                _d = incrementAndAdjust(newDate, dtOffset), newDate = _d[0], adjustedNewDate = _d[1];
            }
            this._firstMinorTickGreaterThanThreshMax = newDate;
            return ticks;
            var _b, _c, _d;
        };
        // mimics logic in PC function getTickVector()
        // this overrides the default FDSScale computeTickVector() function
        // fills in @ticks array instead of returning it
        // note: this vector contains NDC values
        FDSIntradayScale.prototype.computeTickVector = function () {
            if (!this._tickVectorDirty || !this.initialized) {
                return;
            }
            this._setTickRanges();
            this.majorTickInfo = [];
            this.ticks = [];
            var mult = Math.max(1, this._majorTickMultiplier);
            var _a = this._getOffsetVariables(this._majorDateTimeBin, this._time.lookupTimeBin(this.csTickDateBin), mult), years = _a.years, months = _a.months, days = _a.days, time = _a.time;
            var tickdatetime = this._refStart;
            if (this._majorTickSnapToDate) {
                tickdatetime = this._getDateRange(this._refStart, this._majorDateTimeBin, 0)[0];
            }
            // at this point tickdatetime will always be the same for a given visible scale, no matter what
            // the horizontal displacement is. so set the bgFilled HERE
            var bgFilled = false;
            // step tickdatetime backwards in dtOffset increments until it's <= @threshMin
            // loop a maximum of tickSafety times
            // flip bgFilled once for every step backwards, and it'll be 'unflipped' when we go forwards again below
            var prevN = -Infinity;
            var safety = 0;
            while (tickdatetime > this.threshMin && safety++ < this.tickSafety) {
                tickdatetime = this._time.addOffsetVariables(tickdatetime, -years, -months, -days, -time);
                var n = this._lookupInternal(tickdatetime);
                if (!fuzzyEQ(n, prevN)) {
                    bgFilled = !bgFilled;
                }
                prevN = n;
            }
            prevN = -Infinity;
            safety = 0;
            while (tickdatetime <= this.threshMax && safety < this.tickSafety) {
                var inInterval = true;
                if (this._majorDateTimeBin <= 14 /* DAY */) {
                    // figure out if the tickdatetime is on a day with an interval
                    var dayToFind = ~~tickdatetime;
                    inInterval = false;
                    for (var _i = 0, _b = this._intervals; _i < _b.length; _i++) {
                        var int = _b[_i];
                        if (~~(int.start) === dayToFind) {
                            inInterval = true;
                            break;
                        }
                    }
                }
                if (inInterval) {
                    var n = this._lookupInternal(tickdatetime);
                    if (fuzzyGTE(this._reverseNdc(n), 0) && !fuzzyEQ(n, prevN)) {
                        // if the ndc is >= 0 then we're in business. Add a tick!
                        var _c = this._getImmediateValues(tickdatetime), leftImmDate = _c[0], rightImmDate = _c[1];
                        var tickVal = Math.min(Math.max(tickdatetime, rightImmDate), this.threshMax);
                        this._addToTickInfoVector(n, tickVal, leftImmDate, rightImmDate, bgFilled);
                        safety++;
                    }
                    else if (fuzzyLT(this._reverseNdc(n), 0)) {
                        // ndc < 0, no tick. but remember this value
                        this._lastMajorTickLessThanThreshMin = tickdatetime;
                    }
                    // update the bg color whenever there's a new tick value
                    if (!fuzzyEQ(n, prevN)) {
                        bgFilled = !bgFilled;
                    }
                    prevN = n;
                }
                tickdatetime = this._time.addOffsetVariables(tickdatetime, years, months, days, time);
            }
            // this is used for binning final ticks, and can act weird when this tick is a weekend
            // move it forward by a day til it's not a weekend anymore
            tickdatetime = this._adjustUp(tickdatetime);
            this._firstMajorTickGreaterThanThreshMax = tickdatetime;
            if (!this._minorTickSnapToDate) {
                this._lastMajorTickLessThanThreshMin = this.threshMin;
            }
            if (this.majorTickInfo.length === 0) {
                // add a fake tick
                this._addToTickInfoVector(1, this.threshMax, 0, 1, bgFilled);
                this.majorTickInfo[0].artificial = true;
            }
            this._tickVectorDirty = false;
            this._majorLabelInfoDirty = true;
        };
        // Stores the tick information passed in as parameters into arrays
        // logic copied from PC function fillTicksAndMajorTicksVector
        FDSIntradayScale.prototype._addToTickInfoVector = function (ndc, value, prev, next, bgFilled) {
            if (bgFilled === void 0) { bgFilled = false; }
            var index = this.majorTickInfo.length - 1;
            // check if they're close (may not be exactly the same due to conversion errors)
            if (index >= 0 && fuzzyEQ(ndc, this.majorTickInfo[index].ndc)) {
                // overwrite the last tick
                this.majorTickInfo[index].ndc = ndc;
                this.majorTickInfo[index].value = value;
                this.majorTickInfo[index].prev = prev;
                this.majorTickInfo[index].next = next;
                this.majorTickInfo[index].bgFilled = bgFilled;
                this.ticks[index] = ndc;
            }
            else {
                this.majorTickInfo.push((new TickDesc(ndc, value, prev, next, bgFilled)));
                this.ticks.push(ndc);
            }
        };
        // wrapper function that rounds the result of the fn below, to prevent floating pt errors
        FDSIntradayScale.prototype._getImmediateValues = function (date) {
            var _a = this._getImmediateUnroundedValues(date), left = _a[0], right = _a[1];
            return [roundToMaxPrecision(left), roundToMaxPrecision(right)];
        };
        // get the dates immediately to the right and left of a given date
        // logic copied from PC function getImmediateValue
        // takes into account three cases: the date is in an interval, in between two intervals,
        // or outside the scale entirely.
        // @return [Array<Number>] the immediate dates [leftDate, rightDate]
        FDSIntradayScale.prototype._getImmediateUnroundedValues = function (date) {
            var intLen = this._intervals.length;
            if (intLen < 1) {
                return [date - SEC_FRAC, date + SEC_FRAC];
            }
            // find the first interval that ends at or after date
            var found = this._intervalLowerBound(date);
            // the date is somewhere inside the scale
            if (found) {
                var int = found[0], i = found[1];
                // it's inside an interval...
                if (date >= int.start && date <= int.end) {
                    if (date === int.end) {
                        if (i < intLen - 1) {
                            return [int.end - SEC_FRAC, this._intervals[i + 1].start];
                        }
                        else {
                            return [int.end - SEC_FRAC, int.end];
                        }
                    }
                    if (date === int.start) {
                        if (i > 0) {
                            return [this._intervals[i - 1].end - SEC_FRAC, int.start];
                        }
                        else {
                            return [int.start - SEC_FRAC, int.start];
                        }
                    }
                    return [date - SEC_FRAC, date + SEC_FRAC];
                    // it's in between intervals
                }
                else if (i > 0) {
                    return [this._intervals[i - 1].end - SEC_FRAC, int.start];
                }
                else {
                    // note: this is the case where it's before the scale start
                    return [date - SEC_FRAC, int.start];
                }
            }
            // it's not inside any of the intervals - must be after scale end
            if (date > this._intervals[intLen - 1].end) {
                return [this._intervals[intLen - 1].end, this._intervals[intLen - 1].end + SEC_FRAC];
            }
            // this should never be reached
            return [0, 0];
        };
        // helper function to return a bin one bigger than the given bin
        FDSIntradayScale.prototype._getOneBigger = function (bin) {
            switch (bin) {
                case 21 /* FIVEY */:
                    return 22 /* TENY */;
                case 20 /* TWOY */:
                    return 21 /* FIVEY */;
                case 19 /* YEAR */:
                    return 20 /* TWOY */;
                case 18 /* HALFY */:
                    return 19 /* YEAR */;
                case 17 /* QUARTER */:
                    return 18 /* HALFY */;
                case 16 /* MONTH */:
                    return 17 /* QUARTER */;
                case 15 /* WEEK */:
                    return 16 /* MONTH */;
                case 14 /* DAY */:
                    return 15 /* WEEK */;
                case 13 /* SIXHOUR */:
                    return 14 /* DAY */;
                case 12 /* TWOHOUR */:
                    return 13 /* SIXHOUR */;
                case 11 /* HOUR */:
                    return 12 /* TWOHOUR */;
                case 10 /* HALFHOUR */:
                    return 11 /* HOUR */;
                case 9 /* TENMINUTE */:
                    return 10 /* HALFHOUR */;
                case 8 /* FIVEMINUTE */:
                    return 9 /* TENMINUTE */;
                case 7 /* TWOMINUTE */:
                    return 8 /* FIVEMINUTE */;
                case 6 /* MINUTE */:
                    return 7 /* TWOMINUTE */;
                case 5 /* HALFMINUTE */:
                    return 6 /* MINUTE */;
                case 4 /* TENSECOND */:
                    return 5 /* HALFMINUTE */;
                case 3 /* FIVESECOND */:
                    return 4 /* TENSECOND */;
                case 2 /* TWOSECOND */:
                    return 3 /* FIVESECOND */;
                case 1 /* SECOND */:
                    return 2 /* TWOSECOND */;
                default:
                    return bin;
            }
        };
        // Determines the major and minor bins based on the range of the scale
        // logic copied from PC function of the same name
        // this overrides the base scale function of the same name
        FDSIntradayScale.prototype._setTickRanges = function () {
            var _this = this;
            var timeScale = 1;
            if (this._intradayScaleLengthForPartialDays) {
                timeScale = (this._endOfDay - this._startOfDay);
            }
            // Large ranges are easier to reason about in terms of total days
            // For intraday ranges, however, its better to only consider the visible range.
            var getLength = function (rangeIndex) {
                if ((rangeIndex < 14 /* DAY */) ||
                    ((rangeIndex === 14 /* DAY */) && (_this._leastVisibleInterval < 14 /* DAY */))) {
                    return _this._length(_this.threshMin, _this.threshMax) / timeScale;
                }
                else {
                    return _this.threshMax - _this.threshMin;
                }
            };
            var findLastValidBucket = function (rangeTable, index) {
                if (index < 0) {
                    // we ran out of range options so find the last one
                    index = 0; // start at 0
                    while ((index < NumberOfDateBins) && (rangeTable[index] >= Number.MAX_VALUE)) {
                        index++;
                    }
                }
                return Math.max(index, 0); // just in case
            };
            // If the units were explicitly selected by the user, use them
            // NOTE: here the PC side marks these variables as default when they are NONE. This
            // was to solve some issues with frequencies of NONE that we don't seem to have, and was
            // causing its own issues on our side. So we don't do it.
            if (!this._majorTickDateBinDefault) {
                this._majorDateTimeBin = this._time.lookupDateBin(this._majorTickDateBin);
            }
            if (!this._minorTickDateBinDefault) {
                this._minorDateTimeBin = this._time.lookupDateBin(this._minorTickDateBin);
            }
            // if they're both set by user, that's it!
            if ((!this._majorTickDateBinDefault) && (!this._minorTickDateBinDefault)) {
                return;
            }
            // ...otherwise, do some auto-calculating
            var MTM = this._majorTickMultiplier;
            // find the appropriate minor bin based on the number of days in the scale
            var minorIndex = NumberOfDateBins - 1;
            while ((getLength(minorIndex) < this._minorRangeTable[minorIndex] * MTM) && (minorIndex >= 0)) {
                minorIndex--;
            }
            // Check if we ran out of buckets and walk backward if necessary
            minorIndex = findLastValidBucket(this._minorRangeTable, minorIndex);
            if (this._ignoreLeastVisibleInterval || (this._leastVisibleInterval <= minorIndex)) {
                if (this._minorTickDateBinDefault) {
                    this._minorDateTimeBin = minorIndex;
                }
                // major bins also start at biggest bin and go down
                var index = NumberOfDateBins - 1;
                while ((getLength(index) < this._majorRangeTable[index] * MTM) && (index >= 0)) {
                    index--;
                }
                index = findLastValidBucket(this._majorRangeTable, index);
                if (this._majorTickDateBinDefault) {
                    this._majorDateTimeBin = index;
                    if (this._dsFrequency > this._majorDateTimeBin) {
                        this._majorDateTimeBin = this._time.mapToSimpleBin(this._dsFrequency);
                    }
                }
            }
            else {
                if (this._minorTickDateBinDefault) {
                    this._minorDateTimeBin = this._leastVisibleInterval;
                    // if it's the biggest, bump it down one
                    if (this._minorDateTimeBin === 22 /* TENY */) {
                        this._minorDateTimeBin = 21 /* FIVEY */;
                    }
                }
                if (this._majorTickDateBinDefault) {
                    // the major bin is one size bigger than the minor one
                    this._majorDateTimeBin = this._getOneBigger(this._minorDateTimeBin);
                }
            }
        };
        // checks if there's a gap between these two data points - if they're not in the same interval
        FDSIntradayScale.prototype.gapBetweenDatapoints = function (p1, p2) {
            var offset = this._freqOffset;
            if (p2 < p1) {
                _a = [p2, p1], p1 = _a[0], p2 = _a[1];
            }
            var sum$$1 = this._time.addOffsetObject(p1, offset);
            return fuzzyLT(sum$$1, p2);
            var _a;
        };
        // helper function to get the amount of date/time between two points on this scale
        // logic copied from PC function of the same name
        // @return [Number] total amount of date/time in the intervals between the two points
        FDSIntradayScale.prototype._length = function (start, end) {
            var total = 0;
            for (var _i = 0, _a = this._intervals; _i < _a.length; _i++) {
                var int = _a[_i];
                if (int.end <= start || int.start >= end) {
                    continue;
                }
                if (int.start < start) {
                    total += Math.min(int.end, end) - start;
                }
                else if (int.end > end) {
                    total += end - Math.max(int.start, start);
                }
                else {
                    total += int.end - int.start;
                }
            }
            return total;
        };
        // Converts from ndc space to data space
        // @param ndc [Number] point in ndc space
        // @return [Number] point in data space in datetime format
        FDSIntradayScale.prototype.computeValue = function (ndc) {
            return this._computeValueInternal(ndc, true, true);
        };
        FDSIntradayScale.prototype.computeValueUnbinned = function (ndc) {
            return this._computeValueInternal(ndc, true, false);
        };
        // internal function to handle computing values with or without scaling and binning
        FDSIntradayScale.prototype._computeValueInternal = function (ndc, applyScale, useBin) {
            var _this = this;
            if (this._intervals.length === 0) {
                return this.threshMax;
            }
            if (applyScale) {
                ndc = (ndc / this._visibleScale) + this._horizontalTranslation;
                ndc = this._reverseNdc(ndc);
            }
            var interpolate = function (_ndc) {
                _this._time.setWeekType(_this.weekType);
                _this._time.setBeginningOfDay(_this._startOfDay);
                _this._time.setEndOfDay(_this._endOfDay);
                var min$$1 = _this._time.compressUpStd(_this._intervals[0].start);
                var delta = _this._time.compressUpStd(_this._intervals[_this._intervals.length - 1].end) - min$$1;
                return _this._time.decompressStd((_ndc * delta) + min$$1);
            };
            var findInterval = function (searchNdc) {
                for (var i_1 = 0; i_1 < _this._intervals.length; i_1++) {
                    var int_1 = _this._intervals[i_1];
                    if (int_1.ndcRight > searchNdc) {
                        return [int_1, i_1];
                    }
                }
                return null;
            };
            // find the first ndc interval that ends after ndc
            var foundInterval = findInterval(ndc);
            // no interval ends after it - it is after everything
            if (foundInterval == null) {
                return interpolate(ndc);
            }
            var int = foundInterval[0], i = foundInterval[1];
            // ndc is inside this interval
            if (ndc >= int.ndcLeft) {
                var binScale = void 0;
                // this fn has an optional parameter to force the binning to either be on or off
                // this is important for minor tick labeling, which we want to have the actual value, not
                // the start of the bin, even if the scale itself is binned
                if (fuzzyEQ(int.ndcLeft, int.ndcRight)) {
                    binScale = 0;
                }
                else {
                    binScale = (ndc - int.ndcLeft) / (int.ndcRight - int.ndcLeft);
                }
                var value = int.start + (binScale * (int.end - int.start));
                if (useBin && this._axisSubType === 5 /* DATE */) {
                    return ~~value;
                }
                else {
                    return value;
                }
            }
            // between intervals
            if (ndc < int.ndcRight) {
                if (i !== 0) {
                    return this._intervals[i - 1].end;
                }
                else {
                    return interpolate(ndc);
                }
            }
            // before intervals
            return interpolate(ndc);
        };
        FDSIntradayScale.prototype._localLookup = function (value) {
            // mimicking lookupLocal from c++
            return this._lookupInternal(value + this._addOffsetDateDatasets);
        };
        FDSIntradayScale.prototype.snapToFrequency = function (value) {
            var ret = this._getDateRange(value, this._dsFrequency, this._dsTimeBin)[0];
            return ret;
        };
        FDSIntradayScale.prototype._getBinnedMinMax = function (min$$1, max$$1) {
            min$$1 = this._getDateRange(min$$1, this._dsFrequency, this._dsTimeBin)[0];
            _a = this._getDateRange(max$$1, this._dsFrequency, this._dsTimeBin), max$$1 = _a[1];
            if (this._axisSubType === 5 /* DATE */) {
                if (this._dsFrequency > 14 /* DAY */) {
                    max$$1 += 1;
                }
                max$$1 = this._adjustUp(max$$1);
            }
            else if (this._axisSubType === 8 /* DATETIME */) {
                max$$1 += SEC_FRAC;
            }
            if (this._intervals.length > 0) {
                min$$1 = Math.max(this._intervals[0].start, min$$1);
                max$$1 = Math.min(this._intervals[this._intervals.length - 1].end, max$$1);
            }
            return [min$$1, max$$1];
            var _a;
        };
        FDSIntradayScale.prototype._adjust = function (value) {
            var adjusted = this._time.adjust(value);
            if (this._axisSubType === 5 /* DATE */) {
                return ~~adjusted;
            }
            return adjusted;
        };
        FDSIntradayScale.prototype._adjustUp = function (value) {
            return this._time.adjustUp(value);
        };
        FDSIntradayScale.prototype.compressValue = function (value) {
            return this._lookupInternal(value, false);
        };
        FDSIntradayScale.prototype.decompressValue = function (value) {
            return this._computeValueInternal(value, false, false);
        };
        FDSIntradayScale.prototype.adjustTickRanges = function (hint) {
            if (hint < 1) {
                hint = 1;
            }
            this.numLabels = Math.ceil(this._numTicks / hint);
            if (this.numLabels < 1) {
                this.numLabels = 1;
            }
            if (this.numTicksHint > 0 && this.numTicksHint < hint) {
                hint = this.numTicksHint;
            }
            if (hint > 20) {
                hint = 20;
            }
            this.tickOffset = this.subTickOffset = this.delta / hint;
            this._compressedTickOffset = 1.0 / hint;
        };
        FDSIntradayScale.prototype.setWeekType = function (wt) {
            _super.prototype.setWeekType.call(this, wt);
            this._time.setWeekType(this.weekType);
            this._setRanges();
        };
        // helper functions to determine if a value is HE_LEFT/RIGHT or HE_BOTH, to avoid
        // long comparisons
        FDSIntradayScale.prototype._isLeftEnd = function (value) {
            return value === -1 /* LEFT */ || value === 0 /* BOTH */;
        };
        FDSIntradayScale.prototype._isRightEnd = function (value) {
            return value === 1 /* RIGHT */ || value === 0 /* BOTH */;
        };
        // helper function which implements the lower_bound c++ function on intervals specifically
        // returns the first interval which ends at or after the passed-in interval ends
        // @return [Array] returns [Boolean, Interval, Number]: whether the interval was found, and if so,
        // the interval found and its index (if not found it'll just return the last interval of the array)
        FDSIntradayScale.prototype._intervalLowerBound = function (date) {
            var i = 0;
            if (this._lowerBoundCache != null) {
                var int_2 = this._lowerBoundCache[0];
                if (date <= int_2.end) {
                    if (date >= int_2.start) {
                        return this._lowerBoundCache;
                    }
                }
                else {
                    i = this._lowerBoundCache[1] + 1;
                }
            }
            var int;
            var found = false;
            while (i < this._intervals.length) {
                int = this._intervals[i];
                if (int.end >= date) {
                    found = true;
                    break;
                }
                i++;
            }
            if (found) {
                return this._lowerBoundCache = [int, i];
            }
            else {
                this._lowerBoundCache = null;
                return null;
            }
        };
        // helper function to deal with text positions and reversed scales
        FDSIntradayScale.prototype._adjustedTextPosition = function (tp) {
            if (this.reverse) {
                switch (tp) {
                    case 0 /* LEFT */:
                        tp = 1 /* RIGHT */;
                        break;
                    case 1 /* RIGHT */:
                        tp = 0 /* LEFT */;
                        break;
                }
            }
            return tp;
        };
        FDSIntradayScale.prototype._intradayLabelingOn = function () {
            if (!this._intradayLabeling) {
                return false;
            }
            if (this._majorDateTimeBin === 0 /* NONE */) {
                return false;
            }
            var majorBit = 1 << (this._majorDateTimeBin - 1); // this is min 0 and max 31
            return (this._intradayLabelingMask & majorBit) !== 0;
        };
        FDSIntradayScale.selector = 'FDSIntradayScale';
        return FDSIntradayScale;
    }(FDSScale));
    // An extremely basic class for keeping track of intervals (modeled after pc side)
    var Interval = /** @class */ (function () {
        function Interval(start, end, ndcLeft, ndcRight) {
            if (ndcLeft === void 0) { ndcLeft = 0; }
            if (ndcRight === void 0) { ndcRight = 0; }
            this.start = start;
            this.end = end;
            this.ndcLeft = ndcLeft;
            this.ndcRight = ndcRight;
        }
        return Interval;
    }());
    // A class to store information about a label (modeled after pc side)
    // note: x is a value, not in ndc coords
    var LabelDesc = /** @class */ (function () {
        function LabelDesc(label, ndc, alignment, width, x) {
            if (width === void 0) { width = 0; }
            if (x === void 0) { x = 0; }
            // this is to deal with the fact that positions can be calculated multiple times
            // but we only want to adjust them once
            this.label = label;
            this.alignment = alignment;
            this.ndc = ndc;
            this.width = width;
            this.x = x;
            this.needsAdjust = true;
            this.richtext = undefined;
        }
        return LabelDesc;
    }());
    // A class to store detailed info about a tick (modeled after pc side)
    // stores the ndc coord, the next tick, and the previous one
    var TickDesc = /** @class */ (function () {
        function TickDesc(ndc, value, prev, next, bgFilled) {
            if (bgFilled === void 0) { bgFilled = false; }
            this.ndc = ndc;
            this.value = value;
            this.prev = prev;
            this.next = next;
            this.bgFilled = bgFilled;
            this.artificial = false;
        }
        return TickDesc;
    }());
    // A class for storing info about minor labels in the case of intraday labeling. (modeled after pc side)
    // stores the first datapoint, the left label, the right label, and a list of minor labels in between
    var MinorLabelStruct = /** @class */ (function () {
        function MinorLabelStruct() {
            this.firstDatapoint = undefined;
            this.left = undefined;
            this.right = undefined;
            this.rem = [];
        }
        return MinorLabelStruct;
    }());
    
    var svgDivClassPrefix = 'svgDiv';
    var hZoomSliderRegion = 'hZoomSliderRegion';
    
    var FDSSliderRegion = /** @class */ (function () {
        function FDSSliderRegion(axis) {
            this._deactivateSlider = this._deactivateSlider.bind(this);
            this._offsetEventPoint = this._offsetEventPoint.bind(this);
            this._sendSliderInfo = this._sendSliderInfo.bind(this);
            this._handleCenterPress = this._handleCenterPress.bind(this);
            this._handleLeftPress = this._handleLeftPress.bind(this);
            this._handleRightPress = this._handleRightPress.bind(this);
            this.axis = axis;
            this._root = this.axis.root;
            this.boundPlot = this.axis.parent;
            this._id = this.axis.id + "_" + hZoomSliderRegion + "_" + MakeId();
            this.constructRect(this._root.containing_element);
            this._date = new FDSDate(this.axis.weekType);
        }
        // This function either
        //    a) creates the div for the slider or
        //    b) updates it with the new color
        //
        // @param @container [DOMElement] The div that wraps all the chart stuff up
        FDSSliderRegion.prototype.constructRect = function (container) {
            this._container = container;
            if (!document.getElementById(this._id)) {
                this._rect = document.createElement('div');
                this._leftSlider = document.createElement('div');
                this._rightSlider = document.createElement('div');
                this._rect.appendChild(this._leftSlider);
                this._rect.appendChild(this._rightSlider);
                this._container.appendChild(this._rect);
                // save these divs to respond to fake clicks
                this.axis.root.interactionElements.push(this._rect);
                this.axis.root.interactionElements.push(this._leftSlider);
                this.axis.root.interactionElements.push(this._rightSlider);
                this._lBlur = document.createElement('div');
                this._rBlur = document.createElement('div');
                this._container.appendChild(this._lBlur);
                this._container.appendChild(this._rBlur);
                this._rect.style['msUserSelect'] = this._rect.style['webKitUserSelect'] = 'none'; // to prevent copy/paste
                // dialog
                this._rect.style.position = 'absolute';
                this._leftSlider.style.position = 'absolute';
                this._leftSlider.style.height = '100%';
                this._leftSlider.style.zIndex = '1';
                this._rightSlider.style.position = 'absolute';
                this._rightSlider.style.height = '100%';
                this._rightSlider.style.left = '100%';
                this._rightSlider.style.zIndex = '1';
                this._lBlur.style.position = 'absolute';
                this._lBlur.id = this._id + '_blurLeft';
                this._rBlur.style.position = 'absolute';
                this._rBlur.id = this._id + '_blurRight';
                this._hookEventHandlers();
            }
            // this stuff it is possible to be dynamic so anytime constructRect is called and we are just updating
            // we will resync with the axis/plot cached attributes, but we dont need to do the creation of the DOM
            // elements like above
            if (this._root.suppressAllInteraction) {
                this._rect.style.cursor = 'default';
                this._leftSlider.style.cursor = 'default';
                this._rightSlider.style.cursor = 'default';
            }
            else {
                this._rect.style.cursor = 'move';
                this._leftSlider.style.cursor = 'ew-resize';
                this._rightSlider.style.cursor = 'ew-resize';
            }
            this._rect.style.background = this.boundPlot.hZoomRectBrush.toCSSStyle(this._rect.getBoundingClientRect());
            this._rect.style.height = (scaleByDevicePixelRatioInverse(this.boundPlot.plotRect.y2 - this.boundPlot.plotRect.y1)).toString();
            this._rect.style.top = (this.boundPlot.plotRect.y2).toString();
            this._rect.id = this._id;
            this._rect.style.width = scaleByDevicePixelRatioInverse(this.widthPx) + 'px';
            this._rect.style.left = scaleByDevicePixelRatioInverse(this.leftPx) + 'px';
            this._leftSlider.style.width = this.axis.zoomHandleWidth + 'px';
            this._leftSlider.style.marginLeft = -this.axis.zoomHandleWidth + 'px';
            this._rightSlider.style.width = this.axis.zoomHandleWidth + 'px';
            // first try to use an image
            var usedImage = this._fillWithImage();
            if (!usedImage) {
                this._leftSlider.style.background
                    = this.boundPlot.hZoomHandleBrush.toCSSStyle(this._leftSlider.getBoundingClientRect());
                this._rightSlider.style.background
                    = this.boundPlot.hZoomHandleBrush.toCSSStyle(this._rightSlider.getBoundingClientRect());
            }
            this._lBlur.style.left = scaleByDevicePixelRatioInverse(this.boundPlot.plotRect.x1) + 'px';
            this._lBlur.style.width = scaleByDevicePixelRatioInverse(this.leftPx - this.boundPlot.plotRect.x1) + 'px';
            this._lBlur.style.background = this.boundPlot.hZoomFadeBrush.toCSSStyle(this._lBlur.getBoundingClientRect());
            this._lBlur.style.top = this.boundPlot.plotRect.y1 + 'px';
            this._lBlur.style.height = scaleByDevicePixelRatioInverse(this.boundPlot.plotRect.getHeight()) + 'px';
            this._rBlur.style.left = scaleByDevicePixelRatioInverse(this.rightPx) + 'px';
            this._rBlur.style.width = scaleByDevicePixelRatioInverse(this.boundPlot.plotRect.x2 - this.rightPx) + 'px';
            this._rBlur.style.background = this.boundPlot.hZoomFadeBrush.toCSSStyle(this._rBlur.getBoundingClientRect());
            this._rBlur.style.top = this.boundPlot.plotRect.y1 + 'px';
            this._rBlur.style.height = scaleByDevicePixelRatioInverse(this.boundPlot.plotRect.getHeight()) + 'px';
            if (!this.axis.fadeNonZoomedRegion) {
                this._rBlur.style.visibility = 'hidden';
                this._lBlur.style.visibility = 'hidden';
            }
            else {
                this._rBlur.style.visibility = 'visible';
                this._lBlur.style.visibility = 'visible';
            }
        };
        // helper function to fill an area with an image, returning false if anything goes wrong
        FDSSliderRegion.prototype._fillWithImage = function () {
            if (this.boundPlot.hZoomHandleBrush.imageDSName === '') {
                return false;
            }
            var imageDS = this.axis.root.getObject(this.boundPlot.hZoomHandleBrush.imageDSName);
            if (!imageDS || !(isDataSet(imageDS))) {
                return false;
            }
            var imageType = imageDS.attributeSet.get('ImageType');
            var imageString = "data:image/" + imageType + ";base64," + imageDS.getAt(0);
            this._leftSlider.style.background = "$rl(\"" + imageString + "\") 0px 0px / 100% 100%";
            this._rightSlider.style.background = "$rl(\"" + imageString + "\") 0px 0px / 100% 100%";
            // flip the right one so they are mirror of each other
            this._rightSlider.style.transform = 'scaleX(-1)';
            this._rightSlider.style['-webkit-transform'] = 'scaleX(-1)';
            this._leftSlider.style.opacity = (this.boundPlot.hZoomHandleBrush.alpha / 255).toString();
            this._rightSlider.style.opacity = (this.boundPlot.hZoomHandleBrush.alpha / 255).toString();
            return true;
        };
        FDSSliderRegion.prototype.initialize = function (left, right) {
            var scale = this.axis.scale;
            this._centerPos = (scale.compressValue(left) + scale.compressValue(right)) / 2.0;
            this._dataWidth = scale.compressValue(right) - scale.compressValue(left);
            _a = this._clampSlidersToBoundary(left, right), left = _a[0], right = _a[1];
            this.updateSliders(left, right);
            var _a;
        };
        // This will clamp the slides to the edges of the plot rectangle
        //
        // @param startVal [Number] Starting position of the proposed zoom level
        // @param endVal [Number] ending position of the proposed zoom level
        // @return [startVal, endVal] new clamped starting and end points
        FDSSliderRegion.prototype._clampSlidersToBoundary = function (dValue1, dValue2, preserveWidth) {
            if (preserveWidth === void 0) { preserveWidth = true; }
            var startVal;
            var endVal;
            var scale = this.axis.getScale();
            if (scale) {
                startVal = Math.min(dValue1, dValue2);
                endVal = Math.max(dValue1, dValue2);
                var _dataWidth = this._dataWidth;
                if (dValue1 > dValue2) {
                    _dataWidth *= -1;
                }
                if (scale.bin) {
                    // check to see if the box is too far to the left and shift back into bounds preserving width if desired
                    if (fuzzyLTE(startVal, scale.snapToFrequency(scale.threshMin))) {
                        startVal = scale.snapToFrequency(scale.threshMin);
                        if (preserveWidth) {
                            endVal = scale.snapToFrequency(scale.decompressValue(scale.compressValue(startVal) + _dataWidth));
                        }
                    }
                    var offset = scale.getBinDataWidthFromPoint(scale.threshMax);
                    // check to see if the box is too far to the right and shift back into bounds preserving width if desired
                    if (fuzzyGTE(endVal, scale.threshMax - offset)) {
                        endVal = scale.snapToFrequency(scale.threshMax - offset);
                        if (preserveWidth) {
                            startVal = scale.snapToFrequency(scale.decompressValue(scale.compressValue(endVal) - _dataWidth));
                            // do a clamp on startval in case @dataWidth is just too big to fit
                            if (startVal < scale.snapToFrequency(scale.threshMin)) {
                                startVal = scale.snapToFrequency(scale.threshMin);
                            }
                        }
                    }
                }
                else {
                    // check to see if the box is too far to the left and shift back into bounds preserving width if desired
                    if (fuzzyLTE(startVal, scale.threshMin)) {
                        startVal = scale.threshMin;
                        if (preserveWidth) {
                            endVal = scale.decompressValue(scale.compressValue(startVal) + _dataWidth);
                        }
                    }
                    // check to see if the box is too far to the right and shift back into bounds preserving width if desired
                    if (fuzzyGTE(endVal, scale.threshMax)) {
                        endVal = scale.threshMax;
                        if (preserveWidth) {
                            startVal = scale.decompressValue(scale.compressValue(endVal) - _dataWidth);
                            // do a clamp on startval in case @dataWidth is too big to fit
                            if (startVal < scale.threshMin) {
                                startVal = scale.threshMin;
                            }
                        }
                    }
                }
            }
            return [startVal, endVal];
        };
        // Sets the internal left and right data values of the slider as well as the pixel values
        //
        // @param left [Number] new starting point
        // @param right [Number] new ending point
        FDSSliderRegion.prototype.updateSliders = function (left, right) {
            // Since these div elements are being drawn over the chart and not on the chart canvas, we need to scale them
            // here.
            var minSizeManager = this.boundPlot.root.minimumSizeManager;
            var divTop = scaleByDevicePixelRatioInverse(minSizeManager.scaleHeight(this.boundPlot.plotRect.y1)) + 'px';
            var divHeight = scaleByDevicePixelRatioInverse(minSizeManager.scaleHeight(this.boundPlot.plotRect.getHeight())) + 'px';
            this._rect.style.top = divTop;
            this._rect.style.height = divHeight;
            this._lBlur.style.top = divTop;
            this._lBlur.style.height = divHeight;
            this._rBlur.style.top = divTop;
            this._rBlur.style.height = divHeight;
            // left must be set first because you cannot set left and right position of a div :(
            this._moveToWorldValue(0 /* LEFT */, left);
            this._moveToWorldValue(1 /* RIGHT */, right);
            // notify the axis of these new zoomed thresholds
            this._updateZoomRegion(this.leftPt, this.rightPt);
        };
        // This will move the actual div to the proper position.
        //
        // @param side [SliderRegionSide] which side we are on, `enum-ed` for readability
        // @param pos [Number] the actual position we are moving that side to.
        FDSSliderRegion.prototype._moveToWorldValue = function (side, pos) {
            var leftNDC;
            var rightNDC;
            // The divs being modified here are drawn above the chart and not on the canvas, so we need to do scaling here.
            var minSizeManager = this.boundPlot.root.minimumSizeManager;
            switch (side) {
                case 0 /* LEFT */:
                    this.leftPt = pos;
                    if (this.axis.scale.bin) {
                        _a = this.axis.scale.lookupRange(pos), leftNDC = _a[1];
                    }
                    else {
                        leftNDC = this.axis.scale.lookup(pos);
                    }
                    this.leftPx = ~~(this.boundPlot.plotFromNDC(leftNDC, 1 /* X */));
                    this._rect.style.left = scaleByDevicePixelRatioInverse(minSizeManager.scaleWidth(this.leftPx)) + 'px';
                    if (this.axis.fadeNonZoomedRegion) {
                        this._lBlur.style.left = scaleByDevicePixelRatioInverse(minSizeManager.scaleWidth(this.boundPlot.plotRect.x1)) + 'px';
                        this._lBlur.style.width = scaleByDevicePixelRatioInverse(this.leftPx - this.boundPlot.plotRect.x1) + 'px';
                    }
                case 1 /* RIGHT */:
                    this.rightPt = pos;
                    if (this.axis.scale.bin) {
                        _b = this.axis.scale.lookupRange(pos), rightNDC = _b[2];
                    }
                    else {
                        rightNDC = this.axis.scale.lookup(pos);
                    }
                    this.rightPx = ~~(this.boundPlot.plotFromNDC(rightNDC, 1 /* X */));
                    this.widthPx = this.rightPx - this.leftPx;
                    this._rect.style.width = scaleByDevicePixelRatioInverse(minSizeManager.scaleWidth(this.widthPx)) + 'px';
                    if (this.axis.fadeNonZoomedRegion) {
                        this._rBlur.style.left = scaleByDevicePixelRatioInverse(minSizeManager.scaleWidth(this.rightPx)) + 'px';
                        this._rBlur.style.width = scaleByDevicePixelRatioInverse(minSizeManager.scaleWidth(this.boundPlot.plotRect.x2 - this.rightPx)) + 'px';
                    }
            }
            var _a, _b;
        };
        // Notifies the axis that its slider was updated.
        //
        // @param start [Number] updated starting point
        // @param end [Number] updated ending point
        FDSSliderRegion.prototype._updateZoomRegion = function (start, end) {
            this.axis.updateFromSlider(start, end);
        };
        // if the object is no longer existant, this should be called to clean up the
        // div it created
        FDSSliderRegion.prototype.cleanUp = function () {
            if (this._container != null) {
                if (this._rect) {
                    this._container.removeChild(this._rect);
                }
                if (this._lBlur) {
                    this._container.removeChild(this._lBlur);
                }
                if (this._rBlur) {
                    this._container.removeChild(this._rBlur);
                }
            }
        };
        // Creates the event handlers for the <div> tags that are on each component
        // of the slider
        FDSSliderRegion.prototype._hookEventHandlers = function () {
            this._rect.addEventListener('mousedown', this._handleCenterPress);
            this._rect.addEventListener('touchstart', this._handleCenterPress);
            this._leftSlider.addEventListener('mousedown', this._handleLeftPress);
            this._leftSlider.addEventListener('touchstart', this._handleLeftPress);
            this._rightSlider.addEventListener('mousedown', this._handleRightPress);
            this._rightSlider.addEventListener('touchstart', this._handleRightPress);
            this._rect.addEventListener('mouseup', this._deactivateSlider);
            this._rect.addEventListener('touchend', this._deactivateSlider);
        };
        // Used to handle multiple touches on a slider
        FDSSliderRegion.prototype._deactivateSlider = function (event) {
            this.active = false;
        };
        // this may or may not be necessary with the changes, and will likely need to be changed at some
        // point since we are using clientRect to get the edges of the canvas, but for now it works.
        //
        // @param event [PointerEvent] the event we are going to offset to get it's coordinates in chart-space
        FDSSliderRegion.prototype._offsetEventPoint = function (event) {
            var clientRect = this._root.containing_element.getBoundingClientRect();
            var chartOffsetY;
            var chartOffsetX;
            var isTouchAvailable = typeof TouchEvent !== 'undefined' && TouchEvent != null;
            if (isTouchAvailable && event instanceof TouchEvent && event.touches.length === 1) {
                var touch = event.touches[0];
                chartOffsetY = scaleByDevicePixelRatio(touch.clientY - clientRect.top);
                chartOffsetX = scaleByDevicePixelRatio(touch.clientX - clientRect.left);
            }
            else if (event instanceof MouseEvent) {
                chartOffsetY = scaleByDevicePixelRatio(event.clientY - clientRect.top);
                chartOffsetX = scaleByDevicePixelRatio(event.clientX - clientRect.left);
            }
            return [chartOffsetX, chartOffsetY];
        };
        // This tells the chart that we are the currently active slider and what
        // action we are performing
        //
        // @param event [PointerEvent] the actual pointer event. Probably bad practice...
        // @param action [ZoomSliderAction] Whether we are panning, or resizing left/right
        FDSSliderRegion.prototype._sendSliderInfo = function (event, action) {
            var _a = this._offsetEventPoint(event), chartOffsetX = _a[0], chartOffsetY = _a[1];
            var sliderOffsetPt = {
                x: (chartOffsetX - scaleByDevicePixelRatio(this._rect.offsetLeft)),
                y: (chartOffsetY - scaleByDevicePixelRatio(this._rect.offsetTop))
            };
            this._root.setActiveSlider(this, sliderOffsetPt);
            this.action = action;
        };
        FDSSliderRegion.prototype._handleCenterPress = function (event) {
            // the left/right divs are children, so the event will bubble up here
            // which isnt something we really want, so check to see if this was
            // where the event was dispatched from
            if (event.target === this._rect && this.active !== true) {
                this.active = true;
                this._sendSliderInfo(event, 0 /* PAN */);
            }
        };
        FDSSliderRegion.prototype._handleLeftPress = function (event) {
            if (this.active !== true) {
                this.active = true;
                this._sendSliderInfo(event, 1 /* LMOVE */);
            }
        };
        FDSSliderRegion.prototype._handleRightPress = function (event) {
            if (this.active !== true) {
                this.active = true;
                this._sendSliderInfo(event, 2 /* RMOVE */);
            }
        };
        // To offset the center slider so that the slider doesn't always snap
        // the left edge of the slider to the pointer
        //
        // @param point [Point] point of the click on the slider
        FDSSliderRegion.prototype.setDragOffset = function (point) {
            this._dragOffset = { x: point.x, y: point.y };
        };
        // Helper function to convert the pixel value to ndc space
        //
        // @param pt [Number] The pixel value currently of the x-axis point we are converting to ndc
        FDSSliderRegion.prototype._toPlotNDC = function (pt) {
            return (pt - this.boundPlot.plotRect.x1) / this.boundPlot.plotRect.getWidth();
        };
        // This is for the resizing of the slider.
        //
        // @param point [Point] the pointer's location that we are resizing to
        FDSSliderRegion.prototype.resize = function (point) {
            var scale = this.axis.scale;
            var startVal = this.leftPt;
            var endVal = this.rightPt;
            switch (this.action) {
                case 2 /* RMOVE */:
                    endVal = scale.computeValue(this._toPlotNDC(point.x));
                    break;
                case 1 /* LMOVE */:
                    startVal = scale.computeValue(this._toPlotNDC(point.x));
                    break;
            }
            if (scale.bin) {
                startVal = scale.snapToFrequency(startVal);
                endVal = scale.snapToFrequency(endVal);
            }
            _a = this._clampSlidersToBoundary(startVal, endVal, false), startVal = _a[0], endVal = _a[1];
            this._centerPos = (scale.compressValue(startVal) + scale.compressValue(endVal)) / 2;
            this._dataWidth = scale.compressValue(endVal) - scale.compressValue(startVal);
            this.updateSliders(startVal, endVal);
            var _a;
        };
        // This handles the dragging of the center region, so both the left and right
        // edges of the slider are being moved
        //
        // @param point [Number] the point we are moving to, this gets offset by the dragOffset
        FDSSliderRegion.prototype.moveTo = function (point) {
            // we will check to make sure the point we are moving to is inside
            // the plot rect and update it if it is.
            var scale = this.axis.scale;
            var centerPos = scale.computeValue(this._toPlotNDC(point.x - (this._dragOffset.x - this.widthPx / 2)));
            this._centerPos = scale.compressValue(centerPos);
            var startVal = scale.decompressValue(this._centerPos - this._dataWidth / 2);
            var endVal = scale.decompressValue(this._centerPos + this._dataWidth / 2);
            var _a = this._clampSlidersToBoundary(startVal, endVal), leftPt = _a[0], rightPt = _a[1];
            this.updateSliders(leftPt, rightPt);
        };
        return FDSSliderRegion;
    }());
    
    var FDSTimeScale = /** @class */ (function (_super) {
        __extends(FDSTimeScale, _super);
        function FDSTimeScale(root, id, axis) {
            var _this = _super.call(this, root, id, axis) || this;
            _this._date = new FDSDate();
            _this._compressedThreshMin = 0.0;
            _this._compressedThreshMax = 0.0;
            _this._timeBin = 0;
            _this._dateMin = 0;
            _this._nDays = 1;
            _this._activeDate = 0;
            _this._tickDay = 0;
            _this._dateTick = 0;
            _this._dateLabel = 0;
            _this._timeLabel = 0;
            _this._tickTimeBin = 0;
            _this._numTicks = 0;
            _this.bin = true;
            _this.setTickBinned(true);
            _this.scaleType = 7 /* TIME */;
            _this.numTicksHint = 1;
            return _this;
        }
        FDSTimeScale.prototype.getLog = function () {
            return false;
        };
        FDSTimeScale.prototype.supportLog = function () {
            return false;
        };
        // copied from PC side
        // only valid for one day, e.g 00:00:00 to 23:59:59
        FDSTimeScale.prototype.getScaleMin = function () {
            return 0;
        };
        FDSTimeScale.prototype.getScaleMax = function () {
            return 235959;
        };
        FDSTimeScale.prototype._applyMargins = function (min$$1, max$$1) {
            return [min$$1, max$$1];
        };
        FDSTimeScale.prototype._computeNiceRanges = function (min$$1, max$$1) {
            return [min$$1, max$$1];
        };
        FDSTimeScale.prototype._initTickVector = function () {
            this._tick = this._tickDay = 0;
            this._timeLabel = ~~this.tickMin;
            this.ticks = [];
            this._dateTick = this.tickMin;
        };
        FDSTimeScale.prototype._getNextTick = function () {
            var f;
            var bin;
            if (this._nDays > 1) {
                bin = 1.0 / this._nDays;
                f = this._tickDay * bin;
                this._tickDay++;
                if (this._tickDay > this._nDays + 1) {
                    return null;
                }
                else {
                    return f;
                }
            }
            else {
                var tickBinned = this.getTickBinned();
                var threshMax = ~~this.threshMax;
                if (this._dateTick <= this.threshMax) {
                    var max$$1 = void 0;
                    var min$$1 = void 0;
                    _a = this.lookupRange(this._dateTick, this._tickTimeBin), f = _a[0], bin = _a[1];
                    _b = this._date.getTimeBinRange(this._dateTick, this._tickTimeBin), min$$1 = _b[1], max$$1 = _b[2];
                    if (this.getBinned() && !tickBinned && this._date.adjustTime(max$$1, 1) === threshMax) {
                        max$$1 = this._date.adjustTime(max$$1, 1);
                    }
                    this._dateTick = this._date.adjustTime(max$$1, 1);
                    if (tickBinned) {
                        f = bin;
                    }
                    if (!isBounded(f, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                        return null;
                    }
                    else {
                        return f;
                    }
                }
            }
            return null;
            var _a, _b;
        };
        FDSTimeScale.prototype._initLabelVector = function () {
            this._tick = this._tickDay = 0;
            this._timeLabel = ~~this.tickMin;
            var formatString = (this.parentPropertySet.compilePropertyString(this.formatString)).fromValue();
            this.format.setTimeFormat(formatString, this._tickTimeBin);
            this.labelFormatters[formatString] = this.format;
            this.labels = [];
            this._dateLabel = this.tickMin;
            if (this.formatString !== this.oldFormat) {
                this.oldFormat = this.formatString;
                this.parseList = this.formatParser.parseConditionalFormat(this.formatString);
                var formats = this.formatParser.getAllFormatsFromParsedList(this.parseList);
                this._createLabelFormatParsers(formats);
            }
        };
        FDSTimeScale.prototype._getNextLabel = function (plain) {
            var bin;
            var f = 0;
            var label = RichTextString.Empty;
            if (this._nDays > 1) {
                bin = 1.0 / this._nDays;
                f = this._tickDay * bin;
                label = this._formatLabel(this._tickDay);
                this._tickDay++;
                if (this._tickDay > this._nDays + 1) {
                    return null;
                }
                else {
                    if (!this._compiledLabelOverride.isEmpty()) {
                        label = this._compiledLabelOverride.fromValueRT({ labelValue: this._tickDay, formattedLabel: label });
                    }
                    return [label, f, undefined];
                }
            }
            else {
                var threshMax = ~~this.threshMax;
                if (this._dateLabel <= this.threshMax) {
                    for (var i = 0; i < this.numLabels; i++) {
                        var _a = this._date.getTimeBinRange(this._dateLabel, this._tickTimeBin), min$$1 = _a[1], max$$1 = _a[2];
                        if (i === 0) {
                            _b = this.lookupRange(this._dateLabel, this._tickTimeBin), f = _b[0], bin = _b[1];
                            label = this._formatLabel(this._dateLabel);
                        }
                        this._dateLabel = this._date.adjustTime(max$$1, 1);
                        if (this._dateLabel >= 240000) {
                            break;
                        }
                    }
                    if (!isBounded(f, this.getMinPlotFactor(), this.getMaxPlotFactor())) {
                        return null;
                    }
                    else {
                        if (!this._compiledLabelOverride.isEmpty()) {
                            var overrideReturn = this._compiledLabelOverride.fromValueRT({
                                labelValue: this._dateLabel,
                                formattedLabel: label
                            });
                            label = overrideReturn;
                        }
                        return [RichTextString.join(this.labelPrefix, label, this.labelPostfix), f, undefined];
                    }
                }
            }
            return null;
            var _b;
        };
        FDSTimeScale.prototype._getNextSubTick = function () {
            return null;
        };
        FDSTimeScale.prototype._formatLabel = function (value) {
            var format = this.formatString;
            // conditional formatted label, needs to be dealt with on a case-by-case basis
            if ((this.parseList != null) && this.parseList.length > 0) {
                format = this.formatParser.applyParsedList(this.parseList, value);
            }
            // Process `LabelFormat` for property strings
            if (!this.isLabelFormatDefault) {
                this.compiledFormatString = this.parentPropertySet.compilePropertyString(format);
                format = this.compiledFormatString.fromValue();
            }
            var formatter = this.labelFormatters[format];
            if (formatter != null) {
                return new RichTextString(formatter.formatAsTime(value));
            }
            return RichTextString.Empty;
        };
        FDSTimeScale.prototype._setRanges = function (usermin, usermax) {
            if (usermin === void 0) { usermin = Number.NaN; }
            if (usermax === void 0) { usermax = Number.NaN; }
            var tempmin = !isNaN(usermin) ? usermin : this.min;
            var tempmax = !isNaN(usermax) ? usermax : this.max;
            this.outlierMax = tempmax;
            this.outlierMin = tempmin;
            _a = this._threshConsider(tempmin, tempmax), tempmin = _a[0], tempmax = _a[1];
            var _b = this._date.getTimeBinRange(tempmin, this._timeBin), min$$1 = _b[1];
            var _c = this._date.getTimeBinRange(tempmax, this._timeBin), max$$1 = _c[2];
            // calc threshmax stuff here
            var threshMin = min$$1;
            var threshMax = this._date.adjustTime(max$$1, 1);
            if (!this.axis.attributeSet.isDefault('ThreshMin')) {
                threshMin = this.axis.attributeSet.get('ThreshMin');
            }
            if (!this.axis.attributeSet.isDefault('ThreshMax')) {
                threshMax = this.axis.attributeSet.get('ThreshMax');
            }
            this._setThreshold(threshMin, threshMax, true);
            var _a;
        };
        FDSTimeScale.prototype.setFixedMode = function (threshMin, threshMax, hint) {
            return true;
        };
        FDSTimeScale.prototype.setWeekType = function (weekType) {
            _super.prototype.setWeekType.call(this, weekType);
            this._date.setWeekType(weekType);
        };
        FDSTimeScale.prototype.computeValue = function (ndc) {
            if (this._nDays > 1) {
                var bin = 1.0 / this._nDays;
                ndc = clamp(ndc, 0.0, 1.0);
                for (var i = 0; i < this._nDays; i++) {
                    if (ndc < bin * i) {
                        ndc = (ndc - bin * (i - 1)) / bin;
                    }
                }
            }
            var delta = this._compressedThreshMax - this._compressedThreshMin;
            if (this.reverse) {
                return this._date.getPackedTimeSeconds(~~((1.0 - ndc) * delta + this._compressedThreshMin + 0.5));
            }
            else {
                return this._date.getPackedTimeSeconds(~~(ndc * delta + this._compressedThreshMin + 0.5));
            }
        };
        FDSTimeScale.prototype._localLookup = function (value) {
            var delta = this._compressedThreshMax - this._compressedThreshMin;
            var ret = 0.0;
            value = this._date.compressIntraDay(value);
            if (delta === 0.0) {
                delta = 1.0;
            }
            if (this.reverse) {
                ret = 1.0 - ((value - this._compressedThreshMin) / delta);
            }
            else {
                ret = (value - this._compressedThreshMin) / delta;
            }
            if (this._nDays > 1) {
                ret = clamp(ret, 0.0, 1.0);
                var bin = 1.0 / this._nDays;
                ret = (this._date.compress(this._activeDate)) - (this._date.compress(this._dateMin)) * bin + ret * bin;
            }
            return this.applyPlotFactorNDC(ret);
        };
        // returns [lookup_value, low, high, offset]
        FDSTimeScale.prototype.lookupRange = function (val, timeBin) {
            if (timeBin === void 0) { timeBin = this._timeBin; }
            var _a = this._date.getTimeBinRange((~~val), timeBin), bin = _a[0], lowdate = _a[1], highdate = _a[2];
            var adjusted_highdate = this._date.adjustTime(highdate, 1);
            var low = this._localLookup(lowdate);
            var high = this._localLookup(adjusted_highdate);
            if (high < low) {
                _b = [high, low], low = _b[0], high = _b[1];
            }
            var offset = ((high - low) * (1.0 - this.getBinFactor())) / 2.0;
            return [(this.getBinned() ? (low + high) / 2.0 : low), low, high, offset];
            var _b;
        };
        FDSTimeScale.prototype.lookup = function (value) {
            var ret;
            if (this.getBinned()) {
                _a = this.lookupRange(value), ret = _a[0];
            }
            else {
                ret = this._localLookup((~~value));
            }
            return ret;
            var _a;
        };
        FDSTimeScale.prototype.snapToFrequency = function (val) {
            var _a = this._date.getTimeBinRange(val, this._timeBin), bin = _a[0], start = _a[1], end = _a[2];
            return start;
        };
        FDSTimeScale.prototype._setNumber = function (min$$1, max$$1) {
            this.number = (this._date.nTimeBins(this._timeBin, min$$1, max$$1)) + 1;
            this.setBinSize(min$$1, max$$1);
        };
        FDSTimeScale.prototype._setThreshold = function (min$$1, max$$1, ticks) {
            min$$1 = ISNAN(min$$1) ? this.threshMin : min$$1;
            max$$1 = ISNAN(max$$1) ? this.threshMax : max$$1;
            min$$1 = this._date.filterTime((~~min$$1));
            max$$1 = this._date.filterTime((~~max$$1));
            _super.prototype._setThreshold.call(this, min$$1, max$$1, ticks);
            this._setNumber((~~min$$1), (~~max$$1));
            this._compressedThreshMin = this._date.compressIntraDay((~~this.threshMin));
            this._compressedThreshMax = this._date.compressIntraDay((~~this.threshMax));
        };
        FDSTimeScale.prototype.adjust = function (dataset) {
            this._nDays = 1;
            return _super.prototype.adjust.call(this, dataset);
        };
        FDSTimeScale.prototype.reset = function () {
            this.initSettings();
            this.setWeekType(0 /* FIVE_DAY */);
            this.setBinned(true);
            this.setTickBinned(true);
        };
        FDSTimeScale.prototype.initialize = function (dataset) {
            this._nDays = 1;
            return _super.prototype.initialize.call(this, dataset);
        };
        FDSTimeScale.prototype._setTickRanges = function (hint) {
            var min$$1 = ~~this.threshMin;
            var max$$1 = ~~this.threshMax;
            var dateBin = this._date.lookupDateBin(this.csTickDateBin);
            if (dateBin !== 0 /* NONE */) {
                this._tickTimeBin = this._date.lookupDateBin(this.csTickDateBin);
            }
            else {
                var numTicks = this._date.nTimeBins(0, min$$1, max$$1);
                if (numTicks > 18000) {
                    this._tickTimeBin = 10000; // 5H
                }
                else if (numTicks > 7200) {
                    this._tickTimeBin = 3000; // 2H
                }
                else if (numTicks > 3600) {
                    this._tickTimeBin = 1000; // 1H
                }
                else if (numTicks > 1800) {
                    this._tickTimeBin = 500; // 30m
                }
                else if (numTicks > 600) {
                    this._tickTimeBin = 200; // 10m
                }
                else if (numTicks > 300) {
                    this._tickTimeBin = 100; // 5m
                }
                else if (numTicks > 180) {
                    this._tickTimeBin = 30; // 2m
                }
                else if (numTicks > 60) {
                    this._tickTimeBin = 10; // 1m
                }
                else if (numTicks > 20) {
                    this._tickTimeBin = 5; // 20s
                }
                else if (numTicks > 10) {
                    this._tickTimeBin = 2; // 10s
                }
                else {
                    this._tickTimeBin = 0;
                }
            }
            this._numTicks = this._date.nTimeBins(this._tickTimeBin, min$$1, max$$1);
            // if @tickMode is FC_TICKMODE_HIGHLOW
            //    rangeMin = min
            var _a = this._date.getTimeBinRange(min$$1, this._tickTimeBin), bin = _a[0], rangeMin = _a[1], rangeMax = _a[2];
            if (rangeMin < min$$1) {
                this.tickMin = this._date.adjustTime(rangeMax, 1);
            }
            else {
                this.tickMin = rangeMin;
            }
            this.adjustTickRanges(hint);
        };
        FDSTimeScale.prototype.adjustTickRanges = function (hint) {
            if (hint < 1) {
                hint = 1;
            }
            if ((this.numLabels = Math.ceil(this._numTicks / hint)) < 1) {
                this.numLabels = 1;
            }
            if (this.numTicksHint > 0 && this.numTicksHint < hint) {
                hint = this.numTicksHint;
            }
            if (hint > 20) {
                hint = 20;
            }
            var max$$1 = ~~this.threshMax;
            var min$$1 = ~~this.threshMin;
            var delta = this._date.nSeconds(min$$1, max$$1);
            this.tickOffset = this.subTickOffset = delta / hint;
        };
        // Outliers do not work on this scale
        FDSTimeScale.prototype.upperOutlierActive = function () {
            return false;
        };
        FDSTimeScale.prototype.lowerOutlierActive = function () {
            return false;
        };
        FDSTimeScale.prototype.computeLabelVector = function () {
            this._initLabelVector();
            if (this.padLabels) {
                this._computeLabelVectorInternal(true);
                this.padLength = this._getPadLength();
                this.labels = [];
                this._label = 0;
            }
            this._computeLabelVectorInternal(false);
        };
        FDSTimeScale.prototype._computeLabelVectorInternal = function (plain) {
            if (plain === void 0) { plain = false; }
            var safety = 0;
            var label;
            while ((label = this._getNextLabel(plain)) && safety++ < this.tickSafety) {
                this.labels.push(label);
            }
        };
        FDSTimeScale.prototype.getLabelFormatter = function (formatString) {
            var formatter = new FDSFormat();
            formatter.setTimeFormat(formatString);
            return formatter;
        };
        FDSTimeScale.prototype.compressValue = function (value) {
            var time = new FDSTime();
            var compValue = time.convToTimeStd(value);
            return time.getSecondsFromTimeStd(compValue);
        };
        FDSTimeScale.prototype.decompressValue = function (value) {
            var time = new FDSTime();
            return time.getPackedTimeSeconds(value);
        };
        return FDSTimeScale;
    }(FDSScale));
    
    var LineDrawStyle = /** @class */ (function (_super) {
        __extends(LineDrawStyle, _super);
        function LineDrawStyle(series) {
            return _super.call(this, series) || this;
        }
        // helper function to break line (on NA or on gap)
        LineDrawStyle.prototype._startNewLine = function (ctx, pen) {
            pen.closePolyline();
            ctx.stroke();
            ctx.beginPath();
        };
        LineDrawStyle.prototype._buildLineData = function (plot, seriesColor) {
            var prevItem;
            var breakOnNA = this.series.attributeSet.get('BreakOnNA');
            var colorData = this.series.getData(4 /* COLOR */);
            var points = [];
            for (var j = this._start; j < this._end; j += this._step) {
                var i = this.series.getSampleIndex(j);
                var dataItem = this._xData.getAt(i);
                var yDataItem = this._yData.getAt(i);
                if (dataItem == null || yDataItem == null || isNaN(yDataItem)) {
                    if (breakOnNA) {
                        points.push(null);
                    }
                    continue;
                }
                var dpGap = this.series.breakOnGap && (prevItem != null) &&
                    this._xScale.gapBetweenDatapoints(prevItem, dataItem);
                prevItem = dataItem;
                if (dpGap) {
                    points.push(null);
                }
                var x = ~~(plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */));
                var y = ~~(plot.subPlotFromNDC(this._yScale.lookup(yDataItem, this._yBin), 2 /* Y */));
                var color = this._calcColorMapColor(seriesColor, colorData.getAt(i), i);
                points.push({ index: i, x: x, y: y, color: color });
            }
            return points;
        };
        LineDrawStyle.prototype._createLineHitShapes = function (lastPt, pt) {
            var midX = lastPt.x + ((pt.x - lastPt.x) / 2);
            var midY = lastPt.y + ((pt.y - lastPt.y) / 2);
            var line1 = new FDSLineHitShape(lastPt.x, lastPt.y, midX, midY);
            line1.index = lastPt.index;
            var line2 = new FDSLineHitShape(midX, midY, pt.x, pt.y);
            line2.index = pt.index;
            if (this.series.isInteractive(2 /* DRAGGABLE */)) {
                line1.name = 5 /* SERIESHIT */;
                line2.name = 5 /* SERIESHIT */;
            }
            return [line1, line2];
        };
        LineDrawStyle.prototype._buildHitShapes = function (prm, lineData) {
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var pointHitShapes = [];
            var lineHitShapes = [];
            var pR = prm.plotRect;
            var lastPt;
            for (var _i = 0, lineData_1 = lineData; _i < lineData_1.length; _i++) {
                var pt = lineData_1[_i];
                if (pt == null) {
                    lastPt = null;
                    continue;
                }
                var plotPt = { index: pt.index, x: pt.x + pR.x1, y: pt.y + pR.y1 };
                pixelPoints[plotPt.index] = { x: plotPt.x, y: plotPt.y };
                if (lastPt != null) {
                    // add hitlines for the line
                    // 2 halves of the current line: the first attached to the previous point, and the next attached to the
                    // current point
                    var _a = this._createLineHitShapes(lastPt, plotPt), line1 = _a[0], line2 = _a[1];
                    // stagger the lines to make sure the hierarchy works correctly when checking the hitshapes
                    if (plotPt.index === this._xData.data.length) {
                        lineHitShapes.push(line1);
                        lineHitShapes.push(line2);
                    }
                    else {
                        lineHitShapes.push(line2);
                        lineHitShapes.push(line1);
                    }
                }
                // add hitrect for the datapoint
                var dpSize = this.series.datapointHitShapeSize;
                var rect = new FDSRectangleHitShape(plotPt.x - dpSize, plotPt.y - dpSize, dpSize * 2, dpSize * 2);
                rect.index = plotPt.index;
                if (this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect.name = 3 /* DATAPOINT */;
                }
                pointHitShapes.push(rect);
                if (this.seriesSelected && this._selectionSampler.isPointSampled(plotPt.index)) {
                    this.cacheSelectable(prm, 0 /* NONE */, pt.x, pt.y);
                }
                lastPt = plotPt;
                this.series.addLookupPoint(plotPt.x, [plotPt.y], plotPt.index);
            }
            // save those pixel points (and overwrite any old data)
            this.series.root.pixelPoints[this.series.id] = pixelPoints;
            // Priority should be:
            // last point
            // first point
            // all the rest in top-down z-order
            // this code moves the first hit shape to the second to last position in the array
            if (pointHitShapes.length > 2) {
                pointHitShapes.splice(-1, 0, pointHitShapes.splice(0, 1)[0]);
            }
            this.series.hitVector = this.series.hitVector.concat(lineHitShapes);
            this.series.hitVector = this.series.hitVector.concat(pointHitShapes);
        };
        LineDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            var pen = this.series.seriesFGPen;
            var lineData = this._buildLineData(prm.plot, pen.color);
            ctx.save();
            pen.setOnCanvas(ctx);
            ctx.beginPath();
            var lastPt;
            for (var _i = 0, lineData_2 = lineData; _i < lineData_2.length; _i++) {
                var pt = lineData_2[_i];
                if (pt == null) {
                    this._startNewLine(ctx, pen);
                }
                else if (lastPt != null) {
                    if (pen.color !== lastPt.color) {
                        this._startNewLine(ctx, pen);
                        pen = pen.with({ color: lastPt.color });
                        pen.setOnCanvas(ctx);
                    }
                    pen.drawPolyline(ctx, lastPt, pt);
                }
                lastPt = pt;
            }
            pen.closePolyline();
            ctx.stroke();
            ctx.restore();
            this._buildHitShapes(prm, lineData);
        };
        LineDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            // Capture the original pen style, we fake it in the legend and are going to change this to solid.
            var origStyle = this.series.seriesFGPen.style;
            if (origStyle === 5 /* NULL */) {
                return;
            }
            ctx.save();
            var pen = this.series.seriesFGPen.with({ style: 0 /* SOLID */, lineCap: 'butt' });
            var aliasOffset = pen.getAliasOffset();
            pen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            var leftX = x - halfwidth;
            var rightX = x + halfwidth;
            y = ~~y - aliasOffset;
            ctx.beginPath();
            // divide the line into sections based on the type of dashing
            switch (origStyle) {
                case 1 /* DASH */:
                    // dashed line has 3 sections splitting the line into 7 parts:
                    // 2 lines of width 3 and a gap of width 1
                    var dashSize = ~~((3 * width) / 7);
                    ctx.moveTo(~~leftX - aliasOffset, y);
                    ctx.lineTo(~~(leftX + dashSize) - aliasOffset, y);
                    ctx.moveTo(~~(rightX - dashSize) - aliasOffset, y);
                    ctx.lineTo(~~rightX - aliasOffset, y);
                    break;
                case 2 /* DOT */:
                    // dotted line has 5 sections splitting the line into 5 parts:
                    // 3 lines of width 1 and 2 gaps also of width 1
                    dashSize = ~~(width / 5);
                    ctx.moveTo(~~leftX - aliasOffset, y);
                    ctx.lineTo(~~(leftX + dashSize) - aliasOffset, y);
                    ctx.moveTo(~~(leftX + (dashSize * 2)) - aliasOffset, y);
                    ctx.lineTo(~~(leftX + (dashSize * 3)) - aliasOffset, y);
                    ctx.moveTo(~~(leftX + (dashSize * 4)) - aliasOffset, y);
                    ctx.lineTo(~~(leftX + (dashSize * 5)) - aliasOffset, y);
                    break;
                case 3 /* DASHDOT */:
                    // dash-dot line has 6 sections splitting the line into 11 parts:
                    // 2 lines of width 3, a dot of width 1, and 2 gaps of width 2
                    dashSize = ~~((3 * width) / 11);
                    var dotSize = ~~((1 * width) / 11);
                    var gapSize = ~~((2 * width) / 11);
                    ctx.moveTo(~~leftX, y);
                    ctx.lineTo(~~(leftX + dashSize) - aliasOffset, y);
                    ctx.moveTo(~~(leftX + dashSize + gapSize) - aliasOffset, y);
                    ctx.lineTo(~~(leftX + dashSize + gapSize + dotSize) - aliasOffset, y);
                    ctx.moveTo(~~(leftX + dashSize + (gapSize * 2) + dotSize) - aliasOffset, y);
                    ctx.lineTo(~~(leftX + (dashSize * 2) + (gapSize * 2) + dotSize) - aliasOffset, y);
                    break;
                case 4 /* DASHDOTDOT */:
                    // dash-dot-dot line has 6 sections splitting the line into 9 parts:
                    // a line of width 3, 2 dots of width 1, and 2 gaps of width 2
                    dashSize = ~~((3 * width) / 9);
                    dotSize = ~~((1 * width) / 9);
                    gapSize = ~~((2 * width) / 9);
                    ctx.moveTo(~~leftX, y);
                    ctx.lineTo(~~(leftX + dashSize) - aliasOffset, y);
                    ctx.moveTo(~~(leftX + dashSize + gapSize) - aliasOffset, y);
                    ctx.lineTo(~~(leftX + dashSize + gapSize + dotSize) - aliasOffset, y);
                    ctx.moveTo(~~(leftX + dashSize + (gapSize * 2) + dotSize) - aliasOffset, y);
                    ctx.lineTo(~~(leftX + dashSize + (gapSize * 2) + (dotSize * 2)) - aliasOffset, y);
                    break;
                default:// assume solid
                    ctx.moveTo(~~leftX, y);
                    ctx.lineTo(~~rightX, y);
            }
            ctx.stroke();
            ctx.restore();
        };
        LineDrawStyle.prototype.verify = function () {
            return true;
        };
        LineDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        return LineDrawStyle;
    }(BaseDrawStyle));
    
    var Regression = /** @class */ (function (_super) {
        __extends(Regression, _super);
        // Regression constructor
        function Regression(series) {
            return _super.call(this, series, 1 /* X */) || this;
        }
        Regression.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            return LineDrawStyle.prototype.drawLegendPreview.call(this, ctx, x, y, width, height);
        };
        Regression.prototype.verify = function () {
            return true;
        };
        Regression.prototype.hint = function () {
            return 0 /* LINE */;
        };
        Regression.prototype._regressionCore = function (info, prm, isLogRegression, drawBands) {
            if (this.root == null) {
                return;
            }
            var ans = info.regressionData;
            if (ans != null) {
                var extendLine = this.series.extendLine;
                var xmin = 0;
                var xmax = 1;
                if (!extendLine) {
                    xmin = this._xScale.lookup(this._xData.Min()[0]);
                    xmax = this._xScale.lookup(this._xData.Max()[0]);
                }
                xmin = info.scaleXByPlotFactor(xmin);
                xmax = info.scaleXByPlotFactor(xmax);
                if (fuzzyEQ(xmax, xmin)) {
                    return;
                }
                var pixelWidth = prm.plot.subPlotFromNDC(info.scaleXByReversePlotFactor(xmax), 1 /* X */) -
                    prm.plot.subPlotFromNDC(info.scaleXByReversePlotFactor(xmin), 1 /* X */);
                var div = clamp((pixelWidth / 4.0) * info.order, 1.0, 50.0); // adjust curve subdivision base on
                // how curvy things might be combined
                // with the rendered size
                if (info.order < 1 || (info.order === 1 && !this._yScale.log && !this._xScale.log && !isLogRegression)) {
                    div = 1;
                }
                var p = [];
                var p2 = [];
                var delta = (xmax - xmin) / div;
                if (delta < FDSFudge) {
                    delta = 1;
                }
                var inc = 1;
                var startd = -info.bands;
                var endd = info.bands;
                if (!info.bands) {
                    if (info.stdDevMirror) {
                        endd = Math.abs(info.stdDevOffset);
                        startd = -endd;
                        inc = endd === startd ? 1 : endd - startd;
                    }
                    else {
                        startd = endd = info.stdDevOffset;
                    }
                }
                var stdCount = startd;
                var index = 0;
                while (stdCount <= endd) {
                    var selectionSampler = new FDSSeriesSampler(this.series, 1 /* X */, 0, ~~div, pixelWidth);
                    drawBands(info, selectionSampler, p, p2, xmin, xmax, delta, stdCount);
                    index++;
                    stdCount += inc;
                }
            }
        };
        Regression.prototype.drawToBuffer = function (prm, ctx) {
            var _this = this;
            this.prepareToDraw();
            ctx.save();
            var pen = this.series.seriesFGPen;
            var bgColor = this.series.seriesBGBrush.color;
            var pixelPoints = {};
            var setPixPoint = false;
            var isLogRegression = this.series.regressionType !== 0;
            this._regressionCore(new RegressionInfo(this.series), prm, isLogRegression, function (info, selectionSampler, p, p2, xmin, xmax, delta, stdCount) {
                if (_this.series.enableSeriesAlternateFGPen) {
                    if (fuzzyEQ(stdCount, 0)) {
                        pen = _this.series.seriesFGPen;
                    }
                    else {
                        pen = _this.series.seriesAlternateFGPen;
                    }
                }
                else {
                    pen = _this.series.seriesFGPen;
                }
                pen.setOnCanvas(ctx);
                var count = 0;
                var x = xmin;
                while (fuzzyLTE(x, xmax)) {
                    var pt = info.getPoint(prm, x, stdCount);
                    p[count] = pt;
                    // TODO: tooltips
                    if (count > 0) {
                        var line = new FDSLineHitShape(p[count - 1].x + prm.plotRect.x1, p[count - 1].y + prm.plotRect.y1, p[count].x + prm.plotRect.x1, p[count].y + prm.plotRect.y1);
                        line.name = 5 /* SERIESHIT */;
                        line.index = count - 1;
                        _this.series.hitVector.push(line);
                        // also save pixel points. only do this once since they all point to 0
                        // if not setPixPoint
                        var pixX = Math.round(((p[count - 1].x + p[count].x) / 2) + prm.plotRect.x1);
                        var pixY = Math.round(((p[count - 1].y + p[count].y) / 2) + prm.plotRect.y1);
                        pixelPoints[count - 1] = { x: pixX, y: pixY };
                        _this._computeLabelPositionAndDraw(prm, ctx, p[count - 1], p[count], stdCount);
                    }
                    if (_this.series.isSelected() && selectionSampler.isPointSampled(count)) {
                        _this.cacheSelectable(prm, 0 /* NONE */, pt);
                    }
                    count++;
                    x += delta;
                }
                _this.strokePolyline(ctx, pen, p);
            });
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        Regression.prototype._computeLabelPositionAndDraw = function (prm, ctx, pt1, pt2, index) {
            var font = this.series.seriesLabel1Font;
            var xoff = this.series.seriesLabel1XOffset;
            var yoff = this.series.seriesLabel1YOffset;
            var hpos = this.series.seriesLabel1HPosition;
            var vpos = this.series.seriesLabel1VPosition;
            var label;
            // create label
            if (this.series.seriesLabel1Text.length !== 0) {
                var formatString = this.series.properties.compilePropertyString(this.series.seriesLabel1Text);
                label = formatString.fromValue({ seriesIndex: index });
            }
            else {
                label = '';
            }
            var tp1 = new Point(pt1.x, pt1.y);
            var tp2 = new Point(pt2.x, pt2.y);
            tp1.x += Math.round(xoff);
            tp1.y += Math.round(yoff);
            tp2.x += Math.round(xoff);
            tp2.y += Math.round(yoff);
            var fontHeight = (vpos === 0 /* V_BOTTOM */) ? -2 : font.getHeight() + 2;
            ctx.save();
            font.setOnCanvas(ctx);
            var textAlign;
            var textPos;
            switch (hpos) {
                case 0 /* LEFT */:
                    if (pt1.x > pt2.x) {
                        textAlign = 'right';
                    }
                    else {
                        textAlign = 'left';
                    }
                    textPos = tp1;
                    break;
                case 2 /* CENTER */:
                    textPos = { x: Math.round((tp1.x + tp2.x) / 2.0), y: tp1.y };
                    textAlign = 'center';
                    break;
                default:
                    // default handles case TEXT_RIGHT
                    if (pt1.x < pt2.x) {
                        textAlign = 'right';
                    }
                    else {
                        textAlign = 'left';
                    }
                    textPos = tp2;
            }
            ctx.legacyFillText(label, textPos.x, textPos.y + fontHeight, textAlign);
            ctx.restore();
        };
        return Regression;
    }(BaseDrawStyle));
    var RegressionInfo = /** @class */ (function () {
        function RegressionInfo(series) {
            _a = series.getLogRegressionFlags(), this.logRegressionX = _a[0], this.logRegressionY = _a[1];
            this._pXScale = series.getScale(1 /* X */);
            this._pYScale = series.getScale(2 /* Y */);
            this.order = series.regressionOrder;
            if (this.order < 0) {
                this.order = 1;
            }
            this.bands = Math.max(0, series.regressionStdDevBands);
            this.stdDevOffset = series.regressionStdDevOffset;
            this.stdDevMirror = series.regressionStdDevMirror;
            this.regressionData = series.getRegressionData();
            this._xData = series.getData(1 /* X */);
            this._yData = series.getData(2 /* Y */);
            this.stdDevValue = series.getStdDevFromRegression ? series.stdDevFromRegression : this._yData.StdDev();
            this._xMin = this._pXScale.compressValue(this._xData.Min()[0], this.logRegressionX);
            this._yMin = this._pYScale.compressValue(this._yData.Min()[0], this.logRegressionY);
            this._xScale = this._pXScale.compressValue(this._xData.Max()[0], this.logRegressionX) - this._xMin;
            this._yScale = this._pYScale.compressValue(this._yData.Max()[0], this.logRegressionY) - this._yMin;
            if (fuzzyEQ(0.0, this._xScale)) {
                this._xScale = 1.0;
            }
            if (fuzzyEQ(0.0, this._yScale)) {
                this._yScale = 1.0;
            }
            this._axisPlotFactorScale = this._pXScale.getMaxPlotFactor() - this._pXScale.getMinPlotFactor();
            if (fuzzyEQ(this._axisPlotFactorScale, 0.0)) {
                this._axisPlotFactorScale = 1.0;
            }
            var _a;
        }
        RegressionInfo.prototype.getYExtremaOverNDCRange = function (extended) {
            var samples = 50;
            var minX = extended ? 0 : this._pXScale.lookup(this._xData.Min()[0]);
            var maxX = extended ? 1 : this._pXScale.lookup(this._xData.Max()[0]);
            var startX = this.scaleXByReversePlotFactor(minX);
            var endX = this.scaleXByReversePlotFactor(maxX);
            var minY = Infinity;
            var maxY = -Infinity;
            for (var i = 0; i <= samples; i++) {
                var x = ((i / samples) * (endX - startX)) + startX;
                var y = this._getYFromX(x);
                minY = Math.min(y, minY);
                maxY = Math.max(y, maxY);
            }
            return [minY, maxY];
        };
        RegressionInfo.prototype._getYFromX = function (x) {
            var xVal = (this._pXScale.compressValue(this._pXScale.computeValueUnbinned(x), this.logRegressionX) -
                this._xMin) / this._xScale;
            var y = polyinterp(this.regressionData, this.order + 1, xVal);
            return this._pYScale.decompressValue((y * this._yScale) + this._yMin, this.logRegressionY);
        };
        RegressionInfo.prototype.scaleXByPlotFactor = function (x) {
            x = (x - this._pXScale.getMinPlotFactor()) / this._axisPlotFactorScale;
            return Math.max((0.0 - this._pXScale.getMinPlotFactor()) / this._axisPlotFactorScale, x);
        };
        RegressionInfo.prototype.scaleXByReversePlotFactor = function (x) {
            return (x * this._axisPlotFactorScale) + this._pXScale.getMinPlotFactor();
        };
        RegressionInfo.prototype.getPoint = function (prm, x, stdDevCount) {
            if (prm == null) {
                return new Point(0, 0);
            }
            return new Point(prm.plot.subPlotFromNDC(this.scaleXByReversePlotFactor(x), 1 /* X */), prm.plot.subPlotFromNDC(this._pYScale.lookup(this._getYFromX(x) + (stdDevCount * this.stdDevValue)), 2 /* Y */));
        };
        return RegressionInfo;
    }());
    
    var FDSAxis = /** @class */ (function (_super) {
        __extends(FDSAxis, _super);
        function FDSAxis(root, id, dimension, prefix, parent, isBuiltInAxis, scaleSpecifier, wrapper) {
            if (dimension === void 0) { dimension = -1 /* NONE */; }
            if (isBuiltInAxis === void 0) { isBuiltInAxis = false; }
            if (scaleSpecifier === void 0) { scaleSpecifier = 0 /* NONE */; }
            var _this = _super.call(this, root, id, 15 /* FC_AXIS */, { prefix: prefix }) || this;
            _this.updateFromSlider = _this.updateFromSlider.bind(_this);
            _this.dimension = dimension;
            _this.parent = parent;
            _this._prefix = prefix;
            _this.isBuiltInAxis = isBuiltInAxis;
            _this.scaleSpecifier = scaleSpecifier;
            _this.wrapper = wrapper || new FDSAxisWrapper(_this);
            _this.associatedSeries = [];
            _this._seriesListDirty = true;
            _this.seriesHaveValidData = false;
            _this.labelLeftMargin = 5; // px
            _this.axisFGPen = new FDSPen({ color: 6710886 /* TICK_FG_GREY */ });
            _this._ticksFGPen = new FDSPen({ color: 6710886 /* TICK_FG_GREY */ });
            _this._gridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            _this._minorGridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            _this._intradayMajorUnitBGBrush = new FDSBrush();
            _this._intradayMajorUnitBGBrush.color = 16777215 /* WHITE */;
            _this.axisFont = new FDSFont();
            _this.axisMinorFont = new FDSFont();
            _this._labelPadded = false;
            _this.labeled = true;
            _this.minPlotFactor = 0;
            _this.maxPlotFactor = 1;
            _this.crosshairsLabeled = false;
            _this.crosshairsLabelText = _this.properties.EmptyPropertyString;
            _this._crosshairsLabelShowText = true;
            _this._crosshairsLabelTextBox = true;
            _this.crosshairsLabelFont = new FDSFont();
            _this._crosshairsLabelTextBoxFGPen = new FDSPen({ color: 0 /* BLACK */ });
            _this._crosshairsLabelTextBoxBGBrush = new FDSBrush();
            _this._crosshairsLabelTextBoxBGBrush.color = 16777215 /* WHITE */;
            _this._crosshairsLabelTextBoxBGBrush.style = 0 /* SOLID */;
            _this._crosshairsLabelTextBoxDisplayStyle = 0;
            _this._crosshairsLabelTextBoxSizingMode = 0;
            _this._crosshairsLabelTextBoxWidthHint = 0;
            _this._crosshairsLabelTextBoxHeightHint = 0;
            _this._crosshairsLabelTextBoxDisplayMargins = 0;
            _this._crosshairsLabelTextBoxArrowMultiplier = 0;
            _this._crosshairsLabelTextBoxClipText = false;
            _this.crosshairsLabelDrawnWithoutAxisLabels = false;
            _this._referenceLineFGPen = new FDSPen({ color: 6710886 /* TICK_FG_GREY */ });
            _this.crosshairPosition = new Point(0, 0);
            _this.crosshairDrawing = false;
            _this._showMajorUnitWhenNoTicks = true;
            _this._lastBaseThresh = new Thresholds();
            _this._startZoomPt = NAN;
            _this._endZoomPt = NAN;
            _this._zooming = false;
            _this._zoomSliderRegion = false;
            _this.zoomEnabled = false;
            _this._sliderRegion = null;
            _this._zoomIndex = -1;
            _this.zoomGroup = 0;
            _this._windowWasBaseZoom = false;
            _this._windowWasMax = false;
            _this._windowWasMin = false;
            _this._hasZoomed = false;
            _this.titleFont = new FDSFont({
                widthHint: 32000,
                alignment: 2 /* CENTER */,
                escapement: _this.dimension === 2 /* Y */ ? (-Math.PI / 2) : 0,
            });
            // Outlier Attributes
            _this._outlierIndicatorFGPen = new FDSPen();
            _this._outlierIndicatorBGBrush = new FDSBrush();
            _this._outlierIndicatorBGBrush.style = 0 /* SOLID */;
            _this._outlierIndicatorBGBrush.color = RGBtoCOLORREF(255, 0, 0);
            _this.temporaryScale = true;
            _this._axisSeries = '';
            _this._axisDataType = 'NONE';
            _this.maxDimensions = {
                width: 0,
                height: 0
            };
            _this._minTitleOffset = _this._maxTitleOffset = 0;
            if (_this._prefix === undefined) {
                if (_this.dimension === 1 /* X */) {
                    _this._prefix = 'X';
                }
                else if (_this.dimension === 2 /* Y */) {
                    _this._prefix = 'Y';
                }
            }
            // sort of a dumb hack - make sure we don't count plot padding multiple times
            _this._paddingCounted = false;
            _this.intradayDirty = false;
            _this._labels = { major: [], minor: [] };
            // Set up dynamic property handlers. By setting the key to `true` instead
            // of a function object, the dispatcher will use a bound instance of the
            // member function named by the property key (e.g. `FDSAxisValue`) prepended
            // with `_prop` (e.g. `_propFDSAxisValue`)
            _this._setDynamicProperties({
                'FDSAxisValue': true,
                'FDSAxisType': true,
                'FDSAxisFormat': true,
                'FDSAxisLabel': true,
                'FDSCrosshairValue': true,
                'FDSThreshMax': true,
                'FDSThreshMin': true
            });
            _this._setAttributes();
            return _this;
        }
        FDSAxis.prototype._init = function (args) {
            var getDefMapID = function (prefix) {
                switch (prefix) {
                    case 'X':
                        return 'DEF_X_AXIS';
                    case 'Y':
                        return 'DEF_Y_AXIS';
                    case 'Y2':
                        return 'DEF_Y2_AXIS';
                    case 'Y3':
                        return 'DEF_Y3_AXIS';
                    case 'Y4':
                        return 'DEF_Y4_AXIS';
                    default:
                        return 'DEF_AXIS';
                }
            };
            this._defMapID = getDefMapID(args.prefix);
            _super.prototype._init.call(this);
        };
        FDSAxis.prototype.getPrefix = function () {
            return this._prefix || '';
        };
        FDSAxis.prototype.isNumericScale = function () {
            return this._isNumericScale;
        };
        FDSAxis.prototype.clearLabels = function () {
            this._labels = { major: [], minor: [] };
        };
        // Apply a theme based on what was passed into the FDSChart constructor
        FDSAxis.prototype._applyTheme = function () {
            if (!_super.prototype._applyTheme.call(this)) {
                return false;
            }
            var themeAttrs = {};
            if (this._chartTheme === 1 /* QUARTZ */ || this._chartTheme === 2 /* CARBON */) {
                themeAttrs['FontFamily'] = 'Arial';
                themeAttrs['FontHeight'] = 11;
            }
            if (this._chartTheme === 1 /* QUARTZ */) {
                themeAttrs['AxisFGColor'] = 14803425 /* GRAY9 */;
                themeAttrs['FontColor'] = 0;
                themeAttrs['GridFGColor'] = 14803425 /* GRAY9 */;
                themeAttrs['GridFGStyle'] = 0;
                themeAttrs['TicksFGColor'] = 14803425 /* GRAY9 */;
            }
            else if (this._chartTheme === 2 /* CARBON */) {
                themeAttrs['AxisFGColor'] = 4934475 /* DARK_CARBON */;
                themeAttrs['FontColor'] = 16777215 /* WHITE */;
                themeAttrs['GridFGColor'] = 4934475 /* DARK_CARBON */;
                themeAttrs['GridFGStyle'] = 0;
                themeAttrs['TicksFGColor'] = 4934475 /* DARK_CARBON */;
            }
            for (var key in themeAttrs) {
                var val = themeAttrs[key];
                this.attributeSet.setAt(key, 'app', val);
            }
            return true;
        };
        FDSAxis.prototype._setAttributes = function () {
            if (!this.attributeSet.defaultMap.startInitialization()) {
                return;
            }
            _super.prototype._setAttributes.call(this);
            var dimPrefix = this.getDimPrefix();
            var parentPrefix = (this.isBuiltInAxis && dimPrefix != null) ? dimPrefix : this._prefix;
            var inheritFromRoot = this.dimension === 1 /* X */ || this.dimension === 2;
            var dimensionIsY = this.dimension === 2;
            var defAxisPosition = 0;
            if (this.scaleSpecifier === 256 /* Y3 */) {
                defAxisPosition = 2 /* BOTH */;
            }
            else if (this.scaleSpecifier === 512 /* Y4 */) {
                defAxisPosition = 4 /* HIDDEN */;
            }
            var defGrid = this.scaleSpecifier !== 128 /* Y2 */ && this.scaleSpecifier !== 256 /* Y3 */ &&
                this.scaleSpecifier !== 512;
            this.attributeSet.addMultiple([
                ['Axis', Boolean, true, (inheritFromRoot ? parentPrefix + 'Axis' : null)],
                ['Grid', Boolean, defGrid, this._prefix + 'Grid'],
                ['MinorGrid', Boolean, false, this._prefix + 'MinorGrid'],
                ['MinorGridInheritsColor', Boolean, false, null],
                ['Label', Boolean, true, (inheritFromRoot ? parentPrefix + 'Label' : null)],
                ['LabelAnchor', Number, 0, null],
                ['LabelCentered', Boolean, false, null],
                ['LabelCentered2', Boolean, false, null],
                ['LabelFormat', String, '', this._prefix + 'LabelFormat'],
                ['LabelFormat2', String, '', null],
                ['LabelPostfix', String, '', null],
                ['LabelPostfix2', String, '', null],
                ['LabelPrefix', String, '', null],
                ['LabelPrefix2', String, '', null],
                ['Log', Boolean, false, this._prefix + 'Log'],
                ['MinorTicks', Boolean, true, (inheritFromRoot ? parentPrefix + 'MinorTicks' : null)],
                ['MinorTicksLengthFactor', Number, 0.5, null],
                ['RoundMinMax', Boolean, true, null],
                ['ThreshMax', Number, 1, this._prefix + 'ThreshMax'],
                ['ThreshMaxMargin', Number, 0.05, null],
                ['ThreshMin', Number, 0, this._prefix + 'ThreshMin'],
                ['ThreshMinMargin', Number, 0.05, null],
                ['Ticks', Boolean, true, (inheritFromRoot ? parentPrefix + 'Ticks' : null)],
                ['TicksLength', Number, 4, null],
                ['TickMode', Number, 2 /* FIXED */, this._prefix + 'TickMode'],
                ['AxisPosition', Number, defAxisPosition, (inheritFromRoot ? parentPrefix + 'AxisPosition' : null)],
                ['LabelPosition', Number, defAxisPosition, (inheritFromRoot ? parentPrefix + 'AxisPosition' : null)],
                ['TicksPosition', Number, defAxisPosition, (inheritFromRoot ? parentPrefix + 'AxisPosition' : null)],
                ['TickDateBin', String, 'NONE', this._prefix + 'TickDateBin'],
                ['MinorTickDateBin', String, 'NONE', null],
                ['minPlotFactor', Number, 0.0, this._prefix + 'minPlotFactor'],
                ['maxPlotFactor', Number, 1.0, this._prefix + 'maxPlotFactor'],
                ['LabelOffset', Number, 2.0, null],
                ['TicksOffset', Number, 0.0, null],
                ['AxisOffset', Number, 0.0, null],
                ['Bin', Boolean, false, null],
                ['Reference', Number, 0, null],
                ['ReferenceLine', Boolean, false, null],
                ['Reverse', Boolean, false, this._prefix + 'Reverse'],
                ['LabelPadded', Boolean, dimensionIsY, null],
                ['LabelOverride', String, '', null],
                ['BinFactor', Number, 0.8, null],
                ['HLBinsHint', Number, 1, (inheritFromRoot ? parentPrefix + 'HLBinsHint' : null)],
                ['TickBin', Boolean, false, null],
                ['TickOffset', Number, 1, this._prefix + 'TickOffset'],
                ['MinorTickOffset', Number, 0.5, this._prefix + 'MinorTickOffset'],
                ['TicksResize', Boolean, true, null],
                ['CrosshairsLabel', Boolean, false, 'CrosshairsLabel'],
                ['CrosshairsLabelText', String, '', null],
                ['CrosshairsLabelTextBox', Boolean, true, null],
                ['CrosshairsLabelTextBoxDisplayStyle', Number, 0 /* RECT */, null],
                ['CrosshairsLabelTextBoxDisplayMargins', Number, 0, null],
                ['CrosshairsLabelTextBoxSizingMode', Number, 1 /* CUSTOM_HINT */, null],
                ['CrosshairsLabelTextBoxWidthHint', Number, 100, null],
                ['CrosshairsLabelTextBoxHeightHint', Number, 50, null],
                ['CrosshairsLabelTextBoxPlacement', Number, 0, null],
                ['CrosshairsLabelShowText', Boolean, true, null],
                ['CrosshairsLabelTextBoxArrowMultiplier', Number, 1, null],
                ['CrosshairsLabelTextBoxClipText', Boolean, false, null],
                ['CrosshairsLabelDrawnWithoutAxisLabels', Boolean, false, 'CrosshairsLabelDrawnWithoutAxisLabels'],
                ['ZoomEnabled', Boolean, false, null],
                ['ZoomGroup', Number, 0, null],
                ['ZoomSliderRegion', Boolean, false, null],
                ['ZoomDefaultMin', Number, NAN, null],
                ['ZoomDefaultMax', Number, NAN, null],
                ['FadeNonZoomedRegion', Boolean, false, null],
                ['ZoomSliderHandleWidth', Number, 30, null],
                ['ZoomSliderStickyMode', Number, 0 /* ZOOM_NOTSTICKY */, null],
                ['WeekType', Number, 0, null],
                ['OutlierAxis', Boolean, false, (inheritFromRoot ? parentPrefix + 'OutlierAxis' : null)],
                ['OutlierAxisThreshMin', Number, NAN, (inheritFromRoot ? parentPrefix + 'OutlierAxisThreshMin' : null)],
                ['OutlierAxisThreshMax', Number, NAN, (inheritFromRoot ? parentPrefix + 'OutlierAxisThreshMax' : null)],
                ['OutlierAxisMarginMin', Number, 0.1, (inheritFromRoot ? parentPrefix + 'OutlierAxisMarginMin' : null)],
                ['OutlierAxisMarginMax', Number, 0.1, (inheritFromRoot ? parentPrefix + 'OutlierAxisMarginMax' : null)],
                ['OutlierAxisDynamic', Boolean, false, (inheritFromRoot ? parentPrefix + 'OutlierAxisDynamic' : null)],
                ['OutlierAxisDynamicThreshold', Number, 1.5,
                    (inheritFromRoot ? parentPrefix + 'OutlierAxisDynamicThreshold' : null)],
                ['OutlierIndicator', Boolean, false, null],
                ['OutlierIndicatorFactor', Number, 0.0, null],
                ['OutlierIndicatorMarkerStyle', Number, 22 /* LIGHTNING */, null],
                ['OutlierIndicatorMarkerSize', Number, 15.0, null],
                ['ThreshConsider', Boolean, false, null],
                ['ThreshConsiderValue', Number, 0.0, null],
                ['ThreshConsiderFactor', Number, 0.5, null],
                ['RefreshAxis', Boolean, true, 'RefreshAxis'],
                ['DisplayHolidays', Boolean, false, null],
                ['HolidayDataset', String, '', null],
                ['MajorUnitStart', String, '---0-0-0', null],
                ['MinorUnitStart', String, '---9-30-0', null],
                ['MinorUnitEnd', String, '---8-0-0', null],
                ['MajorTickMultiplier', Number, 1, null],
                ['MinorTickMultiplier', Number, 1, null],
                ['AutomaticHolidayDetection', Boolean, false, null],
                ['AutomaticStartEndDayDetection', Boolean, false, null],
                ['TreatWeekendsAsHolidays', Boolean, false, null],
                ['RemoveGapsFromMajorIntervals', Number, 0 /* BOTH */, null],
                ['RemoveGapsFromMinorIntervals', Number, 2 /* NONE */, null],
                ['SecondaryFrequency', String, 'D', null],
                ['ForceEndLabels', Number, 2 /* NONE */, null],
                ['ForceMinorEndLabels', Number, 2 /* NONE */, null],
                ['DateLabelShift', Number, 0, null],
                ['DateMinorLabelShift', Number, 0, null],
                ['EndLabelLeftFormat', String, '', null],
                ['EndLabelLeftPosition', Number, 0 /* INSIDE */, null],
                ['EndLabelMinorLeftFormat', String, '', null],
                ['EndLabelMinorLeftPosition', Number, 0 /* INSIDE */, null],
                ['EndLabelRightFormat', String, '', null],
                ['EndLabelRightPosition', Number, 0 /* INSIDE */, null],
                ['EndLabelMinorRightFormat', String, '', null],
                ['EndLabelMinorRightPosition', Number, 0 /* INSIDE */, null],
                ['EndLabelSnapToDatapoint', Number, 2 /* NONE */, null],
                ['EndMinorLabelSnapToDatapoint', Number, 2 /* NONE */, null],
                ['AlternatingBackground', Boolean, false, null],
                ['AlternatingBackgroundFactor', Number, 0, null],
                ['BaseRangesOnIntervals', Boolean, false, null],
                ['IgnoreIntradayScaleLeastVisibleInterval', Boolean, true, null],
                ['IntradayLabeling', Boolean, false, null],
                ['IntradayLabelingMask', Number, -1, null],
                ['LabelMinorPadding', Number, 0, null],
                ['BinLabelMode', Number, 0 /* START */, null],
                ['BinMinorLabelMode', Number, 0 /* START */, null],
                ['LabelsLevelsMask', Number, 2 /* MAJOR */, null],
                ['MajorTickSnapToDate', Boolean, true, null],
                ['MinorTickSnapToDate', Boolean, true, null],
                ['TickSafety', Number, 500, null],
                ['IntradayScaleLengthForPartialDays', Boolean, false, null],
                ['InnerBinPadding', Number, 0, null],
                ['AxisSeries', String, '', null],
                ['Title', Boolean, false, (inheritFromRoot ? parentPrefix + 'Title' : null)],
                ['TitlePosition', Number, defAxisPosition, null],
                ['TitleAtEnd', Boolean, false, null],
                ['TitleText', String, this._prefix, null],
                ['TitleOffset', Number, 0, null],
                ['TitleTieWithEndLabel', Boolean, true, null],
                ['TitleValuePosition', Number, 0 /* NORMAL */, null],
                ['LabelTooltipEnabled', Boolean, false, null],
                ['LabelTooltipText', String, '', null],
                ['ShowMajorUnitWhenNoTicks', Boolean, true],
                ['TitleRotationMode', Number, 0 /* DEFAULT */],
                ['Alias', String, inheritFromRoot ? this._prefix : 'Custom'],
                ['ExtendMajorTicks', Boolean, false],
                ['ExtendMinorTicks', Boolean, false],
                ['SubBinLabels', String, []],
                ['SubBinLabelsDefault', String, ''],
            ]);
            // add the intraday table attributes (control formatting and ranges)
            var intradayAtts = [];
            // these are the ones that need to inherit for the formatter to be happy
            var fmtrInherits = [
                1 /* SECOND */,
                2 /* TWOSECOND */,
                3 /* FIVESECOND */,
                4 /* TENSECOND */,
                5 /* HALFMINUTE */,
                6 /* MINUTE */,
                7 /* TWOMINUTE */,
                8 /* FIVEMINUTE */,
                9 /* TENMINUTE */,
                10 /* HALFHOUR */,
                11 /* HOUR */,
                12 /* TWOHOUR */,
                13 /* SIXHOUR */,
                14 /* DAY */,
                15 /* WEEK */,
                16 /* MONTH */,
                17 /* QUARTER */,
                18 /* HALFY */,
                19 /* YEAR */,
                20 /* TWOY */,
                21 /* FIVEY */,
                22 /* TENY */
            ];
            var bin = 0;
            for (var _i = 0, DateTimeBinArray_1 = DateTimeBinArray; _i < DateTimeBinArray_1.length; _i++) {
                var binStr = DateTimeBinArray_1[_i];
                var rangeStr = "IntradayScaleRange" + binStr;
                var minRangeStr = "IntradayScaleMinorRange" + binStr;
                var formatStr = "IntradayScaleLabelFormat" + binStr;
                var minFormatStr = "IntradayScaleMinorLabelFormat" + binStr;
                var inherit = inheritFromRoot && fmtrInherits.indexOf(bin) > -1;
                intradayAtts.push([rangeStr, Number, IntradayScaleRanges[bin], (inherit ? parentPrefix + rangeStr : null)]);
                intradayAtts.push([
                    minRangeStr,
                    Number,
                    IntradayScaleMinorRanges[bin],
                    (inherit ? parentPrefix + minRangeStr : null)
                ]);
                intradayAtts.push([formatStr, String, '', (inherit ? parentPrefix + formatStr : null)]);
                intradayAtts.push([minFormatStr, String, '', (inherit ? parentPrefix + minFormatStr : null)]);
                bin++;
            }
            this.attributeSet.addMultiple(intradayAtts);
            var font = new FDSFont();
            // We only want to inherit attributes like Escapement Alignment and WidthHint from the axis-dimension specific
            // attributes, and not BaseFont
            var shouldInheritAllFontAttributes = inheritFromRoot;
            this.titleFont.writeToAttrSet(this.attributeSet, 'TitleFont', (inheritFromRoot ? parentPrefix + 'TitleFont' : 'BaseFont'), shouldInheritAllFontAttributes);
            font.writeToAttrSet(this.attributeSet, 'Font', (inheritFromRoot ? parentPrefix + 'Font' : 'BaseFont'), shouldInheritAllFontAttributes);
            font.writeToAttrSet(this.attributeSet, 'Font2', (inheritFromRoot ? parentPrefix + 'Font' : 'BaseFont2'), shouldInheritAllFontAttributes);
            this.axisFGPen.writeToAttrSet(this.attributeSet, 'AxisFG', (inheritFromRoot ? parentPrefix + 'AxisFG' : 'AxisFG'));
            this._ticksFGPen.writeToAttrSet(this.attributeSet, 'TicksFG', (inheritFromRoot ? parentPrefix + 'TicksFG' : 'AxisFG'));
            this._gridFGPen.writeToAttrSet(this.attributeSet, 'GridFG', (inheritFromRoot ? parentPrefix + 'GridFG' : 'GridFG'));
            this._minorGridFGPen.writeToAttrSet(this.attributeSet, 'MinorGridFG', (inheritFromRoot ? parentPrefix + 'MinorGridFG' : 'MinorGridFG'));
            this._referenceLineFGPen.writeToAttrSet(this.attributeSet, 'ReferenceLineFG', (inheritFromRoot ? parentPrefix + 'AxisFG' : 'AxisFG'));
            this._intradayMajorUnitBGBrush.writeToAttrSet(this.attributeSet, 'IntradayScaleMajorUnitBG', null);
            this.crosshairsLabelFont.writeToAttrSet(this.attributeSet, 'CrosshairsLabelFont', null);
            this._crosshairsLabelTextBoxFGPen.writeToAttrSet(this.attributeSet, 'CrosshairsLabelTextBoxFG', null);
            this._crosshairsLabelTextBoxBGBrush.writeToAttrSet(this.attributeSet, 'CrosshairsLabelTextBoxBG', null);
            this._outlierIndicatorFGPen.writeToAttrSet(this.attributeSet, 'OutlierIndicatorFG', null);
            this._outlierIndicatorBGBrush.writeToAttrSet(this.attributeSet, 'OutlierIndicatorBG', null);
            this.attributeSet.defaultMap.finalizeInitialization();
        };
        FDSAxis.prototype.getDimPrefix = function () {
            switch (this.dimension) {
                case 1 /* X */:
                    return 'X';
                case 2 /* Y */:
                    return 'Y';
            }
            return undefined;
        };
        FDSAxis.prototype._applyStyleObjects = function () {
            if (this.dimension === 1 /* X */ || this.dimension === 2 /* Y */) {
                return null;
            }
            else {
                return _super.prototype._applyStyleObjects.call(this);
            }
        };
        FDSAxis.prototype.getStyleObjectName = function () {
            if ((this.parent == null) || this.isStyleObject) {
                return 'FDSChart';
            }
            var styleKey = this.getDimPrefix();
            if (styleKey) {
                var fcPrefix = this.parent.getFCPrefix();
                return "" + fcPrefix + this.parent.id + "_" + styleKey + "_AXIS";
            }
            return 'FDSChart';
        };
        FDSAxis.prototype.getObjectTypeName = function () {
            return 'FDSAxis';
        };
        FDSAxis.prototype.syncMembers = function () {
            var _this = this;
            _super.prototype.syncMembers.call(this);
            this._applyTheme();
            // Saves on property access and minified file size
            var attributes = this.attributeSet;
            var getAttribute = attributes.get.bind(attributes);
            var isDefault = attributes.isDefault.bind(attributes);
            var wasZoomEnabled = this.zoomEnabled;
            this.zoomEnabled = getAttribute('ZoomEnabled') && (this.dimension === 1 /* X */) && this.root.horizontalZoomEnabled;
            if (this.zoomEnabled || wasZoomEnabled) {
                this.fadeNonZoomedRegion = getAttribute('FadeNonZoomedRegion');
                this.zoomHandleWidth = getAttribute('ZoomSliderHandleWidth');
                this._syncZoomSlider();
                this.zoomGroup = getAttribute('ZoomGroup');
                this._sliderStickyMode = getAttribute('ZoomSliderStickyMode');
            }
            var defaultMap = MapFactory.getDefMap(this._defMapID);
            var dimPrefix = this.getDimPrefix();
            // For axis positions, we're going to skip the plot style set object and look at the root. Label, Ticks, and
            // Title Positions don't have their own root level attribute and use AxisPosition.
            var getPosition = function (attributeName) {
                if (_this.attributeSet.isDefault(attributeName) &&
                    _this.root.attributeSet.isDefault(dimPrefix + 'AxisPosition')) {
                    return defaultMap.lookup(attributeName).value;
                }
                else {
                    if (attributes.getAt(attributeName, 'user') != null) {
                        return attributes.getAt(attributeName, 'user');
                    }
                    else if (attributes.getAt(attributeName, 'app') != null) {
                        return attributes.getAt(attributeName, 'app');
                    }
                    else {
                        return _this.root.attributeSet.get(dimPrefix + 'AxisPosition');
                    }
                }
            };
            this.axisPosition = getPosition('AxisPosition');
            this.labelPosition = getPosition('LabelPosition');
            this.ticksPosition = getPosition('TicksPosition');
            this.titlePosition = getPosition('TitlePosition');
            if (!this.isBoundToSeries()) {
                return;
            }
            if (this._grid = getAttribute('Grid')) {
                this._gridFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'GridFG');
            }
            if (this._minorGrid = getAttribute('MinorGrid')) {
                this._minorGridFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'MinorGridFG');
                if (getAttribute('MinorGridInheritsColor') && isDefault('MinorGridFGColor')) {
                    var minorGridColor = this._grid ? this._gridFGPen.color : getAttribute('GridFGColor');
                    this._minorGridFGPen = this._minorGridFGPen.with({ color: minorGridColor });
                }
            }
            this.axisMinorFont = this.axisMinorFont.inheritFromOtherFont(this.axisFont, this.attributeSet, 'Font2');
            if (getAttribute('MinorGridInheritsColor') && isDefault('MinorGridFGColor')) {
                this._minorGridFGPen = this._minorGridFGPen.with({ color: this._gridFGPen.color });
            }
            this.minPlotFactor = this._getCombinedPlotFactor('min');
            this.maxPlotFactor = this._getCombinedPlotFactor('max');
            // error checking - if max is too small, collapse it to min
            if (this.maxPlotFactor < this.minPlotFactor) {
                this.maxPlotFactor = this.minPlotFactor;
            }
            if (this._axis = getAttribute('Axis')) {
                this.axisFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'AxisFG');
            }
            // we need to always fetch these at the moment because they are used even when ticks and labels aren't shown
            this.ticksOffset = getAttribute('TicksOffset');
            this.labelOffset = getAttribute('LabelOffset');
            this.axisOffset = getAttribute('AxisOffset');
            // don't be fooled, while these attributes mention ticks, they also effect labels, gridlines, and the scale range
            // so we can't guard them behind the @ticks
            this.ticksResize = getAttribute('TicksResize');
            // If the penstyle for ticks is NULL, we don't want to allocate any space for ticks, so turn them off
            this._ticks = getAttribute('Ticks') && getAttribute('TicksFGStyle') !== 5 /* NULL */;
            if (this._ticks) {
                this._ticksFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'TicksFG');
                this._ticksLength = getAttribute('TicksLength');
            }
            if (this._minorTicks = getAttribute('MinorTicks')) {
                this._minorTicksLengthFactor = getAttribute('MinorTicksLengthFactor');
            }
            // This is used to determine if the label is drawn
            if (this.labeled = getAttribute('Label')) {
                this.labelOffset = getAttribute('LabelOffset');
                this._labelPadded = getAttribute('LabelPadded');
                this.labelsLevelsMask = getAttribute('LabelsLevelsMask');
                if (this.labelsLevelsMask !== 0 /* NONE */) {
                    this.axisFont = FDSFont.constructFromAttributes(this.attributeSet, 'Font');
                    if (this.labelsLevelsMask & 1 /* MINOR */) {
                        this.axisMinorFont = FDSFont.constructFromAttributes(this.attributeSet, 'Font2');
                        this.axisMinorFont = this.axisMinorFont.inheritFromOtherFont(this.axisFont, this.attributeSet, 'Font2');
                    }
                }
            }
            this.reference = getAttribute('Reference');
            if (this._referenceLine = getAttribute('ReferenceLine')) {
                this._referenceLineFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'ReferenceLineFG');
            }
            this.crosshairsLabeled = getAttribute('CrosshairsLabel');
            if (this.crosshairsLabeled) {
                this.crosshairsLabelFont = FDSFont.constructFromAttributes(this.attributeSet, 'CrosshairsLabelFont');
                this._crosshairsLabelTextBoxFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'CrosshairsLabelTextBoxFG');
                this._crosshairsLabelTextBoxBGBrush.constructFromAttributes(this.attributeSet, 'CrosshairsLabelTextBoxBG');
                this.crosshairsLabelText = this.properties.compilePropertyString(getAttribute('CrosshairsLabelText'));
                this._crosshairsLabelShowText = getAttribute('CrosshairsLabelShowText');
                this._crosshairsLabelTextBox = getAttribute('CrosshairsLabelTextBox');
                this._crosshairsLabelTextBoxDisplayStyle = getAttribute('CrosshairsLabelTextBoxDisplayStyle');
                this._crosshairsLabelTextBoxSizingMode = getAttribute('CrosshairsLabelTextBoxSizingMode');
                this._crosshairsLabelTextBoxWidthHint = getAttribute('CrosshairsLabelTextBoxWidthHint');
                this._crosshairsLabelTextBoxHeightHint = getAttribute('CrosshairsLabelTextBoxHeightHint');
                this._crosshairsLabelTextBoxDisplayMargins = getAttribute('CrosshairsLabelTextBoxDisplayMargins');
                this._crosshairsLabelTextBoxArrowMultiplier = getAttribute('CrosshairsLabelTextBoxArrowMultiplier');
                this._crosshairsLabelTextBoxClipText = getAttribute('CrosshairsLabelTextBoxClipText');
                this.crosshairsLabelDrawnWithoutAxisLabels = getAttribute('CrosshairsLabelDrawnWithoutAxisLabels');
            }
            this.weekType = getAttribute('WeekType');
            if (this._alternatingBackground = getAttribute('AlternatingBackground')) {
                this._alternatingBackgroundFactor = getAttribute('AlternatingBackgroundFactor');
                this._intradayMajorUnitBGBrush.constructFromAttributes(this.attributeSet, 'IntradayScaleMajorUnitBG');
            }
            this._binFactor = getAttribute('BinFactor');
            // Outlier Attributes
            this.outlierAxis = getAttribute('OutlierAxis');
            if (this.outlierAxis) {
                this._outlierAxisThreshMin = getAttribute('OutlierAxisThreshMin');
                this._outlierAxisThreshMax = getAttribute('OutlierAxisThreshMax');
                this._outlierAxisMarginMin = getAttribute('OutlierAxisMarginMin');
                this._outlierAxisMarginMax = getAttribute('OutlierAxisMarginMax');
                this._outlierAxisDynamic = getAttribute('OutlierAxisDynamic');
                this._outlierAxisDynamicThreshold = getAttribute('OutlierAxisDynamicThreshold');
            }
            this._outlierIndicator = getAttribute('OutlierIndicator');
            if (this._outlierIndicator) {
                this._outlierIndicatorFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'OutlierIndicatorFG');
                this._outlierIndicatorBGBrush.constructFromAttributes(this.attributeSet, 'OutlierIndicatorBG');
                this._outlierIndicatorFactor = getAttribute('OutlierIndicatorFactor');
                this._outlierIndicatorMarkerStyle = getAttribute('OutlierIndicatorMarkerStyle');
                this._outlierIndicatorMarkerSize = getAttribute('OutlierIndicatorMarkerSize');
            }
            this.titleEnabled = getAttribute('Title');
            if (this.titleEnabled) {
                this.titleFont = FDSFont.constructFromAttributes(this.attributeSet, 'TitleFont');
                // adjust title font escapement if necessary
                if (isDefault('TitleFontEscapement')) {
                    this.titleFont = this.titleFont.with({ escapement: this.dimension === 2 /* Y */ ? -Math.PI / 2 : 0 });
                }
                this.titleAtEnd = getAttribute('TitleAtEnd');
                this.titleOffset = getAttribute('TitleOffset');
                this._titleTieWithEndLabel = getAttribute('TitleTieWithEndLabel');
                this.titleValuePosition = getAttribute('TitleValuePosition');
                // set up title text with properties
                var titleText = getAttribute('TitleText');
                this.compiledTitleText = this.properties.compilePropertyString(titleText);
            }
            this._tickSafety = getAttribute('TickSafety');
            this.innerBinPadding = getAttribute('InnerBinPadding');
            this._axisSeries = getAttribute('AxisSeries');
            this._labelTooltipEnabled = getAttribute('LabelTooltipEnabled');
            this._labelTooltipText = getAttribute('LabelTooltipText');
            this._titleRotationMode = getAttribute('TitleRotationMode');
            this._extendMajorTicks = getAttribute('ExtendMajorTicks');
            this._extendMinorTicks = getAttribute('ExtendMinorTicks');
            var subBinLabelUnparsed = getAttribute('SubBinLabels');
            this.subBinLabels = subBinLabelUnparsed.map(function (str) { return _this.properties.compilePropertyString(str); });
            this.subBinLabelsDefault = this.properties.compilePropertyString(getAttribute('SubBinLabelsDefault'));
            this._syncScales(1000);
            if (this.zoomEnabled) {
                this._refreshZoom();
            }
        };
        FDSAxis.prototype.isBoundToSeries = function () {
            return this.associatedSeries.length > 0;
        };
        FDSAxis.prototype._syncScales = function (hint) {
            if (this.associatedSeries.length !== 0) {
                if (this.scale) {
                    this.scale.syncMembers(hint);
                }
                if (this.zoomEnabled) {
                    this._refreshZoom();
                }
            }
        };
        FDSAxis.prototype._syncZoomSlider = function () {
            if (this.zoomEnabled && this.attributeSet.get('ZoomSliderRegion')) {
                if (!this._zoomSliderRegion) {
                    var plot = this.parent;
                    if (plot) {
                        this._zoomSliderRegion = true;
                        this._sliderRegion = new FDSSliderRegion(this);
                    }
                }
                else {
                    this._sliderRegion.constructRect(this.root.containing_element);
                }
                this._updateSliderPixels();
            }
            else {
                if (this._sliderRegion != null) {
                    this._sliderRegion.cleanUp();
                    this._sliderRegion = null;
                }
                this._zoomSliderRegion = false;
            }
        };
        FDSAxis.prototype._startZoom = function (startValue) {
            this._tempStartZoomPt = this._tempEndZoomPt = startValue;
        };
        FDSAxis.prototype._updateZoom = function (point) {
            if (!this._zooming) {
                this._zooming = true;
            } // first time update is called
            this._tempEndZoomPt = point;
            this._updateSliderBars();
        };
        FDSAxis.prototype._updateSliderBars = function () {
            if (this._sliderRegion != null) {
                this._sliderRegion.updateSliders(this._startZoomPt, this._endZoomPt);
                this._updateSliderPixels();
            }
        };
        FDSAxis.prototype._updateSliderPixels = function () {
            if (this._sliderRegion != null) {
                var width = this.zoomHandleWidth / 2;
                var plot = this._sliderRegion.boundPlot;
                var y = Math.round((plot.plotRect.y1 + plot.plotRect.y2) / 2);
                var x1 = Math.round(this._sliderRegion.leftPx - width);
                var x2 = Math.round(this._sliderRegion.rightPx + width);
                var x3 = Math.round((this._sliderRegion.leftPx + this._sliderRegion.rightPx) / 2);
                // store three points - left, right, and center
                this.root.zoomSliderPixelPoints[plot.id] = [{ x: x1, y: y }, { x: x2, y: y }, { x: x3, y: y }];
            }
        };
        FDSAxis.prototype.updateFromSlider = function (start, end) {
            this._startZoomPt = start;
            this._endZoomPt = end;
            this._doZoom();
        };
        FDSAxis.prototype._getZoomRectStart = function () {
            if (this._zooming) {
                return null;
            }
            else {
                return (this._startZoomPt < this._endZoomPt) ? this._startZoomPt : this._endZoomPt;
            }
        };
        FDSAxis.prototype._getZoomRectEnd = function () {
            if (this._zooming) {
                return null;
            }
            else {
                return (this._startZoomPt < this._endZoomPt) ? this._endZoomPt : this._startZoomPt;
            }
        };
        FDSAxis.prototype._resetZoom = function () {
            this._zoomIndex = -1;
            this.root.setNeedUpdate(true);
            this._baseZoom(0 /* BZ_RESET */);
        };
        FDSAxis.prototype._refreshZoom = function () {
            if (this._hasZoomed) {
                this._doZoom();
            }
            else {
                if (this._zoomIndex === -1) {
                    this._baseZoom(0 /* BZ_RESET */);
                }
                else {
                    this._baseZoom(1 /* BZ_UPDATE */);
                }
            }
        };
        // Bound because this is used by an event handler
        FDSAxis.prototype._setZoomedThresholds = function (minThresh, maxThresh, ignoreBins) {
            if (ignoreBins === void 0) { ignoreBins = false; }
            if (this.scale.bin && !ignoreBins) {
                // if  indexScale is this a thing?
                this.scale._setRanges(minThresh, maxThresh);
            }
            else {
                this.scale._setThreshold(minThresh, maxThresh, true);
            }
        };
        FDSAxis.prototype._doZoom = function (updatePlot) {
            if (updatePlot === void 0) { updatePlot = true; }
            if (!this.scale) {
                return;
            }
            this._hasZoomed = true;
            if (!this._zoomSliderRegion) {
                if (updatePlot) {
                    this.refreshPlotAxes(false);
                }
                this._setZoomedThresholds(this._startZoomPt, this._endZoomPt);
            }
        };
        FDSAxis.prototype.refreshPlotAxes = function (forceReset) {
            if (!this.root) {
                return;
            }
            if (forceReset || this.parent.isResizeAllAxesOnZoom()) {
                this.parent.refreshAxis(true);
                this.parent.adjust();
            }
        };
        FDSAxis.prototype._getDefaultZoomWindow = function (thresh) {
            if (this.scale == null) {
                return;
            }
            var bIsZoomDefMinDefaulted = this.attributeSet.isInheritedDefault('ZoomDefaultMin');
            var bIsZoomDefMaxDefaulted = this.attributeSet.isInheritedDefault('ZoomDefaultMax');
            // Both are set, absolute values
            if (!bIsZoomDefMaxDefaulted && !bIsZoomDefMinDefaulted) {
                thresh.set((this.attributeSet.get('ZoomDefaultMin')), (this.attributeSet.get('ZoomDefaultMax')));
                // Min is set, max attribute is defaulted, min is a relative distance from the threshmax
            }
            else if (!bIsZoomDefMinDefaulted && bIsZoomDefMaxDefaulted) {
                thresh.threshMax = this.scale.threshMax;
                thresh.threshMin = thresh.threshMax - (this.attributeSet.get('ZoomDefaultMin'));
                // Max is set, min attribute is defaulted, max is a relative distance from the threshmin
            }
            else if (bIsZoomDefMinDefaulted && !bIsZoomDefMaxDefaulted) {
                thresh.threshMin = this.scale.threshMin;
                thresh.threshMax = thresh.threshMin + (this.attributeSet.get('ZoomDefaultMax'));
            }
            else {
                if (!this.attributeSet.isInheritedDefault('ThreshMin')) {
                    thresh.threshMin = this.attributeSet.get('ThreshMin');
                }
                if (!this.attributeSet.isInheritedDefault('ThreshMax')) {
                    thresh.threshMax = this.attributeSet.get('ThreshMax');
                }
            }
        };
        FDSAxis.prototype._baseZoom = function (behavior) {
            if (!this.scale) {
                return;
            }
            var thresh = new Thresholds(NAN, NAN);
            if (behavior === 1 /* BZ_UPDATE */) {
                thresh.set(this._startZoomPt, this._endZoomPt);
            }
            if (IsNA(thresh.threshMin) && IsNA(thresh.threshMax)) {
                this.scale._setRanges();
                this._lastBaseThresh.setFromAxis(this);
                thresh = this._lastBaseThresh.copy(); // .copy() is because the C++ uses a struct, dont want to just copy the
                // reference
                this._getDefaultZoomWindow(thresh);
            }
            this._startZoomPt = thresh.threshMin;
            this._endZoomPt = thresh.threshMax;
            if (!this._zoomSliderRegion) {
                var ignoreBins = thresh.threshMin === this._lastBaseThresh.threshMin &&
                    thresh.threshMax === this._lastBaseThresh.threshMax;
                this._setZoomedThresholds(thresh.threshMin, thresh.threshMax, ignoreBins);
            }
            if ((this._hasZoomed && behavior === 0 /* BZ_RESET */) || behavior === 1 /* BZ_UPDATE */) {
                this._hasZoomed = false;
                this.refreshPlotAxes(false);
            }
            this._initSliderBars();
        };
        FDSAxis.prototype._initSliderBars = function () {
            if (this._sliderRegion) {
                this._sliderRegion.initialize(this._startZoomPt, this._endZoomPt);
            }
        };
        FDSAxis.prototype._getCombinedPlotFactor = function (minmax) {
            var mpf = this.attributeSet.get(minmax + 'PlotFactor');
            var parent;
            if ((this.parent == null) || !(this.dimension === 1 /* X */ || this.dimension === 2 /* Y */)) {
                parent = minmax === 'min' ? 0 : 1;
            }
            else {
                switch (this.dimension) {
                    case 1 /* X */:
                        parent = this.parent.attributeSet.get(minmax + 'XPlotFactor');
                        break;
                    case 2 /* Y */:
                        parent = this.parent.attributeSet.get(minmax + 'YPlotFactor');
                        break;
                }
            }
            // combine parent's attribute with our attribute by multiplying
            // so if both are .5, result will be .75
            var ret;
            if (minmax === 'min') {
                ret = mpf === 0 ? parent : mpf + (mpf * parent);
            }
            else {
                ret = mpf * parent;
            }
            if (ret > 1) {
                ret = 1;
            }
            if (ret < 0) {
                ret = 0;
            }
            this._paddingCounted = false; // set this flag so we know to redo the padding
            // setting that flag means we need to save our results here though
            if (minmax === 'min') {
                this.minPlotFactor = ret;
            }
            else {
                this.maxPlotFactor = ret;
            }
            return ret;
        };
        FDSAxis.prototype.adjust = function (series) {
            if (!this.scale || !series || !series.adjustAxes) {
                return;
            }
            if (this.zoomEnabled) {
                this._doZoomScaleAdjust(series);
            }
            else {
                var xAxis = series.getAxis(1 /* X */);
                if (!xAxis || (xAxis.parent == null) || !xAxis.zoomEnabled || xAxis._zoomSliderRegion) {
                    if (series.getEffectiveDrawStyle() === 21 /* REGRESSION */) {
                        this._doRegressionScaleAdjust(series);
                    }
                    else {
                        this.scale.adjust(series.getData(this.dimension));
                    }
                }
                else {
                    this._doZoomRegionAdjust(series);
                }
            }
            this.attributeSet.setDirty();
        };
        FDSAxis.prototype.adjustToCurrentSeries = function () {
            if (this.scale == null) {
                return;
            }
            this.scale.initialized = false;
            for (var _i = 0, _a = this.associatedSeries; _i < _a.length; _i++) {
                var s = _a[_i];
                this.adjust(s);
            }
        };
        FDSAxis.prototype._doZoomRegionAdjust = function (series) {
            var xAxis = series.getAxis(1 /* X */);
            if (xAxis) {
                var xData = series.getData(1 /* X */);
                var startPt = xAxis._startZoomPt;
                var endPt = xAxis._endZoomPt;
                if (xData && xData.sorted) {
                    if (endPt < startPt) {
                        _a = [endPt, startPt], startPt = _a[0], endPt = _a[1];
                    }
                    var _b = series.getClosestValueTo(1 /* X */, startPt, true, true), start = _b[0], startIndex = _b[1];
                    var _c = series.getClosestValueTo(1 /* X */, endPt, true, true), end = _c[0], endIndex = _c[1];
                    if (!IsNA(start) && !IsNA(end)) {
                        this.scale.adjust(FDSDataSet.constructPartialDataSet(series.getData(this.dimension), startIndex, endIndex, this.scale.dynamicOutlierThreshold));
                    }
                }
                else {
                    this.scale.adjust(FDSDataSet.constructPartialDataSetFromUnsorted(series.getData(this.dimension), xData, startPt, endPt));
                }
            }
            var _a;
        };
        FDSAxis.prototype._doRegressionScaleAdjust = function (series) {
            var regressionInfluencesScale = series.regressionScaleInfluenceMode !== 0;
            if (this.dimension === 2 /* Y */ && regressionInfluencesScale) {
                var info = new RegressionInfo(series);
                var extended = series.extendLine &&
                    series.regressionScaleInfluenceMode === 2;
                var _a = info.getYExtremaOverNDCRange(extended), minY = _a[0], maxY = _a[1];
                this.scale.adjust(series.getData(this.dimension), minY, maxY);
            }
            else {
                this.scale.adjust(series.getData(this.dimension));
            }
        };
        FDSAxis.prototype._doZoomScaleAdjust = function (series) {
            var scale = this.getScale();
            if (scale) {
                scale.adjust(series.getData(1 /* X */));
                if (this._windowWasBaseZoom) {
                    this._baseZoom(0 /* BZ_RESET */);
                    this._initSliderBars();
                }
                else {
                    if (this._sliderStickyMode !== 0 /* ZOOM_NOTSTICKY */) {
                        var updateZoom = false;
                        var size = scale.compressValue(this._getZoomRectEnd()) - scale.compressValue(this._getZoomRectStart());
                        if (this._windowWasMax && scale.max >= this._getZoomRectEnd()) {
                            this._endZoomPt = scale.max;
                            if (this._sliderStickyMode === 1 /* ZOOM_FIXED_SIZE */) {
                                this._startZoomPt = scale.decompressValue(scale.compressValue(this._endZoomPt) - size);
                            }
                            updateZoom = true;
                        }
                        if ((!updateZoom || this._sliderStickyMode === 2 /* ZOOM_EXPAND_WINDOW */)
                            && (this._windowWasMin && scale.min < this._getZoomRectStart())) {
                            this._startZoomPt = scale.min;
                            if (this._sliderStickyMode === 1 /* ZOOM_FIXED_SIZE */) {
                                this._endZoomPt = scale.decompressValue(scale.compressValue(this._startZoomPt) + size);
                            }
                            updateZoom = true;
                        }
                    }
                    this._doZoom(false);
                    this._initSliderBars();
                }
            }
        };
        FDSAxis.prototype.updateAxisZoomData = function () {
            var scale = this.getScale();
            if (scale) {
                this._windowWasMax = scale.max <= this._getZoomRectEnd();
                this._windowWasMin = scale.min >= this._getZoomRectStart();
                this._windowWasBaseZoom = (IsNA(this._getZoomRectEnd()) && IsNA(this._getZoomRectStart()))
                    || (this._lastBaseThresh.threshMin >= this._getZoomRectStart() &&
                        this._lastBaseThresh.threshMax <= this._getZoomRectEnd());
            }
        };
        FDSAxis.prototype.getScale = function () {
            return this.scale;
        };
        FDSAxis.prototype.shouldDraw = function () {
            if (this.associatedSeries.length === 0) {
                return false;
            }
            // don't try to draw the color axis
            if (this.dimension === 4 /* COLOR */ || this.dimension === 5 /* DSIZE */ || this.dimension === 3 /* Z */) {
                return false;
            }
            if (this.axisPosition === 4 /* HIDDEN */ &&
                this.labelPosition === 4 /* HIDDEN */ &&
                this.ticksPosition === 4 /* HIDDEN */ &&
                this.titlePosition === 4 /* HIDDEN */ &&
                !this._referenceLine) {
                return false;
            }
            return this.scale && this.scale.initialized;
        };
        FDSAxis.prototype.setHistogramScale = function () {
            this.scale = new HistogramScale(this.root, this.id + '_SCALE', this);
        };
        FDSAxis.prototype.setLookupScale = function () {
            this.scale = new FDSLookupScale(this.root, this.id + '_SCALE', this);
        };
        FDSAxis.prototype.addSeries = function (series) {
            // This in the case that we've added a series to our plot, but not yet
            // attached any data to the series. It is quite necessary that our
            // series have data in order to be attached to the plot
            // also return if the series is already added to our associated series
            if (_$1.includes(this.associatedSeries, series)) {
                for (var i = 0; i < this.associatedSeries.length; i++) {
                    series = this.associatedSeries[i];
                    this.seriesHaveValidData = series.hasValidData || this.seriesHaveValidData;
                }
                if (!this.temporaryScale) {
                    return;
                }
            }
            else {
                this.associatedSeries.push(series);
            }
            this._seriesListDirty = true;
            // Create the proper scale for this axis based on the type of the
            // data in the appropriate dimension of the associated series
            var scaleType = this._getScaleTypeFromSeriesDataType(series);
            var dataAtDim = series.getData(this.dimension);
            if (this.scale != null) {
                if (this.temporaryScale && series.hasValidData) {
                    this.scale = new scaleType(this.root, this.id + '_SCALE', this);
                    this.temporaryScale = false;
                    this._axisDataType = dataAtDim.dataType;
                }
            }
            else {
                this.scale = new scaleType(this.root, this.id + '_SCALE', this);
                if (series.hasValidData) {
                    this.temporaryScale = false;
                    this._axisDataType = dataAtDim.dataType;
                }
            }
            this._isNumericScale = _$1.includes(['FLOAT', 'INT', 'INTEGER', 'SINGLE'], this._axisDataType);
            // Set a flag so that we know to call scale.syncMembers later.
            this._seriesChanged = true;
            // this is here so that we can check here and later if we are going to
            // adjust the axis
            series.addAxis(this, this.dimension);
            for (var j = 0; j < this.associatedSeries.length; j++) {
                series = this.associatedSeries[j];
                this.seriesHaveValidData = series.hasValidData || this.seriesHaveValidData;
            }
            this.attributeSet.setDirty(true);
            if (this.parent != null) {
                this.parent.setNeedUpdate(true);
            }
        };
        FDSAxis.prototype._getScaleTypeFromSeriesDataType = function (series) {
            var dataAtDim = series.getData(this.dimension);
            var scaleType;
            if (dataAtDim.attributeSet.get('TreatAsIndex')) {
                switch (dataAtDim.dataType) {
                    case 'DATE':
                    case 'TIME':
                    case 'DATETIME':
                    case 'STRING':
                    case 'FLOAT':
                    case 'INT':
                    case 'INTEGER':
                    case 'SINGLE':
                        scaleType = FDSIndexScale;
                        break;
                    default:
                        scaleType = FDSBinScale;
                }
            }
            else {
                switch (dataAtDim.dataType) {
                    case 'DATE':
                        if (this.parent.attributeSet.get('UseIntradayScale')) {
                            scaleType = FDSIntradayScale;
                        }
                        else {
                            scaleType = FDSDateScale;
                        }
                        break;
                    case 'TIME':
                        scaleType = FDSTimeScale;
                        break;
                    case 'DATETIME':
                        if (this.parent.attributeSet.get('UseIntradayScale')) {
                            scaleType = FDSIntradayScale;
                        }
                        else {
                            scaleType = FDSDateTimeScale;
                        }
                        break;
                    case 'STRING':
                        scaleType = FDSLookupScale;
                        break;
                    case 'INT':
                    case 'INTEGER':
                    case 'FLOAT':
                    case 'SINGLE':
                        scaleType = FDSScale;
                        break;
                    default:
                        scaleType = FDSBinScale;
                }
            }
            return scaleType;
        };
        FDSAxis.prototype.syncScaleMembersIfSeriesChanged = function () {
            if (this._seriesChanged && this.scale) {
                this.scale.syncMembers();
                this._seriesChanged = false;
            }
        };
        /**
         * Resets the scale to an initial state so that it can be properly initialized during the syncMembers pass.
         */
        FDSAxis.prototype.resetScale = function () {
            if (this.parent) {
                this.parent.setNeedUpdate(true);
            }
            if (this.scale) {
                this.scale.reset(true);
            }
            this.setNeedUpdate(true);
        };
        /**
         * Checks whether the current scale type is appropriate for the provided useIntradayScale value.
         * If the scale type is different, this function will create a new scale of the correct form.
         * For Example: if useIntradayScale is true, any FDSDateScale or FDSDateTimeScale scales
         * will be replaced with an FDSIntradayScale, and vice versa.
         *
         * @param useIntradayScale - true if FDSIntradayScale should be preferred over FDSDateScale and FDSDateTimeScale
         */
        FDSAxis.prototype.ensureScaleTypeMatchesUseIntradaySetting = function (useIntradayScale) {
            var scaleType;
            if (useIntradayScale && (this.scale instanceof FDSDateScale || this.scale instanceof FDSDateTimeScale)) {
                scaleType = FDSIntradayScale;
            }
            else if (!useIntradayScale && (this.scale instanceof FDSIntradayScale)) {
                scaleType = this.scale.getAxisSubType() === 8 /* DATETIME */ ? FDSDateTimeScale : FDSDateScale;
            }
            if (scaleType) {
                this.scale = new scaleType(this.root, this.id + '_SCALE', this);
                this.scale.syncMembers();
                if (this.parent) {
                    this.parent.setNeedUpdate(true);
                }
                this.setNeedUpdate(true);
            }
        };
        FDSAxis.prototype.removeSeries = function (seriesToRemove) {
            var validSeries = false;
            for (var i = 0; i < this.associatedSeries.length; i++) {
                var series = this.associatedSeries[i];
                if (series === seriesToRemove) {
                    this.associatedSeries.splice(i, 1);
                    break;
                }
            }
            for (var _i = 0, _a = this.associatedSeries; _i < _a.length; _i++) {
                var series = _a[_i];
                validSeries = series.hasValidData || validSeries;
            }
            this.seriesHaveValidData = validSeries;
            if (!this.seriesHaveValidData) {
                this.scale = null;
                this.temporaryScale = true;
            }
            if (this.parent != null) {
                this.parent.setNeedUpdate(true);
            }
        };
        FDSAxis.prototype.calculateDimensions = function (computeNewLabelVector) {
            if (computeNewLabelVector === void 0) { computeNewLabelVector = true; }
            if (this.dimension === -1 /* NONE */) {
                return;
            }
            if (this.associatedSeries.length === 0) {
                return;
            }
            if (computeNewLabelVector) {
                this.scale.computeLabelVector();
            }
            this.scale.computeLabelDimensions(this.root.getContext());
            if (this.scale instanceof FDSIntradayScale && computeNewLabelVector) {
                // first time only created an array of all labels. Now that we have the sizes
                // of the labels, we actually fill in the major and minor labels arrays
                var intradayScale = this.scale;
                intradayScale.minorLabelPositionsComputed = intradayScale.majorLabelPositionsComputed = false;
                intradayScale.computeLabelPositions();
            }
            this._seriesListDirty = false;
            var offsets = 0;
            offsets += Math.max(this.labelOffset, 0);
            offsets += Math.max(this.ticksOffset, 0);
            offsets += Math.max(this.axisOffset, 0);
            offsets = scaleByDevicePixelRatio(offsets);
            this.maxDimensions.width = this.scale.maxDimensions.width;
            this.maxDimensions.height = this.scale.maxDimensions.height;
            if (this.dimension === 2 /* Y */) {
                this.maxDimensions.width += this.scale.minorMaxDimensions.width;
                this.maxDimensions.width += this.labelLeftMargin + this.getTickLength() + offsets;
            }
            else {
                this.maxDimensions.height += this.scale.minorMaxDimensions.height;
                this.maxDimensions.height += this.getTickLength() + offsets;
            }
            if (this.dimension === 2 /* Y */) {
                this.maxDimensions.height += 4;
            }
            var plotWidth = this.parent.plotRect.getWidth();
            var plotHeight = this.parent.plotRect.getHeight();
            if ((this.dimension === 1 /* X */ || this.dimension === 2 /* Y */) && plotWidth !== 0 && plotHeight !== 0 &&
                !this._paddingCounted) {
                // get plot padding based on new width and height; adjust plot factor
                var _a = (this.dimension === 1 /* X */) ? ['X', plotWidth] : ['Y', plotHeight], prefix = _a[0], total = _a[1];
                var minPlotPadding = this.parent.attributeSet.get("min" + prefix + "PlotPadding") / total;
                this.minPlotFactor = this.minPlotFactor + minPlotPadding;
                var maxPlotPadding = this.parent.attributeSet.get("max" + prefix + "PlotPadding") / total;
                this.maxPlotFactor = this.maxPlotFactor - maxPlotPadding;
                // error checking
                this.maxPlotFactor = clamp(this.maxPlotFactor, 0, 1);
                this.minPlotFactor = clamp(this.minPlotFactor, 0, 1);
                if (this.maxPlotFactor < this.minPlotFactor) {
                    this.maxPlotFactor = this.minPlotFactor;
                }
                this._paddingCounted = true; // set flag so we don't redo this later
            }
        };
        FDSAxis.prototype.getLabelOverhang = function (plot) {
            var labelsExist = (this.scale.labels != null) && this.scale.labels.length !== 0;
            var minorLabelsExist = (this.scale.minorLabels != null) && this.scale.minorLabels.length !== 0;
            if ((this.scale == null) || (!labelsExist && !minorLabelsExist) || this.labeled === false) {
                return [0, 0];
            }
            var overhangLeft = 0;
            var overhangRight = 0;
            // we have to call a fn due to intraday scale
            // intraday labeling causes minor labels to not be in order, and end labels
            // exist for both major and minor labels
            var first$$1, last$$1;
            if (minorLabelsExist) {
                _a = this.scale.getEdgeMinorLabels(), first$$1 = _a[0], last$$1 = _a[1];
                overhangLeft = this._getOverhangForLabel(plot, first$$1, true);
                overhangRight = this._getOverhangForLabel(plot, last$$1, false);
            }
            if (labelsExist) {
                _b = this.scale.getEdgeMajorLabels(), first$$1 = _b[0], last$$1 = _b[1];
                overhangLeft = Math.max(overhangLeft, this._getOverhangForLabel(plot, first$$1, true));
                overhangRight = Math.max(overhangRight, this._getOverhangForLabel(plot, last$$1, false));
            }
            return [overhangLeft, overhangRight];
            var _a, _b;
        };
        FDSAxis.prototype._getOverhangForLabel = function (plot, label, isFirst) {
            if (isFirst === void 0) { isFirst = false; }
            var labelText = label[0];
            var labelPosition = plot.subPlotFromNDC(label[1], this.dimension);
            // get the context fresh - storing it is a bad idea
            var ctx = this.root.getContext();
            var maxPos;
            var labelWidth;
            if (this.dimension === 1 /* X */) {
                maxPos = plot.plotRect.getWidth();
                var dims = RichTextRenderer.measureRichText(ctx, label[0], this.axisFont)[0];
                labelWidth = dims.width;
            }
            else {
                // If we're a Y axis, we need to flip `labelPosition` in order to
                // get a non-upside-down-value.
                maxPos = plot.plotRect.getHeight();
                labelPosition = maxPos - labelPosition;
                var dims = RichTextRenderer.measureRichText(ctx, label[0], this.axisFont)[0];
                labelWidth = dims.height;
            }
            if (isFirst) {
                return Math.ceil(Math.max(0, (labelWidth / 2) - labelPosition));
            }
            else {
                return Math.ceil(Math.max(0, ((labelWidth / 2) + labelPosition) - maxPos));
            }
        };
        FDSAxis.prototype.drawToBuffer = function (ctx, axisRectAlternate, axisRectPrimary) {
            var plot = this.parent;
            var plotRect = plot.plotRect;
            this._drawLabels(ctx, axisRectAlternate, axisRectPrimary, plotRect, plot);
            this._drawOutlierIndicators(ctx, plotRect, plot);
            this._drawTitle(ctx, axisRectAlternate, axisRectPrimary, plot);
            return true;
        };
        FDSAxis.prototype.getReferenceLine = function () {
            var referenceLineInfo = {
                pen: this._referenceLineFGPen,
                isVertical: this.dimension === 1 /* X */,
                lines: []
            };
            if (!this._referenceLine || !this.scale) {
                return referenceLineInfo;
            }
            var plot = this.parent;
            var referenceNdc = clamp(this.scale.lookup(this.reference), 0, 1);
            var range = Range.fromRectangle(plot.plotRect, flipDim(this.dimension));
            var position = Math.round(plot.plotFromNDC(referenceNdc, this.dimension));
            referenceLineInfo.lines.push({ range: range, position: position });
            return referenceLineInfo;
        };
        FDSAxis.prototype.getAxisLines = function (axisRectAlternate, axisRectPrimary) {
            var result = {
                pen: this.axisFGPen,
                isVertical: this.dimension === 2 /* Y */,
                lines: [],
            };
            if (!this.isAxisLineDrawn()) {
                return result;
            }
            var rectPositions = this._getRectsAndPositions(this.axisPosition, axisRectAlternate, axisRectPrimary);
            for (var _i = 0, rectPositions_1 = rectPositions; _i < rectPositions_1.length; _i++) {
                var _a = rectPositions_1[_i], axisRect = _a[0], axisPosition = _a[1];
                var isOnPrimarySide = this.isOnPrimarySide(axisPosition);
                var offset = isOnPrimarySide ? this.axisOffset : -this.axisOffset;
                var range = Range.fromRectangle(Rectangle.AABB([axisRect, this.parent.plotRect]), this.dimension);
                var position = void 0;
                if (this.dimension === 1 /* X */) {
                    position = offset + (isOnPrimarySide ? axisRect.y1 : axisRect.y2);
                }
                else {
                    position = offset + (isOnPrimarySide ? axisRect.x1 : axisRect.x2);
                }
                result.lines.push({ range: range, position: position });
            }
            return result;
        };
        FDSAxis.prototype.drawAlternatingBackground = function (ctx) {
            if (!this._alternatingBackground || !(this.scale instanceof FDSIntradayScale)) {
                return;
            }
            var plot = this.parent;
            var plotRect = plot.plotRect;
            var scale = this.scale;
            var mtiLen = scale.majorTickInfo.length;
            if (mtiLen === 0) {
                return;
            }
            var filled = scale.majorTickInfo[0].bgFilled;
            var p0;
            if (scale.reverse) {
                p0 = Math.round(plot.subPlotFromNDC(1, this.dimension));
            }
            else {
                p0 = Math.round(plot.subPlotFromNDC(0, this.dimension));
            }
            var width, height;
            if (this.dimension === 1 /* X */) {
                height = plotRect.y2 - plotRect.y1;
            }
            else {
                width = plotRect.x2 - plotRect.x1;
            }
            if (!(this.attributeSet.isDefault('AlternatingBackgroundFactor'))) {
                // values copied from PC side
                var colorScale = 0.75;
                var colorThreshold = 105;
                var _a = plot.getEffectiveBGBrush(), tempBrush = _a[0], rect = _a[1];
                var brush = tempBrush.copy();
                brush.color = FDSColor.adjustLightnessByFactor(brush.color, this._alternatingBackgroundFactor, colorThreshold, colorScale);
                brush.gradientColor = FDSColor.adjustLightnessByFactor(brush.gradientColor, this._alternatingBackgroundFactor, colorThreshold, colorScale);
                brush.setOnCanvas(ctx, rect);
            }
            else {
                var brush = this._intradayMajorUnitBGBrush;
                brush.setOnCanvas(ctx, plotRect);
            }
            // one step for every tick, and an extra step at the end for the last rect
            for (var i = 0; i <= mtiLen; i++) {
                var ndc = void 0;
                if (i === mtiLen) {
                    // last rect
                    if (scale.reverse) {
                        ndc = 0;
                    }
                    else {
                        ndc = 1;
                    }
                }
                else {
                    ndc = scale.majorTickInfo[i].ndc;
                }
                var p1 = Math.round(plot.subPlotFromNDC(ndc, this.dimension));
                if (!fuzzyEQ(p0, p1) && filled) {
                    var start = void 0;
                    switch (this.dimension) {
                        case 1 /* X */:
                            width = Math.abs(p1 - p0);
                            start = Math.min(p0, p1);
                            ctx.fillRect(plotRect.x1 + start, plotRect.y1, width, height);
                            break;
                        default:
                            height = Math.abs(p1 - p0);
                            start = Math.min(p0, p1);
                            ctx.fillRect(plotRect.x1, plotRect.y1 + start, width, height);
                    }
                }
                filled = !filled;
                p0 = p1;
            }
        };
        FDSAxis.prototype.getGridLines = function () {
            var _this = this;
            var plot = this.parent;
            var gridLineInfo = [];
            var range = Range.fromRectangle(plot.plotRect, flipDim(this.dimension));
            var getLineInfo = function (pen, ndcValues) { return ({
                pen: pen,
                isVertical: _this.dimension === 1 /* X */,
                lines: ndcValues.map(function (ndc) { return ({
                    range: range,
                    position: Math.round(plot.plotFromNDC(ndc, _this.dimension)),
                }); }),
            }); };
            if (this._minorGrid && this._minorGridFGPen.style !== 5 /* NULL */) {
                gridLineInfo.push(getLineInfo(this._minorGridFGPen, this.scale.subTicks));
            }
            if (this._grid && this._gridFGPen.style !== 5 /* NULL */) {
                var axisSeries = this.lookupAxisSeries();
                var majorTicks = axisSeries ? this._getAxisSeriesTicks(axisSeries) : this.scale.ticks;
                gridLineInfo.push(getLineInfo(this._gridFGPen, majorTicks));
            }
            return gridLineInfo;
        };
        FDSAxis.prototype._getAxisSeriesTicks = function (axisSeries) {
            if (this.dimension !== 1 /* X */ && this.dimension !== 2 /* Y */) {
                return [];
            }
            var ticks = [];
            var data = axisSeries.getData(this.dimension);
            var pScale = this.getScale();
            for (var i = 0; i < axisSeries.size; i++) {
                var value = data.getAt(i);
                if (IsSomeNAN(value)) {
                    continue;
                }
                var val = pScale.lookup(value);
                if (isBounded(val, 0, 1)) {
                    ticks.push(val);
                }
            }
            return ticks;
        };
        FDSAxis.prototype.getTickLines = function (axisRectAlternate, axisRectPrimary) {
            var _this = this;
            var tickInfo = {
                pen: this._ticksFGPen,
                isVertical: this.dimension === 1 /* X */,
                lines: [],
            };
            if (this.ticksPosition === 4 /* HIDDEN */ || this._ticksFGPen.style === 5 /* NULL */) {
                return tickInfo;
            }
            var _a = this._getTickLengths(), majorTickLength = _a.majorTickLength, minorTickLength = _a.minorTickLength;
            // no ticks should be drawn if the tickLength is 0
            if (majorTickLength === 0) {
                return tickInfo;
            }
            var axisSeries = this.lookupAxisSeries();
            var majorTicks = axisSeries ? this._getAxisSeriesTicks(axisSeries) : this.scale.ticks;
            var minorTicks = axisSeries ? [] : this.scale.subTicks;
            var plot = this.parent;
            var otherDim = flipDim(this.dimension);
            var rectPositions = this._getRectsAndPositions(this.ticksPosition, axisRectAlternate, axisRectPrimary);
            var _loop_1 = function (axisRect, axisPosition) {
                var rectRange = Range.fromRectangle(axisRect, otherDim);
                var isOnPrimarySide = this_1.isOnPrimarySide(axisPosition);
                // When drawing from right to left, we need to offset by one pixel.
                // This is because drawing starts at the left edge of the pixel, and
                // if we didn't do this, the tick wouldn't overlap with the axis line
                // on the left side of the plot.
                var tickOffset = scaleByDevicePixelRatioAndRound(this_1.ticksOffset);
                var tickStart = (isOnPrimarySide ? rectRange.start : rectRange.end + 1) + tickOffset;
                var tickDirection = isOnPrimarySide ? 1 : -1;
                var appendTickLines = function (ndcValues, tickLength) {
                    // A tick, as drawn below will overlap with the axis line.
                    // To draw a tickLength of 4, it actually needs to be 5 pixels, so we add 1
                    // *
                    // *
                    // -----
                    // *
                    // *
                    var adjustedTickLength = tickLength + 1;
                    var tickEnd = tickStart + adjustedTickLength * tickDirection;
                    var range = new Range(Math.min(tickStart, tickEnd), Math.max(tickStart, tickEnd));
                    for (var _i = 0, ndcValues_1 = ndcValues; _i < ndcValues_1.length; _i++) {
                        var ndc = ndcValues_1[_i];
                        var position = Math.round(plot.plotFromNDC(ndc, _this.dimension));
                        tickInfo.lines.push({ range: range, position: position });
                    }
                };
                if (this_1._ticks) {
                    appendTickLines(majorTicks, majorTickLength);
                }
                if (this_1._minorTicks) {
                    appendTickLines(minorTicks, minorTickLength);
                }
            };
            var this_1 = this;
            for (var _i = 0, rectPositions_2 = rectPositions; _i < rectPositions_2.length; _i++) {
                var _b = rectPositions_2[_i], axisRect = _b[0], axisPosition = _b[1];
                _loop_1(axisRect, axisPosition);
            }
            return tickInfo;
        };
        FDSAxis.prototype._getTickLengths = function () {
            var tickLengths = { majorTickLength: 0, minorTickLength: 0 };
            var heightOrWidth = this.dimension === 1 /* X */ ? 'height' : 'width';
            if (this._ticks) {
                tickLengths.majorTickLength = this.getTickLength();
                if (this._extendMajorTicks && this.scale.getLabelBinned()) {
                    var extendedLength = this.scale.maxDimensions[heightOrWidth] + this.scale.minorMaxDimensions[heightOrWidth];
                    tickLengths.majorTickLength += extendedLength;
                }
            }
            if (this._minorTicks) {
                var minorFactor = clamp(this._minorTicksLengthFactor, 0, 1);
                tickLengths.minorTickLength = ~~(minorFactor * this.getTickLength());
                if (this._extendMinorTicks && this.scale.getMinorLabelBinned()) {
                    tickLengths.minorTickLength += this.scale.minorMaxDimensions[heightOrWidth];
                }
            }
            return tickLengths;
        };
        FDSAxis.prototype._drawLabels = function (ctx, axisRectAlternate, axisRectPrimary, plotRect, plot) {
            this.clearLabels();
            if (!this.areLabelsDrawn()) {
                return;
            }
            if (this._labelPadded && this.scale.scaleType === 3 /* DOUBLE */) {
                this.scale.setPadLabels(true);
            }
            else {
                this.scale.setPadLabels(false);
            }
            var rectsAndPositions = this._getRectsAndPositions(this.labelPosition, axisRectAlternate, axisRectPrimary);
            // reset the pixel points array
            this.root.pixelPoints[this.id] = {};
            var ticksFGProps = this._ticksFGPen.toPropertyObject();
            var tickLength = this.getTickLength();
            ctx.save();
            // Special series that provides a custom axis based on series data.
            var axisSeries = this.lookupAxisSeries();
            // If there is an axis series we render the labels based on the data
            if (axisSeries !== undefined) {
                // Keeping this as a separate function because there is just enough non-C&P to
                // warrant having it.
                this._drawAxisSeriesLabels(ctx, axisSeries, plot, plotRect, rectsAndPositions, ticksFGProps);
            }
            else {
                // set up objects to hold info for the major and the minor labels
                var major = {
                    labels: this.scale.labels,
                    font: this.axisFont,
                    offset: this.dimension === 2 /* Y */ ?
                        this.scale.minorMaxDimensions.width :
                        this.scale.minorMaxDimensions.height,
                    levelIndex: 0
                };
                var minor = {
                    labels: this.scale.minorLabels,
                    font: this.axisMinorFont,
                    offset: 0,
                    levelIndex: 1
                };
                this._minTitleOffset = -1;
                for (var _i = 0, rectsAndPositions_1 = rectsAndPositions; _i < rectsAndPositions_1.length; _i++) {
                    var _a = rectsAndPositions_1[_i], axisRect = _a[0], position = _a[1];
                    var pixelObjectCleared = 0;
                    for (var _b = 0, _c = [minor, major]; _b < _c.length; _b++) {
                        var level = _c[_b];
                        var drawnLabels = [];
                        var curMin = Infinity;
                        var curMax = 0;
                        if (level.labels.length === 0) {
                            continue;
                        }
                        switch (this.dimension) {
                            case 1 /* X */:
                                level.font = level.font.with({ alignment: 2 /* CENTER */ });
                                break;
                            case 2 /* Y */:
                                level.font = level.font.with({ alignment: this._getAxisLabelsFontAlignment(position) });
                                break;
                        }
                        var offsets = 0;
                        if (this.axisPosition === position || this.axisPosition === 2 /* BOTH */) {
                            offsets += this.axisOffset;
                        }
                        if (this.ticksPosition === position || this.ticksPosition === 2 /* BOTH */) {
                            offsets += this.ticksOffset + tickLength;
                        }
                        offsets += scaleByDevicePixelRatio(this.labelOffset);
                        for (var labelIndex = 0; labelIndex < level.labels.length; labelIndex++) {
                            var _d = level.labels[labelIndex], labelText = _d[0], labelNDC = _d[1], _e = _d[2], labelAlignment = _e === void 0 ? level.font.alignment : _e;
                            var _f = RichTextRenderer.measureRichText(ctx, labelText, level.font), labelMetrics = _f[0], preparedText = _f[1];
                            var labelX = void 0, labelY = void 0;
                            switch (this.dimension) {
                                case 1 /* X */:
                                    labelX = (axisRect.x1 + (plot.subPlotFromNDC(labelNDC, this.dimension))) -
                                        (labelMetrics.width / 2);
                                    if (this.isOnPrimarySide(position)) {
                                        labelY = axisRect.y1 + offsets + level.offset;
                                    }
                                    else {
                                        labelY = axisRect.y2 - offsets - level.offset - labelMetrics.height;
                                    }
                                    // this will end with the min as the first label x, and the max as the last one
                                    if (this._minTitleOffset < 0) {
                                        this._minTitleOffset = labelX;
                                    }
                                    this._maxTitleOffset = labelX + labelMetrics.width;
                                    break;
                                case 2 /* Y */:
                                    labelX = axisRect.rectNdcToGlobalPixels(this._axisNDC(position, axisRect.toRectNDC(offsets, 1 /* X */)), 1 /* X */);
                                    labelX += level.offset;
                                    var maxLabelWidth = this.scale.maxDimensions.width;
                                    if (!this.isOnPrimarySide(position)) {
                                        labelX -= maxLabelWidth;
                                    }
                                    labelY = (axisRect.y1 + (plot.subPlotFromNDC(labelNDC, this.dimension))) -
                                        (~~(labelMetrics.height / 2)) - 1;
                                    // this will end with the min as the first label y, and the max as the last one
                                    if (this._minTitleOffset < 0) {
                                        this._minTitleOffset = labelY + labelMetrics.height;
                                    }
                                    this._maxTitleOffset = labelY;
                                    labelX += RichTextRenderer.calcXOffsetForTextAlignment(labelAlignment, labelMetrics, maxLabelWidth);
                                    break;
                            }
                            if (this.dimension === 1 /* X */ || this.dimension === 2 /* Y */) {
                                if (this.scale.shouldCheckLabelsForOverlap) {
                                    var edge1 = void 0, edge2 = void 0;
                                    switch (this.dimension) {
                                        case 1 /* X */:
                                            edge1 = labelX;
                                            edge2 = labelX + labelMetrics.width;
                                            break;
                                        case 2 /* Y */:
                                            edge1 = labelY;
                                            edge2 = labelY + labelMetrics.height;
                                            break;
                                    }
                                    if (this._doesLabelOverlapDrawnLabels(edge1, edge2, curMax, curMin, drawnLabels)) {
                                        continue;
                                    }
                                    drawnLabels.push([edge1, edge2]);
                                    curMin = Math.min(edge1, curMin);
                                    curMax = Math.max(edge2, curMax);
                                }
                                RichTextRenderer.writeRichText(ctx, labelText, labelX, labelY, level.font, labelAlignment, preparedText);
                                if (this._labelTooltipEnabled) {
                                    // now save this box for hit shapes later
                                    var rect = new Rectangle(labelX, labelY, labelX + labelMetrics.width, labelY + labelMetrics.height);
                                    if (this.attributeSet.isDefault('LabelTooltipText')) {
                                        // default to the long (plain) version of the label
                                        rect['hoverText'] = RichTextRenderer.convertToPlaintext(labelText);
                                    }
                                    else {
                                        rect['hoverText'] = this._labelTooltipText;
                                    }
                                    var id = this.isBuiltInAxis ? this._prefix : this.id;
                                    plot.addAxisRect(id, rect, 'Axis');
                                }
                                var labelRect = new Rectangle(labelX, labelY, labelX + labelMetrics.width, labelY + labelMetrics.height);
                                var labelInfoArray = (level === major) ? this._labels.major : this._labels.minor;
                                labelInfoArray.push({ labelRect: labelRect, labelText: labelText.toString() });
                            }
                            // now save the pixel points of the center of the label
                            var x = Math.round(labelX + (labelMetrics.width / 2));
                            var y = Math.round(labelY + (labelMetrics.height / 2));
                            if (pixelObjectCleared <= labelIndex) {
                                // create/reset the object on the first pass through
                                this.root.pixelPoints[this.id][labelIndex] = [];
                            }
                            this.root.pixelPoints[this.id][labelIndex][level.levelIndex] = { x: x, y: y };
                        }
                        // at this point we've gone through the whole loop, the object has been set up
                        pixelObjectCleared += 1;
                    }
                }
            }
            // Important to reset text alignment since it's persistent throughout the
            // lifetime of the draw context
            ctx.restore();
        };
        // Rendering series axis labels. Separate function for sake of sanity.
        FDSAxis.prototype._drawAxisSeriesLabels = function (ctx, axisSeries, plot, plotRect, rectsAndPositions, ticksFGProps) {
            // We need the dimensional data and the value dimension, as well as the scale and size of the series
            var data = axisSeries.getData(this.dimension);
            var vData = axisSeries.getData(0 /* VALUE */);
            var pScale = this.getScale();
            // Used as part of the prefix in certain cases.
            var dataId = (axisSeries.getData(0 /* VALUE */)).dataId + ' ';
            // The prefix and postfix (if defined) will be added to the front and back of the label respectively.
            var prefixStr = pScale.labelPrefix;
            if (dataId !== ' ') {
                prefixStr = prefixStr.concat(dataId);
            }
            var postfixStr = pScale.labelPostfix;
            for (var _i = 0, rectsAndPositions_2 = rectsAndPositions; _i < rectsAndPositions_2.length; _i++) {
                var _a = rectsAndPositions_2[_i], axisRect = _a[0], position = _a[1];
                var fontAlignment = void 0;
                switch (this.dimension) {
                    case 1 /* X */:
                        fontAlignment = 2 /* CENTER */;
                        break;
                    case 2 /* Y */:
                        fontAlignment = this._getAxisLabelsFontAlignment(position);
                        break;
                }
                var offsets = 0;
                if (this.axisPosition === position || this.axisPosition === 2 /* BOTH */) {
                    offsets += this.axisOffset;
                }
                if (this.ticksPosition === position || this.ticksPosition === 2 /* BOTH */) {
                    offsets += this.ticksOffset + this.getTickLength();
                }
                offsets += scaleByDevicePixelRatio(this.labelOffset);
                var drawnLabels = [];
                var curMin = Infinity;
                var curMax = 0;
                var labelX = void 0, labelY = void 0;
                var edge1 = void 0, edge2 = void 0;
                for (var j = 0; j < axisSeries.size; j++) {
                    // Find the data point, transform to NDC, and confirm no shenanigans.
                    var value = data.getAt(j);
                    if (IsSomeNAN(value)) {
                        continue;
                    }
                    var ndcVal = pScale.lookup(value);
                    if ((ndcVal < 0.0) || (ndcVal > 1.0)) {
                        continue;
                    }
                    var valuePos = plot.subPlotFromNDC(ndcVal, this.dimension);
                    // Add the prefix and postfix around the data value to form the label
                    var labelStr = vData.printAt(j);
                    var completeString = RichTextString.join(prefixStr, labelStr, postfixStr);
                    var _b = RichTextRenderer.measureRichText(ctx, completeString, this.axisFont), labelMetrics = _b[0], preparedText = _b[1];
                    // Determine the final position of the text.
                    if (this.dimension === 1 /* X */) {
                        labelX = (axisRect.x1 + valuePos) - ((labelMetrics.width / 2) | 0);
                        labelY = axisRect.y1 + offsets;
                        edge1 = labelX;
                        edge2 = labelX + labelMetrics.width;
                    }
                    else if (this.dimension === 2 /* Y */) {
                        labelX = axisRect.rectNdcToGlobalPixels(this._axisNDC(position, (axisRect.toRectNDC(offsets, 1 /* X */))), 1 /* X */);
                        var maxLabelWidth = this.scale.maxDimensions.width;
                        if (!this.isOnPrimarySide(position)) {
                            labelX -= maxLabelWidth;
                        }
                        labelY = (axisRect.y1 + valuePos) - (~~(labelMetrics.height / 2));
                        edge1 = labelY;
                        edge2 = labelY + labelMetrics.height;
                        labelX += RichTextRenderer.calcXOffsetForTextAlignment(fontAlignment, labelMetrics, maxLabelWidth);
                    }
                    if (this._doesLabelOverlapDrawnLabels(edge1, edge2, curMax, curMin, drawnLabels)) {
                        continue;
                    }
                    // if we get here we're not overlapping - save some info
                    drawnLabels.push([edge1, edge2]);
                    if (edge1 < curMin) {
                        curMin = edge1;
                    }
                    if (edge2 > curMax) {
                        curMax = edge2;
                    }
                    RichTextRenderer.writeRichText(ctx, completeString, labelX, labelY, this.axisFont, fontAlignment, preparedText);
                    var labelRect = new Rectangle(labelX, labelY, labelX + labelMetrics.width, labelY + labelMetrics.height);
                    var labelText = completeString.toString();
                    this._labels.major.push({ labelRect: labelRect, labelText: labelText });
                    // now save the pixel points of the center of the label
                    var x = Math.round(labelX + (labelMetrics.width / 2));
                    var y = Math.round(labelY + (labelMetrics.height / 2));
                    this.root.pixelPoints[this.id][j] = [{ x: x, y: y }];
                }
            }
        };
        FDSAxis.prototype._doesLabelOverlapDrawnLabels = function (a, b, curMax, curMin, drawnLabels) {
            // short circuit if we're outside all drawn labels
            if (a > curMax || b < curMin) {
                return false;
            }
            // check every drawn label in reverse (since overlaps are liklier to happen at the end)
            for (var j = drawnLabels.length - 1; j >= 0; j--) {
                var label = drawnLabels[j];
                if ((a < label[0] && b > label[0]) || (a < label[1] && b > label[1]) || (a > label[0] && b < label[1])) {
                    return true;
                }
            }
            // we're not overlapping any drawn labels
            return false;
        };
        FDSAxis.prototype._drawTitle = function (ctx, axisRectAlternate, axisRectPrimary, plot) {
            // reset pixel points
            this.root.axisTitlePixelPoints[this.id] = undefined;
            if (this.dimension !== 1 /* X */ && this.dimension !== 2 /* Y */) {
                return;
            }
            if (!this.titleEnabled) {
                return;
            }
            if (this.titleAtEnd) {
                this._drawTitleAtEnd(ctx, axisRectAlternate, axisRectPrimary, plot);
                return;
            }
            var position = this._adjustPosition();
            var titleText = this.compiledTitleText.fromValueRT();
            var _a = this.getTitleDimensions(ctx, titleText), width = _a[0], height = _a[1], richtext = _a[2];
            var _b = this.dimension === 1 /* X */ ? ({
                minPt: axisRectPrimary.x1,
                maxPt: axisRectPrimary.x2,
                minAdj: 0,
                maxAdj: width,
                halfSize: width / 2
            }) : ({
                minPt: axisRectPrimary.y2,
                maxPt: axisRectPrimary.y1,
                minAdj: height,
                maxAdj: 0,
                halfSize: height / 2
            }), minPt = _b.minPt, maxPt = _b.maxPt, minAdj = _b.minAdj, maxAdj = _b.maxAdj, halfSize = _b.halfSize;
            var mainDimPt;
            switch (this.titleValuePosition) {
                case 1 /* MIN */:
                    if (this._titleTieWithEndLabel) {
                        mainDimPt = this._minTitleOffset - minAdj;
                    }
                    else {
                        mainDimPt = minPt - minAdj;
                    }
                    break;
                case 2 /* MAX */:
                    if (this._titleTieWithEndLabel) {
                        mainDimPt = this._maxTitleOffset - maxAdj;
                    }
                    else {
                        mainDimPt = maxPt - maxAdj;
                    }
                    break;
                default:
                    // richTextRenderer takes in the upper left point, so we subtract half the label size from the center pt
                    mainDimPt = (minPt + ((maxPt - minPt) / 2)) - halfSize;
            }
            var id = this.isBuiltInAxis ? this._prefix : this.id;
            var titleFont = this.titleFont;
            var x, y;
            var rect, pixelRect;
            // here we write the text and also save the rect for later hitshapes
            switch (this.dimension) {
                case 1 /* X */:
                    x = mainDimPt;
                    if ((position === 0 /* NORMAL */) || (position === 2 /* BOTH */)) {
                        y = axisRectPrimary.y2 - height;
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                        rect = new Rectangle(x, y, x + width, y + height);
                        plot.addAxisRect(id, rect, 'AxisTitle');
                        pixelRect = rect;
                    }
                    if ((position === 1 /* ALTERNATE */) || (position === 2 /* BOTH */)) {
                        y = axisRectAlternate.y1;
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                        rect = new Rectangle(x, y, x + width, y + height);
                        plot.addAxisRect(id, rect, 'AxisTitle');
                        if (pixelRect == null) {
                            pixelRect = rect;
                        }
                    }
                    break;
                case 2 /* Y */:
                    y = mainDimPt;
                    if ((position === 0 /* NORMAL */) || (position === 2 /* BOTH */)) {
                        x = axisRectPrimary.x2 - width;
                        // adjust font escapement for this side (left=false)
                        titleFont = this._adjustTitleForRotationMode(titleFont, false);
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                        rect = new Rectangle(x, y, x + width, y + height);
                        plot.addAxisRect(id, rect, 'AxisTitle');
                        if (pixelRect == null) {
                            pixelRect = rect;
                        }
                    }
                    if ((position === 1 /* ALTERNATE */) || (position === 2 /* BOTH */)) {
                        x = axisRectAlternate.x1;
                        // adjust font escapement for this side (left=true)
                        titleFont = this._adjustTitleForRotationMode(titleFont, true);
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                        rect = new Rectangle(x, y, x + width, y + height);
                        plot.addAxisRect(id, rect, 'AxisTitle');
                        if (pixelRect == null) {
                            pixelRect = rect;
                        }
                    }
                    break;
            }
            // for the pixel point we just need one title, doesn't matter which one
            var pixX = pixelRect.x1 + (pixelRect.getWidth() / 2);
            var pixY = pixelRect.y1 + (pixelRect.getHeight() / 2);
            this.root.axisTitlePixelPoints[this.id] = { x: pixX, y: pixY };
        };
        FDSAxis.prototype._adjustTitleForRotationMode = function (titleFont, left) {
            if ((this._titleRotationMode === 1 /* IN */ && !left) ||
                (this._titleRotationMode === 2 /* OUT */ && left)) {
                // face left
                return titleFont.with({ escapement: Math.PI / 2 });
            }
            if ((this._titleRotationMode === 1 /* IN */ && left) ||
                (this._titleRotationMode === 2 /* OUT */ && !left)) {
                // face right
                return titleFont.with({ escapement: -Math.PI / 2 });
            }
            return titleFont;
        };
        FDSAxis.prototype.getTitleDimensions = function (ctx, text) {
            this.titleFont.setOnCanvas(ctx);
            if (text == null) {
                text = this.compiledTitleText.fromValueRT();
            }
            var _a = RichTextRenderer.measureRichText(ctx, text, this.titleFont), dims = _a[0], richtext = _a[1];
            return [dims.width, dims.height, richtext];
        };
        FDSAxis.prototype._drawTitleAtEnd = function (ctx, axisRectAlternate, axisRectPrimary, plot) {
            var position = this._adjustPosition();
            var titleText = this.compiledTitleText.fromValueRT();
            var _a = this.getTitleDimensions(ctx, titleText), width = _a[0], height = _a[1], richtext = _a[2];
            var titleFont = this.titleFont;
            var x, y;
            switch (this.dimension) {
                case 1 /* X */:
                    // find x position
                    if (this.titleValuePosition === 1 /* MIN */) {
                        x = plot.plotRect.x1 - plot.leftAxisWidth - width - this.titleOffset;
                    }
                    else {
                        x = (plot.plotRect.x2 + plot.rightAxisWidth + this.titleOffset) - width;
                    }
                    // find y and draw (potentially twice)
                    if (position === 0 /* NORMAL */ || position === 2 /* BOTH */) {
                        y = plot.plotRect.y2 - height;
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                    }
                    if (position === 1 /* ALTERNATE */ || position === 2 /* BOTH */) {
                        y = plot.plotRect.y1;
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                    }
                    break;
                case 2 /* Y */:
                    // find y position
                    if (this.titleValuePosition === 1 /* MIN */) {
                        y = (plot.plotRect.y2 + plot.bottomAxisHeight + this.titleOffset) - height;
                    }
                    else {
                        y = plot.plotRect.y1 - plot.topAxisHeight - this.titleOffset;
                    }
                    // find x and draw (potentially twice)
                    if (position === 0 /* NORMAL */ || position === 2 /* BOTH */) {
                        titleFont = this._adjustTitleForRotationMode(titleFont, false);
                        x = plot.plotRect.x2 - width;
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                    }
                    if (position === 1 /* ALTERNATE */ || position === 2 /* BOTH */) {
                        titleFont = this._adjustTitleForRotationMode(titleFont, true);
                        x = plot.plotRect.x1;
                        RichTextRenderer.writeRichText(ctx, titleText, x, y, titleFont, null, richtext);
                    }
                    break;
            }
        };
        FDSAxis.prototype._adjustPosition = function () {
            var defaultAP = 0;
            var altAP = 1;
            if (this.scaleSpecifier === 128 /* Y2 */) {
                defaultAP = 1 /* ALTERNATE */;
                altAP = 0 /* NORMAL */;
            }
            switch (this.titlePosition) {
                case 0 /* NORMAL */:
                    return defaultAP;
                case 1 /* ALTERNATE */:
                    return altAP;
            }
            return this.titlePosition;
        };
        // Renders outlier indicators on the axis. These are separate and different
        // than Series Outlier Markers.
        FDSAxis.prototype._drawOutlierIndicators = function (ctx, plotRect, plot) {
            if (!this.scale.outlierActive() || !this._outlierIndicator) {
                return;
            }
            ctx.save();
            // Set up Pen and Brush
            this._outlierIndicatorFGPen.setOnCanvas(ctx);
            this._outlierIndicatorBGBrush.setOnCanvas(ctx);
            var markerStyle = this._outlierIndicatorMarkerStyle;
            var markerSize = this._outlierIndicatorMarkerSize;
            var factor = this._outlierIndicatorFactor;
            var position = 0;
            if (this._ticks && (this.ticksPosition !== 4 /* HIDDEN */)) {
                position = this.ticksPosition;
            }
            else if (this.labeled && (this.labelPosition !== 4 /* HIDDEN */)) {
                position = this.labelPosition;
            }
            if (this.scale.upperOutlierActive()) {
                var ndcFactor = this.scale.getOutlierMaxNDC(factor);
                var subNDC = ~~(plot.subPlotFromNDC(ndcFactor, this.dimension));
                var markerX = 0;
                var markerY = 0;
                if (this.dimension === 1 /* X */) {
                    if ((position === 0 /* NORMAL */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x1 + subNDC;
                        markerY = plotRect.y2;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if ((position === 1 /* ALTERNATE */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x1 + subNDC;
                        markerY = plotRect.y1;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if (position === 3 /* MIDDLE */) {
                        markerX = plotRect.x1 + subNDC;
                        markerY = plotRect.y1 + ((plotRect.y2 - plotRect.y1) / 2);
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                }
                else if (this.dimension === 2 /* Y */) {
                    if ((position === 0 /* NORMAL */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x2;
                        markerY = plotRect.y1 + subNDC;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if ((position === 1 /* ALTERNATE */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x1;
                        markerY = plotRect.y1 + subNDC;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if (position === 3 /* MIDDLE */) {
                        markerX = plotRect.x1 + ((plotRect.x2 - plotRect.x1) / 2);
                        markerY = plotRect.y1 + subNDC;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                }
            }
            if (this.scale.lowerOutlierActive()) {
                var ndcFactor = this.scale.getOutlierMinNDC(factor);
                var subNDC = ~~(plot.subPlotFromNDC(ndcFactor, this.dimension));
                var markerX = 0;
                var markerY = 0;
                if (this.dimension === 1 /* X */) {
                    if ((position === 0 /* NORMAL */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x1 + subNDC;
                        markerY = plotRect.y2;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if ((position === 1 /* ALTERNATE */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x1 + subNDC;
                        markerY = plotRect.y1;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if (position === 3 /* MIDDLE */) {
                        markerX = plotRect.x1 + subNDC;
                        markerY = plotRect.y1 + ((plotRect.y2 - plotRect.y1) / 2);
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                }
                else if (this.dimension === 2 /* Y */) {
                    if ((position === 0 /* NORMAL */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x2;
                        markerY = plotRect.y1 + subNDC;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if ((position === 1 /* ALTERNATE */) || (position === 2 /* BOTH */)) {
                        markerX = plotRect.x1;
                        markerY = plotRect.y1 + subNDC;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if (position === 3 /* MIDDLE */) {
                        markerX = plotRect.x1 + ((plotRect.x2 - plotRect.x1) / 2);
                        markerY = plotRect.y1 + subNDC;
                        this._drawOutlierMarker(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                }
            }
            ctx.restore();
        };
        // Draws a marker at the outlier axis position. Just so we can avoid a lot of duplication above.
        FDSAxis.prototype._drawOutlierMarker = function (ctx, markerX, markerY, markerStyle, markerSize) {
            // Handle anti-aliasing
            var props = this._outlierIndicatorFGPen.toPropertyObject();
            markerX += props.aliasOffset;
            markerY += props.aliasOffset;
            var drawFunc = getMarkerDrawFunctor(markerStyle, markerSize, props.willDrawStroke);
            if (drawFunc !== undefined) {
                ctx.beginPath();
                drawFunc(ctx, markerX, markerY);
                ctx.fill();
                ctx.stroke();
            }
        };
        // Renders a rectangle that is both filled in, and has a border.
        // NOTE: I am doing this manually to facilitate being able to use clip() for text clipping.
        //       Clipping will not work with drawRect() from what I've seen.
        FDSAxis.prototype._drawRectangleLabel = function (ctx, x, y, width, height) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + width, y);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x, y + height);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        // Renders a circle that is both filled in, and has a border.
        FDSAxis.prototype._drawCircleLabel = function (ctx, x, y, radius) {
            ctx.beginPath();
            ctx.ellipse(x, y, radius / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        // Renders an ellipse that is both filled in, and has a border.
        FDSAxis.prototype._drawEllipseLabel = function (ctx, x, y, width, height) {
            var biggestDim = Math.max(width, height);
            ctx.beginPath();
            ctx.ellipse(x, y, width / 2, height / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        // Render a marker, where one end is a pointed arrow. Filled in, with a border.
        FDSAxis.prototype._drawMarkerLabel = function (ctx, x, y, width, height, altSide) {
            // Determines the size of the arrow
            var arrowOffset = (this.getTickLength() + this.ticksOffset) * this._crosshairsLabelTextBoxArrowMultiplier;
            // Base rectangle coordinates used to create the marker
            var rectX = x - (width / 2);
            var rectY = y - (height / 2);
            var rectW = width;
            var rectH = height;
            // Figure out where the arrow is actually pointing
            var arrowDirection = -1;
            // Determine arrow direction
            if (this.dimension === 2 /* Y */ && altSide === false) {
                arrowDirection = 2 /* LEFT */;
            }
            if (this.dimension === 2 /* Y */ && altSide === true) {
                arrowDirection = 3 /* RIGHT */;
            }
            if (this.dimension === 1 /* X */ && altSide === false) {
                arrowDirection = 0 /* UP */;
            }
            if (this.dimension === 1 /* X */ && altSide === true) {
                arrowDirection = 1 /* DOWN */;
            }
            // Draw Marker
            ctx.beginPath();
            ctx.moveTo(rectX, rectY);
            if (arrowDirection === 0 /* UP */) {
                ctx.lineTo(rectX + (rectW / 2), rectY - arrowOffset);
            }
            ctx.lineTo(rectX + rectW, rectY);
            if (arrowDirection === 3 /* RIGHT */) {
                ctx.lineTo(rectX + rectW + arrowOffset, rectY + (rectH / 2));
            }
            ctx.lineTo(rectX + rectW, rectY + rectH);
            if (arrowDirection === 1 /* DOWN */) {
                ctx.lineTo(rectX + (rectW / 2), rectY + rectH + arrowOffset);
            }
            ctx.lineTo(rectX, rectY + rectH);
            if (arrowDirection === 2 /* LEFT */) {
                ctx.lineTo(rectX - arrowOffset, rectY + (rectH / 2));
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        // Calculates width and height for crosshair axes label shapes
        FDSAxis.prototype.computeAxesLabelsShapeDimensions = function (textWidth, textHeight) {
            var crosshairsLabelWidthHint = scaleByDevicePixelRatio(this._crosshairsLabelTextBoxWidthHint);
            var crosshairsLabelHeightHint = scaleByDevicePixelRatio(this._crosshairsLabelTextBoxHeightHint);
            // Stores hints for width and height of the label. These are determined by the sizing mode.
            var heightHint = 0;
            var widthHint = 0;
            switch (this._crosshairsLabelTextBoxSizingMode) {
                case 0 /* DEFAULT */:
                    if (this._crosshairsLabelTextBoxDisplayStyle === 1 /* CIRCLE */) {
                        widthHint = heightHint = Math.max(textWidth, textHeight);
                    }
                    else {
                        widthHint = textWidth;
                        heightHint = textHeight;
                    }
                    break;
                case 2 /* CUSTOM_FORCE */:
                    if (this._crosshairsLabelTextBoxDisplayStyle === 1 /* CIRCLE */) {
                        widthHint = heightHint = crosshairsLabelHeightHint;
                    }
                    else {
                        widthHint = crosshairsLabelWidthHint;
                        heightHint = crosshairsLabelHeightHint;
                    }
                    break;
                case 1 /* CUSTOM_HINT */:
                    if (this._crosshairsLabelTextBoxDisplayStyle === 1 /* CIRCLE */) {
                        var tmpW = Math.max(textWidth, crosshairsLabelWidthHint);
                        var tmpH = Math.max(textHeight, crosshairsLabelHeightHint);
                        widthHint = heightHint = Math.max(tmpW, tmpH);
                    }
                    else {
                        widthHint = Math.max(textWidth, crosshairsLabelWidthHint);
                        heightHint = Math.max(textHeight, crosshairsLabelHeightHint);
                    }
                    break;
            }
            // Extra padding for when we're not using FC_SIZE_CUSTOM_FORCE
            var padding = scaleByDevicePixelRatio(this._crosshairsLabelTextBoxDisplayMargins);
            if (padding > 0 && this._crosshairsLabelTextBoxSizingMode !== 2 /* CUSTOM_FORCE */) {
                widthHint += (2 * padding);
                heightHint += (2 * padding);
            }
            return [widthHint, heightHint];
        };
        // So, altSide is the side that we're rendering the label (false=primary, true=alternate).
        // If the component is on the alternate side, AND we are drawing the label on the alt side, add offset.
        // If the component is NOT on the alt side, AND we are drawing on the primary side, add offset.
        // Any other combination: Don't add the offset.
        FDSAxis.prototype.computeComponentOffsets = function (altSide) {
            var showTicks;
            var showLabels;
            var showAxis = showTicks = showLabels = false;
            if ((!this.isOnPrimarySide(this.axisPosition)) === altSide || this.axisPosition === 2 /* BOTH */) {
                showAxis = true;
            }
            if ((!this.isOnPrimarySide(this.ticksPosition)) === altSide || this.ticksPosition === 2 /* BOTH */) {
                showTicks = true;
            }
            if ((!this.isOnPrimarySide(this.labelPosition)) === altSide || this.labelPosition === 2 /* BOTH */) {
                showLabels = true;
            }
            var cumulativeOffsets = 0;
            if (showAxis && this.axisPosition !== 4 /* HIDDEN */) {
                cumulativeOffsets += this.axisOffset;
            }
            if (showTicks && this.ticksPosition !== 4 /* HIDDEN */) {
                cumulativeOffsets += this.ticksOffset;
            }
            if (showLabels && (this.labelPosition !== 4 /* HIDDEN */) && this.labeled) {
                cumulativeOffsets += this.labelOffset;
            }
            return cumulativeOffsets;
        };
        FDSAxis.prototype.drawCrosshairsAxesLabels = function (chart, plotRect, altSide, offsetX, offsetY) {
            if ((!this.crosshairsLabeled) || (!this.labeled && !this.crosshairsLabelDrawnWithoutAxisLabels)) {
                return;
            }
            if (!this.shouldDraw()) {
                return;
            }
            if (this.labelPosition === 4 /* HIDDEN */) {
                return;
            }
            // Mouse position when positioning label
            var baseMouseXPos = 0;
            var baseMouseYPos = 0;
            // Axis position when positioning label
            var baseAxisXPos = 0;
            var baseAxisYPos = 0;
            // Alternate axis position
            var altAxisXPos = 0;
            var altAxisYPos = 0;
            // We need to store both possible axis positions. By default, we use the right side.
            switch (this.dimension) {
                case 1 /* X */:
                    altAxisYPos = plotRect.y1;
                    baseAxisYPos = plotRect.y1 + plotRect.getHeight();
                    baseMouseXPos = offsetX;
                    break;
                case 2 /* Y */:
                    altAxisXPos = plotRect.x1;
                    baseAxisXPos = plotRect.x1 + (plotRect.getWidth());
                    baseMouseYPos = offsetY;
                    break;
            }
            // Detect if we need to render to the alternate axis position
            if (altSide) {
                baseAxisXPos = altAxisXPos;
                baseAxisYPos = altAxisYPos;
            }
            // Build the data value (if possible) from the passed in property tags.
            var dataValue = this.crosshairsLabelText.fromValueRT();
            var ctx = chart.getOverlayContext();
            // Width and Font for textbox sizing. (Width is actually the length of the entire string in pixels)
            var _a = RichTextRenderer.measureRichText(ctx, dataValue, this.crosshairsLabelFont), textDimensions = _a[0], preparedText = _a[1];
            // Compute dimensions for our shape
            var _b = this.computeAxesLabelsShapeDimensions(textDimensions.width, textDimensions.height), widthHint = _b[0], heightHint = _b[1];
            // We have to take into account all offsets from axis, ticks and labels so that our label remains
            // at the same position of the axis static labels. This may seem "incorrect" at first glance, but
            // it keeps us the closest to where we should actually be.
            var cumulativeOffsets = this.computeComponentOffsets(altSide);
            // Specific adjustments to keep textboxes at the edge of the axis label
            if (this.dimension === 2 /* Y */ && altSide === false) {
                baseAxisXPos += (widthHint / 2) + cumulativeOffsets;
            }
            if (this.dimension === 2 /* Y */ && altSide === true) {
                baseAxisXPos -= (widthHint / 2) + cumulativeOffsets;
            }
            if (this.dimension === 1 /* X */ && altSide === false) {
                baseAxisYPos += (heightHint / 2) + cumulativeOffsets;
            }
            if (this.dimension === 1 /* X */ && altSide === true) {
                baseAxisYPos -= (heightHint / 2) + cumulativeOffsets;
            }
            // *** Background TextBox ***
            if (this._crosshairsLabelTextBox) {
                // Style for the background rectangle
                this._crosshairsLabelTextBoxBGBrush.setOnCanvas(ctx, plotRect);
                // Style and stuff for foreground (border)
                this._crosshairsLabelTextBoxFGPen.setOnCanvas(ctx);
                // Finally, render our background shape
                switch (this._crosshairsLabelTextBoxDisplayStyle) {
                    case 0 /* RECT */:
                        this._drawRectangleLabel(ctx, (baseMouseXPos + baseAxisXPos) - (widthHint / 2), (baseMouseYPos + baseAxisYPos) - (heightHint / 2), widthHint, heightHint);
                        break;
                    case 1 /* CIRCLE */:
                        this._drawCircleLabel(ctx, baseMouseXPos + baseAxisXPos, baseMouseYPos + baseAxisYPos, widthHint);
                        break;
                    case 2 /* ELLIPSE */:
                        this._drawEllipseLabel(ctx, baseMouseXPos + baseAxisXPos, baseMouseYPos + baseAxisYPos, widthHint, heightHint);
                        break;
                    case 3 /* MARKER */:
                        this._drawMarkerLabel(ctx, baseMouseXPos + baseAxisXPos, baseMouseYPos + baseAxisYPos, widthHint, heightHint, altSide);
                        break;
                }
            }
            // *** Text ***
            if (this._crosshairsLabelShowText) {
                var textX = (baseMouseXPos + ~~baseAxisXPos) - ~~(textDimensions.width / 2);
                var textY = baseMouseYPos + ~~baseAxisYPos - ~~(textDimensions.height / 2);
                // This will actually clip based on the previously drawn shape.
                if (this._crosshairsLabelTextBoxClipText && this._crosshairsLabelTextBox) {
                    ctx.save();
                    ctx.clip();
                }
                RichTextRenderer.writeRichText(ctx, dataValue, textX, textY, this.crosshairsLabelFont, 2 /* CENTER */, preparedText);
                // For clipping
                if (this._crosshairsLabelTextBoxClipText && this._crosshairsLabelTextBox) {
                    ctx.restore();
                }
            }
        };
        FDSAxis.prototype._axisNDC = function (position, ndc) {
            if (this.isOnPrimarySide(position)) {
                return ndc;
            }
            else {
                return 1 - ndc;
            }
        };
        /**
         * Returns the effective 'TickLength' in device pixels.
         */
        FDSAxis.prototype.getTickLength = function () {
            if (this._ticks) {
                return scaleByDevicePixelRatioAndRound(this._ticksLength);
            }
            else {
                return 0;
            }
        };
        FDSAxis.prototype.informOfNewSubplotRect = function (rect) {
            if (!this.scale.initialized) {
                return false;
            }
            var scaleHint = 1000;
            switch (this.dimension) {
                case 1 /* X */:
                    if (this.scale.maxDimensions.width > 0) {
                        scaleHint = (rect.getWidth() * (this.maxPlotFactor - this.minPlotFactor)) /
                            this.scale.maxDimensions.width;
                    }
                    break;
                case 2 /* Y */:
                    // Okay, you might be asking yourself, what's with that magic
                    // number there? Well, friends, that number brings the hint number
                    // closer to what the PC chart generates, which is really important
                    // for smaller, log-scale charts. The scale dimensions are
                    // *already* exaggerated because `FDSFont` has built-in
                    // exaggerations for text measurement, but for some reason, the PC
                    // chart concludes that a
                    if (this.scale.maxDimensions.height > 0) {
                        scaleHint = (rect.getHeight() * (this.maxPlotFactor - this.minPlotFactor)) /
                            ((this.scale.maxDimensions.height) * 1.15);
                    }
                    break;
            }
            // The PC chart truncates `scaleHint` with a `static_cast` to `int`.
            scaleHint = ~~scaleHint;
            if (!this.ticksResize) {
                scaleHint = this._tickSafety;
            }
            if (this.scale.tickMode === 2 /* FIXED */) {
                this.scale.updateFixedMode(scaleHint);
            }
            this.scale.adjustTickRanges(scaleHint);
            this.scale.computeTickVector();
            this.scale.computeLabelVector();
            if (this.scale instanceof FDSIntradayScale) {
                this.scale.computeLabelDimensions(this.root.getContext());
                // first time only created an array of all labels. Now that we have the sizes
                // of the labels, we actually fill in the major and minor labels arrays
                this.scale.computeLabelPositions();
            }
            else if (this.scale instanceof FDSIndexScale) {
                this.scale.computeLabelDimensions(this.root.getContext());
            }
            this.scale.computeSubTickVector();
            this._updateSliderBars();
            // If the scale dimensions changed, then we need to return true to inform
            // the plot that its dimensions need to be recalculated
            var oldWidth = this.maxDimensions.width;
            var oldHeight = this.maxDimensions.height;
            this.calculateDimensions(false);
            if (oldWidth !== this.maxDimensions.width || oldHeight !== this.maxDimensions.height) {
                return true;
            }
            return false;
        };
        // For the sake of sanity, I am calling the `primary` side of the X axis the bottom
        // and the `primary` side of the Y axis is on the right
        FDSAxis.prototype.isOnPrimarySide = function (position) {
            switch (this.dimension) {
                case 1 /* X */:
                    return position === 0 /* NORMAL */;
                case 2 /* Y */:
                    var isY2 = this.isBuiltInAxis && this._prefix === 'Y2';
                    return (isY2 && position === 1 /* ALTERNATE */) || (!isY2 && position === 0 /* NORMAL */);
            }
            return false;
        };
        FDSAxis.prototype._getAbsoluteAxisPos = function () {
            var primary, alternate;
            if (this.isOnPrimarySide(0 /* NORMAL */)) {
                primary = 0 /* NORMAL */;
                alternate = 1 /* ALTERNATE */;
            }
            else {
                primary = 1 /* ALTERNATE */;
                alternate = 0 /* NORMAL */;
            }
            return [primary, alternate];
        };
        FDSAxis.prototype._getRectsAndPositions = function (position, axisRectAlternate, axisRectPrimary) {
            // This is a test to determine the absolute position of the axis (either left
            // of the plot or right of it)
            var _a = this._getAbsoluteAxisPos(), prim = _a[0], alt = _a[1];
            var result = [];
            if (position === 2 /* BOTH */ || this.isOnPrimarySide(position)) {
                result.push([axisRectPrimary, prim]);
            }
            if (position === 2 /* BOTH */ || !this.isOnPrimarySide(position)) {
                result.push([axisRectAlternate, alt]);
            }
            return result;
        };
        FDSAxis.prototype.serialize = function (level) {
            // only serialize custom axes
            if (!this.isBuiltInAxis) {
                this._serializeObject('Axis', level);
            }
            return '';
        };
        FDSAxis.prototype.lookupRefreshAttr = function (refresh) {
            if (!this.attributeSet.isInheritedDefault('RefreshAxis')) {
                refresh.val = this.attributeSet.get('RefreshAxis');
                return true;
            }
            return false;
        };
        FDSAxis.prototype.objectAction = function (action, flags, args) {
            var handled = false;
            var ret = '';
            var errString = '';
            switch (action) {
                case 'GetPrefix':
                    handled = true;
                    ret = this._prefix;
                    break;
                case 'IsBoundToSeries':
                    handled = true;
                    ret = this.associatedSeries.length !== 0;
                    break;
                case 'QueryZoomExtents':
                    ret = [this._getZoomRectStart(), this._getZoomRectEnd(), this._zoomIndex];
                    handled = true;
                    break;
                case 'QueryZoomGroup':
                    ret = this.zoomGroup;
                    handled = true;
                    break;
                case 'SetZoomExtents':
                    if (args.length === 2) {
                        var startVal = Number(args[0]);
                        var endVal = Number(args[1]);
                        if (flags === 0) {
                            this.root.fireZoomEvent(startVal, endVal, this);
                            this._updateSliderBars();
                        }
                        else {
                            this._startZoom(startVal);
                            this._updateZoom(endVal);
                            this._doZoom();
                        }
                        this.root.invalidate();
                        handled = true;
                    }
                    break;
                case 'ResetZoom':
                    this._resetZoom();
                    handled = true;
                    break;
                case 'QueryScaleSpecifier':
                    ret = this.scaleSpecifier;
                    handled = true;
                    break;
                case 'QueryDimension':
                    var dim = -1;
                    switch (this.dimension) {
                        case 1 /* X */:
                            dim = 1 /* X */;
                            break;
                        case 2 /* Y */:
                            dim = 2 /* Y */;
                            break;
                        case 4 /* COLOR */:
                            dim = 4 /* COLOR */;
                            break;
                        case 5 /* DSIZE */:
                            dim = 5 /* SIZE */;
                            break;
                    }
                    ret = dim;
                    handled = true;
                    break;
                case 'QueryAxisType':
                    ret = this.getAxisType();
                    handled = true;
                    break;
                default:
                    // Otherwise, call FDSChartObject's objectAction
                    _a = _super.prototype.objectAction.call(this, action, flags, args), handled = _a[0], ret = _a[1], errString = _a[2];
            }
            return [handled, ret, errString];
            var _a;
        };
        FDSAxis.prototype.getAxisType = function () {
            if (this.getScale() != null) {
                return this._axisDataType;
            }
            else {
                return 'NONE';
            }
        };
        FDSAxis.prototype.getLabels = function () {
            return this._labels;
        };
        FDSAxis.prototype._propFDSAxisValue = function (propertyValueContext) {
            return propertyValueContext.labelValue;
        };
        FDSAxis.prototype._propFDSAxisType = function (propertyValueContext) {
            switch (this._axisDataType) {
                case 'DATE':
                case 'DATETIME':
                case 'TIME':
                    return this._axisDataType;
            }
            return 'FLOAT';
        };
        FDSAxis.prototype._propFDSAxisFormat = function (propertyValueContext) {
            return this.scale.formatString;
        };
        FDSAxis.prototype._propFDSAxisLabel = function (propertyValueContext) {
            return propertyValueContext.formattedLabel;
        };
        FDSAxis.prototype._propFDSCrosshairValue = function (propertyValueContext) {
            if (this.dimension === 1 /* X */) {
                return "" + roundToMaxPrecision(this.scale.computeValue(this.crosshairPosition.x));
            }
            else if (this.dimension === 2 /* Y */) {
                return "" + roundToMaxPrecision(this.scale.computeValue(this.crosshairPosition.y));
            }
            else {
                return '';
            }
        };
        FDSAxis.prototype._propFDSThreshMax = function (propertyValueContext) {
            return this.scale.threshMax;
        };
        FDSAxis.prototype._propFDSThreshMin = function (propertyValueContext) {
            return this.scale.threshMin;
        };
        // Returns the series object for the series specified by the AxisSeries attribute.
        FDSAxis.prototype.lookupAxisSeries = function () {
            if (this.root !== undefined && this._axisSeries !== '') {
                return this.root.getTypedObject(this._axisSeries, isSeries);
            }
            return undefined;
        };
        FDSAxis.prototype._getAttributesForSerialization = function (genApp, genUser, appAttrs, userAttrs) {
            var prefix = (this.isBuiltInAxis && this._prefix) ? this._prefix : '';
            if (genApp) {
                for (var _i = 0, _a = this.attributeSet.getValuesAtLevel('app'); _i < _a.length; _i++) {
                    var _b = _a[_i], name_1 = _b.name, value = _b.value;
                    appAttrs.push({ name: prefix + name_1, value: value });
                }
            }
            if (genUser) {
                for (var _c = 0, _d = this.attributeSet.getValuesAtLevel('user'); _c < _d.length; _c++) {
                    var _e = _d[_c], name_2 = _e.name, value = _e.value;
                    userAttrs.push({ name: prefix + name_2, value: value });
                }
            }
        };
        FDSAxis.prototype.isAxisLineDrawn = function () {
            return this.axisPosition !== 4 /* HIDDEN */ && this._axis;
        };
        FDSAxis.prototype.areTicksDrawn = function () {
            return this.ticksPosition !== 4 /* HIDDEN */ && this._ticks;
        };
        FDSAxis.prototype.areLabelsDrawn = function () {
            return this.labelPosition !== 4 /* HIDDEN */ && this.labeled &&
                this.labelsLevelsMask !== 0 /* NONE */;
        };
        FDSAxis.prototype.getPropertyUsage = function (usedPropertiesMap) {
            if (this.root.propertyUsageManager.isTrackingProperties()) {
                // This technically works if it's after super.getPropertyUsage since this is called multiple times per series,
                // but being consistent with FDSChart.getPropertiesUsage
                this._getPropertyUsageForUnrenderedAttributes();
            }
            _super.prototype.getPropertyUsage.call(this, usedPropertiesMap);
        };
        FDSAxis.prototype._getPropertyUsageForUnrenderedAttributes = function () {
            this.properties.compilePropertyString(this.attributeSet.get('CrosshairsLabelText')).fromValue();
        };
        FDSAxis.prototype._getAxisLabelsFontAlignment = function (position) {
            var textPosition;
            var labelsAreNumeric = this.isNumericScale() && this._axisSeries === '';
            if (this.attributeSet.isInheritedDefault('FontAlignment')) {
                if (this.isOnPrimarySide(position)) {
                    if (labelsAreNumeric) {
                        textPosition = 1 /* RIGHT */;
                    }
                    else {
                        textPosition = 0 /* LEFT */;
                    }
                }
                else {
                    textPosition = 1 /* RIGHT */;
                }
            }
            else {
                textPosition = this.axisFont.alignment;
            }
            return textPosition;
        };
        // On other FDSChartObject implementations, Label is a string. On FDSAxis, Label is a boolean that toggles
        // visibility
        FDSAxis.prototype._setLabelText = function () {
        };
        FDSAxis.prototype._setLabelAttribute = function () {
        };
        FDSAxis.selector = 'FDSAxis';
        return FDSAxis;
    }(FDSChartObject));
    var FDSAxisStyle = /** @class */ (function (_super) {
        __extends(FDSAxisStyle, _super);
        function FDSAxisStyle(root, id, dimension, prefix, parent, isBuiltInAxis, scaleSpecifier) {
            if (dimension === void 0) { dimension = -1 /* NONE */; }
            if (isBuiltInAxis === void 0) { isBuiltInAxis = false; }
            if (scaleSpecifier === void 0) { scaleSpecifier = 0 /* NONE */; }
            return _super.call(this, root, id, dimension, prefix, parent, isBuiltInAxis, scaleSpecifier) || this;
        }
        FDSAxisStyle.prototype._init = function (args) {
            this.isStyleObject = true;
            this.type = 16 /* FC_AXIS_STYLE */;
            _super.prototype._init.call(this, args);
        };
        return FDSAxisStyle;
    }(FDSAxis));
    var Thresholds = /** @class */ (function () {
        function Thresholds(threshMin, threshMax) {
            if (threshMin === void 0) { threshMin = 0; }
            if (threshMax === void 0) { threshMax = 0; }
            this.threshMin = NAN;
            this.threshMax = NAN;
            this.threshMin = threshMin;
            this.threshMax = threshMax;
        }
        Thresholds.prototype.set = function (threshMin, threshMax) {
            this.threshMin = threshMin;
            this.threshMax = threshMax;
        };
        Thresholds.prototype.setFromAxis = function (axis) {
            if (!(isAxis(axis)) || !(axis.scale instanceof FDSScale)) {
                return;
            }
            if (!axis.attributeSet.isInheritedDefault('ThreshMin')) {
                this.threshMin = axis.attributeSet.get('ThreshMin');
            }
            else {
                this.threshMin = axis.scale.threshMin;
            }
            if (!axis.attributeSet.isInheritedDefault('ThreshMax')) {
                this.threshMax = axis.attributeSet.get('ThreshMax');
            }
            else {
                this.threshMax = axis.scale.threshMax;
            }
        };
        Thresholds.prototype.copy = function () {
            return new Thresholds(this.threshMin, this.threshMax);
        };
        return Thresholds;
    }());
    function flipDim(dim) {
        return dim === 1 /* X */ ? 2 /* Y */ : 1 /* X */;
    }
    
    /**
     * Heading object for either the plot or chartlevel headers and footers
     *
     * @class FDSHeadingNamespace
     */
    var FDSHeading = /** @class */ (function () {
        /**
         * Creates an instance of FDSHeading.
         *
         * @param root the root chart object
         * @param id - the name for the heading object
         * @param parent - The parent plot or chart object that owns the heading and its attributes.
         */
        function FDSHeading(root, id, parent, fontOptions) {
            if (fontOptions === void 0) { fontOptions = {}; }
            this._id = id;
            this.font = new FDSFont(_$1.defaults(fontOptions, { widthHint: 32000 }));
            this.extendsToEdge = false;
            this.arrangement = 0 /* LEFT_CENTER_RIGHT */;
            this.visible = false;
            this.text = '';
            this.altText = '';
            this.centerText = '';
            this._xOffsets = { x1: 0, x2: 0 };
            this._parentPropertySet = parent.properties;
        }
        /**
         * Sets the heading's internal values based on the parent object's attributes
         *
         * @param attrSet - the attribute set that owns the heading's attributes
         * @param attrBase - the base name to prepend to the heading's attributes
         */
        FDSHeading.prototype.constructFromAttributes = function (attrSet, attrBase) {
            var getAttr = function (attr) { return attrSet.get(attrBase + attr); };
            if (this.visible = attrSet.get(attrBase)) {
                this.font = FDSFont.constructFromAttributes(attrSet, attrBase + 'Font');
                this.arrangement = getAttr('Position');
                this.extendsToEdge = getAttr('BasePosition') !== 2 /* PLOT_CENTER */;
                this.text = getAttr('Text');
                this.altText = getAttr('AltText');
                this.centerText = getAttr('CenterText');
                this._compiledText = { cps: this._parentPropertySet.compilePropertyString(this.text) };
                this._compiledAltText = { cps: this._parentPropertySet.compilePropertyString(this.altText) };
                this._compiledCenterText = { cps: this._parentPropertySet.compilePropertyString(this.centerText) };
            }
        };
        /**
         * Write the heading object's attributes into the attribute set's default map
         *
         * @param attrSet - the attribute set that will contain the heading's attributes
         * @param attrBase - the base name to prepend to the heading's attributes
         * @param [parentAttrBase] - the base name for inherited attribute values
         */
        FDSHeading.prototype.writeToAttrSet = function (attrSet, attrBase, parentAttrBase) {
            this.font.writeToAttrSet(attrSet, attrBase + 'Font', parentAttrBase ? parentAttrBase + 'Font' : null);
            var set = attrSet.getDefaultSetter(attrBase, parentAttrBase);
            set('', this.visible);
            set('Position', this.arrangement);
            set('BasePosition', this.extendsToEdge ? 0 /* PLOT_LEFT */ : 2 /* PLOT_CENTER */);
            set('Text', this.text);
            set('AltText', this.altText);
            set('CenterText', this.centerText);
        };
        /**
         * Calculates and returns the maximum width and height of the left, center, and right text
         *
         * @param ctx - the chart rendering context
         * @returns {[width, height]}
         */
        FDSHeading.prototype.computeTextDimensions = function (ctx) {
            // Store the old font and set the context font to our font
            if (ctx && this.visible) {
                var maxHeight = 0;
                var maxWidth = 0;
                for (var _i = 0, _a = [this._compiledText, this._compiledAltText, this._compiledCenterText]; _i < _a.length; _i++) {
                    var compiledText = _a[_i];
                    var _b = RichTextRenderer.measureRichText(ctx, compiledText.cps.fromValueRT(), this.font, compiledText.preparedText), richTextDim = _b[0], preparedText = _b[1];
                    compiledText.preparedText = preparedText;
                    if (richTextDim.height > maxHeight) {
                        maxHeight = richTextDim.height;
                    }
                    if (richTextDim.width > maxWidth) {
                        maxWidth = richTextDim.width;
                    }
                }
                return [maxWidth, maxHeight];
            }
            else {
                return [0, 0];
            }
        };
        /**
         * Set's the offsetRect's x values based on the values of basePosition.
         * In particular, this function determines whether to align the heading rectangle to the plot edges.
         * Additionally, the position varies based on type of renderManager (plot vs chart level)
         *
         * @private
         * @param headerRect - the rectangle provided to drawToCanvas
         * @param renderManager - the chart or plot render manager.
         */
        FDSHeading.prototype._setXOffset = function (headerRect, renderManager) {
            var _this = this;
            var computeOffsetRect = function (centeredRect, otherRect) {
                if (_this.extendsToEdge) {
                    _this._xOffsets.x1 = otherRect.x1;
                    _this._xOffsets.x2 = otherRect.x2;
                }
                else {
                    _this._xOffsets.x1 = centeredRect.x1;
                    _this._xOffsets.x2 = centeredRect.x2;
                }
            };
            if (renderManager instanceof ChartRenderManager) {
                computeOffsetRect(headerRect, renderManager.chart.chartSubRect);
            }
            else {
                computeOffsetRect(renderManager.plot.plotRect, headerRect);
            }
        };
        /**
         * Draws the heading object onto the provided canvas
         *
         * @param ctx - the ChartRenderingContext to draw the heading onto
         * @param yOffset - how far to offset the heading text in the vertical direction (accounting for prior headings)
         * @param headerRect - the rectangle where the heading should be drawn (mostly concerning the x-dimension)
         * @param renderManager - the plot or chart render manager
         */
        FDSHeading.prototype.drawToCanvas = function (ctx, yOffset, headerRect, renderManager) {
            var _this = this;
            // Helper function to clean up some work in drawToCanvas.
            // Takes in a context and a compiled text string, returns the width.
            var textWidth = function (compiledText) {
                var textValue = compiledText.cps.fromValueRT();
                var _a = RichTextRenderer.measureRichText(ctx, textValue, _this.font), dims = _a[0], preparedText = _a[1];
                compiledText.preparedText = preparedText;
                return dims.width;
            };
            this._setXOffset(headerRect, renderManager);
            ctx.setFont(this.font);
            // Calculate positions for each type of text
            var textXOffset = 2; // Carried over from FDSChart for parity
            var centerOffset = 1; // Carried over from FDSChart for parity
            var baseLeftX = this._xOffsets.x1 + textXOffset;
            var baseRightX = this._xOffsets.x2 - textXOffset;
            var baseCenterX = Math.round(((this._xOffsets.x1 + this._xOffsets.x2) / 2) + centerOffset);
            var mainTextPos, mainTextXPos, altTextPos, altTextXPos, cenTextPos, cenTextXPos;
            // Based on @textPosition, the main, alt and center text strings
            // swap positions or are omitted.
            // TextPosition.LEFT is Main(Left), Alt(Right) and Center(Center)
            // TextPosition.RIGHT is Main(Right), Alt(Left) and Center(Center)
            // TextPosition.CENTER is Main(Center), Alt(Hidden) and Center(Hidden)
            if (this.arrangement === 0 /* LEFT_CENTER_RIGHT */) {
                if (this.text) {
                    mainTextXPos = baseLeftX;
                    mainTextPos = 0 /* LEFT */;
                }
                if (this.altText) {
                    altTextXPos = baseRightX - textWidth(this._compiledAltText);
                    altTextPos = 1 /* RIGHT */;
                }
                if (this.centerText) {
                    cenTextXPos = ~~(baseCenterX - (textWidth(this._compiledCenterText) / 2));
                    cenTextPos = 2 /* CENTER */;
                }
            }
            else if (this.arrangement === 1 /* RIGHT_CENTER_LEFT */) {
                if (this.text) {
                    mainTextXPos = baseRightX - textWidth(this._compiledText);
                    mainTextPos = 1 /* RIGHT */;
                }
                if (this.altText) {
                    altTextXPos = baseLeftX;
                    altTextPos = 0 /* LEFT */;
                }
                if (this.centerText) {
                    cenTextXPos = ~~(baseCenterX - (textWidth(this._compiledCenterText) / 2));
                    cenTextPos = 2 /* CENTER */;
                }
            }
            else if (this.arrangement === 2 /* CENTER_ONLY */) {
                if (this.text) {
                    mainTextXPos = ~~(baseCenterX - (textWidth(this._compiledText) / 2));
                    mainTextPos = 2 /* CENTER */;
                }
            }
            // Since the different positions of the heading share a single font object,
            // we can't use the alignment on the font object and we will pass it in with the
            // writeRichText
            if (this.text) {
                RichTextRenderer.writeRichText(ctx, this._compiledText.cps.fromValueRT(), mainTextXPos, yOffset - 4, this.font, mainTextPos, this._compiledText.preparedText);
            }
            if (this.altText && this.arrangement !== 2 /* CENTER_ONLY */) {
                RichTextRenderer.writeRichText(ctx, this._compiledAltText.cps.fromValueRT(), altTextXPos, yOffset - 4, this.font, altTextPos, this._compiledAltText.preparedText);
            }
            if (this.centerText && this.arrangement !== 2 /* CENTER_ONLY */) {
                RichTextRenderer.writeRichText(ctx, this._compiledCenterText.cps.fromValueRT(), cenTextXPos, yOffset - 4, this.font, cenTextPos, this._compiledCenterText.preparedText);
            }
        };
        /**
         * Sets new text for the left heading and recompile the property string
         *
         * @param newText - the new text
         */
        FDSHeading.prototype.setText = function (newText) {
            this.text = newText;
            this._compiledText = { cps: this._parentPropertySet.compilePropertyString(this.text) };
        };
        return FDSHeading;
    }());
    
    var WrapperHelper = /** @class */ (function () {
        function WrapperHelper(_object, _name) {
            this._object = _object;
            this._name = _name;
        }
        WrapperHelper.prototype._getAttr = function (attr) {
            return this._object.getAttribute("" + this._name + attr);
        };
        WrapperHelper.prototype._setAttr = function (attr, value) {
            this._object.setAttribute("" + this._name + attr, 'user', value);
            return this;
        };
        return WrapperHelper;
    }());
    var BrushWrapper = /** @class */ (function (_super) {
        __extends(BrushWrapper, _super);
        function BrushWrapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BrushWrapper.prototype.getHexColor = function () {
            return COLORREFtoHex(this._getAttr('Color'));
        };
        BrushWrapper.prototype.setHexColor = function (value) {
            return this._setAttr('Color', HEXtoCOLORREF(value));
        };
        BrushWrapper.prototype.getStyle = function () {
            return this._getAttr('Style');
        };
        BrushWrapper.prototype.setStyle = function (value) {
            return this._setAttr('Style', value);
        };
        BrushWrapper.prototype.getAlpha = function () {
            return this._getAttr('Alpha');
        };
        BrushWrapper.prototype.setAlpha = function (value) {
            return this._setAttr('Alpha', value);
        };
        BrushWrapper.prototype.getGradientAngle = function () {
            return this._getAttr('GradientAngle');
        };
        BrushWrapper.prototype.setGradientAngle = function (value) {
            return this._setAttr('GradientAngle', value);
        };
        BrushWrapper.prototype.getHexGradientColor = function () {
            return COLORREFtoHex(this._getAttr('GradientColor'));
        };
        BrushWrapper.prototype.setHexGradientColor = function (value) {
            return this._setAttr('GradientColor', HEXtoCOLORREF(value));
        };
        BrushWrapper.prototype.getGradientStyle = function () {
            return this._getAttr('GradientStyle');
        };
        BrushWrapper.prototype.setGradientStyle = function (value) {
            return this._setAttr('GradientStyle', value);
        };
        BrushWrapper.prototype.getGradientFactor = function () {
            return this._getAttr('GradientFactor');
        };
        BrushWrapper.prototype.setGradientFactor = function (value) {
            return this._setAttr('GradientFactor', value);
        };
        BrushWrapper.prototype.getRadialGradientOffsetX = function () {
            return this._getAttr('RadialGradientOffsetX');
        };
        BrushWrapper.prototype.setRadialGradientOffsetX = function (value) {
            return this._setAttr('RadialGradientOffsetX', value);
        };
        BrushWrapper.prototype.getRadialGradientOffsetY = function () {
            return this._getAttr('RadialGradientOffsetY');
        };
        BrushWrapper.prototype.setRadialGradientOffsetY = function (value) {
            return this._setAttr('RadialGradientOffsetY', value);
        };
        BrushWrapper.prototype.getImageName = function () {
            return this._getAttr('ImageName');
        };
        BrushWrapper.prototype.setImageName = function (value) {
            return this._setAttr('ImageName', value);
        };
        return BrushWrapper;
    }(WrapperHelper));
    var PenWrapper = /** @class */ (function (_super) {
        __extends(PenWrapper, _super);
        function PenWrapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PenWrapper.prototype.getHexColor = function () {
            return COLORREFtoHex(this._getAttr('Color'));
        };
        PenWrapper.prototype.setHexColor = function (value) {
            return this._setAttr('Color', HEXtoCOLORREF(value));
        };
        PenWrapper.prototype.getWidth = function () {
            return this._getAttr('Width');
        };
        PenWrapper.prototype.setWidth = function (value) {
            return this._setAttr('Width', value);
        };
        PenWrapper.prototype.getStyle = function () {
            return this._getAttr('Style');
        };
        PenWrapper.prototype.setStyle = function (value) {
            return this._setAttr('Style', value);
        };
        PenWrapper.prototype.getDashFactor = function () {
            return this._getAttr('DashFactor');
        };
        PenWrapper.prototype.setDashFactor = function (value) {
            return this._setAttr('DashFactor', value);
        };
        PenWrapper.prototype.getLineCap = function () {
            return this._getAttr('LineCap');
        };
        PenWrapper.prototype.setLineCap = function (value) {
            return this._setAttr('LineCap', value);
        };
        return PenWrapper;
    }(WrapperHelper));
    var FontWrapper = /** @class */ (function (_super) {
        __extends(FontWrapper, _super);
        function FontWrapper() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FontWrapper.prototype.getHexColor = function () {
            return COLORREFtoHex(this._getAttr('Color'));
        };
        FontWrapper.prototype.setHexColor = function (value) {
            return this._setAttr('Color', HEXtoCOLORREF(value));
        };
        FontWrapper.prototype.getDegRotation = function () {
            return this._getAttr('Escapement') / 100;
        };
        FontWrapper.prototype.setDegRotation = function (value) {
            return this._setAttr('Escapement', value * 100);
        };
        FontWrapper.prototype.getRadRotation = function () {
            return DegToRad(this._getAttr('Escapement') / 100);
        };
        FontWrapper.prototype.setRadRotation = function (value) {
            return this._setAttr('Escapement', RadToDeg(value * 100));
        };
        FontWrapper.prototype.getFamily = function () {
            return this._getAttr('Family');
        };
        FontWrapper.prototype.setFamily = function (value) {
            return this._setAttr('Family', value);
        };
        FontWrapper.prototype.getHeight = function () {
            return this._getAttr('Height');
        };
        FontWrapper.prototype.setHeight = function (value) {
            return this._setAttr('Height', value);
        };
        FontWrapper.prototype.getWeight = function () {
            return this._getAttr('Weight');
        };
        FontWrapper.prototype.setWeight = function (value) {
            return this._setAttr('Weight', value);
        };
        FontWrapper.prototype.getItalic = function () {
            return this._getAttr('Italic');
        };
        FontWrapper.prototype.setItalic = function (value) {
            return this._setAttr('Italic', value);
        };
        FontWrapper.prototype.getUnderline = function () {
            return this._getAttr('Underline');
        };
        FontWrapper.prototype.setUnderline = function (value) {
            return this._setAttr('Underline', value);
        };
        FontWrapper.prototype.getWidthHint = function () {
            return this._getAttr('WidthHint');
        };
        FontWrapper.prototype.setWidthHint = function (value) {
            return this._setAttr('WidthHint', value);
        };
        FontWrapper.prototype.getAlignment = function () {
            return this._getAttr('Alignment');
        };
        FontWrapper.prototype.setAlignment = function (value) {
            return this._setAttr('Alignment', value);
        };
        return FontWrapper;
    }(WrapperHelper));
    
    var DIMs = [
        'value',
        'x',
        'y',
        'z',
        'color',
        'size',
        'hit'
    ];
    var FDSSeriesWrapper = /** @class */ (function (_super) {
        __extends(FDSSeriesWrapper, _super);
        function FDSSeriesWrapper(opts) {
            if (opts === void 0) { opts = { x: null, y: null, drawStyle: -1 /* NONE */ }; }
            var _this = _super.call(this, opts) || this;
            _this.seriesList = [];
            _this.dataMap = {};
            _this.seriesListDirty = true;
            _this.dataMapDirty = true;
            _this.tempDataChildren = {};
            if (optsAreSeries(opts)) {
                _this.initialize();
            }
            else {
                _this.id = (opts.id != null) ? opts.id : null;
                _this.label = (opts.label != null) ? opts.label : null;
                // NOT safe for external use
                _this.tempDataChildren = {
                    value: opts.value,
                    x: opts.x,
                    y: opts.y,
                    z: opts.z,
                    color: opts.color,
                    size: opts.size,
                    hit: opts.hit
                };
                _this.drawStyle = opts.drawStyle;
                _this.onYAxis = opts.onYAxis;
                _this.onXAxis = opts.onXAxis;
            }
            return _this;
        }
        FDSSeriesWrapper_1 = FDSSeriesWrapper;
        FDSSeriesWrapper.prototype.setSeriesListDirty = function () {
            this.seriesListDirty = true;
        };
        FDSSeriesWrapper.prototype.setDataMapDirty = function () {
            this.dataMapDirty = true;
        };
        FDSSeriesWrapper.prototype.initialize = function () {
            this.seriesValueFGPen = new PenWrapper(this, 'SeriesValueFG');
            this.seriesValueBGBrush = new BrushWrapper(this, 'SeriesValueBG');
            this.seriesValueFont = new FontWrapper(this, 'SeriesValueFont');
            this.seriesLabel1Font = new FontWrapper(this, 'SeriesLabel1Font');
            this.seriesLabel2Font = new FontWrapper(this, 'SeriesLabel2Font');
            this.seriesArrowFGPen = new PenWrapper(this, 'SeriesValueArrowFG');
            this.seriesArrowLineFGPen = new PenWrapper(this, 'SeriesValueLineFG');
            this.seriesArrowBGBrush = new BrushWrapper(this, 'SeriesValueArrowBG');
            this.seriesBGBrush = new BrushWrapper(this, 'SeriesBG');
            this.seriesFGPen = new PenWrapper(this, 'SeriesFG');
            this.seriesOutlinePen = new PenWrapper(this, 'SeriesOutline');
            this.seriesMarkerBGBrush = new BrushWrapper(this, 'SeriesMarkerBG');
            this.seriesMarkerFGPen = new PenWrapper(this, 'SeriesMarkerFG');
            this.seriesMarkerOutlinePen = new PenWrapper(this, 'SeriesMarkerOutline');
            this.seriesMarkerFont = new FontWrapper(this, 'SeriesMarkerFont');
            this.seriesAlternateBGBrush = new BrushWrapper(this, 'SeriesAlternateBG');
            this.seriesAlternateFGPen = new PenWrapper(this, 'SeriesAlternateFG');
            this.seriesAlternateOutlinePen = new PenWrapper(this, 'SeriesAlternateOutline');
            this.quickLabelFont = new FontWrapper(this, 'SeriesQuickLabelFont');
            this.quickLabelFGPen = new PenWrapper(this, 'SeriesQuickLabelTextBoxFG');
            this.quickLabelBGBrush = new BrushWrapper(this, 'SeriesQuickLabelTextBoxBG');
        };
        FDSSeriesWrapper.prototype.updateDataCache = function () {
            this.dataMap = {};
            for (var dim = 0; dim < 7 /* MEMBERS */; dim++) {
                if (this._chartObject.isDefined(dim)) {
                    this.dataMap[DIMs[dim]] = this._chartObject.getData(dim).wrapper;
                }
            }
            this.dataMapDirty = false;
        };
        FDSSeriesWrapper.prototype.updateSeriesCache = function () {
            var _this = this;
            this.seriesList = Object.keys(this._chartObject.children)
                .map(function (o) { return _this._chartObject.children[o].wrapper; });
            this.seriesListDirty = false;
        };
        FDSSeriesWrapper.prototype.getResolvedProperty = function (str, seriesOptions) {
            return this._chartObject.getResolvedProperty(str, _$1.pick(seriesOptions, 'seriesIndex'));
        };
        FDSSeriesWrapper.prototype.getResolvedPropertyString = function (str, seriesOptions) {
            var pfs = this._chartObject.properties.compilePropertyString(str);
            return pfs.fromValue(_$1.pick(seriesOptions, 'seriesIndex'));
        };
        FDSSeriesWrapper.prototype.isUnbinnedHistogram = function () {
            var series = this._chartObject;
            if (!series) {
                return false;
            }
            var drawStyle = series.getEffectiveDrawStyle();
            var unbinnedDataId = series.histogramBinsCreator.getUnbinnedDatasetId(series.id);
            var unbinnedData = this.chart.getObjectById(unbinnedDataId);
            if (!unbinnedData) {
                return false;
            }
            return (drawStyle === 62 /* HISTOGRAM */ || drawStyle === 64 /* HISTOGRAM_AS_COLUMNS */);
        };
        /* BEGIN PUBLIC API */
        /**
         * @typedef {Object} DataMap
         * @property {FDSDataWrapper} value - The data wrapper that contains the value data.
         * @property {FDSDataWrapper} x - The data wrapper that contains the x data.
         * @property {FDSDataWrapper} y - The data wrapper that contains the y data.
         * @property {FDSDataWrapper} z - The data wrapper that contains the z data.
         * @property {FDSDataWrapper} color - The data wrapper that contains the color data.
         * @property {FDSDataWrapper} size - The data wrapper that contains the size data.
         * @property {FDSDataWrapper} hit - The data wrapper that contains the hit data.
         */
        /**
         * Returns an object with the defined data dimensions of this series.
         *
         * @return {DataMap} An object with value, x, y, z, color, size, and hit properties. Omitted properties mean that
         *   there is no dataset defined at that dimension.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.getData = function () {
            if (this.dataMapDirty) {
                this.updateDataCache();
            }
            return this.dataMap;
        };
        /**
         * Returns the size of the dataset. This is effectively the minimum of the lengths of all child datasets.
         *
         * @returns {number} The size of the dataset/the number of data points.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.getSize = function () {
            return this._chartObject.size;
        };
        /**
         * Fetches the wrapper of the axis that this series belongs to given the dimension.
         *
         * @param {number} dim - 1 for the x-axis or 2 for the y-axis.
         * @returns {FDSAxisWrapper} The wrapper of the axis that this series belongs to.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.getAxis = function (dim) {
            var axis = this._chartObject.getAxis(dim);
            return axis ? axis.wrapper : undefined;
        };
        /**
         * Returns the wrapper for the series with the provided id, or undefined if it does not exist.
         *
         * @param {string} id - The id of the child series to fetch.
         * @returns {FDSSeriesWrapper} The wrapper for the series with the provided id.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.getChildSeriesById = function (id) {
            console.assert((this._chartObject.children[id] != null), this.id + " has no series child with name: " + id);
            var child = this._chartObject.children[id];
            return child ? child.wrapper : undefined;
        };
        /**
         * Returns an array with all of the wrappers for the series children.
         *
         * @returns {FDSSeriesWrapper[]} An array containing wrapper objects for all of the series children.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.getSeriesChildren = function () {
            if (this.seriesListDirty) {
                this.updateSeriesCache();
            }
            return this.seriesList;
        };
        /**
         * Adds a series as a child of this series.
         *
         * @param {FDSSeriesWrapper} child - The FDSSeriesWrapper instance of the child to add.
         * @returns {FDSSeriesWrapper} The instance of the series wrapper, for chainability.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.addSeriesChild = function (child) {
            console.assert(child instanceof FDSSeriesWrapper_1, 'FDSSeriesWrapper::addSeriesChild - child must be a FDSSeriesWrapper!');
            child.addToChart(this.chart);
            this._chartObject.addSeriesChild(child._chartObject);
            return this;
        };
        /**
         * Removes data defined in the dataObj parameter from this series.
         *
         * @param {DataMap} dataObj - A map that defines the data to be removed. Any of the properties can be omitted.
         * @returns {FDSSeriesWrapper} The instance of the series wrapper, for chainability.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.removeDataChildren = function (dataObj) {
            console.assert(this.attached && (this.chart != null), 'Unable to remove children since we are in a detached state');
            for (var _i = 0, DIMs_1 = DIMs; _i < DIMs_1.length; _i++) {
                var dim = DIMs_1[_i];
                var dataset = dataObj[dim];
                if (!dataset) {
                    continue;
                }
                dataset.removeFromSeries(this.chart, this);
                dataObj[dim] = null;
            }
            return this;
        };
        /**
         * Sets data defined in the dataObj parameter from this series.
         *
         * @param {DataMap} dataObj - A map that defines the data to be set. Any of the properties can be omitted.
         * @returns {FDSSeriesWrapper} The instance of the series wrapper, for chainability.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.setDataChildren = function (dataObj) {
            console.assert(this.attached, 'FDSSeriesWrapper cannot set data children because it is not attached');
            var childIDs = [];
            for (var _i = 0, DIMs_2 = DIMs; _i < DIMs_2.length; _i++) {
                var dim = DIMs_2[_i];
                var dataset = dataObj[dim];
                if (!dataset) {
                    childIDs.push('');
                }
                else {
                    this.tempDataChildren[dim] = dataset;
                    childIDs.push(dataset.id);
                    dataset.addParent(this);
                }
            }
            this._chartObject.setChildren(childIDs);
            return this;
        };
        FDSSeriesWrapper.prototype.getComputedSeriesColor = function () {
            return this._chartObject.calculatedSeriesColor;
        };
        /**
         * Gets the computed drawstyle the series actually uses to draw, not necessarily the one passed in.
         *
         * @returns {number} The computed drawstyle as a DrawStyle enum.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.getComputedDrawStyle = function () {
            console.assert(this.attached, 'FDSSeriesWrapper cannot compute draw style because it is not attached');
            // the true means return an enum not an object
            return this._chartObject.getDrawStylePrototype().drawStyleEnum;
        };
        /**
         * Returns whether or not the plot has data.
         *
         * @returns {boolean} True if the plot has data, false if the plot has no data.
         *
         * @memberOf FDSSeriesWrapper;
         */
        FDSSeriesWrapper.prototype.hasValidData = function () {
            return this._chartObject.hasValidPrimaryData;
        };
        /**
         * Shades all hitshapes in the series hitshape list for easier debugging
         */
        FDSSeriesWrapper.prototype.shadeHitShapes = function () {
            this._chartObject.shadeHitshapes();
        };
        /**
         * Cases the bins and frequencies for a histogram series to be recalculated based
         * on the values in the dataset that has the same id as the series appended with
         * 'HistogramData'. If such a dataset does not exist, this method will be a no-op.
         *
         * @return The series wrapper for chainability.
         */
        FDSSeriesWrapper.prototype.triggerHistogramBinsCalculation = function () {
            this._chartObject.triggerCalcHistogramBins();
        };
        /* END PUBLIC API */
        FDSSeriesWrapper.prototype.attachDataObjects = function (dataObj) {
            console.assert(this.attached && (this.chart != null), 'FDSSeriesWrapper cannot attach datasets because it is not attached or its chart is invalid');
            for (var _i = 0, DIMs_3 = DIMs; _i < DIMs_3.length; _i++) {
                var dim = DIMs_3[_i];
                var dataset = dataObj[dim];
                if (dataset == null) {
                    continue;
                }
                dataset.addToChart(this.chart);
            }
        };
        FDSSeriesWrapper.prototype.addToChart = function (chart) {
            console.assert(!this.attached, "Series " + this.id + " is already attached to the chart!");
            if (this.id == null) {
                this.setId(chart.getNextSeriesId());
            }
            FDSChartObjectWrapper.unwrap(chart)
                .addObject(this.id, 2 /* FC_SERIES */, 0 /* NO_FLAGS */, this.label, [], this);
            console.assert((chart.getObjectById(this.id) != null), "FDSSeriesWrapper failed to attach series " + this.id + " to chart");
            this.attached = true;
            this.chart = chart;
            this._chartObject = FDSChartObjectWrapper.unwrap(chart).objects[this.id];
            this.attachDataObjects(this.tempDataChildren);
            this.setDataChildren(this.tempDataChildren);
            this.tempDataChildren = {};
        };
        FDSSeriesWrapper.prototype.addToPlot = function (chart, plot) {
            console.assert(plot.attached, "Plot " + plot.id + " must be attached before adding series!");
            this.addToChart(chart);
            // This needs to be after setting @attached to true
            if (this.onYAxis != null) {
                this.setAttribute('OnYAxis', 'app', this.onYAxis);
            }
            if (this.onXAxis != null) {
                this.setAttribute('OnXAxis', 'app', this.onXAxis);
            }
            FDSChartObjectWrapper.unwrap(plot).setChildren([this.id]);
            this.plot = plot;
            this.initialize();
            this.setAttribute('DrawStyle', 'app', this.drawStyle);
        };
        FDSSeriesWrapper.prototype.removeFromChart = function (chart, deleteChildren) {
            if (deleteChildren === void 0) { deleteChildren = false; }
            console.assert(this.attached && (chart.getObjectById(this.id) != null), "Series " + this.id + " is not attached to the chart");
            var deleteFlag = deleteChildren ? 1 /* DELETE_WITH_CHILD */ : 0;
            this.removeDataChildren(this.getData());
            FDSChartObjectWrapper.unwrap(chart).deleteObject(this.id, deleteFlag);
            console.assert(!(chart.getObjectById(this.id) != null), "FDSSeriesWrapper failed to delete series " + this.id + " from the chart");
            this._chartObject = null;
            this.attached = false;
            this.chart = null;
            this.plot = null;
        };
        // for the following two functions the logic is as follows. Calculating which pen or brush
        // a series uses can be tricky so when it exists we yield to the logic inside choosePens()
        // If it doesn't exist we return the color from the pen/brush color, with a bit additional
        // logic to check if we should be using the outline or FG pen
        FDSSeriesWrapper.prototype.getSeriesFGColor = function () {
            var ds = this._chartObject.getDrawStylePrototype().drawStyle;
            if (ds && _$1.isFunction(ds._choosePens)) {
                var ctx = this._chartObject.root.getContext();
                var penProps = ds._choosePens(ctx).penProps;
                if (penProps != null) {
                    return penProps.color;
                }
            }
            var color;
            // if we get here we need to find the color a more basic way
            switch (this._chartObject.getEffectiveDrawStyle()) {
                case 9 /* AREA */:
                case 18 /* AREASTEP */:
                case 55 /* ELLIPSE */:
                case 12 /* BARS */:
                case 6 /* COLUMNS */:
                case 31 /* BUBBLE */:
                case 3 /* MARKER */:
                case 23 /* CANDLE */:
                case 4 /* RANGEBAR */:
                    color = this._chartObject.seriesOutlinePen.color;
                    break;
                default:
                    color = this._chartObject.seriesFGPen.color;
            }
            return COLORREFtoHex(color);
        };
        FDSSeriesWrapper.prototype.getSeriesBGColor = function () {
            // backup color
            var color = this._chartObject.seriesBGBrush.color;
            var ds = this._chartObject.getDrawStylePrototype().drawStyle;
            if (ds._choosePens) {
                var ctx = this._chartObject.root.getContext();
                var brush = ds._choosePens(ctx).brush;
                if (brush != null) {
                    color = brush.color;
                }
            }
            return COLORREFtoHex(color);
        };
        FDSSeriesWrapper.prototype.getPieRadius = function () {
            return this._chartObject.cachedPieRadius;
        };
        // returns [min, max]
        FDSSeriesWrapper.prototype.getHeatmapColorScaleMinMax = function () {
            var _a = this._chartObject.getHeatmapColorScaleMinMax(), colorMin = _a.colorMin, colorMax = _a.colorMax;
            return [colorMin, colorMax];
        };
        FDSSeriesWrapper.prototype.getPlotParent = function () {
            var parent = this._chartObject.getPlotParent();
            return parent ? parent.wrapper : undefined;
        };
        FDSSeriesWrapper.prototype.getDrawingToolType = function () {
            return this._chartObject.drawingToolType;
        };
        FDSSeriesWrapper.selector = 'FDSSeriesWrapper';
        FDSSeriesWrapper = FDSSeriesWrapper_1 = __decorate([
            FDSChartObjectWrapperLogDecorator
        ], FDSSeriesWrapper);
        return FDSSeriesWrapper;
        var FDSSeriesWrapper_1;
    }(FDSChartObjectWrapper));
    var optsAreSeries = function (opts) {
        return isChartObject(opts) && isSeries(opts);
    };
    
    var defaultOptions = {
        binCount: 0,
        binSize: 0,
        binMin: undefined,
        binMax: undefined,
        aggregateDataOutOfRange: false,
        adjustForNiceBins: false,
        countAsPercents: false,
    };
    var optionToAttributeName = {
        binMin: 'HistogramBinMin',
        binMax: 'HistogramBinMax',
        binCount: 'HistogramBinCount',
        binSize: 'HistogramBinSize',
        aggregateDataOutOfRange: 'HistogramAggregateDataOutOfRange',
        adjustForNiceBins: 'HistogramAdjustForNiceBins',
        countAsPercents: 'HistogramCountAsPercents',
    };
    var UnbinnedDatasetIdPostFix = 'HistogramDataset';
    var HistogramBinsCreator = /** @class */ (function () {
        function HistogramBinsCreator(histogramOptions) {
            if (histogramOptions === void 0) { histogramOptions = {}; }
            this._setHistogramOptions(histogramOptions);
        }
        HistogramBinsCreator.prototype._setHistogramOptions = function (histogramOptions) {
            this._histogramOptions = __assign({}, defaultOptions, histogramOptions);
        };
        HistogramBinsCreator.prototype.createHistogramBins = function (values$$1) {
            var valuesWithoutNaN = _$1.reject(values$$1, function (value) { return IsSomeNAN(value); });
            var sortedValues = valuesWithoutNaN.sort(function (a, b) { return a - b; });
            var valuesMin = sortedValues[0];
            var valuesMax = sortedValues[sortedValues.length - 1] + this._minConsecutiveDiff(sortedValues);
            var binMin = isNaN(this._histogramOptions.binMin) ? valuesMin : this._histogramOptions.binMin;
            var binMax = isNaN(this._histogramOptions.binMax) ? valuesMax : this._histogramOptions.binMax;
            if (binMin > binMax) {
                var temp = binMin;
                binMin = binMax;
                binMax = temp;
            }
            this._createBins(sortedValues, binMin, binMax);
            this._applyFrequenciesToBins(sortedValues);
            this._aggDataBelowRange(sortedValues, valuesMin);
            this._aggDataAboveRange(sortedValues, valuesMax);
            if (this._histogramOptions.countAsPercents) {
                this._convertFrequenciesToPercents(sortedValues.length);
            }
            return {
                bins: this._histogramBins,
                belowRangeAggregate: this._belowRangeAggregate,
                aboveRangeAggregate: this._aboveRangeAggregate
            };
        };
        HistogramBinsCreator.prototype._minConsecutiveDiff = function (sortedValues) {
            var minDiff = Infinity;
            for (var i = 0; i < sortedValues.length - 1; i++) {
                var diff = sortedValues[i + 1] - sortedValues[i];
                if (diff !== 0) {
                    minDiff = Math.min(diff, minDiff);
                }
            }
            return minDiff === Infinity ? 1 : minDiff;
        };
        HistogramBinsCreator.prototype._createBins = function (sortedValues, histogramStart, histogramEnd) {
            var histogramRange = histogramEnd - histogramStart;
            var areStartAndEndIntegers = (histogramEnd % 1 === 0) && (histogramStart % 1 === 0);
            var shouldRoundBinSize = areStartAndEndIntegers && this._histogramOptions.adjustForNiceBins;
            var binSizes = this._calcBinSize(sortedValues, histogramRange, shouldRoundBinSize);
            if (binSizes.interiorBinSize === 0) {
                var bin = { binStart: histogramStart, binEnd: histogramEnd, frequency: 0 };
                this._histogramBins = [bin];
                return;
            }
            var binCount = (this._histogramOptions.binCount > 0) ? Math.floor(this._histogramOptions.binCount)
                : Math.ceil(histogramRange / binSizes.interiorBinSize);
            this._initBins(binCount);
            // When an option for binCount is given, and adjustForNiceBins is true,
            // the first and last bins may be a different size than the interior bins,
            // so we handle them seperately.
            var firstBin = _$1.first(this._histogramBins);
            firstBin.binStart = firstBin.binEnd = histogramStart;
            firstBin.binEnd += (binSizes.firstBinSize > 0) ? binSizes.firstBinSize : binSizes.interiorBinSize;
            var currBinPos = firstBin.binEnd;
            for (var i = 1; i < this._histogramBins.length - 1; i += 1) {
                this._histogramBins[i].binStart = currBinPos;
                currBinPos += binSizes.interiorBinSize;
                this._histogramBins[i].binEnd = currBinPos;
            }
            var lastBin = _$1.last(this._histogramBins);
            if (lastBin !== firstBin) {
                lastBin.binStart = currBinPos;
                lastBin.binEnd = histogramEnd;
            }
        };
        HistogramBinsCreator.prototype._calcBinSize = function (sortedValues, range, shouldRound) {
            var binSizes = { interiorBinSize: 0, firstBinSize: 0, lastBinSize: 0 };
            if (range === 0) {
                return binSizes;
            }
            var binSize;
            if (this._histogramOptions.binCount > 0) {
                var binCount = ~~(this._histogramOptions.binCount);
                binSize = range / binCount;
                if (shouldRound && binSize > 1) {
                    var ceiledBinSize = Math.ceil(binSize);
                    var remainingSize = range - (binCount - 2) * ceiledBinSize;
                    if (remainingSize > 0) {
                        binSize = ceiledBinSize;
                    }
                    else {
                        binSize = Math.floor(binSize);
                        remainingSize = range - (binCount - 2) * binSize;
                    }
                    if (remainingSize % 2 === 0) {
                        binSizes.firstBinSize = binSizes.lastBinSize = remainingSize / 2;
                    }
                    else {
                        binSizes.firstBinSize = Math.ceil(remainingSize / 2);
                        binSizes.lastBinSize = Math.floor(remainingSize / 2);
                    }
                }
                binSizes.interiorBinSize = binSize;
            }
            else if (this._histogramOptions.binSize > 0) {
                binSizes.interiorBinSize = this._histogramOptions.binSize;
            }
            else {
                binSizes.interiorBinSize = this._calcDefaultBinWidth(sortedValues);
            }
            return binSizes;
        };
        HistogramBinsCreator.prototype._calcDefaultBinWidth = function (sortedValues) {
            // We'll use the Freedman-Diaconis rule to determine default bin width.
            // We assume that the values have already been sorted.
            var interquartileRange = this._calcInterquartileRange(sortedValues);
            var binWidth = (2 * interquartileRange) / (Math.pow(sortedValues.length, (1 / 3)));
            return (binWidth > 1) ? Math.floor(binWidth) : binWidth;
        };
        HistogramBinsCreator.prototype._calcInterquartileRange = function (sortedValues) {
            var valuesCount = sortedValues.length;
            var quartileSubsetLength;
            if (valuesCount % 2 === 0) {
                quartileSubsetLength = Math.round(valuesCount / 2);
            }
            else {
                quartileSubsetLength = ~~(valuesCount / 2) + 1;
            }
            var firstQuartile;
            var thirdQuartile;
            if (quartileSubsetLength % 2 === 0) {
                var firstQuartileMedianIndex1 = quartileSubsetLength / 2;
                var firstQuartileMedianIndex2 = firstQuartileMedianIndex1 - 1;
                var thirdQuartileMedianIndex1 = (valuesCount - 1) - quartileSubsetLength / 2;
                var thirdQuartileMedianIndex2 = thirdQuartileMedianIndex1 + 1;
                firstQuartile = (sortedValues[firstQuartileMedianIndex1] + sortedValues[firstQuartileMedianIndex2]) / 2;
                thirdQuartile = (sortedValues[thirdQuartileMedianIndex1] + sortedValues[thirdQuartileMedianIndex2]) / 2;
            }
            else {
                var firstQuartileMedianIndex = (quartileSubsetLength - 1) / 2;
                var thirdQuartileMedianIndex = (valuesCount - 1) - firstQuartileMedianIndex;
                firstQuartile = sortedValues[firstQuartileMedianIndex];
                thirdQuartile = sortedValues[thirdQuartileMedianIndex];
            }
            return thirdQuartile - firstQuartile;
        };
        HistogramBinsCreator.prototype._initBins = function (binCount) {
            var histogramBins = [];
            for (var i = 0; i < binCount; i++) {
                var bin = { binStart: 0, binEnd: 0, frequency: 0 };
                histogramBins.push(bin);
            }
            this._histogramBins = histogramBins;
        };
        HistogramBinsCreator.prototype._applyFrequenciesToBins = function (values$$1) {
            for (var _i = 0, values_1 = values$$1; _i < values_1.length; _i++) {
                var value = values_1[_i];
                this._addValueToHistogram(value);
            }
        };
        HistogramBinsCreator.prototype._addValueToHistogram = function (value) {
            // Each of our bin intervals are (x1, x2].
            var valueContainingBin = _$1.find(this._histogramBins, function (histogramBin) {
                return value >= histogramBin.binStart && value < histogramBin.binEnd;
            });
            if (valueContainingBin) {
                valueContainingBin.frequency++;
            }
        };
        HistogramBinsCreator.prototype._aggDataBelowRange = function (sortedValues, valuesMin) {
            this._belowRangeAggregate = null;
            var binMin = this._histogramOptions.binMin;
            if (!isNaN(binMin) && binMin > valuesMin) {
                this._belowRangeAggregate = { binStart: valuesMin, binEnd: binMin, frequency: 0 };
                for (var _i = 0, sortedValues_1 = sortedValues; _i < sortedValues_1.length; _i++) {
                    var value = sortedValues_1[_i];
                    if (value >= this._belowRangeAggregate.binStart && value < this._belowRangeAggregate.binEnd) {
                        this._belowRangeAggregate.frequency += 1;
                    }
                    else {
                        // Because our values are sorted, we know that as soon as we reach a value that is
                        // too large for our aggregate bin range, all consecutive values must be too large
                        // as well.
                        break;
                    }
                }
            }
        };
        HistogramBinsCreator.prototype._aggDataAboveRange = function (sortedValues, valuesMax) {
            this._aboveRangeAggregate = null;
            var binMax = this._histogramOptions.binMax;
            if (!isNaN(binMax) && binMax < valuesMax) {
                this._aboveRangeAggregate = { binStart: binMax, binEnd: valuesMax, frequency: 0 };
                for (var i = sortedValues.length - 1; i >= 0; i--) {
                    var value = sortedValues[i];
                    if (value >= this._aboveRangeAggregate.binStart && value < this._aboveRangeAggregate.binEnd) {
                        this._aboveRangeAggregate.frequency += 1;
                    }
                    else {
                        // Because our values are sorted, we know that as soon as we reach a value that is
                        // too small for our aggregate bin range, all consecutive values must be too small
                        // as well.
                        break;
                    }
                }
            }
        };
        HistogramBinsCreator.prototype._convertFrequenciesToPercents = function (valuesCount) {
            for (var _i = 0, _a = this._histogramBins; _i < _a.length; _i++) {
                var bin = _a[_i];
                bin.frequency = (bin.frequency / valuesCount) * 100;
            }
            if (!_$1.isNull(this._aboveRangeAggregate)) {
                this._aboveRangeAggregate.frequency = (this._aboveRangeAggregate.frequency / valuesCount) * 100;
            }
            if (!_$1.isNull(this._belowRangeAggregate)) {
                this._belowRangeAggregate.frequency = (this._belowRangeAggregate.frequency / valuesCount) * 100;
            }
        };
        HistogramBinsCreator.prototype.updateAttributesAndCalcHistogramBinsIfNeeded = function (series) {
            // The histogram scale is the only scale that is set based on drawstyle. Unfortunately,
            // when the series is added and the scale is initially created, we have no way of determining
            // the drawstyle. So we set the scale to a histogram scale here.
            this._setHistogramScaleIfNeeded(series);
            var binsNeedUpdating = this._didAttributesChange(series);
            if (binsNeedUpdating) {
                this._calcSeriesHistogramBins(series);
            }
        };
        HistogramBinsCreator.prototype._setHistogramScaleIfNeeded = function (series) {
            if (series.getScale(1 /* X */).scaleType !== 12 /* HISTOGRAM */ &&
                series.drawStyle === 62 /* HISTOGRAM */) {
                var seriesAxis = series.getAxis(1 /* X */);
                seriesAxis.setHistogramScale();
            }
        };
        HistogramBinsCreator.prototype._didAttributesChange = function (series) {
            var oldHistogramOptions = _$1.cloneDeep(this._histogramOptions);
            this._getHistogramAttributesFromSeries(series);
            return !_$1.isMatch(oldHistogramOptions, this._histogramOptions);
        };
        HistogramBinsCreator.prototype.getAttributesAndCalcSeriesHistogramBins = function (series) {
            this._getHistogramAttributesFromSeries(series);
            this._calcSeriesHistogramBins(series);
        };
        HistogramBinsCreator.prototype._calcSeriesHistogramBins = function (series) {
            this._getHistogramAttributesFromSeries(series);
            var unbinnedDataset = this._getUnbinnedDatasetForSeries(series);
            if (unbinnedDataset) {
                this.createHistogramBins(unbinnedDataset.data);
                this._replaceSeriesDatasets(series);
                this._resetAxis(series, 1 /* X */);
                this._resetAxis(series, 2 /* Y */);
            }
        };
        HistogramBinsCreator.prototype._replaceSeriesDatasets = function (series) {
            var xData = series.getData(1 /* X */);
            var binnedVals = this._structureHistogramBinsForSeries();
            xData.replace(0, binnedVals.x1);
            xData.replace(1, binnedVals.x2);
            series.getData(2 /* Y */).replace(0, binnedVals.y);
        };
        HistogramBinsCreator.prototype._resetAxis = function (series, dimension) {
            var axis = series.getAxis(dimension);
            if (axis.associatedSeries.length === 1) {
                var scale = axis.scale;
                scale.initialize(series.getData(dimension));
                scale.syncMembers();
            }
        };
        HistogramBinsCreator.prototype._getHistogramAttributesFromSeries = function (series) {
            this._histogramOptions.binMin = series.attributeSet.get('HistogramBinMin');
            this._histogramOptions.binMax = series.attributeSet.get('HistogramBinMax');
            this._histogramOptions.binCount = series.attributeSet.get('HistogramBinCount');
            this._histogramOptions.binSize = series.attributeSet.get('HistogramBinSize');
            this._histogramOptions.aggregateDataOutOfRange = series.attributeSet.get('HistogramAggregateDataOutOfRange');
            this._histogramOptions.adjustForNiceBins = series.attributeSet.get('HistogramAdjustForNiceBins');
            this._histogramOptions.countAsPercents = series.attributeSet.get('HistogramCountAsPercents');
        };
        HistogramBinsCreator.prototype._getUnbinnedDatasetForSeries = function (series) {
            var unbinnedDatasetId = this.getUnbinnedDatasetId(series.id);
            var unbinnedDataset = series.root.getObject(unbinnedDatasetId);
            if (isDataSet(unbinnedDataset)) {
                return unbinnedDataset;
            }
            else {
                return null;
            }
        };
        HistogramBinsCreator.prototype._structureHistogramBinsForSeries = function () {
            var x1 = [];
            var x2 = [];
            var y = [];
            if (this._histogramOptions.aggregateDataOutOfRange && this._belowRangeAggregate) {
                x1.push(this._belowRangeAggregate.binStart);
                x2.push(this._belowRangeAggregate.binEnd);
                y.push(this._belowRangeAggregate.frequency);
            }
            for (var _i = 0, _a = this._histogramBins; _i < _a.length; _i++) {
                var histogramBin = _a[_i];
                x1.push(histogramBin.binStart);
                x2.push(histogramBin.binEnd);
                y.push(histogramBin.frequency);
            }
            if (this._histogramOptions.aggregateDataOutOfRange && this._aboveRangeAggregate) {
                x1.push(this._aboveRangeAggregate.binStart);
                x2.push(this._aboveRangeAggregate.binEnd);
                y.push(this._aboveRangeAggregate.frequency);
            }
            return { x1: x1, x2: x2, y: y };
        };
        HistogramBinsCreator.prototype.getUnbinnedDatasetId = function (seriesId) {
            return seriesId + UnbinnedDatasetIdPostFix;
        };
        HistogramBinsCreator.prototype.setAttributesOnSeries = function (seriesWrapper) {
            var attributes = this._getAttributesFromOptions();
            for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                var attribute = attributes_1[_i];
                seriesWrapper.setAttribute(attribute.name, 'app', attribute.value);
            }
        };
        HistogramBinsCreator.prototype._getAttributesFromOptions = function () {
            var attributes = [];
            for (var _i = 0, _a = Object.keys(optionToAttributeName); _i < _a.length; _i++) {
                var key = _a[_i];
                var value = this._histogramOptions[key];
                var defValue = defaultOptions[key];
                if (!_$1.isUndefined(value) && value !== defValue) {
                    attributes.push({ name: optionToAttributeName[key], value: value });
                }
            }
            return attributes;
        };
        return HistogramBinsCreator;
    }());
    
    var HistogramAsColumnsBinsCreator = /** @class */ (function (_super) {
        __extends(HistogramAsColumnsBinsCreator, _super);
        function HistogramAsColumnsBinsCreator(histogramOptions, numDecimals) {
            if (histogramOptions === void 0) { histogramOptions = {}; }
            if (numDecimals === void 0) { numDecimals = 0; }
            var _this = _super.call(this, histogramOptions) || this;
            _this._numDecimals = numDecimals;
            return _this;
        }
        HistogramAsColumnsBinsCreator.prototype._replaceSeriesDatasets = function (series) {
            var columnLabels = [];
            var frequencies = [];
            if (this._histogramOptions.aggregateDataOutOfRange) {
                var belowRangeAggregate = this._getBelowRangeAggregateForSeries();
                columnLabels.push(belowRangeAggregate.columnLabel);
                frequencies.push(belowRangeAggregate.frequency);
            }
            for (var _i = 0, _a = this._histogramBins; _i < _a.length; _i++) {
                var bin = _a[_i];
                var startLabel = this._getColumnLabel(bin.binStart);
                var endLabel = this._getColumnLabel(bin.binEnd);
                columnLabels.push(startLabel + ' to ' + endLabel);
                frequencies.push(bin.frequency);
            }
            if (this._histogramOptions.aggregateDataOutOfRange) {
                var aboveRangeAggregate = this._getAboveRangeAggregateForSeries();
                columnLabels.push(aboveRangeAggregate.columnLabel);
                frequencies.push(aboveRangeAggregate.frequency);
            }
            series.getData(1 /* X */).replace(0, columnLabels);
            series.getData(2 /* Y */).replace(0, frequencies);
        };
        HistogramAsColumnsBinsCreator.prototype._getBelowRangeAggregateForSeries = function () {
            var columnLabel = '< ';
            var frequency;
            if (this._belowRangeAggregate) {
                columnLabel += this._getColumnLabel(this._belowRangeAggregate.binEnd);
                frequency = this._belowRangeAggregate.frequency;
            }
            else {
                columnLabel += this._getColumnLabel(_$1.first(this._histogramBins).binStart);
                frequency = 0;
            }
            return { columnLabel: columnLabel, frequency: frequency };
        };
        HistogramAsColumnsBinsCreator.prototype._getAboveRangeAggregateForSeries = function () {
            var columnLabel = '>= ';
            var frequency;
            if (this._aboveRangeAggregate) {
                columnLabel += this._getColumnLabel(this._aboveRangeAggregate.binStart);
                frequency = this._aboveRangeAggregate.frequency;
            }
            else {
                columnLabel += this._getColumnLabel(_$1.last(this._histogramBins).binEnd);
                frequency = 0;
            }
            return { columnLabel: columnLabel, frequency: frequency };
        };
        HistogramAsColumnsBinsCreator.prototype._getColumnLabel = function (value) {
            return value.toFixed(this._numDecimals);
        };
        HistogramAsColumnsBinsCreator.prototype._didAttributesChange = function (series) {
            var oldNumDecimals = this._numDecimals;
            if (_super.prototype._didAttributesChange.call(this, series)) {
                return true;
            }
            else {
                return oldNumDecimals !== this._numDecimals;
            }
        };
        HistogramAsColumnsBinsCreator.prototype._setHistogramScaleIfNeeded = function (series) {
            if (series.getScale(1 /* X */).scaleType !== 4 /* STRING */ &&
                series.drawStyle === 64 /* HISTOGRAM_AS_COLUMNS */) {
                var seriesAxis = series.getAxis(1 /* X */);
                seriesAxis.setLookupScale();
            }
        };
        HistogramAsColumnsBinsCreator.prototype.setAttributesOnSeries = function (seriesWrapper) {
            _super.prototype.setAttributesOnSeries.call(this, seriesWrapper);
            seriesWrapper.setAttribute('HistogramAsColumnsNumDecimals', 'app', this._numDecimals);
        };
        HistogramAsColumnsBinsCreator.prototype._getHistogramAttributesFromSeries = function (series) {
            _super.prototype._getHistogramAttributesFromSeries.call(this, series);
            this._numDecimals = series.attributeSet.get('HistogramAsColumnsNumDecimals');
        };
        return HistogramAsColumnsBinsCreator;
    }(HistogramBinsCreator));
    
    var FDSPlotWrapper = /** @class */ (function (_super) {
        __extends(FDSPlotWrapper, _super);
        function FDSPlotWrapper(opts) {
            if (opts === void 0) { opts = {}; }
            var _this = _super.call(this, opts) || this;
            if (optsArePlot(opts)) {
                _this.factors = Factors.createFromChartObject(opts);
                _this.label = _this._chartObject.attributeSet.get('Label');
                _this.initialize();
            }
            else {
                // If we don't pass in an ID with the options hash, then we will have
                // to determine the automatic ID later when adding to the chart.
                _this.id = (opts.id != null) ? opts.id : null;
                _this.label = (opts.label != null) ? opts.label : null;
                if (opts.factors == null) {
                    opts.factors = { xMin: 0, xMax: 1, yMin: 0, yMax: 1 };
                }
                _this.factors = new Factors(opts.factors.xMin, opts.factors.xMax, opts.factors.yMin, opts.factors.yMax);
            }
            _this.seriesListDirty = true;
            _this.axisListDirty = true;
            _this.seriesList = [];
            _this.axisList = [];
            return _this;
        }
        FDSPlotWrapper.prototype.initialize = function () {
            this.plotBGBrush = new BrushWrapper(this, 'PlotBG');
            this.chartBGBrush = new BrushWrapper(this, 'ChartBG');
            this.zoomRectBrush = new BrushWrapper(this, 'HorizontalZoomRect');
            this.zoomHandleBrush = new BrushWrapper(this, 'HorizonalZoomHandle');
            this.zoomFadeBrush = new BrushWrapper(this, 'HorizontalZoomFade');
            this.chartFGPen = new PenWrapper(this, 'ChartFG');
            this.plotFGPen = new PenWrapper(this, 'PlotFG');
            this.legendFont = new FontWrapper(this, 'LegendFont');
        };
        FDSPlotWrapper.prototype.updateSeriesCache = function () {
            var _this = this;
            this.seriesList = Object.keys(this._chartObject.seriesList)
                .map(function (o) { return _this._chartObject.seriesList[o].wrapper; });
            this.seriesListDirty = false;
        };
        FDSPlotWrapper.prototype.updateAxisCache = function () {
            this.axisList = this._chartObject.axes.map(function (o) { return o.wrapper; });
            this.axisListDirty = false;
        };
        /* BEGIN PUBLIC API */
        /**
         * Adds a series to the plot.
         *
         * @param {FDSSeriesWrapper} series - The wrapper of the series to add.
         * @returns {FDSPlotWrapper} The instance of the plot wrapper, for chainability.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.addSeries = function (series) {
            series.addToPlot(this.chart, this);
            return this;
        };
        /**
         * Calculates bins and frequencies for an array of values. Then, this method uses the calculated data
         * to create a histogram series with the given id and adds the series to the plot.
         *
         * @param {string} seriesId - The id to give the created series.
         * @param {number[]} values - A list of numbers, whose distribution is to be counted.
         * @param {HistogramOptions = {}} histogramOptions - An optional object that contains options for the histogram calculation.
         * @param {HistogramDataOptions = {}} xDataOptions - An optional object that contains id and label for the x dataset.
         * @param {HistogramDataOptions = {}} yDataOptions - An optional object that contains id and label for the y dataset.
         * @returns {FDSSeriesWrapper} The wrapper of the added series.
         */
        FDSPlotWrapper.prototype.addHistogramSeries = function (seriesId, values$$1, histogramOptions, xDataOptions, yDataOptions) {
            if (histogramOptions === void 0) { histogramOptions = {}; }
            if (xDataOptions === void 0) { xDataOptions = {}; }
            if (yDataOptions === void 0) { yDataOptions = {}; }
            var binsCreator = new HistogramBinsCreator(histogramOptions);
            var chartObjectIds = this.chart.getAllObjectIds();
            var xDataIdIsDuplicated = !_$1.isUndefined(xDataOptions.id) &&
                _$1.includes(chartObjectIds.concat([seriesId, yDataOptions.id]), xDataOptions.id);
            var yDataIdIsDuplicated = !_$1.isUndefined(yDataOptions.id) &&
                _$1.includes(chartObjectIds.concat([seriesId, xDataOptions.id]), yDataOptions.id);
            if (xDataIdIsDuplicated || yDataIdIsDuplicated) {
                return null;
            }
            var xData = new FDSDataWrapper({
                id: xDataOptions.id,
                label: xDataOptions.label,
                dataType: 'float',
                data: [],
                children: [[]]
            });
            var yData = new FDSDataWrapper({
                id: yDataOptions.id,
                label: yDataOptions.label,
                dataType: 'float',
                data: []
            });
            var histogramSeries = new FDSSeriesWrapper({
                id: seriesId,
                x: xData,
                y: yData,
                drawStyle: 62 /* HISTOGRAM */
            });
            histogramSeries.addToPlot(this.chart, this);
            binsCreator.setAttributesOnSeries(histogramSeries);
            // We add the unbinned data as a child data set of the chart.
            var unbinnedData = new FDSDataWrapper({
                id: binsCreator.getUnbinnedDatasetId(seriesId),
                dataType: 'float',
                data: values$$1
            });
            unbinnedData.addToChart(this.chart);
            return histogramSeries;
        };
        /**
         * Calculates bins and frequencies for an array of values. Then, this method uses the calculated data
         * to create a column series with the given id and adds the series to the plot.
         *
         * @param {string} seriesId - The id to give the created series.
         * @param {number[]} values - A list of numbers, whose distribution is to be counted.
         * @param {HistogramOptions = {}} histogramOptions - An optional object that contains options for the histogram calculation.
         * @param {HistogramDataOptions = {}} xDataOptions - An optional object that contains id and label for the x dataset.
         * @param {HistogramDataOptions = {}} yDataOptions - An optional object that contains id and label for the y dataset.
         * @param {numDecimals = 0} - The number of decimals that the column labels should have.
         * @returns {FDSSeriesWrapper} The wrapper of the added series.
         */
        FDSPlotWrapper.prototype.addHistogramSeriesAsColumns = function (seriesId, values$$1, histogramOptions, xDataOptions, yDataOptions, numDecimals) {
            if (histogramOptions === void 0) { histogramOptions = {}; }
            if (xDataOptions === void 0) { xDataOptions = {}; }
            if (yDataOptions === void 0) { yDataOptions = {}; }
            if (numDecimals === void 0) { numDecimals = 0; }
            var chartObjectIds = this.chart.getAllObjectIds();
            var xDataIdIsDuplicated = !_$1.isUndefined(xDataOptions.id) &&
                _$1.includes(chartObjectIds.concat([seriesId, yDataOptions.id]), xDataOptions.id);
            var yDataIdIsDuplicated = !_$1.isUndefined(yDataOptions.id) &&
                _$1.includes(chartObjectIds.concat([seriesId, xDataOptions.id]), yDataOptions.id);
            if (xDataIdIsDuplicated || yDataIdIsDuplicated) {
                return null;
            }
            var binsCreator = new HistogramAsColumnsBinsCreator(histogramOptions, numDecimals);
            var xData = new FDSDataWrapper({
                id: xDataOptions.id,
                label: xDataOptions.label,
                dataType: 'string',
                data: []
            });
            var yData = new FDSDataWrapper({
                id: yDataOptions.id,
                label: yDataOptions.label,
                dataType: 'float',
                data: []
            });
            var columnsSeries = new FDSSeriesWrapper({
                id: seriesId,
                x: xData,
                y: yData,
                drawStyle: 64 /* HISTOGRAM_AS_COLUMNS */
            });
            columnsSeries.addToPlot(this.chart, this);
            binsCreator.setAttributesOnSeries(columnsSeries);
            // We add the unbinned data as a child data set of the chart.
            var unbinnedData = new FDSDataWrapper({
                id: binsCreator.getUnbinnedDatasetId(seriesId),
                dataType: 'float',
                data: values$$1
            });
            unbinnedData.addToChart(this.chart);
            return columnsSeries;
        };
        /**
         * Removes a series from the plot.
         *
         * @param {FDSSeriesWrapper} series - The wrapper of the series to remove.
         * @returns {FDSPlotWrapper} - The instance of the plot wrapper, for chainability.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.removeSeries = function (series) {
            series.removeFromChart(this.chart, true);
            return this;
        };
        /**
         * Adds an axis to the plot.
         *
         * @param {FDSAxisWrapper} axis - The wrapper of the axis to add.
         * @returns {FDSPlotWrapper} - The instance of the plot wrapper, for chainability.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.addAxis = function (axis) {
            axis.addToPlot(this.chart, this);
            return this;
        };
        /**
         * Returns the wrapper for the first axis with the provided dimension, or undefined if it does not exist.
         *
         * @param {string} dimension - The dimension of the child axis to fetch (valid values: 'x', 'y').
         * @returns {FDSAxisWrapper} The wrapper for the axis with the provided id.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.getChildAxisByDimension = function (dimension) {
            var dim = this._dimensionStringToDIM(dimension);
            if (dim != null) {
                var axisObj = this._chartObject.getAxisByDimension(dim);
                if (axisObj) {
                    return axisObj.wrapper;
                }
            }
            return undefined;
        };
        /**
         * Returns the wrapper for the axis with the provided id, or undefined if it does not exist.
         *
         * @param {string} id - The id of the child axis to fetch.
         * @returns {FDSAxisWrapper} The wrapper for the axis with the provided id.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.getChildAxisById = function (id) {
            var axisObj = this._chartObject.getAxis(id);
            if (axisObj) {
                return axisObj.wrapper;
            }
            else {
                return null;
            }
        };
        /**
         * Removes an axis from the plot.
         *
         * @param {FDSAxisWrapper} axis - An wrapper of the axis to remove.
         * @returns {FDSPlotWrapper} - The instance of the plot wrapper, for chainability.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.removeAxis = function (axis) {
            axis.removeFromChart(this.chart);
            return this;
        };
        /**
         * Returns the wrapper for the series with the provided id, or undefined if it does not exist.
         *
         * @param {string} id - The id of the child series to fetch.
         * @returns {FDSSeriesWrapper} The wrapper for the series with the provided id.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.getChildSeriesById = function (id) {
            if (this.seriesListDirty) {
                this.updateSeriesCache();
            }
            console.assert(this._chartObject.children[id] != null, this.id + " has no series child with name: " + id);
            return _$1.find(this.seriesList, function (series) { return series.id === id; });
        };
        /**
         * Gets a list of the series attached to this plot.
         *
         * @returns {FDSSeriesWrapper[]} An array containing the wrapper objects for the series on the plot.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.getSeriesChildren = function () {
            if (this.seriesListDirty) {
                this.updateSeriesCache();
            }
            return _$1.clone(this.seriesList);
        };
        /**
         * Gets a list of the axes attached to this plot.
         *
         * @returns {FDSAxisWrapper[]} An array containing the wrapper objects for the axes on the plot.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.getAxisChildren = function () {
            if (this.axisListDirty) {
                this.updateAxisCache();
            }
            return _$1.clone(this.axisList);
        };
        /**
         *
         * @typedef {Object} PlotRect
         * @property {number} x1 The x-coordinate of the left edge of the plot area.
         * @property {number} x2 The x-coordinate of the right edge of the plot area.
         * @property {number} y1 The y-coordinate of the top edge of the plot area.
         * @property {number} y2 The y-coordinate of the bottom edge of the plot area.
         */
        /**
         * Returns a rectangle with coordinates of the bounding rect for the plot area, including the chart offsets on the
         * page.
         *
         * @returns {PlotRect} A rectangle with coordinates of the bounding rect for the plot area.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.getClientRect = function () {
            var rect = this._chartObject.renderManager.chartRect;
            var clientRect = this._chartObject.root.containing_element.getBoundingClientRect();
            return ({
                x1: scaleByDevicePixelRatioInverse(rect.x1) + clientRect.left,
                y1: scaleByDevicePixelRatioInverse(rect.y1) + clientRect.top,
                x2: scaleByDevicePixelRatioInverse(rect.x2) + clientRect.left,
                y2: scaleByDevicePixelRatioInverse(rect.y2) + clientRect.top
            });
        };
        /**
         * Returns whether or not the plot has data.
         *
         * @returns {boolean} True if the plot has data and false if the plot has no data.
         *
         * @memberOf FDSPlotWrapper
         */
        FDSPlotWrapper.prototype.hasValidData = function () {
            console.assert(this.attached, 'Unable to check data since we are in a detached state');
            console.assert((this._chartObject.renderManager != null), 'Unable to check data as the render manager does not exist');
            return this._chartObject.renderManager.hasPrimaryData;
        };
        /**
         * Shades all hitshapes in the plot hitshape list for easier debugging
         */
        FDSPlotWrapper.prototype.shadeHitShapes = function () {
            this._chartObject.shadeHitshapes();
        };
        /* END PUBLIC API */
        FDSPlotWrapper.prototype.addToChart = function (chart) {
            console.assert(!this.attached, "Plot " + this.id + " is already attached to the chart");
            if (this.id == null) {
                this.setId(chart.getNextPlotId());
            }
            FDSChartObjectWrapper.unwrap(chart)
                .addObject(this.id, 4 /* FC_PLOT */, 0 /* NO_FLAGS */, this.label, this.factors.toArray(), this);
            console.assert(chart.getObjectById(this.id) != null, "FDSPlotWrapper failed to attach plot " + this.id + " to chart");
            this._chartObject = FDSChartObjectWrapper.unwrap(chart).objects[this.id];
            this.attached = true;
            this.initialize();
            this.chart = chart;
        };
        FDSPlotWrapper.prototype.removeFromChart = function (chart, deleteChildren) {
            if (deleteChildren === void 0) { deleteChildren = false; }
            console.assert(this.attached && (chart.getObjectById(this.id) != null), "Plot " + this.id + " is not attached to the chart");
            var deleteFlag = deleteChildren ? 1 /* DELETE_WITH_CHILD */ : 0;
            FDSChartObjectWrapper.unwrap(chart).deleteObject(this.id, deleteFlag);
            console.assert(!(chart.getObjectById(this.id) != null), "FDSPlotWrapper failed to delete plot " + this.id + " from chart");
            this._chartObject = null;
            this.attached = false;
            this.chart = null;
        };
        FDSPlotWrapper.prototype._dimensionStringToDIM = function (dimension) {
            if (dimension === 'x') {
                return 1 /* X */;
            }
            else if (dimension === 'y') {
                return 2 /* Y */;
            }
            return undefined;
        };
        FDSPlotWrapper.selector = 'FDSPlotWrapper';
        FDSPlotWrapper = __decorate([
            FDSChartObjectWrapperLogDecorator
        ], FDSPlotWrapper);
        return FDSPlotWrapper;
    }(FDSChartObjectWrapper));
    var optsArePlot = function (opts) {
        return isChartObject(opts) && isPlot(opts);
    };
    var Factors = /** @class */ (function () {
        function Factors(xMin, xMax, yMin, yMax) {
            if (xMin === void 0) { xMin = 0; }
            if (xMax === void 0) { xMax = 1; }
            if (yMin === void 0) { yMin = 0; }
            if (yMax === void 0) { yMax = 1; }
            this.xMin = xMin;
            this.xMax = xMax;
            this.yMin = yMin;
            this.yMax = yMax;
        }
        Factors.prototype.toArray = function () {
            return [this.xMin, this.xMax, this.yMin, this.yMax];
        };
        Factors.createFromChartObject = function (obj) {
            return new Factors(obj.attributeSet.get('minXFactor'), obj.attributeSet.get('maxXFactor'), obj.attributeSet.get('minYFactor'), obj.attributeSet.get('maxXFactor'));
        };
        return Factors;
    }());
    
    var ColorMap = /** @class */ (function () {
        // colors are represented as RGB percentage floats
        // ie 1 is equivalent to 255, etc
        function ColorMap(colorScheme, color1, color2) {
            if (color1 === void 0) { color1 = new FDSColor(0, 0, 0); }
            if (color2 === void 0) { color2 = new FDSColor(1, 1, 1); }
            this.setMap(colorScheme, color1, color2);
        }
        ColorMap.prototype.setMap = function (colorScheme, color1, color2, color3, lightenFactor) {
            this._mapElements = [];
            this.scheme = colorScheme;
            switch (colorScheme) {
                case 0 /* BW */:
                    this._mapElements = [
                        { color: new FDSColor(0, 0, 0), index: 0 },
                        { color: new FDSColor(1, 1, 1), index: 1 }
                    ];
                    break;
                case 1 /* RAINBOW */:
                    this._mapElements = [
                        { color: new FDSColor(0, 0, 1), index: 0 },
                        { color: new FDSColor(0, 1, 1), index: .25 },
                        { color: new FDSColor(0, 1, 0), index: .5 },
                        { color: new FDSColor(1, 1, 0), index: .75 },
                        { color: new FDSColor(1, 0, 0), index: 1 }
                    ];
                    break;
                case 2 /* FAST */:
                    this._mapElements = [
                        { color: new FDSColor(0, 0, 0), index: 0 },
                        { color: new FDSColor(0, 0, 1), index: 0.142857 },
                        { color: new FDSColor(0, 1, 1), index: 0.285714 },
                        { color: new FDSColor(0, 1, 0), index: 0.428571 },
                        { color: new FDSColor(1, 1, 0), index: 0.571429 },
                        { color: new FDSColor(1, 0, 0), index: 0.714286 },
                        { color: new FDSColor(1, 0, 1), index: 0.857143 },
                        { color: new FDSColor(1, 1, 1), index: 1.0 }
                    ];
                    break;
                case 3 /* CONTRAST */:
                    this._mapElements = [
                        { color: new FDSColor(1, 1, 1), index: 0 },
                        { color: new FDSColor(0, 0.4, 1), index: 0.071429 },
                        { color: new FDSColor(0, .85, 1), index: 0.142857 },
                        { color: new FDSColor(0, 1, 0), index: 0.214286 },
                        { color: new FDSColor(1, .7, 0), index: 0.285714 },
                        { color: new FDSColor(1, 1, 0), index: 0.357143 },
                        { color: new FDSColor(0, 0, 1), index: 0.428571 },
                        { color: new FDSColor(0, .15, .6), index: 0.5 },
                        { color: new FDSColor(.85, .55, .85), index: 0.571429 },
                        { color: new FDSColor(1, 0, 1), index: 0.642857 },
                        { color: new FDSColor(.35, .75, 0), index: 0.714286 },
                        { color: new FDSColor(.45, .95, .35), index: 0.785714 },
                        { color: new FDSColor(.6, .1, .2), index: 0.857143 },
                        { color: new FDSColor(1, 0, 0), index: 0.928571 },
                        { color: new FDSColor(.4, .4, .4), index: 1.0 }
                    ];
                    break;
                case 5 /* GRADIENT */:
                case 4 /* ALSO_GRADIENT */:
                    this._mapElements = [
                        { color: color2, index: 0 },
                        { color: color1, index: 1 }
                    ];
                    break;
                case 6 /* AUTOLIGHTEN */:
                    var center = 10.0;
                    var factorMin = center - lightenFactor;
                    var factorMax = center + lightenFactor;
                    var lColor = color1;
                    var hColor = new FDSColor(color1.r, color1.g, color1.b);
                    lColor.lightenByPercent(factorMin);
                    hColor.lightenByPercent(factorMax);
                    this._mapElements = [
                        { color: lColor, index: 0 },
                        { color: hColor, index: 1 }
                    ];
                    break;
                case 7 /* GREENRED */:
                    this._mapElements = [
                        { color: new FDSColor(1, 0, 0), index: 0 },
                        { color: new FDSColor(0, 0, 0), index: 0.5 },
                        { color: new FDSColor(0, 1, 0), index: 1 }
                    ];
                    break;
                case 9 /* UP_NEUTRAL_DOWN */:
                    this._mapElements = [
                        { color: color1, index: 0 },
                        { color: color2, index: 0.5 },
                        { color: color3, index: 1 }
                    ];
                    break;
                default:
                    this._setDefaultMap();
            }
        };
        // custom maps get their own call
        ColorMap.prototype.setCustomMap = function (colorData) {
            this._mapElements = [];
            if (!colorData) {
                this._setDefaultMap();
                return;
            }
            var childId = colorData.childIds[0];
            var child = colorData.children[childId];
            if (!child || !child.data || !colorData.data) {
                this._setDefaultMap();
                return;
            }
            for (var i = 0; i < colorData.data.length; i++) {
                var color = Number(colorData.data[i]);
                var newcolor = new FDSColor(color);
                this._mapElements.push({ color: newcolor, index: Number(child.getAt(i)) });
            }
            this._mapElements.sort(function (a, b) { return a.index - b.index; });
        };
        ColorMap.prototype._setDefaultMap = function () {
            // default is BW
            return this._mapElements = [
                { color: new FDSColor(0, 0, 0), index: 0 },
                { color: new FDSColor(1, 1, 1), index: 1 }
            ];
        };
        ColorMap.prototype.getColorMapElements = function () {
            return this._mapElements;
        };
        // using the current color mapping, do a weighted average
        // on the closest colors to the value and return the color
        // takes in an index between 0 and 1
        ColorMap.prototype.getColor = function (index) {
            var length = this._mapElements.length;
            if (length === 0) {
                return new FDSColor();
            }
            var min$$1 = this._mapElements[0].index;
            var max$$1 = this._mapElements[length - 1].index;
            if (index < min$$1) {
                return this._mapElements[0].color;
            }
            else if (index > max$$1) {
                return this._mapElements[length - 1].color;
            }
            else {
                // find the weighted average
                var lo = 0;
                var hi = 0;
                var iterable = this._mapElements;
                for (var i = 0; i < iterable.length; i++) {
                    var element = iterable[i];
                    if (element.index === index) {
                        return element.color;
                    }
                    else if (element.index >= index) {
                        hi = i;
                        break;
                    }
                }
                if (hi === 0) {
                    return this._mapElements[0].color;
                }
                lo = hi - 1;
                var clr_lo = this._mapElements[lo].color;
                var clr_hi = this._mapElements[hi].color;
                var range = this._mapElements[hi].index - this._mapElements[lo].index;
                var offset = index - this._mapElements[lo].index;
                var percent = (range === 0) ? .5 : offset / range;
                var pct_inv = 1 - percent;
                return new FDSColor(clr_lo.r * pct_inv + clr_hi.r * percent, clr_lo.g * pct_inv + clr_hi.g * percent, clr_lo.b * pct_inv + clr_hi.b * percent);
            }
        };
        return ColorMap;
    }());
    var setPieColorMapColors = function (series, defaultColor, proposedColor, index) {
        var bgColor = defaultColor;
        var outlineColor = series.seriesOutlinePen.color;
        var cycleColorIndex = series.cycleColorIndex;
        var useColor = series.useColor;
        if (series.attributeSet.isInheritedDefault('CycleColorIndex')) {
            cycleColorIndex = true;
            useColor = true;
        }
        if (useColor && !IsNA(proposedColor)) {
            if (series.useColorMap) {
                var cScale = (series.getAxis(4 /* COLOR */)).getScale();
                bgColor = series.colorMap.getColor(cScale.lookup(proposedColor)).getCOLORREF();
            }
            else if (series.useColorIndex) {
                bgColor = series.getSeriesColor(proposedColor);
                if (series.isSeriesOutlineColorDefault) {
                    outlineColor = series.getSeriesOutlineColor(proposedColor);
                }
            }
            else if (cycleColorIndex) {
                bgColor = series.getSeriesColor(index);
                if (series.isSeriesOutlineColorDefault) {
                    outlineColor = series.getSeriesOutlineColor(index);
                }
            }
            else {
                bgColor = proposedColor;
            }
        }
        return { bgColor: bgColor, outlineColor: outlineColor };
    };
    
    var FDSLegend = /** @class */ (function (_super) {
        __extends(FDSLegend, _super);
        function FDSLegend(root, id, parent) {
            var _this = _super.call(this, root, id, 8 /* FC_LEGEND */) || this;
            _this.parent = parent;
            if (_this.wrapper == null) {
                _this.wrapper = new FDSChartObjectWrapper(_this);
            }
            _this._setAttributes();
            _this._parentPropertySet = _this.parent.properties;
            return _this;
        }
        FDSLegend.prototype._init = function () {
            this._defMapID = 'DEF_LEGEND';
            _super.prototype._init.call(this);
            this.legendProperties = new LegendProperties(this, this.id, this.attributeSet);
            this.seriesArray = [];
            this._entries = [];
            this.clearRenderCache();
        };
        FDSLegend.prototype.getPrefix = function () {
            return 'Legend';
        };
        FDSLegend.prototype.clearRenderCache = function () {
            this.canvas = this.root.createRenderingLayer();
            if (this.parent && this.parent.isActiveLegendHeatmap()) {
                this.parent.heatmapLegend.clearRenderCache();
            }
        };
        FDSLegend.prototype._getAttributesForSerialization = function (genApp, genUser, appAttrs, userAttrs) {
            var _this = this;
            var prefix = 'Legend';
            var updateAttrs = function (level, retObject) {
                for (var _i = 0, _a = _this.attributeSet.getValuesAtLevel(level); _i < _a.length; _i++) {
                    var _b = _a[_i], name_1 = _b.name, value = _b.value;
                    if (name_1 !== 'Legend') {
                        retObject.push({ name: prefix + name_1, value: value });
                    }
                    else {
                        retObject.push({ name: name_1, value: value });
                    }
                }
            };
            if (genApp) {
                updateAttrs('app', appAttrs);
            }
            if (genUser) {
                updateAttrs('user', userAttrs);
            }
        };
        FDSLegend.prototype._setAttributes = function () {
            if (!this.legendProperties.attributeSet.defaultMap.startInitialization()) {
                return;
            }
            _super.prototype._setAttributes.call(this);
            this.legendProperties._setAttributes();
            this.legendProperties.attributeSet.defaultMap.finalizeInitialization();
        };
        FDSLegend.prototype.syncMembers = function () {
            _super.prototype.syncMembers.call(this);
            this.legendProperties.syncMembers();
            if (this.parent && this.parent.isActiveLegendHeatmap()) {
                this.parent.heatmapLegend.syncMembers();
            }
        };
        // Returns either just this plot's entries, or if GroupedLegend is true,
        // other plots with GroupedLegend set to true entries plus ours
        // Does some other entries logic as well like reversing and slicing the entries array if necessary
        // @return [Array<LegendEntry>] an array (divorced from the @entries object) containing the entries for this legend
        FDSLegend.prototype._getEntries = function () {
            // copy the entries array so you don't modify it itself
            var entries = this._entries.slice();
            var sortFunc = function (a, b) {
                if (a.index > b.index) {
                    return 1;
                }
                if (a.index < b.index) {
                    return -1;
                }
                return 0;
            };
            if (this.legendProperties.orderCustom) {
                entries.sort(sortFunc);
            }
            if (this.legendProperties.reverse) {
                entries = entries.reverse();
            }
            if (this.parent.groupedLegend) {
                var sibs = this.parent.parent.children;
                for (var s in sibs) {
                    var sib = sibs[s];
                    if (sib === this.parent) {
                        continue;
                    }
                    if (!isPlot(sib)) {
                        continue;
                    }
                    var plot = sib;
                    if (!plot.groupedLegend) {
                        continue;
                    }
                    entries = entries.concat(plot.legend._entries);
                }
            }
            if (this.legendProperties.maxEntries > 0 && this.legendProperties.maxEntries < entries.length) {
                entries = entries.slice(0, this.legendProperties.maxEntries);
            }
            return entries;
        };
        FDSLegend.prototype._applyStyleObjects = function () {
            return null;
        };
        FDSLegend.prototype.getStyleObjectName = function () {
            if (this.isStyleObject) {
                return 'FDSChart';
            }
            else {
                return 'FC_PLOT_Legend';
            }
        };
        FDSLegend.prototype.getObjectTypeName = function () {
            return 'FDSLegend';
        };
        // This function will take all of the series in @seriesArray and
        // determines if the series is `eligible` to be in the legend.
        // Then, if a series in the legends seriesArray is a PieDrawStyle,
        // it creates entries for each of the datapoints in the series.
        FDSLegend.prototype.formatEntries = function () {
            this._entries = [];
            var lp = this.legendProperties;
            for (var _i = 0, _a = this.seriesArray; _i < _a.length; _i++) {
                var series = _a[_i];
                // skip series if invalid and we're not showing invalid series
                if (!(series.hasValidData || lp.showInvalidSeries)) {
                    continue;
                }
                // we must reparse legendText for each series because
                // the CompiledPropertyString must be in the context of each series
                // as a short-circuit, we only do this if the property is more complex than the default
                // which we can handle without parsing.
                var labelCPS = void 0;
                if (lp.legendText !== '<FDSLegendLabel>') {
                    labelCPS = series.properties.compilePropertyString(lp.legendText);
                }
                var eligible = false;
                var quickLabels = false;
                if (lp.annotation) {
                    // annotation legend not supported yet
                    eligible = false;
                    return;
                }
                else if (lp.footnote) {
                    // footnote legend not supported yet
                    eligible = false;
                    return;
                }
                else if (series.isAnnotation) {
                    // annotations have their own rules
                    eligible = series.annotationInLegend && series.annotationAllowAnnotInLegend;
                }
                else {
                    eligible = series.inLegend;
                }
                if (!series.hasValidData) {
                    eligible = eligible && lp.showInvalidSeries;
                }
                if ((series.visible && eligible) || (eligible && series.interactiveVisibleOverride)) {
                    var seriesDS = series.getEffectiveDrawStyle();
                    var pieFormatter = new FDSFormat();
                    pieFormatter.setNumberFormat(series.pieDesc.percentFormat);
                    var pieCount = 0;
                    var totalOfAbsVals = series.getData(2 /* Y */).dataSetSumOfAbsoluteVals(0);
                    var snumber = void 0;
                    if (seriesDS === 19 /* PIE */ || seriesDS === 36 /* PIE3D */) {
                        snumber = series.size;
                    }
                    else {
                        snumber = 1;
                    }
                    var bgColor = void 0;
                    var outlineColor = void 0;
                    for (var index = 0; index < snumber; index++) {
                        var drawEntry = true;
                        var str = void 0;
                        if (seriesDS === 19 /* PIE */ || seriesDS === 36 /* PIE3D */) {
                            var yValue = series.getData(2 /* Y */).getAt(index);
                            var cValue = series.getData(4 /* COLOR */).getAt(index);
                            var colors = series.getSeriesColors();
                            var fgColor = colors[0];
                            bgColor = colors[1], outlineColor = colors[2];
                            drawEntry = !IsSomeNAN(yValue);
                            if (drawEntry) {
                                var colorScale = series.getAxis(4 /* COLOR */).getScale();
                                var defaultColor = series.getSeriesColor(pieCount);
                                if ((colorScale != null) && !IsSomeNAN(cValue)) {
                                    (_b = setPieColorMapColors(series, defaultColor, Number(cValue), pieCount), bgColor = _b.bgColor, outlineColor = _b.outlineColor);
                                }
                                else {
                                    bgColor = defaultColor;
                                    outlineColor = series.seriesOutlinePen.color;
                                }
                                str = this._getResolvedLegendText(labelCPS, index, series, lp);
                                var tempStr = '';
                                if (series.pieDesc.piePercent) {
                                    tempStr += pieFormatter.formatAsNumber((Math.abs(yValue) / totalOfAbsVals) * 100);
                                    str = str.concat(tempStr);
                                }
                                pieCount++;
                            }
                        }
                        else {
                            str = this._getResolvedLegendText(labelCPS, index, series, lp);
                        }
                        if (drawEntry) {
                            var entry = new LegendEntry(series, this);
                            entry.showMarker = lp.showMarker;
                            entry.markerOnRight = lp.markerOnRight;
                            entry.str = str;
                            entry.seriesColor = series.getSeriesColor();
                            entry.textFollowsSeriesColor = series.legendTextFollowsSeriesColor;
                            if (outlineColor != null) {
                                entry.pen = series.seriesOutlinePen.with({ color: outlineColor });
                            }
                            else {
                                entry.pen = series.seriesOutlinePen;
                            }
                            var brushStyle = series.bgStyle;
                            entry.brush = series.seriesBGBrush.copy();
                            entry.brush.style = brushStyle === 4 /* STEPPED */ ? 0 /* SOLID */ : brushStyle;
                            if (bgColor != null) {
                                entry.brush.color = bgColor;
                            }
                            entry.index = series.legendOrderIndex;
                            this._entries.push(entry);
                        }
                    }
                }
            }
            var _b;
        };
        // Resolves the legend text properties
        //
        // @param formatString [CompiledPropertyString] property resolver for the series
        // @param index [Integer] if this is a pie chart, the index of the data point we are resolving
        // @param series [FDSSeries] the series object atht this will get resolved to
        // @param lp [LegendProperties] reference to the legend properties, for simplicity
        // @return [String] resolved legend text
        FDSLegend.prototype._getResolvedLegendText = function (formatString, index, series, lp) {
            var drawStyle = series.getEffectiveDrawStyle();
            var context = drawStyle === 19 /* PIE */ || drawStyle === 36 /* PIE3D */ ?
                { propertySet: series.properties, seriesIndex: index }
                :
                    {};
            if (formatString != null) {
                return formatString.fromValueRT(context);
            }
            else {
                return series._propFDSLegendLabel(context);
            }
        };
        // Adjusts the size info
        FDSLegend.prototype._adjustCanvas = function (entries, sizeInfo, ctx, font) {
            // if the legend is centered on the plot then limit its width to the width of the plot
            // otherwise limit it to width of chart
            var rectWidth = this.root.chartRect.x2 - this.root.chartRect.x1;
            if (this.legendProperties.basePosition === 2 /* CENTER */) {
                rectWidth = this.parent.plotRect.x2 - this.parent.plotRect.x1;
            }
            if (this.legendProperties.wrapEntriesText) {
                font = font.with({ widthHint: rectWidth - (sizeInfo.space * 2) - sizeInfo.markerWidth });
                // recompute size with the new font widthHint
                sizeInfo = this._computeSize(ctx, font);
            }
            while (sizeInfo.width > rectWidth) {
                if (this.legendProperties.direction === 1 /* ROW */) {
                    // set larger nums/0 explicitly to entries.length which is identical behavior but makes the math easier
                    if (this.legendProperties.entryBreak <= 0 || this.legendProperties.entryBreak > entries.length) {
                        this.legendProperties.entryBreak = entries.length;
                    }
                    if (this.legendProperties.entryBreak === 1) {
                        break;
                    } // can't shift any more
                    this.legendProperties.entryBreak -= 1; // make the rows a bit shorter see if it helps
                }
                else {
                    // in these cases it's already a column of width 1, can't do any more
                    if (this.legendProperties.entryBreak <= 0 || this.legendProperties.entryBreak >= entries.length) {
                        break;
                    }
                    this.legendProperties.entryBreak += 1; // make the columns a bit taller see if it helps
                }
                sizeInfo = this._computeSize(ctx, font);
            }
            return [sizeInfo, font];
        };
        FDSLegend.prototype.renderToCanvas = function () {
            var _this = this;
            var cleanupCanvas = function () { return _this.canvas.resize(0, 0); };
            // Abort if we're not `visible`
            if (!this.legendProperties.visible) {
                cleanupCanvas();
                return false;
            }
            var entries = this._getEntries();
            if (entries.length === 0) {
                cleanupCanvas();
                return false;
            }
            // Initialize a blank canvas; we'll need to resize it later once we
            // calculate the dimensions of the legend area and its entries
            var ctx = this.canvas.context;
            var font = this.legendProperties.font;
            font.setOnCanvas(ctx);
            var sizeInfo;
            if (this.legendProperties.axisPosition === 3 /* MIDDLE */ &&
                this.legendProperties.basePosition !== 2 /* CENTER */) {
                // if it's on the edge of the plot, force a column
                this.legendProperties.entryBreak = 0;
                this.legendProperties.direction = 0 /* COLUMN */;
                // and compute size appropriately
                sizeInfo = this._computeSize(ctx, font);
                // no need to adjust since it already has the minimum number of things per line
            }
            else {
                // reset these since syncmembers isn't called when a chart is resized
                this.legendProperties.entryBreak = this.legendProperties.initEntryBreak;
                this.legendProperties.direction = this.legendProperties.initDirection;
                // compute canvas size and adjust it to fit on the chart/plot
                sizeInfo = this._computeSize(ctx, font);
                _a = this._adjustCanvas(entries, sizeInfo, ctx, font), sizeInfo = _a[0], font = _a[1];
            }
            if (this.legendProperties.minEntries > 0 && entries.length < this.legendProperties.minEntries) {
                sizeInfo.width = sizeInfo.height = 0;
            }
            var width = sizeInfo.width, height = sizeInfo.height, space = sizeInfo.space, entryWidth = sizeInfo.entryWidth, markerWidth = sizeInfo.markerWidth, rowHeights = sizeInfo.rowHeights, columnWidths = sizeInfo.columnWidths;
            // bail if the computed height or width is 0 to save time
            if (height === 0 || width === 0) {
                cleanupCanvas();
                return false;
            }
            else {
                this.canvas.resize(width, height);
            }
            ctx.clear();
            // draw the legend box itself
            var legendRect = new Rectangle(0, 0, width, height);
            this.legendProperties.brush.setOnCanvas(ctx, legendRect);
            ctx.fillRect(0, 0, width, height);
            this.legendProperties.pen.setOnCanvas(ctx);
            ctx.strokeRect(0, 0, width, height);
            // Draw each legend entry
            var lastX = space;
            var baseY = 0;
            var colInd = 0;
            var rowInd = 0;
            // set up starting position for entries
            if (this.legendProperties.extendBounds) {
                switch (this.legendProperties.position) {
                    case 2 /* CENTER */:
                        // entries need to be centered
                        lastX = ~~((width / 2) - (entryWidth / 2));
                        if (lastX < 0) {
                            lastX = 0;
                        }
                        break;
                    case 1 /* RIGHT */:
                        // entries need to be aligned right
                        lastX = width - entryWidth;
                        if (lastX < 0) {
                            lastX = 0;
                        }
                        break;
                }
            }
            var adjustWidth = 0;
            var centerLastRow = this.legendProperties.centerRows && this.legendProperties.entryBreak > 0 &&
                entries.length % this.legendProperties.entryBreak !== 0;
            if (centerLastRow) {
                var lastRowCount = void 0;
                // calculate how much you'd need to bump the last row to center it
                if (this.legendProperties.direction === 0 /* COLUMN */) {
                    lastRowCount = ~~(entries.length / this.legendProperties.entryBreak);
                }
                else {
                    lastRowCount = entries.length % this.legendProperties.entryBreak;
                }
                adjustWidth = 0;
                for (var i = lastRowCount; i < columnWidths.length; i++) {
                    adjustWidth += (columnWidths[i] + markerWidth + (2 * space));
                }
                adjustWidth /= 2;
            }
            var measuredEntries = entries.map(function (entry) {
                var _a = RichTextRenderer.measureRichText(ctx, entry.str, font), entryDim = _a[0], preparedText = _a[1];
                return { entry: entry, entryDim: entryDim, preparedText: preparedText };
            });
            var smallestEntryHeight = _$1.some(entries) ?
                _$1.min(measuredEntries.map(function (entry) { return entry.entryDim.height; })) :
                0;
            for (var i = 0; i < entries.length; i++) {
                var _b = measuredEntries[i], entry = _b.entry, entryDim = _b.entryDim, preparedText = _b.preparedText;
                var textFollowsSeriesColor = this.legendProperties.textFollowsSeriesColor || entry.textFollowsSeriesColor;
                var entryFont = textFollowsSeriesColor ? font.with({ color: entry.seriesColor }) : font;
                entryFont.setOnCanvas(ctx);
                var x = lastX;
                if (centerLastRow && rowInd === rowHeights.length - 1) {
                    x += adjustWidth;
                }
                if (this.legendProperties.markerOnRight) {
                    x += columnWidths[colInd] - entryDim.width; // adjust so all text ends at the same column width
                    this._drawEntryText(entry, entryDim, preparedText, x, baseY, ctx, entryFont);
                    x += entryDim.width + space;
                    this._drawEntryMarker(entry, entryDim, sizeInfo.markerWidth, x, baseY, smallestEntryHeight, ctx);
                }
                else {
                    this._drawEntryMarker(entry, entryDim, sizeInfo.markerWidth, x, baseY, smallestEntryHeight, ctx);
                    x += markerWidth + space;
                    this._drawEntryText(entry, entryDim, preparedText, x, baseY, ctx, entryFont);
                }
                if (this.legendProperties.direction === 0 /* COLUMN */) {
                    baseY += rowHeights[rowInd];
                    rowInd++;
                }
                else {
                    lastX += columnWidths[colInd] + markerWidth + (2 * space);
                    colInd++;
                }
                if (this.legendProperties.entryBreak > 0 && (i + 1) % this.legendProperties.entryBreak === 0) {
                    if (this.legendProperties.direction === 1 /* ROW */) {
                        // new row - wrap
                        baseY += rowHeights[rowInd];
                        lastX = space;
                        colInd = 0;
                        rowInd++;
                    }
                    else {
                        // new column - wrap
                        baseY = 0;
                        lastX += columnWidths[colInd] + markerWidth + (2 * space);
                        colInd++;
                        rowInd = 0;
                    }
                }
            }
            if (width === 0 || height === 0) {
                return false;
            }
            else {
                return true;
            }
            var _a;
        };
        // Internal function to draw the legend preview from the series' `DrawStyle`. Individual
        // drawstyles can override `drawLegendPreview` to provide a better
        // approximation of their appearance.
        FDSLegend.prototype._drawEntryMarker = function (entry, entryDim, markerWidth, lastX, baseY, smallestEntryHeight, ctx) {
            if (!this.legendProperties.showMarker) {
                return;
            }
            // if there's no text we still want to put the markers at a good place
            // 15 is the height of a line with 12pt font (the default)
            if (smallestEntryHeight === 0) {
                smallestEntryHeight = 15;
            }
            var firstLineSize;
            if (entryDim.firstLineSize === 0) {
                firstLineSize = 15;
            }
            else {
                firstLineSize = entryDim.firstLineSize;
            }
            entry.pen.setOnCanvas(ctx);
            entry.brush.setOnCanvas(ctx);
            var _a = entry.series.getDrawStylePrototype(), DS = _a.drawStyle, DSEnum = _a.drawStyleEnum;
            var glyphY;
            switch (this.legendProperties.markerVPosition) {
                case 1 /* V_TOP */:
                    glyphY = (firstLineSize / 2) + 1;
                    break;
                case 0 /* V_BOTTOM */:
                    glyphY = entryDim.height - (firstLineSize / 2) - 1;
                    break;
                case 2 /* V_CENTER */:
                    glyphY = ~~(entryDim.height / 2.0);
                    break;
            }
            glyphY = (~~glyphY) + 0.5;
            var curX = (~~(lastX + (markerWidth / 2))) + 0.5;
            DS.drawLegendPreview(ctx, curX, glyphY + baseY, markerWidth, smallestEntryHeight);
            var isMarkerStyle = (DSEnum === 3 /* MARKER */ || DSEnum === 31 /* BUBBLE */);
            // Draw the series marker on the legend marker if necessary
            if (isMarkerStyle || entry.series.seriesMarker) {
                var cx = ~~(lastX + (markerWidth / 2.0));
                var cy = ~~(glyphY + baseY);
                var markerStyle = entry.series.markerStyle;
                var isSimpleMarker = DS.isSimpleMarker(markerStyle);
                var _b = DS.configureMarkerPens(isMarkerStyle, isSimpleMarker, ctx, true), brush = _b[0], props = _b[1];
                // marker size limited by the entry height, the entry width, and the series marker size
                var markerSize = ~~(Math.min(entry.series.markerSize, markerWidth, smallestEntryHeight - 2));
                // fourth arg here tells us we need a legend version of this marker
                var markerFunc = getMarkerDrawFunctor(markerStyle, markerSize, props.willDrawStroke, true);
                cx -= props.aliasOffset;
                cy -= props.aliasOffset;
                var halfSize = markerSize / 2;
                var rect = new Rectangle(cx - halfSize, cy - halfSize, cx + halfSize, cy + halfSize);
                brush.setBubble3dMode(entry.series.tryGetMarker3dLightPosition());
                ctx.setBrush(brush, rect);
                if (markerFunc !== undefined) {
                    ctx.beginPath();
                    markerFunc(ctx, cx, cy);
                    if (!isSimpleMarker) {
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }
        };
        FDSLegend.prototype._drawEntryText = function (entry, entryDim, preparedText, lastX, baseY, ctx, entryFont) {
            RichTextRenderer.writeRichText(ctx, entry.str, lastX, baseY, entryFont, entryFont.alignment, preparedText);
        };
        // Returns the offsets for drawing our canvas into a larger rectangle as `[x,
        // y]`
        FDSLegend.prototype.getLegendOffsetsInsideRectangle = function (rectangle) {
            switch (this.legendProperties.position) {
                case 0 /* LEFT */:
                    return [0, 0];
                case 1 /* RIGHT */:
                    return [rectangle.getWidth() - this.canvas.getWidth(), 0];
                case 2 /* CENTER */:
                    return [~~((rectangle.getWidth() / 2) - (this.canvas.getWidth() / 2)), 0];
            }
            return [0, 0];
        };
        FDSLegend.prototype.getCanvasDimensions = function () {
            return [this.canvas.getWidth(), this.canvas.getHeight()];
        };
        // Computes the size of the bounding box for drawing the legend. Returns
        // {width, height, markerWidth, space, maxTextWidth, entryWidth, columnWidths, rowHeights}
        // as an object with those keys and corresponding values.
        // where "width" is the width of the entire legend, and "entryWidth" is the width
        // the entries themselves take up. "columnWidths" and "rowHeights" are arrays
        FDSLegend.prototype._computeSize = function (ctx, font) {
            var columnWidths = [];
            var rowHeights = [];
            var colInd = 0;
            var rowInd = 0;
            var maxTextWidth = 0;
            var minLineHeight = Infinity;
            // step through the legend entries and calculate some stuff
            var entries = this._getEntries();
            if (entries.length === 0) {
                return {
                    width: 0,
                    height: 0,
                    markerWidth: 0,
                    space: 0,
                    maxTextWidth: 0,
                    entryWidth: 0,
                    columnWidths: [],
                    rowHeights: []
                };
            }
            for (var i = 0; i < entries.length; i++) {
                // set up this column/row if necessary
                var entry = entries[i];
                if (columnWidths[colInd] == null) {
                    columnWidths[colInd] = 0;
                }
                if (rowHeights[rowInd] == null) {
                    rowHeights[rowInd] = 0;
                }
                var size = RichTextRenderer.measureRichText(ctx, entry.str, font)[0];
                var curWidth = size.width + 1; // to account for alignment off by one pixel
                // find the widest entry
                if (curWidth > maxTextWidth) {
                    maxTextWidth = curWidth;
                }
                // keep track of column widths and row heights
                if (curWidth > columnWidths[colInd]) {
                    columnWidths[colInd] = curWidth;
                }
                if (size.height > rowHeights[rowInd]) {
                    rowHeights[rowInd] = size.height;
                }
                // find the shortest line for marker computation
                if (size.minLineHeight < minLineHeight) {
                    (minLineHeight = size.minLineHeight);
                }
                // advance indeces
                if (this.legendProperties.direction === 1 /* ROW */) {
                    colInd++;
                }
                else {
                    rowInd++;
                }
                // end-of-row calculations
                if ((this.legendProperties.entryBreak > 0 && (i + 1) % this.legendProperties.entryBreak === 0) ||
                    (i === entries.length - 1)) {
                    if (this.legendProperties.direction === 1 /* ROW */) {
                        rowInd++;
                        colInd = 0;
                    }
                    else {
                        colInd++;
                        rowInd = 0;
                    }
                }
            }
            // minLineHeight of 0 probably means no text, but we still need this height to calculate other
            // things, so make it the default font height
            if (minLineHeight === 0) {
                minLineHeight = 12;
            }
            // height based on row heights
            var height = 0;
            for (var k = 0; k < rowHeights.length; k++) {
                height += rowHeights[k];
            }
            if (!this.legendProperties.packing) {
                // replace every column width with the max if you're not packing the columns
                for (var j = 0; j < columnWidths.length; j++) {
                    columnWidths[j] = maxTextWidth;
                }
            }
            // entryWidth based on column widths
            var entryWidth = 0;
            for (var i1 = 0; i1 < columnWidths.length; i1++) {
                entryWidth += columnWidths[i1];
            }
            // If there's no user-set value for `MarkerWidth`, set it to twice the font height,
            // using the smallest font height so it won't be too big for any of the lines
            var markerWidth;
            var space;
            if (this.attributeSet.isDefault('MarkerWidth')) {
                markerWidth = 2 * minLineHeight;
            }
            else {
                markerWidth = this.legendProperties.markerWidth;
            }
            if (this.legendProperties.showMarker && markerWidth > 0) {
                space = Math.round((minLineHeight / 5.0));
            }
            else {
                markerWidth = 0;
                space = 2;
            }
            // add in the marker and space widths
            var numCols = columnWidths.length;
            // n markers; n spaces between text and markers, n between markers and text, 1 at end
            entryWidth += (markerWidth * numCols) + (space * ((2 * numCols) + 1));
            // normally the width is just the width of the entries
            var width = entryWidth;
            // if extendBounds, width is determined by plot/chart rect
            if (this.legendProperties.extendBounds) {
                switch (this.legendProperties.basePosition) {
                    case 0 /* LEFT */:
                    case 1 /* RIGHT */:
                        if (this.legendProperties.axisPosition !== 3 /* MIDDLE */) {
                            width = (this.parent.maxXFactor - this.parent.rightMargin) -
                                (this.parent.minXFactor + this.parent.leftMargin);
                        }
                        break;
                    default:// FCPosition.CENTER
                        width = this.parent.plotRect.x2 - this.parent.plotRect.x1;
                }
            }
            return { width: width, height: height, markerWidth: markerWidth, space: space, maxTextWidth: maxTextWidth, entryWidth: entryWidth, columnWidths: columnWidths, rowHeights: rowHeights };
        };
        FDSLegend.prototype.addSeries = function (series) {
            if (series.attributeSet.get('InLegend')) {
                this.seriesArray.push(series);
            }
        };
        FDSLegend.prototype.serialize = function (level) {
            // legends aren't serialized
            return '';
        };
        FDSLegend.prototype.removeSeries = function (series) {
            if (!_$1.includes(this.seriesArray, series)) {
                false;
            }
            this.seriesArray.splice(this.seriesArray.indexOf(series), 1);
        };
        FDSLegend.prototype.getInteractivityObjectType = function () {
            return 128 /* LEGEND */;
        };
        FDSLegend.selector = 'FDSLegend';
        return FDSLegend;
    }(FDSChartObject));
    var LegendEntry = /** @class */ (function () {
        function LegendEntry(series, legend) {
            this.series = series;
            this.legend = legend;
            if (!isSeries(this.series)) {
                throw 'LegendEntry constructor requires an associated series.';
            }
            this._init();
        }
        LegendEntry.prototype._init = function () {
            this.seriesColor = 0;
            this.markerOnRight = false;
            this.textFollowsSeriesColor = false;
            this.legendDrawStyle = 0 /* LINE */;
            this.pen = new FDSPen();
            this.markerPen = new FDSPen();
            this.brush = new FDSBrush();
            this.markerBrush = new FDSBrush();
            this.showMarker = true;
            this.str = '';
            this.index = 0;
        };
        return LegendEntry;
    }());
    var LegendProperties = /** @class */ (function () {
        function LegendProperties(legend, name, attributes) {
            if (name === void 0) { name = ''; }
            this._legend = legend;
            this._name = name;
            this.attributeSet = attributes;
            this._init();
        }
        LegendProperties.prototype._init = function () {
            this.visible = true;
            this.reverse = false;
            this.centerRows = false;
            this.extendBounds = false;
            this.position = 0 /* LEFT */;
            this.axisPosition = 0 /* NORMAL */;
            this.vPosition = 1 /* TOP */;
            this.basePosition = 2 /* CENTER */;
            this.textPosition = 0 /* LEFT */;
            this.initDirection = this.direction = 0 /* COLUMN */;
            this.initDirection = this.entryBreak = 0;
            this.markerWidth = -1.0;
            this.annotation = false;
            this.footnote = false;
            this.dataMask = 0;
            this.labelMask = 0;
            this.sublabelMask = -1;
            this.showMarker = true;
            this.markerOnRight = false;
            this.markerVPosition = 1 /* V_TOP */;
            this.showLabel = true;
            this.showInvalidSeries = true;
            this.sortMode = 1 /* X */;
            this.autoIncrementMode = 0 /* NUMBER */;
            this.shadowX = 0;
            this.shadowY = 0;
            this.shadowColor = 0;
            this.shadow = false;
            this.textFollowsSeriesColor = false;
            this.xOffset = 0.0;
            this.yOffset = 0.0;
            this.minEntries = 0;
            this.maxEntries = 0;
            this.packing = true;
            this.legendText = '<FDSLegendLabel>';
            this.wrapEntriesText = false;
            this.orderCustom = false;
            this.pen = new FDSPen({ color: 0 /* BLACK */, style: 5 /* NULL */ });
            this.markerPen = new FDSPen();
            this.brush = new FDSBrush();
            this.brush.color = 16777215 /* WHITE */;
            this.brush.style = 1;
            this.markerBrush = new FDSBrush();
            this.font = new FDSFont({ widthHint: 32000 });
        };
        LegendProperties.prototype._setAttributes = function () {
            var prefix = 'Legend';
            this.attributeSet.addMultiple([
                ['Legend', Boolean, true, prefix],
                ['Position', Number, this.position, prefix + 'Position'],
                ['BasePosition', Number, this.basePosition, prefix + 'BasePosition'],
                ['Direction', Number, this.direction, prefix + 'Direction'],
                ['AxisPosition', Number, this.axisPosition, prefix + 'AxisPosition'],
                ['VPosition', Number, this.vPosition, prefix + 'VPosition'],
                ['Break', Number, this.entryBreak, null],
                ['Reverse', Boolean, this.reverse, null],
                ['ExtendBounds', Boolean, this.extendBounds, null],
                ['MarkerOnRight', Boolean, this.markerOnRight, null],
                ['CenterRows', Boolean, this.centerRows, null],
                ['MarkerWidth', Number, this.markerWidth, null],
                ['MarkerVPosition', Number, this.markerVPosition, null],
                ['IsAnnotation', Boolean, this.annotation, null],
                ['IsFootnote', Boolean, this.footnote, null],
                ['ShowInvalidSeries', Boolean, this.showInvalidSeries, null],
                ['ShowLabel', Boolean, this.showLabel, null],
                ['ShowMarker', Boolean, this.showMarker, null],
                ['DataMask', Number, this.dataMask, null],
                ['LabelMask', Number, this.labelMask, null],
                ['SublabelMask', Number, this.sublabelMask, null],
                ['XOffset', Number, this.xOffset, prefix + 'XOffset'],
                ['YOffset', Number, this.yOffset, prefix + 'YOffset'],
                ['MinEntries', Number, this.minEntries, null],
                ['MaxEntries', Number, this.maxEntries, null],
                ['TextFollowsSeriesColor', Boolean, this.textFollowsSeriesColor, null],
                ['Packing', Boolean, this.packing, prefix + 'Packing'],
                ['Text', String, this.legendText, prefix + 'Text'],
                ['WrapEntries', Boolean, this.wrapEntriesText, null],
                ['OrderCustom', Boolean, this.orderCustom, null],
                ['HeatmapLegendPosition', Number, 0 /* BELOW */, null],
                ['HeatmapLegendLabelPosition', Number, 0 /* BELOW */, null],
                ['HeatmapLegendLabelRange', Number, 3 /* TIGHT */, null],
                ['HeatmapLegendWidth', Number, 0.3, null]
            ]);
            this.pen.writeToAttrSet(this.attributeSet, 'FG', prefix + 'FG');
            this.brush.writeToAttrSet(this.attributeSet, 'BG', prefix + 'BG');
            this.font.writeToAttrSet(this.attributeSet, 'Font', prefix + 'Font');
            this.attributeSet.defaultMap.finalizeInitialization();
        };
        LegendProperties.prototype.syncMembers = function () {
            // Saves on property access and minified file size
            var getAttribute = this.attributeSet.get.bind(this.attributeSet);
            if (this.visible = getAttribute('Legend')) {
                this.position = getAttribute('Position');
                this.basePosition = getAttribute('BasePosition');
                this.initDirection = this.direction = getAttribute('Direction');
                this.initEntryBreak = this.entryBreak = getAttribute('Break');
                this.axisPosition = getAttribute('AxisPosition');
                this.vPosition = getAttribute('VPosition');
                this.reverse = getAttribute('Reverse');
                this.extendBounds = getAttribute('ExtendBounds');
                this.markerOnRight = getAttribute('MarkerOnRight');
                this.centerRows = getAttribute('CenterRows');
                this.markerWidth = scaleByDevicePixelRatioAndRound(getAttribute('MarkerWidth'));
                this.annotation = getAttribute('IsAnnotation');
                this.footnote = getAttribute('IsFootnote');
                this.showInvalidSeries = getAttribute('ShowInvalidSeries');
                this.showLabel = getAttribute('ShowLabel');
                this.showMarker = getAttribute('ShowMarker');
                this.dataMask = getAttribute('DataMask');
                this.labelMask = getAttribute('LabelMask');
                this.sublabelMask = getAttribute('SublabelMask');
                this.xOffset = scaleByDevicePixelRatioAndRound(getAttribute('XOffset'));
                this.yOffset = scaleByDevicePixelRatioAndRound(getAttribute('YOffset'));
                this.minEntries = getAttribute('MinEntries');
                this.maxEntries = getAttribute('MaxEntries');
                this.textFollowsSeriesColor = getAttribute('TextFollowsSeriesColor');
                this.packing = getAttribute('Packing');
                this.legendText = getAttribute('Text');
                this.wrapEntriesText = getAttribute('WrapEntries');
                this.markerVPosition = getAttribute('MarkerVPosition');
                this.orderCustom = getAttribute('OrderCustom');
                this.pen = FDSPen.constructFromAttributes(this.attributeSet, 'FG');
                this.brush.constructFromAttributes(this.attributeSet, 'BG');
                this.font = FDSFont.constructFromAttributes(this.attributeSet, 'Font');
            }
        };
        return LegendProperties;
    }());
    
    var ThiefThemeInfo = /** @class */ (function () {
        function ThiefThemeInfo() {
        }
        ThiefThemeInfo._onyx = {
            HeatmapLegendOutlineColor: 6579300 /* GRAY4 */
        };
        ThiefThemeInfo._crystal = {
            HeatmapLegendOutlineColor: 13158600 /* GRAY8 */
        };
        ThiefThemeInfo._carbon = {
            HeatmapLegendOutlineColor: 6579300 /* GRAY4 */
        };
        ThiefThemeInfo._quartz = {
            HeatmapLegendOutlineColor: 13158600 /* GRAY8 */
        };
        ThiefThemeInfo.getTheme = function () {
            switch (getThiefTheme()) {
                case 4 /* ONYX */:
                    return _$1.cloneDeep(ThiefThemeInfo._onyx);
                case 3 /* CRYSTAL */:
                    return _$1.cloneDeep(ThiefThemeInfo._crystal);
                case 2 /* CARBON */:
                    return _$1.cloneDeep(ThiefThemeInfo._carbon);
                case 1 /* QUARTZ */:
                default:
                    return _$1.cloneDeep(ThiefThemeInfo._quartz);
            }
        };
        return ThiefThemeInfo;
    }());
    
    var HeatmapLegend = /** @class */ (function () {
        function HeatmapLegend(root, plot, series) {
            this._barHeight = 9; // App design spec is 1px outline top/bottom + 8px bar height so 9 is correct value
            this._tickLength = 3;
            this._padding = 2;
            this.root = root;
            this.parent = plot;
            this.series = series;
            this._init();
        }
        HeatmapLegend.prototype._init = function () {
            this.legendProperties = new HeatmapLegendProperties(this.parent.legend);
            this.clearRenderCache();
        };
        HeatmapLegend.prototype.clearRenderCache = function () {
            if (this.canvas) {
                this.canvas.destroy();
            }
            this.canvas = this.root.createRenderingLayer();
        };
        HeatmapLegend.prototype.syncMembers = function () {
            this.legendProperties.syncMembers();
        };
        /**
         * Returns values for color scale labels
         *
         * @private
         * @returns {number[]} Array of numbers for scale labels
         */
        HeatmapLegend.prototype._getLabelValues = function () {
            var _a = this.series.getHeatmapColorScaleMinMax(), colorMin = _a.colorMin, colorMax = _a.colorMax, valueMin = _a.valueMin, valueMax = _a.valueMax;
            var labelValues;
            var range = this.legendProperties.labelRange;
            if (valueMax < 0 && range === 1 /* POSITIVE */) {
                console.warn('HeatmapLegendLabelRange is set to POSITIVE but the maximum data point is less than zero. Falling back to TIGHT for label range.');
                this.legendProperties.labelRange = 3 /* TIGHT */;
            }
            else if (valueMin > 0 && range === 2 /* NEGATIVE */) {
                console.warn('HeatmapLegendLabelRange is set to NEGATIVE but the minimum data point is greater than zero. Falling back to TIGHT for label range.');
                this.legendProperties.labelRange = 3 /* TIGHT */;
            }
            switch (this.legendProperties.labelRange) {
                case 0 /* SYMMETRIC */:
                    var extreme = Math.max(Math.abs(valueMin), Math.abs(valueMax));
                    labelValues = [-extreme, (-extreme * 0.5), 0, (extreme * 0.5), extreme];
                    break;
                case 1 /* POSITIVE */:
                    labelValues = [0, (valueMax * 0.25), (valueMax * 0.5), (valueMax * 0.75), valueMax];
                    break;
                case 2 /* NEGATIVE */:
                    labelValues = [valueMin, (valueMin * 0.75), (valueMin * 0.5), (valueMin * 0.25), 0];
                    break;
                case 4 /* CLIP */:
                    var colorMid = (colorMin + colorMax) / 2;
                    labelValues = [colorMin, ((colorMin + colorMid) / 2), colorMid, ((colorMid + colorMax) / 2), colorMax];
                    break;
                case 3 /* TIGHT */:
                default:
                    var mid = (valueMin + valueMax) / 2;
                    labelValues = [valueMin, ((valueMin + mid) / 2), mid, ((mid + valueMax) / 2), valueMax];
                    break;
            }
            switch (this.legendProperties.labelPosition) {
                case 1 /* ENDS */:
                    return [_$1.first(labelValues), _$1.last(labelValues)];
                case 0 /* BELOW */:
                default:
                    return labelValues;
            }
        };
        /**
         * Formats labels for the heatmap legend
         */
        HeatmapLegend.prototype.formatLabels = function () {
            var ctx = this.canvas.context;
            var font = this.legendProperties.font;
            var values$$1 = this._getLabelValues();
            var colorAxis = this.series.getAxis(4 /* COLOR */);
            var formatter = new FDSFormat();
            var compiledFormat = colorAxis.properties.compilePropertyString(colorAxis.attributeSet.get('LabelFormat'));
            var format = compiledFormat.fromValue();
            formatter.setNumberFormat(format);
            this._labels = values$$1.map(function (value) {
                var label = formatter.formatAsNumber(value);
                var _a = RichTextRenderer.measureRichText(ctx, label, font), labelDim = _a[0], preparedText = _a[1];
                return { label: label, value: value, width: labelDim.width, height: labelDim.height, preparedText: preparedText };
            });
        };
        /**
         * Renders the heatmap legend to canvas based on attribute settings
         *
         * @returns {boolean} True if the canvas has as size, false if it does not
         */
        HeatmapLegend.prototype.renderToCanvas = function () {
            var _this = this;
            var cleanupCanvas = function () { return _this.canvas.resize(0, 0); };
            if (!this.legendProperties.visible) {
                cleanupCanvas();
                return false;
            }
            this.legendProperties.font.setOnCanvas(this.canvas.context);
            this.formatLabels();
            var _a = this._computeSize(), canvasWidth = _a.canvasWidth, canvasHeight = _a.canvasHeight, legendRect = _a.legendRect;
            // bail if the computed height or width is 0 to save time
            if (canvasWidth === 0 || canvasHeight === 0) {
                cleanupCanvas();
                return false;
            }
            else {
                this.canvas.resize(canvasWidth, canvasHeight);
            }
            this.canvas.context.clear();
            this.root.heatmapLegendLabels[this.parent.id] = [];
            switch (this.legendProperties.labelPosition) {
                case 1 /* ENDS */:
                    this._drawBarWithLabelsAtEnds(canvasWidth, legendRect);
                    break;
                case 0 /* BELOW */:
                default:
                    this._drawBarWithLabelsBelow(canvasWidth, legendRect);
                    break;
            }
            this.root.heatmapLegendLabels[this.parent.id] = _$1.sortBy(this.root.heatmapLegendLabels[this.parent.id], function (label) { return label.labelRect.x; });
            return true;
        };
        HeatmapLegend.prototype._drawBarWithLabelsAtEnds = function (canvasWidth, legendRect) {
            if (this._labels.length !== 2) {
                this._drawOnlyGradient(canvasWidth);
                return;
            }
            var leftLabel = _$1.first(this._labels);
            var rightLabel = _$1.last(this._labels);
            var doLabelsFitOnEnds = (leftLabel.width + rightLabel.width) <= legendRect.width;
            if (!doLabelsFitOnEnds) {
                this._drawOnlyGradient(canvasWidth);
                return;
            }
            var barSpace = this._drawEndLabels(leftLabel, rightLabel, legendRect);
            barSpace.x1 = barSpace.x1 + this._padding;
            barSpace.x2 = barSpace.x2 - this._padding;
            this._drawGradientBar(barSpace);
        };
        HeatmapLegend.prototype._drawBarWithLabelsBelow = function (canvasWidth, legendRect) {
            if (this._labels.length !== 5) {
                this._drawOnlyGradient(canvasWidth);
                return;
            }
            var endLabels = [this._labels[0], this._labels[4]];
            var midLabels = [this._labels[1], this._labels[3]];
            var centerLabel = this._labels[2];
            var endTickOffset = Math.max(~~(endLabels[0].width / 2), ~~(endLabels[1].width / 2));
            var tickRect = new Rectangle(legendRect.x1 + endTickOffset, legendRect.y1 + this._padding + this._barHeight, legendRect.x2 - endTickOffset, legendRect.y1 + this._padding + this._barHeight + this._tickLength);
            var endTicks = [this._getTick(tickRect, 0), this._getTick(tickRect, 1)];
            var midTicks = [this._getTick(tickRect, 0.25), this._getTick(tickRect, 0.75)];
            var centerTick = this._getTick(tickRect, 0.5);
            var labelSpace = new Rectangle(legendRect.x1, tickRect.y2, legendRect.x2, legendRect.y2);
            if (!this._canEndTicksFitLabels(endLabels[0], endLabels[1], labelSpace, endTicks[0], endTicks[1])) {
                this._drawOnlyGradient(canvasWidth);
                return;
            }
            labelSpace = this._drawLabelBelowTick(endLabels[0], labelSpace, endTicks[0]).rightSpace;
            labelSpace = this._drawLabelBelowTick(endLabels[1], labelSpace, endTicks[1]).leftSpace;
            if (this._canTickFitLabel(centerLabel, labelSpace, centerTick)) {
                var _a = this._drawLabelBelowTick(centerLabel, labelSpace, centerTick), leftSpace = _a.leftSpace, rightSpace = _a.rightSpace;
                if (this._canTickFitLabel(midLabels[0], leftSpace, midTicks[0]) &&
                    this._canTickFitLabel(midLabels[1], rightSpace, midTicks[1])) {
                    this._drawLabelBelowTick(midLabels[0], leftSpace, midTicks[0]);
                    this._drawLabelBelowTick(midLabels[1], rightSpace, midTicks[1]);
                }
            }
            var gradientRect = new Rectangle(tickRect.x1, legendRect.y1 + this._padding, tickRect.x2, legendRect.y1 + this._barHeight + this._padding);
            this._drawGradientBar(gradientRect);
            return;
        };
        /**
         * Shrinks the canvas to the height of the gradient bar and draws a bar across the full width of the canvas
         *
         * @private
         * @param {number} canvasWidth - Width of the canvas to draw the bar on
         * @param {Rectangle} gradientRect - Rectangle coordinates for the gradient bar
         */
        HeatmapLegend.prototype._drawOnlyGradient = function (canvasWidth) {
            this.canvas.context.clear();
            this.canvas.resize(canvasWidth, this._barHeight + (this._padding * 2));
            var canvasRect = new Rectangle(0, 0, this.getCanvasDimensions()[0], this.getCanvasDimensions()[1]);
            this._drawGradientBar(canvasRect);
        };
        /**
         * Draws the gradient bar for the legend scale.
         * Uses the full width of the provided space, and centers the bar vertically in the provided space
         *
         * @private
         * @param {Rectangle} space - Rectangle coordinates for the gradient bar space
         */
        HeatmapLegend.prototype._drawGradientBar = function (space) {
            var _this = this;
            var ctx = this.canvas.context;
            var outline = this.legendProperties.outline;
            var offsetToCenter = (space.height > this._barHeight) ? ~~((space.height - this._barHeight) / 2) : 0;
            var gradientSegments = this._getGradientSegments(space);
            var gradientBrush = new FDSBrush();
            gradientBrush.style = 0 /* SOLID */;
            gradientBrush.gradientStyle = 1 /* HALF */;
            gradientBrush.gradientAngle = 0;
            gradientSegments.forEach(function (gradientSegment, index) {
                gradientBrush.pushHistory();
                gradientBrush.setAttr('gradientColor', gradientSegment.startColor);
                gradientBrush.setAttr('color', gradientSegment.endColor);
                var segmentRect = new Rectangle(gradientSegment.startX, space.y1 + offsetToCenter, gradientSegment.endX, space.y1 + offsetToCenter + _this._barHeight);
                ctx.setBrush(gradientBrush, segmentRect);
                ctx.fillRect(segmentRect.x, segmentRect.y, segmentRect.width, segmentRect.height);
            });
            ctx.setPen(outline.pen);
            ctx.strokeRect(space.x1 + outline.offset, space.y1 + offsetToCenter + outline.offset, space.width, this._barHeight);
        };
        /**
         * Generates the gradient segments for the bar based on the series' color map and min/max label values
         *
         * @private
         * @param {Rectangle} bar - Rectangle coordinates for the gradient bar
         * @returns {GradientSegment[]} Array of segments to draw for the bar
         */
        HeatmapLegend.prototype._getGradientSegments = function (bar) {
            var colorMap = this.series.colorMap;
            var colorMapElements = colorMap.getColorMapElements();
            var _a = this.series.getHeatmapColorScaleMinMax(), colorMin = _a.colorMin, colorMax = _a.colorMax;
            var scaledMin = (_$1.first(this._labels).value - colorMin) / (colorMax - colorMin);
            var scaledMax = (_$1.last(this._labels).value - colorMin) / (colorMax - colorMin);
            var labelMinElement = { color: colorMap.getColor(scaledMin), index: scaledMin };
            var labelMaxElement = { color: colorMap.getColor(scaledMax), index: scaledMax };
            var labelRange = new Range(labelMinElement.index, labelMaxElement.index);
            colorMapElements = colorMapElements.concat([labelMinElement, labelMaxElement]);
            colorMapElements = _$1.sortBy(colorMapElements, 'index');
            var scaleToBar = function (value) {
                return bar.x1 + ~~(((value - scaledMin) / (scaledMax - scaledMin)) * bar.width);
            };
            var segments = [];
            for (var i = 0; i < (colorMapElements.length - 1); i++) {
                var leftElement = colorMapElements[i];
                var rightElement = colorMapElements[i + 1];
                var overlap = Range.CheckForOverlap(new Range(leftElement.index, rightElement.index), labelRange);
                switch (overlap) {
                    case 0 /* CLEAR_START */:
                        // Not on gradient bar
                        break;
                    case 1 /* OVERLAP_START */:
                        segments.push({
                            startColor: labelMinElement.color.getCOLORREF(),
                            endColor: rightElement.color.getCOLORREF(),
                            startX: scaleToBar(labelMinElement.index),
                            endX: scaleToBar(rightElement.index)
                        });
                        break;
                    case 2 /* AROUND */:
                    case 3 /* EQUAL */:
                        segments.push({
                            startColor: labelMinElement.color.getCOLORREF(),
                            endColor: labelMaxElement.color.getCOLORREF(),
                            startX: scaleToBar(labelMinElement.index),
                            endX: scaleToBar(labelMaxElement.index),
                        });
                        break;
                    case 4 /* INSIDE */:
                        segments.push({
                            startColor: leftElement.color.getCOLORREF(),
                            endColor: rightElement.color.getCOLORREF(),
                            startX: scaleToBar(leftElement.index),
                            endX: scaleToBar(rightElement.index)
                        });
                        break;
                    case 5 /* OVERLAP_END */:
                        segments.push({
                            startColor: leftElement.color.getCOLORREF(),
                            endColor: labelMaxElement.color.getCOLORREF(),
                            startX: scaleToBar(leftElement.index),
                            endX: scaleToBar(labelMaxElement.index),
                        });
                        break;
                    case 6 /* CLEAR_END */:
                        // Not on gradient bar
                        break;
                }
            }
            return segments;
        };
        /**
         *  Draws the labels aligned at the ends of the rectangle, centered vertically
         *
         * @private
         * @param {LegendLabel} leftLabel - Label to draw at the left of the space
         * @param {LegendLabel} rightLabel - Label to draw at the right of the space
         * @param {Rectangle} space - Space to fit labels in
         * @returns {Rectangle} The center space remaining after drawing the labels
         */
        HeatmapLegend.prototype._drawEndLabels = function (leftLabel, rightLabel, space) {
            var ctx = this.canvas.context;
            var font = this.legendProperties.font;
            var leftX = space.x1;
            var leftY = ~~(space.y1 + ((space.height - leftLabel.height) / 2));
            var rightX = space.x2 - rightLabel.width;
            var rightY = ~~(space.y1 + ((space.height - rightLabel.height) / 2));
            RichTextRenderer.writeRichText(ctx, leftLabel.label, leftX, leftY, font, font.alignment, leftLabel.preparedText);
            RichTextRenderer.writeRichText(ctx, rightLabel.label, rightX, rightY, font, font.alignment, leftLabel.preparedText);
            this._cacheLabel(leftX, leftY, leftLabel);
            this._cacheLabel(rightX, rightY, rightLabel);
            return new Rectangle(space.x1 + leftLabel.width, space.y, space.x2 - rightLabel.width, space.y2);
        };
        HeatmapLegend.prototype._cacheLabel = function (x, y, label) {
            var cache = this.root.heatmapLegendLabels[this.parent.id];
            if (_$1.isUndefined(cache)) {
                cache = this.root.heatmapLegendLabels[this.parent.id] = [];
            }
            var labelRect = { x: x, y: y, width: label.width, height: label.height };
            cache.push({ labelText: label.label, labelRect: labelRect });
        };
        HeatmapLegend.prototype._getTick = function (rect, offset) {
            return {
                x: rect.x1 + ~~(rect.width * offset),
                y1: rect.y1,
                y2: rect.y2
            };
        };
        /**
         * Checks whether two labels can fit in the provided space when both labels are centered under their tick marks
         *
         * @private
         * @param {LegendLabel[]} labels - Labels to sum the widths of
         * @param {number} width - Space to fit
         * @returns {boolean} Whether the summed labels fit in the space
         */
        HeatmapLegend.prototype._canEndTicksFitLabels = function (leftLabel, rightLabel, space, leftTick, rightTick) {
            if (!this._canTickFitLabel(leftLabel, space, leftTick) ||
                !this._canTickFitLabel(rightLabel, space, rightTick)) {
                return false;
            }
            var leftLabelEdge = leftTick.x + ~~(leftLabel.width / 2);
            var rightLabelEdge = rightTick.x - ~~(rightLabel.width / 2);
            return leftLabelEdge <= rightLabelEdge;
        };
        /**
         * Checks whether a label can fit in the provided space when it is centered under the provided tick mark
         *
         * @private
         * @param {LegendLabel} label - Label to fit
         * @param {Rectangle} space - Space to fit label inside
         * @param {Tick} tick - Tick mark to center label under
         * @returns {boolean} Whether or not the label fits
         */
        HeatmapLegend.prototype._canTickFitLabel = function (label, space, tick) {
            if (label.width > space.width) {
                return false;
            }
            var labelLeft = tick.x - ~~(label.width / 2);
            var labelRight = tick.x + ~~(label.width / 2);
            return !(labelLeft < space.x1 || labelRight > space.x2);
        };
        /**
         * Draws the label centered at the tick horizontally and centered in the space vertically
         *
         * @private
         * @param {LegendLabel} label - Label to draw
         * @param {Rectangle} space - Space to draw the label in
         * @param {Tick} tick - Tick mark to center the label under
         * @returns {{leftSpace: Rectangle, rightSpace: Rectangle}} Rectangles comprised of the remaining space to the left and right of the label
         */
        HeatmapLegend.prototype._drawLabelBelowTick = function (label, space, tick) {
            var ctx = this.canvas.context;
            var font = this.legendProperties.font;
            var outline = this.legendProperties.outline;
            var labelX = tick.x - ~~(label.width / 2);
            var labelY = ~~(space.y1 + (space.height - label.height) / 2);
            RichTextRenderer.writeRichText(ctx, label.label, labelX, labelY, font, font.alignment, label.preparedText);
            this._cacheLabel(labelX, labelY, label);
            ctx.setPen(outline.pen);
            ctx.beginPath();
            ctx.moveTo(tick.x + outline.offset, tick.y1 + outline.offset);
            ctx.lineTo(tick.x + outline.offset, tick.y2 + outline.offset);
            ctx.closePath();
            ctx.stroke();
            var leftSpace = new Rectangle(space.x, space.y, labelX, space.y2);
            var rightSpace = new Rectangle(labelX + label.width, space.y, space.x2, space.y2);
            return { leftSpace: leftSpace, rightSpace: rightSpace };
        };
        HeatmapLegend.prototype.getLegendOffsetsInsideRectangle = function (rectangle) {
            switch (this.legendProperties.position) {
                case 1 /* TOP_RIGHT */:
                    return [rectangle.getWidth() - this.canvas.getWidth(), 0];
                case 0 /* BELOW */:
                default:
                    return [
                        ~~((rectangle.getWidth() / 2) - (this.canvas.getWidth() / 2)),
                        rectangle.getHeight() - this.canvas.getHeight()
                    ];
            }
        };
        HeatmapLegend.prototype.getCanvasDimensions = function () {
            return [this.canvas.getWidth(), this.canvas.getHeight()];
        };
        /**
         * Computes the size of the canvas for the legend based on the positioning of the gradient bar and labels
         *
         * @private
         * @returns {SizeInfo}
         */
        HeatmapLegend.prototype._computeSize = function () {
            var canvasWidth = 0;
            var canvasHeight = 0;
            var plotWidth = this.parent.plotRect.x2 - this.parent.plotRect.x1;
            switch (this.legendProperties.position) {
                case 1 /* TOP_RIGHT */:
                    var lpWidth = this.legendProperties.width;
                    if (lpWidth <= 1) {
                        canvasWidth = ~~((plotWidth * lpWidth) + (this._padding * 2));
                    }
                    else {
                        canvasWidth = (lpWidth < plotWidth) ? (lpWidth + (this._padding * 2)) : plotWidth;
                    }
                    break;
                case 0 /* BELOW */:
                default:
                    canvasWidth = plotWidth;
                    break;
            }
            var labelHeight = Math.max.apply(Math, (_$1.map(this._labels, function (label) { return label.height; })));
            switch (this.legendProperties.labelPosition) {
                case 1 /* ENDS */:
                    canvasHeight = Math.max(this._barHeight, labelHeight) + (this._padding * 2);
                    break;
                case 0 /* BELOW */:
                default:
                    canvasHeight = this._barHeight + this._tickLength + labelHeight + (this._padding * 3);
                    break;
            }
            var legendRect = new Rectangle(this._padding, this._padding, canvasWidth - this._padding, canvasHeight - this._padding);
            return { canvasWidth: canvasWidth, canvasHeight: canvasHeight, legendRect: legendRect };
        };
        HeatmapLegend.selector = 'FDSLegend';
        return HeatmapLegend;
    }());
    var HeatmapLegendProperties = /** @class */ (function () {
        function HeatmapLegendProperties(legend) {
            this._legend = legend;
            this._init();
        }
        HeatmapLegendProperties.prototype._init = function () {
            this.visible = true;
            this.position = 0 /* BELOW */;
            this.labelPosition = 0 /* BELOW */;
            this.labelRange = 3 /* TIGHT */;
            this.width = 0.25;
            var penColor = ThiefThemeInfo.getTheme().HeatmapLegendOutlineColor;
            var pen = new FDSPen({ color: penColor, style: 0 /* SOLID */ });
            this.outline = { pen: pen, offset: pen.getAliasOffset() };
            this.font = new FDSFont({ widthHint: 32000 });
        };
        HeatmapLegendProperties.prototype.syncMembers = function () {
            var lp = this._legend.legendProperties;
            // Saves on property access and minified file size
            var getAttribute = lp.attributeSet.get.bind(lp.attributeSet);
            if (this.visible = getAttribute('Legend') || lp.visible) {
                this.position = getAttribute('HeatmapLegendPosition');
                this.labelPosition = getAttribute('HeatmapLegendLabelPosition');
                this.labelRange = getAttribute('HeatmapLegendLabelRange');
                this.width = getAttribute('HeatmapLegendWidth');
                this.font = FDSFont.constructFromAttributes(lp.attributeSet, 'Font');
                var penColor = ThiefThemeInfo.getTheme().HeatmapLegendOutlineColor;
                var pen = new FDSPen({ color: penColor, style: 0 /* SOLID */ });
                this.outline = { pen: pen, offset: pen.getAliasOffset() };
            }
        };
        return HeatmapLegendProperties;
    }());
    
    var FDSPlot = /** @class */ (function (_super) {
        __extends(FDSPlot, _super);
        function FDSPlot(root, id, minX, maxX, minY, maxY, wrapper) {
            if (minX === void 0) { minX = 0; }
            if (maxX === void 0) { maxX = 1; }
            if (minY === void 0) { minY = 0; }
            if (maxY === void 0) { maxY = 1; }
            var _this = 
            // FDSChartObject.constructor calls _init, so no need to do that here
            _super.call(this, root, id, 4 /* FC_PLOT */, { wrapper: wrapper }) || this;
            if (minX > maxX) {
                _a = [maxX, minX], minX = _a[0], maxX = _a[1];
            }
            if (minY > maxY) {
                _b = [maxY, minY], minY = _b[0], maxY = _b[1];
            }
            _this.minXFactor = minX;
            _this.maxXFactor = maxX;
            _this.minYFactor = minY;
            _this.maxYFactor = maxY;
            if (!(0 < _this.minXFactor && _this.minXFactor < 1)) {
                _this.minXFactor = 0;
            }
            if (!(0 < _this.maxXFactor && _this.maxXFactor < 1)) {
                _this.maxXFactor = 1;
            }
            if (!(0 < _this.minYFactor && _this.minYFactor < 1)) {
                _this.minYFactor = 0;
            }
            if (!(0 < _this.maxYFactor && _this.maxYFactor < 1)) {
                _this.maxYFactor = 1;
            }
            if (_this.minXFactor !== 0) {
                _this.attributeSet.setAt('minXFactor', 'app', _this.minXFactor);
            }
            if (_this.maxXFactor !== 1) {
                _this.attributeSet.setAt('maxXFactor', 'app', _this.maxXFactor);
            }
            if (_this.minYFactor !== 0) {
                _this.attributeSet.setAt('minYFactor', 'app', _this.minYFactor);
            }
            if (_this.maxYFactor !== 1) {
                _this.attributeSet.setAt('maxYFactor', 'app', _this.maxYFactor);
            }
            return _this;
            var _a, _b;
        }
        FDSPlot.prototype._init = function (args) {
            this._defMapID = 'DEF_PLOT';
            _super.prototype._init.call(this);
            // this needs to be in place before the built-in axes are created
            this.wrapper = args.wrapper ? args.wrapper : new FDSPlotWrapper(this);
            this._builtinObjects = {
                X: undefined,
                Y: undefined,
                Y2: undefined,
                Y3: undefined,
                Y4: undefined,
                Z: undefined,
                COLOR: undefined,
                DSIZE: undefined,
                HIT: undefined,
                Legend: undefined
            };
            this.drawStyle = 0 /* LINE */;
            this.plotBGBrush = new FDSBrush();
            this.plotBGBrush.color = 16777215 /* WHITE */;
            this.plotBGBrush.style = 0 /* SOLID */;
            this.chartBGBrush = new FDSBrush();
            this.chartBGBrush.style = 1 /* NULL */;
            this.chartBGBrush.color = 16777215 /* WHITE */;
            this.hZoomRectBrush = new FDSBrush();
            this.hZoomRectBrush.color = RGBtoCOLORREF(255, 0, 0);
            this.hZoomRectBrush.style = 0 /* SOLID */;
            this.hZoomHandleBrush = new FDSBrush();
            this.hZoomHandleBrush.color = RGBtoCOLORREF(28, 10, 191);
            this.hZoomHandleBrush.style = 0 /* SOLID */;
            this.hZoomFadeBrush = new FDSBrush();
            this.hZoomFadeBrush.color = RGBtoCOLORREF(128, 128, 128);
            this.hZoomFadeBrush.style = 0 /* SOLID */;
            this.hZoomFadeBrush.alpha = 128;
            // `@plotFGPen` is used to draw a box outline around the chart on the
            // chart area.
            this.plotFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this.chartFGPen = new FDSPen({ color: 0 /* BLACK */, style: 5 /* NULL */ });
            // The PC-side chart supports a fixed number of headers; initialize
            // those here
            this.header = new FDSHeading(this.root, 'Header', this, { weight: 700 /* BOLD */ });
            this.heading1 = new FDSHeading(this.root, 'Heading1', this, { weight: 700 /* BOLD */ });
            this.heading2 = new FDSHeading(this.root, 'Heading2', this);
            this.heading3 = new FDSHeading(this.root, 'Heading3', this);
            this.heading4 = new FDSHeading(this.root, 'Heading4', this);
            this.footer = new FDSHeading(this.root, 'Footer', this, { italic: true, height: 10, family: 'Times New Roman' });
            // Footers default to displaying the standard copyright
            // message on the right-side with a few other trimmings.
            this.footer.text = 'Â©FactSet Research Systems';
            this.footer.arrangement = 1 /* RIGHT_CENTER_LEFT */;
            this.footer.extendsToEdge = true;
            // `@legendFont` serves as a placeholder, essentially, to provide the
            // ability to redirect chart-level base font attributes to the legend
            // attributes.
            this._builtinObjects['Legend'] = this.legend = new FDSLegend(this.root, this.id + '_Legend', this);
            this._legendFont = new FDSFont({ widthHint: 32000 });
            this.addChild(this.legend);
            this.emptyMessageFont = new FDSFont();
            // Heading2 defaults to visible on PC-side.
            this.heading1.visible = true;
            this.heading2.visible = true;
            this.plotRect = new Rectangle();
            this.headerRect = new Rectangle();
            this.footerRect = new Rectangle();
            this.legendRect = new Rectangle();
            // Quick label positioning rectangles
            this._beforeAxisQuickLabelRect = new Rectangle();
            this._outsideAxisQuickLabelRect = new Rectangle();
            this.renderManager = null;
            this.axisGap = 2;
            this.leftMargin = scaleByDevicePixelRatioAndRound(5);
            this.rightMargin = scaleByDevicePixelRatioAndRound(5);
            this.topMargin = scaleByDevicePixelRatioAndRound(5);
            this.bottomMargin = scaleByDevicePixelRatioAndRound(5);
            this.leftPlotMargin = 0;
            this.rightPlotMargin = 0;
            this.topPlotMargin = 0;
            this.bottomPlotMargin = 0;
            // Override to allow top overhang to be applied when calculating plot size
            this._allowTopOverhang = false;
            this.seriesEventMask = 1 /* PICK */ | 4 /* DROP */;
            this.referenceLineEventMask = 1 /* PICK */ | 4 /* DROP */;
            this.annotationEventMask = 1 /* PICK */ | 2 /* DROP */ |
                4 /* TEXTCHANGED */;
            this.seriesInterval = [];
            this.seriesList = {};
            this._childrenNames = [];
            // stored on plot itself
            this._cumulativeHeaderHeight = 0;
            this._footerHeight = 0;
            this.leftAxisWidth = 0;
            this.rightAxisWidth = 0;
            this.bottomAxisHeight = 0;
            this._axisResetOnDataChange = false;
            this._axisRefreshMask = -1 /* ALL */;
            this.leftQuickLabelOffsets = { inside: 0, outside: 0, beforeAxes: 0, onAxis: 0 };
            this.rightQuickLabelOffsets = { inside: 0, outside: 0, beforeAxes: 0, onAxis: 0 };
            this._oldCrosshairsSnapToSeries = '';
            this.compiledCrosshairsSnapStr = this.properties.compilePropertyString(this._oldCrosshairsSnapToSeries);
            this._HZoomResizeOtherAxes = false;
            this._plotVisible = true;
            this._chartVisible = true;
            this.hitShapes = [];
            this.storedAxisRects = [];
            this.storedHeaderRects = [];
            // QL stuff for the series to inherit
            this.quickLabelFont = new FDSFont({ height: 10, color: 13421772 /* PLOT_FG_GREY */, weight: 800 /* EXTRABOLD */ });
            // Quick label backgrounds default to white
            this.quickLabelFGPen = new FDSPen();
            this.quickLabelBGBrush = new FDSBrush();
            this.quickLabelBGBrush.style = 0 /* SOLID */;
            this.quickLabelBGBrush.color = 16777215 /* WHITE */;
            this.sharedAxisAnchor = new SharedAxisAnchor();
            // For now, this call should be at the end of the constructor, since
            // everything should be setup at this point.
            this._setAttributes();
            // Similarly, since _setAttributes isn't guaranteed to ever execute if the default map has already
            // been initialized. As a result, we do that here instead.
            this._createBuiltInAxes();
            if (!this.attributeSet.defaultMap.isInitialized()) {
                this.attributeSet.defaultMap.finalizeInitialization();
            }
        };
        FDSPlot.prototype._isChartVisible = function () {
            return this._chartVisible;
        };
        FDSPlot.prototype._isPlotVisible = function () {
            return this._plotVisible;
        };
        // Apply a theme based on what was passed into the FDSChart constructor
        FDSPlot.prototype._applyTheme = function () {
            if (!_super.prototype._applyTheme.call(this)) {
                return false;
            }
            var themeAttrs = {};
            if (this._chartTheme === 1 /* QUARTZ */) {
                themeAttrs['ChartBGColor'] = 16777215 /* WHITE */;
                themeAttrs['ChartBGStyle'] = 1;
                themeAttrs['FooterFontColor'] = 0 /* BLACK */;
                themeAttrs['Heading1FontColor'] = 0 /* BLACK */;
                themeAttrs['Heading2FontColor'] = 0 /* BLACK */;
                themeAttrs['Heading3FontColor'] = 0 /* BLACK */;
                themeAttrs['Heading4FontColor'] = 0 /* BLACK */;
                themeAttrs['LegendFontColor'] = 0 /* BLACK */;
                themeAttrs['LegendFontHeight'] = 11;
                themeAttrs['PlotBGColor'] = 16777215 /* WHITE */;
                themeAttrs['PlotBGStyle'] = 0 /* SOLID */;
                themeAttrs['PlotFGColor'] = 14803425 /* GRAY9 */;
            }
            else if (this._chartTheme === 2 /* CARBON */) {
                themeAttrs['ChartBGColor'] = 3289650 /* CARBON */;
                themeAttrs['ChartBGStyle'] = 1;
                themeAttrs['ChartBGGradientStyle'] = 0;
                themeAttrs['FooterFontColor'] = 16777215 /* WHITE */;
                themeAttrs['Heading1FontColor'] = 16777215 /* WHITE */;
                themeAttrs['Heading2FontColor'] = 16777215 /* WHITE */;
                themeAttrs['Heading3FontColor'] = 16777215 /* WHITE */;
                themeAttrs['Heading4FontColor'] = 16777215 /* WHITE */;
                themeAttrs['LegendFontColor'] = 16777215 /* WHITE */;
                themeAttrs['LegendFontHeight'] = 11;
                themeAttrs['PlotBGColor'] = 3289650 /* CARBON */;
                themeAttrs['PlotBGGradientStyle'] = 0;
                themeAttrs['PlotBGStyle'] = 0 /* SOLID */;
                themeAttrs['PlotFGColor'] = 4934475 /* DARK_CARBON */;
            }
            for (var key in themeAttrs) {
                this.attributeSet.setAt(key, 'app', themeAttrs[key]);
            }
            return true;
        };
        FDSPlot.prototype._setAttributes = function () {
            if (!this.attributeSet.defaultMap.startInitialization()) {
                return;
            }
            _super.prototype._setAttributes.call(this);
            this.attributeSet.addMultiple([
                [
                    'TopMargin',
                    Number,
                    5
                ],
                [
                    'BottomMargin',
                    Number,
                    5
                ],
                [
                    'LeftMargin',
                    Number,
                    5
                ],
                [
                    'RightMargin',
                    Number,
                    5
                ],
                [
                    'TopPlotMargin',
                    Number,
                    0
                ],
                [
                    'BottomPlotMargin',
                    Number,
                    0
                ],
                [
                    'LeftPlotMargin',
                    Number,
                    0
                ],
                [
                    'RightPlotMargin',
                    Number,
                    0
                ],
                [
                    'EquateLRMargins',
                    Boolean,
                    true,
                    'EquateLRMargins'
                ],
                [
                    'ClipPlot',
                    Boolean,
                    true
                ],
                [
                    'ClipSubPlot',
                    Boolean,
                    false
                ],
                [
                    'ClipSubPlotX',
                    Boolean,
                    false
                ],
                [
                    'CrosshairsBoundToPlot',
                    Boolean,
                    false,
                    'CrosshairsBoundToPlot'
                ],
                [
                    'CrosshairsDrawOnPlot',
                    Boolean,
                    false,
                    'CrosshairsDrawOnPlot'
                ],
                [
                    'CrosshairsLineSize',
                    Number,
                    1,
                    'CrosshairsLineSize'
                ],
                [
                    'CrosshairsLineColor',
                    Number,
                    this.root.crosshairsLineColor,
                    'CrosshairsLineColor'
                ],
                [
                    'CrosshairsShowHorizontal',
                    Boolean,
                    true,
                    'CrosshairsShowHorizontal'
                ],
                [
                    'CrosshairsShowVertical',
                    Boolean,
                    true,
                    'CrosshairsShowVertical'
                ],
                [
                    'CrosshairsSnapToSeries',
                    String,
                    '',
                    'CrosshairsSnapToSeries'
                ],
                [
                    'CrosshairsSnapXToSeries',
                    Boolean,
                    true,
                    'CrosshairsSnapXToSeries'
                ],
                [
                    'CrosshairsSnapYToSeries',
                    Boolean,
                    false,
                    'CrosshairsSnapYToSeries'
                ],
                [
                    'EmptyMessage',
                    String,
                    'No Data'
                ],
                [
                    'MaxZoom',
                    Number,
                    4.0
                ],
                [
                    'MinZoom',
                    Number,
                    1.0
                ],
                [
                    'SVGElementID',
                    String,
                    'SVGMap'
                ],
                [
                    'SVGElementIDAJAX',
                    String,
                    'SVGURL'
                ],
                [
                    'minXPlotFactor',
                    Number,
                    0
                ],
                [
                    'maxXPlotFactor',
                    Number,
                    1
                ],
                [
                    'minYPlotFactor',
                    Number,
                    0
                ],
                [
                    'maxYPlotFactor',
                    Number,
                    1
                ],
                [
                    'minXPlotPadding',
                    Number,
                    0
                ],
                [
                    'maxXPlotPadding',
                    Number,
                    0
                ],
                [
                    'minYPlotPadding',
                    Number,
                    0
                ],
                [
                    'maxYPlotPadding',
                    Number,
                    0
                ],
                [
                    'minXFactor',
                    Number,
                    0
                ],
                [
                    'maxXFactor',
                    Number,
                    1
                ],
                [
                    'minYFactor',
                    Number,
                    0
                ],
                [
                    'maxYFactor',
                    Number,
                    1
                ],
                [
                    'BinMode',
                    String,
                    '2D'
                ],
                [
                    'DrawStyle',
                    Number,
                    0
                ],
                [
                    'GroupedLegend',
                    Boolean,
                    false
                ],
                [
                    'Grouped',
                    Boolean,
                    true
                ],
                [
                    'GroupedY',
                    Boolean,
                    false
                ],
                [
                    'GroupedLeft',
                    Boolean,
                    false
                ],
                [
                    'GroupedRight',
                    Boolean,
                    false
                ],
                [
                    'GroupedTop',
                    Boolean,
                    false
                ],
                [
                    'GroupedBottom',
                    Boolean,
                    false
                ],
                [
                    'AxisGap',
                    Number,
                    2
                ],
                [
                    'seriesId',
                    Number,
                    0
                ],
                [
                    'AxisResetOnDataChange',
                    Boolean,
                    false
                ],
                [
                    'ZoomGrouped',
                    Boolean,
                    true
                ],
                [
                    'ZoomMode',
                    Number,
                    3 /* XY */
                ],
                [
                    'ResizeAllAxesOnZoom',
                    Boolean,
                    false,
                    'ResizeAllAxesOnZoom'
                ],
                [
                    'UseIntradayScale',
                    Boolean,
                    false
                ],
                [
                    'SeriesShadowBlurAmount',
                    Number,
                    0
                ],
                [
                    'PlotDragEnabled',
                    Boolean,
                    false,
                    'PlotDragEnabled'
                ],
                [
                    'ResizeEnabled',
                    Boolean,
                    false,
                    'ResizeEnabled'
                ],
                [
                    'ResizeTouchingOnly',
                    Boolean,
                    true,
                    'ResizeTouchingOnly'
                ],
                [
                    'ResizeMinFactorX',
                    Number,
                    0,
                    'ResizeMinFactorX'
                ],
                [
                    'ResizeMinFactorY',
                    Number,
                    0,
                    'ResizeMinFactorY'
                ],
                [
                    'AllowTopOverhang',
                    Boolean,
                    false,
                    'AllowTopOverhang'
                ],
                [
                    'InteractivityMode',
                    Number,
                    1 /* SELECTABLE */
                ],
                [
                    'SimpleZoom',
                    Boolean,
                    false,
                    'SimpleZoom'
                ],
                [
                    'OnLeftButtonClick',
                    String,
                    '',
                    'OnLeftButtonClick'
                ],
                [
                    'OnLeftButtonDoubleClick',
                    String,
                    '',
                    'OnLeftButtonDoubleClick'
                ],
                [
                    'OnRightButtonClick',
                    String,
                    '',
                    'OnRightButtonClick'
                ],
                [
                    'OnRightButtonDoubleClick',
                    String,
                    '',
                    'OnRightButtonDoubleClick'
                ],
                [
                    'OnMiddleButtonClick',
                    String,
                    '',
                    'OnMiddleButtonClick'
                ],
                [
                    'OnMiddleButtonDoubleClick',
                    String,
                    '',
                    'OnMiddleButtonDoubleClick'
                ],
                [
                    'AxisRefreshMask',
                    Number,
                    -1 /* ALL */
                ],
                [
                    'ReferenceLineEventMask',
                    Number,
                    this.referenceLineEventMask,
                    'ReferenceLineEventMask'
                ],
                [
                    'SeriesEventMask',
                    Number,
                    this.seriesEventMask,
                    'SeriesEventMask'
                ],
                [
                    'AnnotationEventMask',
                    Number,
                    this.annotationEventMask,
                    'AnnotationEventMask'
                ],
                [
                    'Cursor',
                    String,
                    '',
                    'Cursor'
                ],
                [
                    'LegendCursor',
                    String,
                    '',
                    'Cursor'
                ],
                [
                    'FootnoteLegendCursor',
                    String,
                    '',
                    'Cursor'
                ],
                [
                    'AnnotationLegendCursor',
                    String,
                    '',
                    'Cursor'
                ],
                // Quicklabel attrs for series to inherit from
                [
                    'SeriesQuickLabel',
                    Boolean,
                    false,
                    'SeriesQuickLabel'
                ],
                [
                    'SeriesQuickLabelText',
                    String,
                    '<FDSLabel>',
                    'SeriesQuickLabelText'
                ],
                [
                    'SeriesQuickLabelAutoPosition',
                    Boolean,
                    true,
                    'SeriesQuickLabelAutoPosition'
                ],
                [
                    'SeriesQuickLabelPosition',
                    Number,
                    2 /* RIGHT */,
                    'SeriesQuickLabelPosition'
                ],
                [
                    'SeriesQuickLabelVerticalPosition',
                    Number,
                    2 /* DEFAULT */,
                    'SeriesQuickLabelVerticalPosition'
                ],
                [
                    'SeriesQuickLabelLeftPositionModifier',
                    Number,
                    0 /* INSIDE */,
                    'SeriesQuickLabelLeftPositionModifier'
                ],
                [
                    'SeriesQuickLabelRightPositionModifier',
                    Number,
                    0 /* INSIDE */,
                    'SeriesQuickLabelRightPositionModifier'
                ],
                [
                    'SeriesQuickLabelTextBox',
                    Boolean,
                    false,
                    'SeriesQuickLabelTextBox'
                ],
                [
                    'SeriesQuickLabelTextBoxDisplayStyle',
                    Number,
                    0 /* RECT */,
                    'SeriesQuickLabelTextBoxDisplayStyle'
                ],
                [
                    'SeriesQuickLabelColorFollowsSeriesColor',
                    Boolean,
                    true,
                    'SeriesQuickLabelColorFollowsSeriesColor'
                ],
                [
                    'SeriesQuickLabelColorMaximumContrast',
                    Boolean,
                    false,
                    'SeriesQuickLabelColorMaximumContrast'
                ]
            ]);
            this.sharedAxisAnchor.writeToAttrSet(this.attributeSet);
            this.quickLabelFont.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelFont', 'SeriesQuickLabelFont');
            this.quickLabelFGPen.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelTextBoxFG', 'SeriesQuickLabelTextBoxFG');
            this.quickLabelBGBrush.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelTextBoxBG', 'SeriesQuickLabelTextBoxBG');
            this.chartBGBrush.writeToAttrSet(this.attributeSet, 'ChartBG', 'ChartBG');
            this.chartFGPen.writeToAttrSet(this.attributeSet, 'ChartFG', 'ChartFG');
            this.hZoomRectBrush.writeToAttrSet(this.attributeSet, 'HorizontalZoomRect');
            this.hZoomHandleBrush.writeToAttrSet(this.attributeSet, 'HorizontalZoomHandle');
            this.hZoomFadeBrush.writeToAttrSet(this.attributeSet, 'HorizontalZoomFade');
            this.plotBGBrush.writeToAttrSet(this.attributeSet, 'PlotBG', 'PlotBG');
            this.plotFGPen.writeToAttrSet(this.attributeSet, 'PlotFG', 'PlotFG');
            this.header.writeToAttrSet(this.attributeSet, 'Header', 'Header');
            this.heading1.writeToAttrSet(this.attributeSet, 'Heading1', 'Heading1');
            this.heading2.writeToAttrSet(this.attributeSet, 'Heading2', 'Heading2');
            this.heading3.writeToAttrSet(this.attributeSet, 'Heading3', 'Heading3');
            this.heading4.writeToAttrSet(this.attributeSet, 'Heading4', 'Heading4');
            this.footer.writeToAttrSet(this.attributeSet, 'Footer', 'Footer');
            // `@legendFont`s attributes *must* be written before the injection of the
            // legend's attributes so that inheritance of the base font gets set up
            // correctly.
            this._legendFont.writeToAttrSet(this.attributeSet, 'LegendFont', 'LegendFont');
            this.emptyMessageFont.writeToAttrSet(this.attributeSet, 'EmptyMessageFont', 'BaseFont');
            // we need to defer this call until after builtin axes and legend attributes are injected
            // @attributes.defaultMap.finalizeInitialization()
        };
        /**
         * Reset any scales which don't match the current "UseIntradayScale" setting.
         */
        FDSPlot.prototype.resetScalesToMatchUseIntradaySetting = function () {
            // The only time we would need to update the scales is if the "UseIntradayScale" attribute changed.
            // Therefore, we can skip checking if the attributes haven't changed.
            if (this.attributeSet.isDirty()) {
                var currentUseIntradayValue_1 = this.attributeSet.get('UseIntradayScale');
                if (this.useIntradayScale !== currentUseIntradayValue_1) {
                    this.axes.forEach(function (axis) { return axis.ensureScaleTypeMatchesUseIntradaySetting(currentUseIntradayValue_1); });
                }
            }
        };
        FDSPlot.prototype.allPlotSeriesDrawStylesMatch = function (drawStyleArray) {
            if (!_$1.includes(drawStyleArray, this.drawStyle) && !this.attributeSet.isDefault('DrawStyle')) {
                return false;
            }
            return _$1.every(this.seriesList, function (series) { return _$1.includes(drawStyleArray, series.getEffectiveDrawStyle()); });
        };
        FDSPlot.prototype.getSimpleZoomEnabled = function () {
            if (this.allPlotSeriesDrawStylesMatch([19 /* PIE */, 36 /* PIE3D */])) {
                // If the drawstyle is a type of pie chart, we never let simple zoom be enabled.
                this.simpleZoomEnabled = false;
            }
            else if (this.allPlotSeriesDrawStylesMatch([38 /* TREEMAP */])) {
                // If the drawstyle is a treemap, we never let simple zoom be disabled.
                this.simpleZoomEnabled = true;
            }
            else if (this.attributeSet.isInheritedDefault('SimpleZoom') &&
                this.allPlotSeriesDrawStylesMatch([41 /* KMLMAP */])) {
                // If the SimpleZoom attribute has never been modified, we default it as true for the kml map drawstyle.
                this.simpleZoomEnabled = true;
            }
            return this.simpleZoomEnabled;
        };
        // returns [brush, rect]
        FDSPlot.prototype.getEffectiveBGBrush = function () {
            if (this.plotBGBrush.style !== 1 /* NULL */) {
                return [this.plotBGBrush, this.plotRect];
            }
            if (this.chartBGBrush.style !== 1 /* NULL */) {
                return [this.root.chartBGBrush, this.root.chartRect];
            }
            return [this.root.canvasBGBrush, new Rectangle(0, 0, this.root.getWidth(), this.root.getHeight())];
        };
        FDSPlot.prototype.getFCPrefix = function () {
            return this.id !== 'FC_PLOT' ? 'FC_' : '';
        };
        FDSPlot.prototype._createBuiltInAxes = function () {
            // Setup built-in axes
            this.axes = [];
            var builtInObjects = this.isStyleObject ? this._getBuiltInStyles() : this._getBuiltInAxes();
            // here we just create the built-in axes and add them to the root.
            // they are added to the plot later when all the plot's children are added.
            for (var _i = 0, builtInObjects_1 = builtInObjects; _i < builtInObjects_1.length; _i++) {
                var _a = builtInObjects_1[_i], id = _a.id, dim = _a.dim, prefix = _a.prefix, scaleSpecifier = _a.scaleSpecifier;
                // the final 'true' here tells it it's a built-in axis
                var newAxis = void 0;
                if (this.isStyleObject) {
                    newAxis = new FDSAxisStyle(this.root, id, dim, prefix, this, true, scaleSpecifier);
                }
                else {
                    newAxis = new FDSAxis(this.root, id, dim, prefix, this, true, scaleSpecifier);
                }
                this.needsUpdate = true;
                // save axis as child object of root
                if (this.isStyleObject) {
                    this.root.addStyleObject(newAxis);
                }
                this.root.addChild(newAxis);
                // built-in axes get added here, not later
                this.addChild(newAxis);
                this._builtinObjects[prefix] = newAxis;
            }
        };
        FDSPlot.prototype._getBuiltInStyles = function () {
            var fcPrefix = this.getFCPrefix();
            return [
                {
                    id: "" + fcPrefix + this.id + "_X_AXIS_STYLE",
                    dim: 1 /* X */,
                    prefix: 'X',
                    scaleSpecifier: 2 /* X */
                },
                {
                    id: "" + fcPrefix + this.id + "_Y_AXIS_STYLE",
                    dim: 2 /* Y */,
                    prefix: 'Y',
                    scaleSpecifier: 4 /* Y */
                }
            ];
        };
        FDSPlot.prototype._getBuiltInAxes = function () {
            var fcPrefix = this.getFCPrefix();
            return [
                {
                    id: "" + fcPrefix + this.id + "_X_AXIS",
                    dim: 1 /* X */,
                    prefix: 'X',
                    scaleSpecifier: 2 /* X */
                },
                {
                    id: "" + fcPrefix + this.id + "_Y_AXIS",
                    dim: 2 /* Y */,
                    prefix: 'Y',
                    scaleSpecifier: 4 /* Y */
                },
                {
                    id: "" + fcPrefix + this.id + "_Y2_AXIS",
                    dim: 2 /* Y */,
                    prefix: 'Y2',
                    scaleSpecifier: 128 /* Y2 */
                },
                {
                    id: "" + fcPrefix + this.id + "_Y3_AXIS",
                    dim: 2 /* Y */,
                    prefix: 'Y3',
                    scaleSpecifier: 256 /* Y3 */
                },
                {
                    id: "" + fcPrefix + this.id + "_Y4_AXIS",
                    dim: 2 /* Y */,
                    prefix: 'Y4',
                    scaleSpecifier: 512 /* Y4 */
                },
                {
                    id: "" + fcPrefix + this.id + "_Z_AXIS",
                    dim: 3 /* Z */,
                    prefix: 'Z',
                    scaleSpecifier: 8 /* Z */
                },
                {
                    id: "" + fcPrefix + this.id + "_COLOR_AXIS",
                    dim: 4 /* COLOR */,
                    prefix: 'COLOR',
                    scaleSpecifier: 16 /* COLOR */
                },
                {
                    id: "" + fcPrefix + this.id + "_DSIZE_AXIS",
                    dim: 5 /* DSIZE */,
                    prefix: 'DSIZE',
                    scaleSpecifier: 32 /* SIZE */
                },
                {
                    id: "" + fcPrefix + this.id + "_HIT_AXIS",
                    dim: 6 /* HIT */,
                    prefix: 'HIT',
                    scaleSpecifier: 64 /* HIT */
                }
            ];
        };
        FDSPlot.prototype.syncMembers = function () {
            _super.prototype.syncMembers.call(this);
            if (!this.attributeSet.isDirty()) {
                return;
            }
            // Saves on property access and minified file size
            var getAttribute = this.attributeSet.get.bind(this.attributeSet);
            this.simpleZoomEnabled = this.attributeSet.get('SimpleZoom');
            this.simpleZoomEnabledIsDefault = this.attributeSet.isInheritedDefault('SimpleZoom');
            this.drawStyle = this.attributeSet.get('DrawStyle');
            this.setInteractivityMode(getAttribute('InteractivityMode'));
            this._syncInteractivity();
            this._applyTheme();
            this.axisGap = getAttribute('AxisGap');
            var objects = {
                'PlotBG': this.plotBGBrush,
                'ChartBG': this.chartBGBrush,
                'Header': this.header,
                'Heading1': this.heading1,
                'Heading2': this.heading2,
                'Heading3': this.heading3,
                'Heading4': this.heading4,
                'Footer': this.footer,
                'HorizontalZoomRect': this.hZoomRectBrush,
                'HorizontalZoomHandle': this.hZoomHandleBrush,
                'HorizontalZoomFade': this.hZoomFadeBrush
            };
            this.plotFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'PlotFG');
            this.chartFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'ChartFG');
            this.emptyMessageFont = FDSFont.constructFromAttributes(this.attributeSet, 'EmptyMessageFont');
            for (var attrBase in objects) {
                objects[attrBase].constructFromAttributes(this.attributeSet, attrBase);
            }
            if (this.attributeSet.isDefault('Heading1Text')) {
                this.heading1.setText(this.labelText);
            }
            var _a = this.getXYFactors(), minXFactor = _a.minXFactor, minYFactor = _a.minYFactor, maxXFactor = _a.maxXFactor, maxYFactor = _a.maxYFactor;
            if (minXFactor !== this.minXFactor ||
                minYFactor !== this.minYFactor ||
                maxXFactor !== this.maxXFactor ||
                maxYFactor !== this.maxYFactor) {
                this.root.plotResizeManager.setHitShapesDirty();
                this.maxXFactor = maxXFactor;
                this.minXFactor = minXFactor;
                this.maxYFactor = maxYFactor;
                this.minYFactor = minYFactor;
            }
            this.useIntradayScale = getAttribute('UseIntradayScale');
            this.grouped = getAttribute('Grouped');
            this.groupedY = getAttribute('GroupedY');
            this.groupedRight = getAttribute('GroupedRight');
            this.groupedLeft = getAttribute('GroupedLeft');
            this.groupedTop = getAttribute('GroupedTop');
            this.groupedBottom = getAttribute('GroupedBottom');
            this.groupedLegend = getAttribute('GroupedLegend');
            this.leftMargin = scaleByDevicePixelRatioAndRound(getAttribute('LeftMargin'));
            this.rightMargin = scaleByDevicePixelRatioAndRound(getAttribute('RightMargin'));
            this.topMargin = scaleByDevicePixelRatioAndRound(getAttribute('TopMargin'));
            this.bottomMargin = scaleByDevicePixelRatioAndRound(getAttribute('BottomMargin'));
            this.leftPlotMargin = scaleByDevicePixelRatioAndRound(getAttribute('LeftPlotMargin'));
            this.rightPlotMargin = scaleByDevicePixelRatioAndRound(getAttribute('RightPlotMargin'));
            this.topPlotMargin = scaleByDevicePixelRatioAndRound(getAttribute('TopPlotMargin'));
            this.bottomPlotMargin = scaleByDevicePixelRatioAndRound(getAttribute('BottomPlotMargin'));
            this.minZoom = getAttribute('MinZoom');
            this.maxZoom = getAttribute('MaxZoom');
            this.drawStyle = getAttribute('DrawStyle');
            this._axisRefreshMask = getAttribute('AxisRefreshMask');
            this.referenceLineEventMask = getAttribute('ReferenceLineEventMask');
            this.seriesEventMask = getAttribute('SeriesEventMask');
            this.annotationEventMask = getAttribute('AnnotationEventMask');
            var crosshairsSnapSeries = getAttribute('CrosshairsSnapToSeries');
            if (crosshairsSnapSeries !== this._oldCrosshairsSnapToSeries) {
                this.compiledCrosshairsSnapStr = this.properties.compilePropertyString(crosshairsSnapSeries);
                this._oldCrosshairsSnapToSeries = crosshairsSnapSeries;
            }
            this.crosshairsLineColor = getAttribute('CrosshairsLineColor');
            this._axisResetOnDataChange = getAttribute('AxisResetOnDataChange');
            this.plotDragEnabled = getAttribute('PlotDragEnabled');
            this.resizeEnabled = getAttribute('ResizeEnabled');
            if (this.resizeEnabled !== this._oldResizeEnabled) {
                this._oldResizeEnabled = this.resizeEnabled;
                this.root.plotResizeManager.setSlidersDirty();
            }
            this.resizeTouchingOnly = getAttribute('ResizeTouchingOnly');
            this.resizeMinFactorX = getAttribute('ResizeMinFactorX');
            this.resizeMinFactorY = getAttribute('ResizeMinFactorY');
            this._allowTopOverhang = getAttribute('AllowTopOverhang');
            this.clipSubPlotX = getAttribute('ClipSubPlotX');
            this.clipSubPlot = getAttribute('ClipSubPlot');
            this.clipPlot = getAttribute('ClipPlot');
            var oldZoomResizeAxes = this._HZoomResizeOtherAxes;
            this._HZoomResizeOtherAxes = getAttribute('ResizeAllAxesOnZoom');
            if (this._HZoomResizeOtherAxes !== oldZoomResizeAxes) {
                this.refreshAxis(true);
                this.adjust();
                this.setNeedUpdate(true);
            }
            // figure out how much space the headers take up
            var headers = [
                this.header,
                this.heading1,
                this.heading2,
                this.heading3,
                this.heading4
            ];
            var ctx = this.root.getContext();
            this._cumulativeHeaderHeight = 0;
            for (var _i = 0, headers_1 = headers; _i < headers_1.length; _i++) {
                var header = headers_1[_i];
                if (header.visible) {
                    var _b = header.computeTextDimensions(ctx), height = _b[1];
                    this._cumulativeHeaderHeight += height;
                }
            }
            // also figure out the footer text height
            this._footerHeight = 0;
            if (this.footer.visible) {
                var _c = this.footer.computeTextDimensions(ctx), height = _c[1];
                this._footerHeight = height;
            }
            this.legend.syncMembers();
            // series inherits this
            this.quickLabel = getAttribute('SeriesQuickLabel');
            this.quickLabelPosition = getAttribute('SeriesQuickLabelPosition');
            this.quickLabelVerticalPosition = getAttribute('SeriesQuickLabelVerticalPosition');
            this.quickLabelLeftPositionModifier = getAttribute('SeriesQuickLabelLeftPositionModifier');
            this.quickLabelRightPositionModifier = getAttribute('SeriesQuickLabelRightPositionModifier');
            this.quickLabelBox = getAttribute('SeriesQuickLabelTextBox');
            this.quickLabelBoxDisplayStyle = getAttribute('SeriesQuickLabelTextBoxDisplayStyle');
            this.quickLabelColorFollowsSeriesColor = getAttribute('SeriesQuickLabelColorFollowsSeriesColor');
            this.quickLabelColorMaximumContrast = getAttribute('SeriesQuickLabelColorMaximumContrast');
            this.quickLabelFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesQuickLabelTextBoxFG');
            this.quickLabelBGBrush.constructFromAttributes(this.attributeSet, 'SeriesQuickLabelTextBoxBG');
            this.quickLabelFont = FDSFont.constructFromAttributes(this.attributeSet, 'SeriesQuickLabelFont');
            // update series label stuff in case we changed it
            for (var id in this.seriesList) {
                this.seriesList[id].updateQLAttrs();
            }
            this.leftQuickLabelOffsets = { inside: 0, outside: 0, beforeAxes: 0, onAxis: 0 };
            this.rightQuickLabelOffsets = { inside: 0, outside: 0, beforeAxes: 0, onAxis: 0 };
            this.sharedAxisAnchor.syncMembers(this.attributeSet);
            this.sharedAxisAnchor.computePositions(this.axes);
            // we need to go through and sync all our axes because if a plot's attribute set is flagged
            // as dirty, its possible that a redirected attribute was actually changed which won't get
            // pulled in from just syncing the plot's attributes. This was removed before for performance
            // reasons, but now it is less of a concern because the axes were (unnecessarily) recomputing
            // their sizes in each sync call.
            for (var _d = 0, _e = this.axes; _d < _e.length; _d++) {
                var axis = _e[_d];
                axis.syncMembers();
            }
        };
        FDSPlot.prototype.getSeriesEventMask = function () {
            return this.seriesEventMask;
        };
        FDSPlot.prototype.adjust = function () {
            this._initializeAxes();
            this._adjustAxesToSeries();
            this.attributeSet.setDirty();
        };
        FDSPlot.prototype._initializeAxes = function () {
            // only thing we need to do here for now is to set up the zoom data to enable sticky zoooming
            return this.axes.map(function (axis) {
                return axis.updateAxisZoomData();
            });
        };
        FDSPlot.prototype._adjustAxesToSeries = function () {
            for (var id in this.seriesList) {
                this.seriesList[id].syncMembers();
            }
            this.getXYBins(); // we need this so our bins (based on the stacking) can be set up prior to the adjust for the
            var _loop_1 = function (axis) {
                axis.associatedSeries.filter(function (series) { return !series.isAnnotation; })
                    .forEach(function (series) { return axis.adjust(series); });
            };
            // scales
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                _loop_1(axis);
            }
            this.sharedAxisAnchor.computePositions(this.axes);
        };
        // Override `FDSChartObject.addChild` so that we can create a legend entry on
        // series addition.
        FDSPlot.prototype.addChild = function (child) {
            // Call `FDSChartObject.addChild` to actually add the child. If addition
            // is successful, check to see what type the object is. If a series, add a
            // legend entry; if an axis, add to axes list.
            if (_super.prototype.addChild.call(this, child)) {
                if (isSeries(child)) {
                    // note: this doesn't really do everything it should. You should really be calling
                    // addSeries (which calls into here) instead!
                    if (child.getEffectiveDrawStyle() === 38 /* TREEMAP */ || child.getEffectiveDrawStyle() === 41 /* KMLMAP */) {
                        this.heatmapLegend = new HeatmapLegend(this.root, this, child);
                    }
                    else {
                        this.legend.addSeries(child);
                    }
                    this.seriesList[child.id] = child;
                    this.wrapper['seriesListDirty'] = true;
                    return true;
                }
                else if (isAxis(child)) {
                    this.wrapper['axisListDirty'] = true;
                    child.wrapper.plot = this.wrapper;
                    if (this.axes.length === 0 || !child.serializeFirst) {
                        this.axes.push(child);
                    }
                    else {
                        // stick it at the end of the "beforeAxes" axes
                        // we need to cache the initial length or else appending
                        // to the array will cause an infinite loop.
                        var initialLength = this.axes.length;
                        for (var i = 0; i < initialLength; i++) {
                            var ax = this.axes[i];
                            if (i === this.axes.length - 1) {
                                this.axes.push(child);
                            }
                            else if (ax.isBuiltInAxis) {
                                this.axes.splice(i, 0, child);
                                break;
                            }
                        }
                    }
                    return true;
                }
                else if (isLegend(child)) {
                    return true;
                }
            }
            return false;
        };
        FDSPlot.prototype._removeAxis = function (axis) {
            if (!axis) {
                return;
            }
            this.removeChild(axis);
            this.wrapper['axisListDirty'] = true;
            // custom axes have dimension defined by the series that use them
            if (!axis.isBuiltInAxis) {
                axis.dimension = -1 /* NONE */;
            }
            // undefine the scale so if this is reused in the future the scale will
            // match the type of the new data
            axis.scale = undefined;
            for (var i = 0; i < this.axes.length; i++) {
                var a = this.axes[i];
                if (a === axis) {
                    if (a.isBuiltInAxis) {
                        this._builtinObjects[a.getPrefix()] = undefined;
                    }
                    this.axes.splice(i, 1);
                    break;
                }
            }
        };
        FDSPlot.prototype.addAxisRect = function (text, rect, tag) {
            this.storedAxisRects.push({ text: text, rect: rect, tag: tag });
        };
        // Adds a series to the plot. This will handle the @addChild call, but we have some extra stuff to do
        // if the child is a series so we handle it here.
        //
        // @param series [FDSSeries] The series to add to the plot
        FDSPlot.prototype._addSeries = function (series) {
            if (!series) {
                return false;
            }
            // if the series doesn't exist yet, set up some stuff
            if (this.seriesList[series.id] === undefined) {
                this.addChild(series);
                this.seriesList[series.id] = series;
                var id = this.attributeSet.get('seriesId');
                series.setSeriesNumber(id);
                id++;
                this.attributeSet.setAt('seriesId', 'app', id);
                this.setNeedUpdate(true);
            }
            // either way, add it to the axis
            if (!series.isAnnotation) {
                // annotations don't affect the scales
                this._addSeriesToAxes(series);
            }
            return true;
        };
        FDSPlot.prototype._addSeriesToAxes = function (series) {
            // Use default if on(X/Y/Z)Axis doesn't match a valid prefix or axis
            // Store locally for readability and to avoid multiple fetches.
            var onXAxis = series.attributeSet.get('OnXAxis');
            // compatabilty shim for older charts which specify OnY2 instead of OnYAxis:Y2
            var onYAxis = (series.attributeSet.isInheritedDefault('OnYAxis') && series.attributeSet.get('OnY2')) ?
                'Y2' :
                series.attributeSet.get('OnYAxis');
            var defaultX;
            var defaultY;
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                var prefix = axis.getPrefix();
                if (onXAxis === prefix ||
                    onYAxis === prefix ||
                    axis.dimension === 4 /* COLOR */ || // every series goes on the color axis
                    axis.dimension === 5 /* DSIZE */) {
                    axis.addSeries(series);
                }
                // custom axes need to check id, not prefix
                if ((onXAxis === axis.id) && ((axis.dimension === -1 /* NONE */) || (axis.dimension === 1 /* X */))) {
                    axis.dimension = 1 /* X */;
                    axis.addSeries(series);
                    axis.attributeSet.defaultMap = MapFactory.getDefMap('DEF_X_AXIS');
                }
                if (onYAxis === axis.id && ((axis.dimension === -1 /* NONE */) || (axis.dimension === 2 /* Y */))) {
                    axis.dimension = 2 /* Y */;
                    axis.addSeries(series);
                    axis.attributeSet.defaultMap = MapFactory.getDefMap('DEF_Y_AXIS');
                }
                // also while we're here, save the default axes
                if (prefix === 'X') {
                    defaultX = axis;
                }
                if (prefix === 'Y') {
                    defaultY = axis;
                }
            }
            // use defaults if no matching axis was found
            if (!series.getAxis(1 /* X */)) {
                if (defaultX == null) {
                    throw 'No default x-axis available to add series.';
                }
                defaultX.addSeries(series);
            }
            if (!series.getAxis(2 /* Y */)) {
                if (defaultY == null) {
                    throw 'No default y-axis available to add series.';
                }
                defaultY.addSeries(series);
            }
        };
        // Removes a series from the plot since we have extra work to do for removing series, we handle it here.
        //
        // @param series [FDSSeries] series to be removed from the plot
        FDSPlot.prototype._removeSeries = function (series) {
            if (!series || !_$1.includes(Object.keys(this.seriesList), series.id)) {
                return false;
            }
            this.wrapper['seriesListDirty'] = true;
            this.removeChild(series);
            this.legend.removeSeries(series);
            if (this.heatmapLegend) {
                this.heatmapLegend = undefined;
            }
            series.removeSelfFromAxes();
            delete this.seriesList[series.id];
            if (this._axisResetOnDataChange) {
                this.refreshAxis(false);
            }
            return true;
        };
        // Sets the children in the `children` array to be parented to this plot
        //
        // @param children [Array] array containing the string IDs of children to be added to this plot
        // @return [Array] array containing a success bool and an error string
        FDSPlot.prototype.setChildren = function (children) {
            var ret = true;
            var errString;
            if (!this.root) {
                return [false, 'Invalid root during parenting'];
            }
            if (children == null) {
                // no children to set, not really an error...
                return [true, ''];
            }
            var beforeBuiltIns = true;
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                var obj = this.root.getChild(child);
                if (isAxis(obj) && obj.isBuiltInAxis) {
                    beforeBuiltIns = false;
                    continue;
                }
                if (!(isSeries(obj) || isAxis(obj))) {
                    errString = "Plot " + this.id + ": Child " + child + " is not a Series or Axis";
                    ret = false;
                }
                else {
                    if (isSeries(obj)) {
                        ret = this._addSeries(obj);
                    }
                    else {
                        obj.serializeFirst = beforeBuiltIns;
                        ret = this.addChild(obj);
                    }
                    if (!ret) {
                        errString = "Plot " + this.id + " is unable to parent " + child;
                        ret = false;
                    }
                }
            }
            return [ret, errString];
        };
        FDSPlot.prototype.initFromElement = function (element) {
            // make sure we handle attributes in the FDSChartObject initializer first
            _super.prototype.initFromElement.call(this, element);
            var children;
            var fdsChildrenTags = element.getElementsByTagName('FDSChildren');
            if (fdsChildrenTags.length > 0) {
                children = fdsChildrenTags[0];
            }
            if (children == null) {
                return;
            }
            if (children) {
                var childIds = children.getElementsByTagName('ChildId');
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < childIds.length; i++) {
                    var childId = childIds[i];
                    if (childId.textContent == null) {
                        continue;
                    }
                    this._childrenNames.push(childId.textContent);
                }
            }
        };
        // function to add all the children whose names were saved in initFromElement
        FDSPlot.prototype.addChildren = function () {
            this.setChildren(this._childrenNames);
            this._childrenNames = [];
        };
        // this is called after all the child objects have been added
        FDSPlot.prototype.processChildren = function () {
            var _this = this;
            var seriesNumber = 0;
            _$1.forOwn(this.children, function (childObject) {
                if (isSeries(childObject)) {
                    if (childObject.attributeSet.isDefault('SeriesNumber')) {
                        childObject.attributeSet.setAt('SeriesNumber', 'app', seriesNumber++);
                    }
                    if (!childObject.isAnnotation) {
                        _this._addSeriesToAxes(childObject);
                    }
                }
            });
        };
        // this function creates the quicklabel boxes and sets up the offsets for the plot based
        // on the quicklabel positions
        FDSPlot.prototype.computeQuickLabelOffsets = function () {
            var _this = this;
            this.renderManager.quickLabels = [];
            this.leftQuickLabelOffsets = { inside: 0, outside: 0, beforeAxes: 0, onAxis: 0 };
            this.rightQuickLabelOffsets = { inside: 0, outside: 0, beforeAxes: 0, onAxis: 0 };
            var _loop_2 = function (id) {
                var series = this_1.seriesList[id];
                if (!series.quickLabel || !series.visible || !series.hasValidData) {
                    return "continue";
                }
                // Build a `CompiledFormatString` from the series' quick label text
                var quickLabelCompiledFormatString = series.properties.compilePropertyString((series.quickLabelText));
                // Get the actual quick label text for the series by compiling the string
                var quickLabelText = quickLabelCompiledFormatString.fromValueRT({ propertySet: series.properties });
                // skip empty labels
                if (quickLabelText.isEmpty()) {
                    return "continue";
                }
                var _a = series.getMinMaxValidPoints(), startPt = _a[0], endPt = _a[1];
                var _b = series.getMinMaxValidIndices(), startInd = _b[0], endInd = _b[1];
                var ctx = this_1.root.getContext();
                var createInfoBox = function (opt) {
                    var box = new QuickLabelInfoBox(ctx, series, quickLabelText, opt.alignment);
                    var offsets = opt.offsets;
                    var offset = box.width + series.quickLabelGap;
                    switch (opt.positionModifier) {
                        case 0 /* INSIDE */:
                            offsets.inside = Math.max(offsets.inside, offset);
                            break;
                        case 1 /* OUTSIDE */:
                            offsets.outside = Math.max(offsets.outside, offset);
                            break;
                        case 2 /* BEFORE_AXES */:
                            offsets.beforeAxes = Math.max(offsets.beforeAxes, offset);
                            break;
                        case 3 /* ON_AXIS */:
                            offsets.onAxis = Math.max(offsets.onAxis, offset);
                            break;
                    }
                    box.personalPosition = opt.position;
                    box.personalModifier = opt.positionModifier;
                    box.personalPoint = opt.point;
                    box.personalIndex = opt.index;
                    _this.renderManager.quickLabels.push(box);
                };
                var isQuickLabelOnLeft = (series.quickLabelPosition & 1 /* LEFT */) !== 0;
                // save these so the plot can use them when subplotting things
                if (isQuickLabelOnLeft) {
                    var verticalPosition = series.quickLabelVerticalPosition;
                    var pointsSwapped = series.quickLabelVerticalPosition === 1;
                    createInfoBox({
                        alignment: series.quickLabelFontAlignmentLeft,
                        positionModifier: series.quickLabelLeftPositionModifier,
                        offsets: this_1.leftQuickLabelOffsets,
                        position: 1 /* LEFT */,
                        point: pointsSwapped ? endPt : startPt,
                        index: pointsSwapped ? endInd : startInd,
                    });
                }
                var isQuickLabelOnRight = (series.quickLabelPosition & 2 /* RIGHT */) !== 0;
                if (isQuickLabelOnRight) {
                    var pointsSwapped = series.quickLabelVerticalPosition === 0;
                    createInfoBox({
                        alignment: series.quickLabelFontAlignmentRight,
                        positionModifier: series.quickLabelRightPositionModifier,
                        offsets: this_1.rightQuickLabelOffsets,
                        position: 2 /* RIGHT */,
                        point: pointsSwapped ? startPt : endPt,
                        index: pointsSwapped ? startInd : endInd,
                    });
                }
            };
            var this_1 = this;
            for (var id in this.seriesList) {
                _loop_2(id);
            }
        };
        // Will be called externally before drawing
        FDSPlot.prototype.computeDimensions = function (plotRectSet) {
            // Check to see if we got different dimensions when we hit
            // `informOfNewSubplotRect`.
            if (plotRectSet === void 0) { plotRectSet = false; }
            var didComputeDimensions = this._computeDimensions(false, plotRectSet);
            // If we need to, recompute the dimensions a maximum of one time.
            if (!didComputeDimensions) {
                this._computeDimensions(true, plotRectSet);
            }
        };
        FDSPlot.prototype._computeDimensions = function (ignoreAxisDifference, plotRectSet) {
            if (ignoreAxisDifference === void 0) { ignoreAxisDifference = false; }
            if (plotRectSet === void 0) { plotRectSet = false; }
            // intraday scale needs to wait til after this step to update its labels, which it
            // only does once. so this flag tells it to wait
            this.computingDimensions = true;
            if (!plotRectSet) {
                this._computePlotRect();
            }
            this.computingDimensions = false;
            // if we made the axes change, return false and redo the plot stuff a second time
            var didChangeScaleDimensions = false;
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (!axis.shouldDraw()) {
                    continue;
                }
                didChangeScaleDimensions = axis.informOfNewSubplotRect(this.plotRect) || didChangeScaleDimensions;
            }
            if (didChangeScaleDimensions && !ignoreAxisDifference) {
                return false;
            }
            this._computePlotRelatedThings(this.minXFactor, this.maxXFactor, this.minYFactor, plotRectSet);
            return true;
        };
        // Computes the width and height for a label based on its text
        FDSPlot.prototype._computeCrosshairsFontSizes = function (axis) {
            // We need the canvas to calculate font height
            var ctx = this.root.getContext();
            // The trick here is we use the value (properly formatted) from the max threshold.
            // This ensures that any possible value can fit within the space we've set aside.
            // It can be a little ugly sometimes, but the alternative is much worse, where rendering
            // issues appear because we don't redraw non-interactive elements at each update.
            var maxDataPoint = axis.scale.threshMax;
            // Default text width/height just in case.
            var textWidth = 0;
            var textHeight = 0;
            // Iterate the series list, accumulating the offsets as we go
            for (var seriesID in this.children) {
                var seriesObject = this.children[seriesID];
                if (isSeries(seriesObject)) {
                    // We need the data set to determine formatting, frequency, etc...
                    var dataSet = seriesObject.getData(axis.dimension);
                    // And this guy will actually do the formatitng for us.
                    var dataValue = void 0;
                    // If this is a non FDSProperty string, we just need to take the width of the base string.
                    // If not, we need to actually calculate the maximum value. If we don't do this, we won't
                    // resize the plot properly when a non-FDSProperty is inserted.
                    if (!axis.crosshairsLabelText.isOnlyText()) {
                        dataValue = axis.crosshairsLabelText.fromValueRT();
                    }
                    else {
                        var valueFormatter = new FDSFormat();
                        var format = dataSet.compiledFormat.fromValue();
                        switch (dataSet.dataType) {
                            case 'INT':
                            case 'INTEGER':
                            case 'FLOAT':
                                valueFormatter.setNumberFormat('#+.2F'); // format
                                dataValue = valueFormatter.formatAsNumber(maxDataPoint);
                                break;
                            case 'DATE':
                                valueFormatter.setDateFormat(format, dataSet.getDateBin());
                                dataValue = valueFormatter.formatAsDate(maxDataPoint);
                                break;
                            case 'TIME':
                                valueFormatter.setTimeFormat(format, dataSet.getTimeBin());
                                dataValue = valueFormatter.formatAsTime(maxDataPoint);
                                break;
                            case 'DATETIME':
                                valueFormatter.setDateTimeFormat(format, dataSet.getDateBin(), dataSet.getTimeBin(), dataSet.needTime);
                                dataValue = valueFormatter.formatAsDateTime(maxDataPoint);
                                break;
                            default:// If we get here, just hope for the best.
                                dataValue = maxDataPoint.toString();
                        }
                    }
                    // Custom font for use in the label
                    var textDimensions = RichTextRenderer.measureRichText(ctx, dataValue, axis.crosshairsLabelFont)[0];
                    // Store width and font for use in textbox sizing
                    textWidth = textDimensions.width;
                    textHeight = textDimensions.height;
                }
            }
            return [textWidth, textHeight];
        };
        FDSPlot.prototype._computePlotRect = function () {
            var _this = this;
            // Start with the base size of the chart
            var x1, y1, x2, y2;
            this.minXFactor = x1 = this._getFactor(1 /* X */, 'min');
            this.minYFactor = y1 = this._getFactor(2 /* Y */, 'min');
            this.maxXFactor = x2 = this._getFactor(1 /* X */, 'max');
            this.maxYFactor = y2 = this._getFactor(2 /* Y */, 'max');
            var plotBaseX1 = x1;
            var plotBaseX2 = x2;
            var plotBaseY1 = y1;
            var plotBaseY2 = y2;
            var plotGripperOffset = PlotDragManager.isPlotDragManagerNeeded(this.root) ? scaleByDevicePixelRatioAndRound(15) : 0;
            // add the margins to the subplot, which is where the actual plot will be drawn
            var subPlotBase = new Rectangle(x1 + this.leftMargin, y1 + this.topMargin, x2 - this.rightMargin - plotGripperOffset, y2 - this.bottomMargin);
            // figure out where the axes are/what space they take up
            var gapAdded = false;
            this.rightAxisWidth = this.leftAxisWidth = this.bottomAxisHeight = this.topAxisHeight = 0;
            // this obj keeps track of if we've seen an axis in any of these 4 positions before
            // the properties match those of subPlotBase for convenience
            var axisSeen = { x1: false, x2: false, y1: false, y2: false };
            var _loop_3 = function (axis) {
                if (!axis.shouldDraw() || this_2.isFullPlotDrawStyle()) {
                    return "continue";
                }
                axis.calculateDimensions();
                var showAxis = axis.axisPosition !== 4;
                var showTicks = axis.ticksPosition !== 4;
                var showLabels = (axis.labelPosition !== 4 /* HIDDEN */) && axis.labeled;
                var showTitle = (axis.titlePosition !== 4 /* HIDDEN */) && axis.titleEnabled;
                var overrideLabels = axis.crosshairsLabelDrawnWithoutAxisLabels;
                var crosshairsLabeled = (axis.labeled || overrideLabels) && axis.crosshairsLabeled &&
                    (axis.labelPosition !== 4 /* HIDDEN */);
                var textWidth = void 0, textHeight = void 0;
                var chlWidthHint, chlHeightHint;
                // General set-up required for crosshair axis labels
                if (crosshairsLabeled) {
                    _a = this_2._computeCrosshairsFontSizes(axis), textWidth = _a[0], textHeight = _a[1];
                    _b = axis.computeAxesLabelsShapeDimensions(textWidth, textHeight), chlWidthHint = _b[0], chlHeightHint = _b[1];
                }
                var titleWidth;
                var titleHeight;
                if (axis.titleEnabled) {
                    var titleText = axis.compiledTitleText.fromValueRT();
                    var dims = RichTextRenderer.measureRichText(this_2.root.getContext(), titleText, axis.titleFont)[0];
                    titleHeight = dims.height + axis.titleOffset;
                    titleWidth = dims.width + axis.titleOffset;
                }
                /*
                   Here we are looping through each series associated with the axis being examined. The intent
                   here is to figure out the amount of room a quicklabel is going to need if drawn on the axis
                   and not on the plot. If the quicklabel width is larger than the expected width of the axis,
                   the axis will need to be expanded to fit it (done using adjForLeftFeature and adjForRightFeature
                   later in this function). However, if the quicklabels are being drawn inside the plot, then the
                   axes don't need to be adjusted, and these values shouldn't be updated.
                */
                var maxLeftQuickLabelWidth = 0;
                var maxRightQuickLabelWidth = 0;
                if (axis.dimension === 2 /* Y */) {
                    var seriesWithQuickLabels = axis.associatedSeries.filter(function (series) { return series.quickLabel; });
                    for (var _i = 0, seriesWithQuickLabels_1 = seriesWithQuickLabels; _i < seriesWithQuickLabels_1.length; _i++) {
                        var series = seriesWithQuickLabels_1[_i];
                        var newWidth = series.getCalculatedQuickLabelWidth();
                        var quickLabelsAreOnRight = (series.quickLabelPosition === 2 /* RIGHT */ ||
                            series.quickLabelPosition === 3 /* LEFTRIGHT */);
                        var rightPositionIsOnAxis = series.quickLabelRightPositionModifier ===
                            3;
                        if (quickLabelsAreOnRight && rightPositionIsOnAxis) {
                            maxRightQuickLabelWidth = newWidth - axis.axisOffset;
                        }
                        var quickLabelsAreOnLeft = (series.quickLabelPosition === 1 /* LEFT */ ||
                            series.quickLabelPosition === 3 /* LEFTRIGHT */);
                        var leftPositionIsOnAxis = series.quickLabelLeftPositionModifier ===
                            3;
                        if (quickLabelsAreOnLeft && leftPositionIsOnAxis) {
                            maxLeftQuickLabelWidth = newWidth - axis.axisOffset;
                        }
                    }
                }
                // #### BEGIN HELPER FUNCTIONS #####
                // These are here to make the calculations below more readable.
                // All of these things are done for all for dimensions + positions (primary or alternate)
                // adjusts subPlotBase and total axis width based on feature
                // edge = the property name on the rect for the edge being adjusted: 'x1','x2','y1',or 'y2'
                // negative = whether the plotbase is being adjusted in a negative direction
                var adjForFeature = function (edge, negative, axisWidth, showFeature, position, width) {
                    var absWidth = width; // save the positive width for later
                    // axes being adjusted in a positive direction are the non-primary ones
                    var correctPos = !(axis.isOnPrimarySide(position));
                    var gap = _this.axisGap;
                    if (negative) {
                        correctPos = !correctPos;
                        width = -width;
                        gap = -gap;
                    }
                    if (showFeature && (correctPos || (position === 2 /* BOTH */))) {
                        subPlotBase[edge] += width;
                        axisWidth += absWidth;
                        if (axisSeen[edge] && !gapAdded) {
                            axisWidth += _this.axisGap;
                            subPlotBase[edge] += gap;
                        }
                        axisSeen[edge] = gapAdded = true;
                    }
                    return axisWidth;
                };
                // adjusts subPlotBase and total axis width based on axis title stuff
                // returns updated axis width/height
                var adjForTitle = function (edge, negative, axisWidth) {
                    var correctPos = !(axis.isOnPrimarySide(axis.titlePosition));
                    if (negative) {
                        correctPos = !correctPos;
                    }
                    if (showTitle && (correctPos || axis.titlePosition === 2 /* BOTH */)) {
                        if (axis.titleAtEnd) {
                            if (negative && axis.titlePosition === 2 /* BOTH */) {
                                // this will get called twice if position is both, and we only want to adjust once
                                // arbitrarily decide to return when it's negative, and adjust when positive
                                return axisWidth;
                            }
                            if (axis.dimension === 2 /* Y */) {
                                if (axis.titleValuePosition === 1 /* MIN */) {
                                    subPlotBase.y2 -= titleHeight;
                                    _this.bottomAxisHeight = _this.bottomAxisHeight + titleHeight;
                                }
                                else {
                                    subPlotBase.y1 += titleHeight;
                                    _this.topAxisHeight = _this.topAxisHeight + titleHeight;
                                }
                            }
                            else {
                                if (axis.titleValuePosition === 1 /* MIN */) {
                                    subPlotBase.x1 += titleWidth;
                                    _this.leftAxisWidth = _this.leftAxisWidth + titleWidth;
                                }
                                else {
                                    subPlotBase.x2 -= titleWidth;
                                    _this.rightAxisWidth = _this.rightAxisWidth + titleWidth;
                                }
                            }
                        }
                        else {
                            if (axis.dimension === 2 /* Y */) {
                                return adjForFeature(edge, negative, axisWidth, showTitle, axis.titlePosition, titleWidth);
                            }
                            else {
                                return adjForFeature(edge, negative, axisWidth, showTitle, axis.titlePosition, titleHeight);
                            }
                        }
                    }
                    return axisWidth;
                };
                var adjForCrosshairLabels = function (edge, negative, axisWidth) {
                    var correctPos = !(axis.isOnPrimarySide(axis.labelPosition));
                    var factor = 1;
                    if (negative) {
                        correctPos = !correctPos;
                        factor = -1;
                    }
                    if (crosshairsLabeled && (correctPos || axis.labelPosition === 2 /* BOTH */)) {
                        // Cumulative width from axis, ticks, and labels, if drawn. We use this to determine
                        // how much deadzone is left for a crosshair label before we need to shrink the plot
                        // Negatively-adjusted axes are primary. This function wants to know if we're alternate.
                        var cumulativeOffset = axis.computeComponentOffsets((!negative));
                        var hint = axis.dimension === 2 /* Y */ ? chlWidthHint : chlHeightHint;
                        var crosshairLabelSum = hint + cumulativeOffset;
                        crosshairLabelSum -= axisWidth;
                        if (crosshairLabelSum > 0) {
                            subPlotBase[edge] += crosshairLabelSum * factor;
                            axisWidth += crosshairLabelSum;
                        }
                        if (axisSeen[edge] && !gapAdded) {
                            axisWidth += _this.axisGap;
                            subPlotBase[edge] += _this.axisGap * factor;
                        }
                        axisSeen[edge] = gapAdded = true;
                    }
                    return axisWidth;
                };
                // #### END HELPER FUNCTIONS #####
                switch (axis.dimension) {
                    case 1 /* X */:
                        var axisHeight = Math.max(axis.axisOffset, 0);
                        var ticksHeight = Math.max(axis.getTickLength() + axis.ticksOffset, 0);
                        var labelHeight = Math.max(axis.scale.maxDimensions.height + axis.scale.minorMaxDimensions.height +
                            axis.labelOffset, 0);
                        // # Bottom Axis Stuff ##
                        gapAdded = false;
                        // save all the stuff that's the same for right features
                        var adjForBottomFeature = adjForFeature.bind(this_2, 'y2', true);
                        this_2.bottomAxisHeight = adjForBottomFeature(this_2.bottomAxisHeight, showAxis, axis.axisPosition, axisHeight);
                        this_2.bottomAxisHeight = adjForBottomFeature(this_2.bottomAxisHeight, showTicks, axis.ticksPosition, ticksHeight);
                        this_2.bottomAxisHeight = adjForBottomFeature(this_2.bottomAxisHeight, showLabels, axis.labelPosition, labelHeight);
                        this_2.bottomAxisHeight = adjForTitle('y2', true, this_2.bottomAxisHeight);
                        this_2.bottomAxisHeight = adjForCrosshairLabels('y2', true, this_2.bottomAxisHeight);
                        // # Top Axis Stuff ##
                        gapAdded = false;
                        // save all the stuff that's the same for right features
                        var adjForTopFeature = adjForFeature.bind(this_2, 'y1', false);
                        this_2.topAxisHeight = adjForTopFeature(this_2.topAxisHeight, showAxis, axis.axisPosition, axisHeight);
                        this_2.topAxisHeight = adjForTopFeature(this_2.topAxisHeight, showTicks, axis.ticksPosition, ticksHeight);
                        this_2.topAxisHeight = adjForTopFeature(this_2.topAxisHeight, showLabels, axis.labelPosition, labelHeight);
                        this_2.topAxisHeight = adjForTitle('y1', false, this_2.topAxisHeight);
                        // crosshairLabels must be last because they depend on total axis width
                        this_2.topAxisHeight = adjForCrosshairLabels('y1', false, this_2.topAxisHeight);
                        break;
                    case 2 /* Y */:
                        var axisWidth = axis.axisOffset;
                        var ticksWidth = axis.getTickLength() + axis.ticksOffset;
                        var labelWidth = axis.scale.maxDimensions.width + axis.scale.minorMaxDimensions.width +
                            axis.labelOffset + axis.labelLeftMargin;
                        // # Right Axis Stuff ##
                        gapAdded = false;
                        // save all the stuff that's the same for right features
                        var adjForRightFeature = adjForFeature.bind(this_2, 'x2', true);
                        this_2.rightAxisWidth = adjForRightFeature(this_2.rightAxisWidth, showAxis, axis.axisPosition, axisWidth);
                        this_2.rightAxisWidth = adjForRightFeature(this_2.rightAxisWidth, showTicks, axis.ticksPosition, ticksWidth);
                        this_2.rightAxisWidth = adjForRightFeature(this_2.rightAxisWidth, showLabels, axis.labelPosition, Math.max(labelWidth, maxRightQuickLabelWidth));
                        this_2.rightAxisWidth = adjForTitle('x2', true, this_2.rightAxisWidth);
                        // crosshairLabels must be last because they depend on total axis width
                        this_2.rightAxisWidth = adjForCrosshairLabels('x2', true, this_2.rightAxisWidth);
                        // # Left Axis Stuff ##
                        gapAdded = false;
                        // save all the stuff that's the same for left features
                        var adjForLeftFeature = adjForFeature.bind(this_2, 'x1', false);
                        this_2.leftAxisWidth = adjForLeftFeature(this_2.leftAxisWidth, showAxis, axis.axisPosition, axisWidth);
                        this_2.leftAxisWidth = adjForLeftFeature(this_2.leftAxisWidth, showTicks, axis.ticksPosition, ticksWidth);
                        this_2.leftAxisWidth = adjForLeftFeature(this_2.leftAxisWidth, showLabels, axis.labelPosition, Math.max(labelWidth, maxLeftQuickLabelWidth));
                        this_2.leftAxisWidth = adjForTitle('x1', false, this_2.leftAxisWidth);
                        // crosshairLabels must be last because they depend on total axis width
                        this_2.leftAxisWidth = adjForCrosshairLabels('x1', false, this_2.leftAxisWidth);
                        break;
                }
                var _a, _b;
            };
            var this_2 = this;
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                _loop_3(axis);
            }
            // adjust plot for quicklabels
            // make sure the total axis width fits the on-axis quicklabels
            if (this.rightAxisWidth < this.rightQuickLabelOffsets.onAxis) {
                var diff = this.rightQuickLabelOffsets.onAxis - this.rightAxisWidth;
                subPlotBase.x2 -= diff;
                this.rightAxisWidth = this.rightQuickLabelOffsets.onAxis;
            }
            // also add space for additional labels before and after the axes
            var rightOffsets = this.rightQuickLabelOffsets.beforeAxes + this.rightQuickLabelOffsets.outside;
            subPlotBase.x2 -= rightOffsets;
            this.rightAxisWidth += rightOffsets;
            // adjust for quicklabels
            // make sure the axis width fits the on-axis quicklabels
            if (this.leftAxisWidth < this.leftQuickLabelOffsets.onAxis) {
                var diff = this.leftQuickLabelOffsets.onAxis - this.leftAxisWidth;
                subPlotBase.x1 += diff;
                this.leftAxisWidth = this.leftQuickLabelOffsets.onAxis;
            }
            // also add space for additional labels before and after the axis
            var leftOffsets = this.leftQuickLabelOffsets.outside + this.leftQuickLabelOffsets.beforeAxes;
            subPlotBase.x1 += leftOffsets;
            this.leftAxisWidth += leftOffsets;
            subPlotBase.x1 += this.leftPlotMargin;
            subPlotBase.x2 -= this.rightPlotMargin;
            // deal with centering the plot if necessary
            var eqLRmargins = this.attributeSet.get('EquateLRMargins');
            if (eqLRmargins) {
                var leftMargin = subPlotBase.x1 - plotBaseX1;
                var rightMargin = plotBaseX2 - subPlotBase.x2;
                var marginDiff = Math.abs(leftMargin - rightMargin);
                if (leftMargin > rightMargin) {
                    subPlotBase.x2 -= marginDiff;
                }
                else {
                    subPlotBase.x1 += marginDiff;
                }
            }
            // error checking - make sure the plot isn't out of bounds or in a bad order
            if (subPlotBase.x1 < x1) {
                subPlotBase.x1 = x1;
            }
            if (subPlotBase.x1 > x2) {
                subPlotBase.x1 = x2;
            }
            if (subPlotBase.x2 < x1) {
                subPlotBase.x2 = x1;
            }
            if (subPlotBase.x2 > x2) {
                subPlotBase.x2 = x2;
            }
            // desired behavior for margins - if xs or ys are backwards, collapse them
            if (subPlotBase.x2 < subPlotBase.x1) {
                // eqLRmargins means they should collapse to the middle
                if (eqLRmargins) {
                    var mid = subPlotBase.x1 - subPlotBase.x2;
                    // add to X2 since it's smaller (since they're backwards)
                    var midpt = subPlotBase.x2 + (~~(mid / 2));
                    subPlotBase.x1 = subPlotBase.x2 = midpt;
                }
                else {
                    subPlotBase.x1 = subPlotBase.x2;
                }
            }
            if (subPlotBase.y2 < subPlotBase.y1) {
                subPlotBase.y1 = subPlotBase.y2;
            }
            subPlotBase.y1 = subPlotBase.y1 + this._cumulativeHeaderHeight + this.topPlotMargin;
            subPlotBase.y2 = subPlotBase.y2 - this._footerHeight - this.bottomPlotMargin;
            if (subPlotBase.y1 < y1) {
                subPlotBase.y1 = y1;
            }
            if (subPlotBase.y2 < y1) {
                subPlotBase.y2 = y1;
            }
            if (subPlotBase.y1 > y2) {
                subPlotBase.y1 = y2;
            }
            if (subPlotBase.y2 > y2) {
                subPlotBase.y2 = y2;
            }
            // quickie last minute error checking
            // make sure it's not backwards
            if (this.plotRect.x1 > this.plotRect.x2) {
                this.plotRect.x1 = this.plotRect.x2;
            }
            // make sure all x and y limits are within the original bounds
            if (this.plotRect.x1 < x1) {
                this.plotRect.x1 = x1;
            }
            if (this.plotRect.x2 < x1) {
                this.plotRect.x2 = x1;
            }
            if (this.plotRect.x1 > x2) {
                this.plotRect.x1 = x2;
            }
            if (this.plotRect.x2 > x2) {
                this.plotRect.x2 = x2;
            }
            if (this.plotRect.y1 < y1) {
                this.plotRect.y1 = y1;
            }
            if (this.plotRect.y2 < y1) {
                this.plotRect.y2 = y1;
            }
            if (this.plotRect.y1 > y2) {
                this.plotRect.y1 = y2;
            }
            if (this.plotRect.y2 > y2) {
                this.plotRect.y2 = y2;
            }
            this.plotRect.setRect(subPlotBase.x1, subPlotBase.y1, subPlotBase.x2, subPlotBase.y2);
        };
        FDSPlot.prototype._computePlotRelatedThings = function (x1, x2, y, plotRectSet) {
            var _a = this._computeOverhang(), leftOverhang = _a[0], bottomOverhang = _a[1], rightOverhang = _a[2], topOverhang = _a[3];
            this._computeLegendPosition(plotRectSet, leftOverhang, this._allowTopOverhang ? topOverhang : 0, rightOverhang);
            this._computeHeaderDimensions(x1, x2, y);
            this._computeFooterDimensions(x1, x2, y);
        };
        FDSPlot.prototype.isFullPlotDrawStyle = function () {
            if (isFullPlotDrawStyle(this.drawStyle)) {
                return true;
            }
            else {
                return _$1.every(this.seriesList, function (series) { return isFullPlotDrawStyle(series.drawStyle); });
            }
        };
        // returns [xAxisLeftOverhang, yAxisBottomOverhang, xAxisRightOverhang, yAxisTopOverhang]
        FDSPlot.prototype._computeOverhang = function () {
            if (this.isFullPlotDrawStyle()) {
                return [0, 0, 0, 0];
            }
            var yAxisTopOverhang = 0;
            var yAxisBottomOverhang = 0;
            var xAxisRightOverhang = 0;
            var xAxisLeftOverhang = 0;
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (!axis.shouldDraw()) {
                    continue;
                }
                var _b = axis.getLabelOverhang(this), startOverhang = _b[0], endOverhang = _b[1];
                // check to make sure the axis overhang actually exists (ie, there are multiple labels etc)
                if (startOverhang || endOverhang) {
                    if (axis.dimension === 1 /* X */) {
                        xAxisLeftOverhang += startOverhang;
                        xAxisRightOverhang += endOverhang;
                    }
                    else {
                        yAxisBottomOverhang += startOverhang;
                        yAxisTopOverhang += endOverhang;
                    }
                }
            }
            return [xAxisLeftOverhang, yAxisBottomOverhang, xAxisRightOverhang, yAxisTopOverhang];
        };
        FDSPlot.prototype._computeLegendPosition = function (plotRectSet, leftOverhang, topOverhang, rightOverhang) {
            // Generate the legend
            var activeLegend = this.isActiveLegendHeatmap() ? this.heatmapLegend : this.legend;
            var oldLegendHeight = activeLegend.getCanvasDimensions()[1];
            var _a = activeLegend.renderToCanvas() ? activeLegend.getCanvasDimensions() : [0, 0], legendWidth = _a[0], legendHeight = _a[1];
            var LP = activeLegend.legendProperties;
            if (!plotRectSet) {
                // Add the integral axis overhang to `@plotRect`
                // we only want to bump the left and right sides of the plot
                // if the overhang is larger than the current axis width
                this.plotRect.x1 += (Math.max(leftOverhang - this.leftAxisWidth, 0));
                this.plotRect.y1 += topOverhang;
                this.plotRect.x2 -= (Math.max(rightOverhang - this.rightAxisWidth, 0));
            }
            if (LP instanceof LegendProperties) {
                // which attribute takes priority depends on the vertical alignment
                if (LP.axisPosition === 3 /* MIDDLE */) {
                    // when it's in the middle vertically, the base position attribute takes priority
                    switch (LP.basePosition) {
                        case 1 /* RIGHT */:
                            // bump plot over
                            var overlap = (legendWidth -
                                (this.maxXFactor - this.rightMargin - this.rightPlotMargin - this.plotRect.x2)) +
                                this.rightAxisWidth;
                            if (overlap > 0 && !plotRectSet) {
                                this.plotRect.x2 -= overlap;
                            }
                            this.legendRect.x2 = this.maxXFactor - this.rightMargin;
                            this.legendRect.x1 = this.legendRect.x2 - legendWidth;
                            break;
                        case 2 /* CENTER */:
                            switch (LP.position) {
                                case 1 /* RIGHT */:
                                    // put legend up against the edge of the plot
                                    this.legendRect.x2 = this.plotRect.x2;
                                    this.legendRect.x1 = this.legendRect.x2 - legendWidth;
                                    break;
                                case 2 /* CENTER */:
                                    var midpt = this.plotRect.x1 + ((this.plotRect.x2 - this.plotRect.x1) / 2);
                                    this.legendRect.x1 = ~~(midpt - (legendWidth / 2));
                                    this.legendRect.x2 = ~~(midpt + (legendWidth / 2));
                                    break;
                                default:// FCPosition.LEFT
                                    // put legend up against the edge of the plot
                                    this.legendRect.x1 = this.plotRect.x1;
                                    this.legendRect.x2 = this.legendRect.x1 + legendWidth;
                            }
                            break;
                        default:// FCPosition.LEFT
                            // bump plot over
                            overlap = (legendWidth - (this.plotRect.x1 - this.minXFactor - this.leftMargin - this.leftPlotMargin)) +
                                this.leftAxisWidth;
                            if (overlap > 0 && !plotRectSet) {
                                this.plotRect.x1 += overlap;
                            }
                            this.legendRect.x1 = this.minXFactor + this.leftMargin;
                            this.legendRect.x2 = this.legendRect.x1 + legendWidth;
                    }
                }
                else {
                    // when it's on top or bottom of plot, position attribute takes priority
                    switch (LP.position) {
                        case 2 /* CENTER */:
                            var midpt = this.plotRect.x1 + ((this.plotRect.x2 - this.plotRect.x1) / 2);
                            this.legendRect.x1 = ~~(midpt - (legendWidth / 2));
                            this.legendRect.x2 = ~~(midpt + (legendWidth / 2));
                            break;
                        case 1 /* RIGHT */:
                            if (LP.basePosition === 2 /* CENTER */) {
                                // put legend up against the edge of the plot
                                this.legendRect.x2 = this.plotRect.x2;
                                this.legendRect.x1 = this.legendRect.x2 - legendWidth;
                            }
                            else {
                                // put legend along the chart edge
                                this.legendRect.x2 = this.maxXFactor - this.rightMargin;
                                this.legendRect.x1 = this.legendRect.x2 - legendWidth;
                            }
                            break;
                        default:// FCPosition.LEFT
                            if (LP.basePosition === 2 /* CENTER */) {
                                // put legend up against the edge of the plot
                                this.legendRect.x1 = this.plotRect.x1;
                                this.legendRect.x2 = this.legendRect.x1 + legendWidth;
                            }
                            else {
                                // put legend along chart edge
                                this.legendRect.x1 = this.minXFactor + this.leftMargin;
                                this.legendRect.x2 = this.legendRect.x1 + legendWidth;
                            }
                    }
                }
                // offset adjustments
                this.legendRect.x1 += LP.xOffset;
                this.legendRect.x2 += LP.xOffset;
            }
            else {
                // Heatmap Legend
                switch (LP.position) {
                    case 1 /* TOP_RIGHT */:
                        // put legend up against the edge of the plot
                        this.legendRect.x2 = this.plotRect.x2;
                        this.legendRect.x1 = this.legendRect.x2 - legendWidth;
                        break;
                    case 0 /* BELOW */:
                    default:
                        var midpt = this.plotRect.x1 + ((this.plotRect.x2 - this.plotRect.x1) / 2);
                        this.legendRect.x1 = ~~(midpt - (legendWidth / 2));
                        this.legendRect.x2 = ~~(midpt + (legendWidth / 2));
                        break;
                }
            }
            // when plotRect has been adjusted externally by the grouping, we check whether or not the legend's height
            // changed
            // when we called legend.renderToCanvas. If so, then we need to re-adjust the legends vertical position with the
            // new height. Otherwise, we are done.
            if (plotRectSet) {
                var newLegendHeight = activeLegend.getCanvasDimensions()[1];
                if (newLegendHeight !== oldLegendHeight) {
                    this._adjustLegendVerticalCoordinates(LP, oldLegendHeight, newLegendHeight);
                }
                return;
            }
            if (LP instanceof LegendProperties) {
                // vertical positioning
                switch (LP.axisPosition) {
                    case 1 /* ALTERNATE */:// aka bottom
                        // bump the plot up and put the legend underneath it
                        this.plotRect.y2 -= legendHeight;
                        this.legendRect.y1 = this.plotRect.y2 + this.bottomAxisHeight + this.bottomPlotMargin;
                        this.legendRect.y2 = this.legendRect.y1 + legendHeight;
                        break;
                    case 3 /* MIDDLE */:
                        switch (LP.vPosition) {
                            case 0 /* BOTTOM */:
                                this.legendRect.y2 = this.plotRect.y2;
                                this.legendRect.y1 = this.legendRect.y2 - legendHeight;
                                break;
                            case 2 /* CENTER */:
                                var midpt = this.plotRect.y1 + ((this.plotRect.y2 - this.plotRect.y1) / 2);
                                this.legendRect.y1 = ~~(midpt - (legendHeight / 2));
                                this.legendRect.y2 = ~~(midpt + (legendHeight / 2));
                                break;
                            default:// FCVPosition.TOP
                                this.legendRect.y1 = this.plotRect.y1;
                                this.legendRect.y2 = this.legendRect.y1 + legendHeight;
                        }
                        break;
                    default:// AxisPosition.NORMAL aka top
                        // bump plot down and put legend above it
                        this.plotRect.y1 += legendHeight;
                        this.legendRect.y2 = this.plotRect.y1 - topOverhang - this.topAxisHeight - this.topPlotMargin;
                        this.legendRect.y1 = this.legendRect.y2 - legendHeight;
                }
                // y offset bumps legend up
                this.legendRect.y1 -= LP.yOffset;
                this.legendRect.y2 -= LP.yOffset;
            }
            else {
                // Heatmap Legend
                switch (LP.position) {
                    case 1 /* TOP_RIGHT */:
                        // bump plot down and put legend above it
                        this.plotRect.y1 += legendHeight;
                        this.legendRect.y2 = this.plotRect.y1 - topOverhang - this.topAxisHeight - this.topPlotMargin;
                        this.legendRect.y1 = this.legendRect.y2 - legendHeight;
                        break;
                    case 0 /* BELOW */:
                    default:
                        // bump the plot up and put the legend underneath it
                        this.plotRect.y2 -= legendHeight;
                        this.legendRect.y1 = this.plotRect.y2 + this.bottomAxisHeight + this.bottomPlotMargin;
                        this.legendRect.y2 = this.legendRect.y1 + legendHeight;
                        break;
                }
            }
        };
        FDSPlot.prototype._adjustLegendVerticalCoordinates = function (legendProperties, oldLegendHeight, legendHeight) {
            var legendHeightDifference = legendHeight - oldLegendHeight;
            if (legendProperties instanceof LegendProperties) {
                switch (legendProperties.axisPosition) {
                    case 1 /* ALTERNATE */:// a.k.a Bottom.
                        this.plotRect.y2 -= legendHeightDifference;
                        this.legendRect.y1 -= legendHeightDifference;
                        this.legendRect.y2 = this.legendRect.y1 + legendHeight;
                        break;
                    case 3 /* MIDDLE */:
                        switch (legendProperties.vPosition) {
                            case 0 /* BOTTOM */:
                                this.legendRect.y1 -= legendHeightDifference;
                                break;
                            case 2 /* CENTER */:
                                this.legendRect.y1 = ~~(this.legendRect.y1 - legendHeightDifference / 2);
                                this.legendRect.y2 = ~~(this.legendRect.y2 - legendHeightDifference / 2);
                                break;
                            default:// We default to FCVPosition.TOP.
                                this.legendRect.y2 += legendHeightDifference;
                        }
                        break;
                    default:// We default to AxisPosition.Normal a.k.a. Top
                        this.plotRect.y1 += legendHeightDifference;
                        this.legendRect.y2 += legendHeightDifference;
                        this.legendRect.y1 = this.legendRect.y2 - legendHeight;
                }
            }
            else {
                // Heatmap Legend
                switch (legendProperties.position) {
                    case 1 /* TOP_RIGHT */:
                        this.plotRect.y1 += legendHeightDifference;
                        this.legendRect.y2 += legendHeightDifference;
                        this.legendRect.y1 = this.legendRect.y2 - legendHeight;
                        break;
                    case 0 /* BELOW */:
                    default:
                        this.plotRect.y2 -= legendHeightDifference;
                        this.legendRect.y1 -= legendHeightDifference;
                        this.legendRect.y2 = this.legendRect.y1 + legendHeight;
                        break;
                }
            }
        };
        FDSPlot.prototype._computeHeaderDimensions = function (plotX1, plotX2, plotY1) {
            this.headerRect.x1 = plotX1 + this.leftMargin;
            this.headerRect.y1 = plotY1 + this.topMargin;
            this.headerRect.x2 = plotX2 - this.rightMargin;
            this.headerRect.y2 = this.headerRect.y1 + this._cumulativeHeaderHeight;
        };
        FDSPlot.prototype._computeFooterDimensions = function (plotX1, plotX2, plotY2) {
            this.footerRect.x1 = plotX1 + this.leftMargin;
            this.footerRect.y1 = plotY2 + this.bottomMargin;
            this.footerRect.x2 = plotX2 - this.rightMargin;
            this.footerRect.y2 = this.footerRect.y1 + this._footerHeight;
        };
        // Compute the center of the plot area
        //
        // @return [Float, Float, Float, Float] width, height, centerX, centerY
        FDSPlot.prototype.computeEffectiveCenter = function () {
            // note: on the PC side this depends on the m_minMargin and m_maxMargin variables
            // we don't have those, so I'm using their default values of 0.05 instead
            var min$$1 = this.subPlotFromNDC(0, 1 /* X */);
            var max$$1 = this.subPlotFromNDC(1, 1 /* X */);
            var margins = (max$$1 - min$$1) * 0.1; // two margins
            var width = max$$1 - min$$1 - margins;
            var centerX = (min$$1 + width + margins) / 2;
            min$$1 = this.subPlotFromNDC(1, 2 /* Y */);
            max$$1 = this.subPlotFromNDC(0, 2 /* Y */);
            margins = (max$$1 - min$$1) * 0.1; // two margins
            var height = max$$1 - min$$1 - margins;
            var centerY = (min$$1 + height + margins) / 2;
            return [width, height, centerX, centerY];
        };
        FDSPlot.prototype.getXYBins = function () {
            var nYBins = 0;
            var nXBins = 0;
            var index = 0;
            var useDelta = false;
            if (this.attributeSet.get('BinMode') === '2D') {
                useDelta = true;
                // First valid series in the list
                var firstSeries = undefined;
                // Is always the previous series (except for the first real iteration).
                var prevSeries = undefined;
                for (var seriesID in this.seriesList) {
                    var seriesObject = this.seriesList[seriesID];
                    if (seriesObject.attributeSet.isInheritedDefault('SeriesBin') && seriesObject.visible) {
                        // We need to know the first series during calculations later. We also need a valid series
                        // to start with as the "previous" series.
                        if (firstSeries === undefined) {
                            firstSeries = seriesObject;
                            prevSeries = seriesObject;
                        }
                        var ds = seriesObject.getEffectiveDrawStyle();
                        if (isHorizonalBarType(ds)) {
                            if (seriesObject.isStacked) {
                                seriesObject.barNumber = nYBins;
                            }
                            else {
                                if (seriesObject !== firstSeries && prevSeries.isStacked) {
                                    nYBins += 1;
                                }
                                seriesObject.barNumber = nYBins++;
                            }
                        }
                        else if (isVerticalBarType(ds)) {
                            if (seriesObject.isStacked) {
                                seriesObject.barNumber = nXBins;
                            }
                            else {
                                if (seriesObject !== firstSeries && prevSeries.isStacked) {
                                    nXBins += 1;
                                }
                                seriesObject.barNumber = nXBins++;
                            }
                        }
                        else {
                            var effectiveDS = prevSeries.getEffectiveDrawStyle();
                            if (prevSeries.isStacked && isStackable(effectiveDS)) {
                                nXBins += 1;
                                nYBins += 1;
                            }
                        }
                        prevSeries = seriesObject;
                    }
                }
                // By this point, prevSeries will always be the last valid series in the list.
                if (prevSeries !== undefined && prevSeries.isStacked) {
                    nXBins += 1;
                    nYBins += 1;
                }
                for (var seriesID in this.seriesList) {
                    var seriesObject = this.seriesList[seriesID];
                    if (!seriesObject.attributeSet.isInheritedDefault('SeriesBin') && seriesObject.visible) {
                        index = seriesObject.attributeSet.get('SeriesBin');
                        seriesObject.barNumber = index;
                        var effectiveDS = seriesObject.getEffectiveDrawStyle();
                        if (isHorizonalBarType(effectiveDS) && (index >= nYBins)) {
                            nYBins = index + 1;
                        }
                        else if (isVerticalBarType(effectiveDS) && (index >= nXBins)) {
                            nXBins = index + 1;
                        }
                    }
                }
            }
            if (nYBins <= 0) {
                nYBins = 1;
            }
            if (nXBins <= 0) {
                nXBins = 1;
            }
            return [nXBins, nYBins, useDelta];
        };
        // This functions simlar to the PC-side `subPlot[dimension]` functions, only
        // the dimension is explicitly passed as an argument.
        // This includes the quicklabel offsets when calculating position
        FDSPlot.prototype.subPlotFromNDC = function (ndc, dimension) {
            if ((this.leftQuickLabelOffsets != null)
                && (this.rightQuickLabelOffsets != null)
                && (dimension === 1 /* X */)
                && (this.leftQuickLabelOffsets.inside !== 0 || this.rightQuickLabelOffsets.inside !== 0)) {
                var actualPosition = this.plotRect.fromNDC(ndc, dimension);
                var totalPlotWidth = this.plotRect.getWidth() - this.leftQuickLabelOffsets.inside -
                    this.rightQuickLabelOffsets.inside;
                return (actualPosition * (totalPlotWidth / this.plotRect.getWidth())) + this.leftQuickLabelOffsets.inside;
            }
            else {
                return this.plotRect.fromNDC(ndc, dimension);
            }
        };
        FDSPlot.prototype.plotFromNDC = function (ndc, dimension) {
            switch (dimension) {
                case 1 /* X */:
                    return this.plotRect.x1 + this.subPlotFromNDC(ndc, dimension);
                case 2 /* Y */:
                    return this.plotRect.y1 + this.subPlotFromNDC(ndc, dimension);
            }
            return 0;
        };
        FDSPlot.prototype.normSubPlot = function (pt, dimension, isChartNDC) {
            if (isChartNDC === void 0) { isChartNDC = true; }
            if ((this.leftQuickLabelOffsets != null)
                && (this.rightQuickLabelOffsets != null)
                && (dimension === 1 /* X */)
                && (this.leftQuickLabelOffsets.inside !== 0 || this.rightQuickLabelOffsets.inside !== 0)) {
                var totalPlotWidth = this.plotRect.getWidth() - this.leftQuickLabelOffsets.inside -
                    this.rightQuickLabelOffsets.inside;
                var insideX1 = this.plotRect.x1 + this.leftQuickLabelOffsets.inside;
                if (!isChartNDC) {
                    pt = pt + this.plotRect.x1;
                }
                return (pt - insideX1) / totalPlotWidth;
            }
            if (dimension === 1 /* X */) {
                // normPlot assumes our point is in chart ndc, but this could be plot ndc
                if (!isChartNDC) {
                    pt = pt + this.plotRect.x1;
                }
                return this._normPlotX(pt);
            }
            else {
                if (!isChartNDC) {
                    pt = pt + this.plotRect.y1;
                }
                return this._normPlotY(pt);
            }
        };
        FDSPlot.prototype._normPlotX = function (pt) {
            return (pt - this.plotRect.x1) / this.plotRect.getWidth();
        };
        FDSPlot.prototype._normPlotY = function (pt) {
            return 1 - ((pt - this.plotRect.y1) / this.plotRect.getHeight());
        };
        FDSPlot.prototype.getPlotFactor = function (dimension, minmax) {
            return this.getAxisByDimension(dimension)._getCombinedPlotFactor(minmax);
        };
        FDSPlot.prototype.getXYFactors = function () {
            if (this.attributeSet.isDirty()) {
                return {
                    minXFactor: this._getFactor(1 /* X */, 'min'),
                    minYFactor: this._getFactor(2 /* Y */, 'min'),
                    maxXFactor: this._getFactor(1 /* X */, 'max'),
                    maxYFactor: this._getFactor(2 /* Y */, 'max'),
                };
            }
            else {
                return {
                    minXFactor: this.minXFactor,
                    minYFactor: this.minYFactor,
                    maxXFactor: this.maxXFactor,
                    maxYFactor: this.maxYFactor,
                };
            }
        };
        // this function returns the min or max dimension of the plot in pixels
        // NOTE: any changes to this probably need to be made in both the DIM.X and
        // DIM.Y sections, so make sure you're making all necessary changes!
        FDSPlot.prototype._getFactor = function (dimension, minmax) {
            var maxmin = minmax === 'min' ? 'max' : 'min';
            var f;
            var opp;
            switch (dimension) {
                case 1 /* X */:
                    f = this.attributeSet.get(minmax + 'XFactor');
                    if (f < 0) {
                        f = 0;
                    }
                    else if (f <= 1) {
                        f = Math.round(this.root.chartSubRect.getWidth() * f);
                    }
                    else if (f > this.root.chartSubRect.getWidth()) {
                        f = this.root.chartSubRect.getWidth();
                    }
                    // compare f to the opposite attribute and switch if opp is smaller/bigger
                    opp = this.attributeSet.get(maxmin + 'XFactor');
                    if (opp < 0) {
                        opp = 0;
                    }
                    else if (opp <= 1) {
                        opp = Math.round(opp * this.root.chartSubRect.getWidth());
                    }
                    else if (opp > this.root.chartSubRect.getWidth()) {
                        opp = this.root.chartSubRect.getWidth();
                    }
                    if ((f > opp && minmax === 'min') || (f < opp && minmax === 'max')) {
                        f = opp;
                    }
                    return f;
                case 2 /* Y */:
                    // since Y axis is flipped, get opposite factor and then subtract from 1
                    f = this.attributeSet.get(maxmin + 'YFactor');
                    if (f < 0) {
                        f = 0;
                    }
                    else if (f <= 1) {
                        f = Math.round(this.root.chartSubRect.getHeight() * f);
                    }
                    else if (f > this.root.chartSubRect.getHeight()) {
                        f = this.root.chartSubRect.getHeight();
                    }
                    // compare f to the specified factor (since Y is flipped)
                    // and switch if opp is bigger/smaller
                    opp = this.attributeSet.get(minmax + 'YFactor');
                    if (opp > 0 && opp <= 1) {
                        opp = Math.round(opp * this.root.chartSubRect.getHeight());
                    }
                    if (opp > this.root.chartSubRect.getHeight()) {
                        opp = this.root.chartSubRect.getHeight();
                    }
                    if ((f < opp && minmax === 'min') || (f > opp && minmax === 'max')) {
                        f = opp;
                    }
                    return this.root.chartRect.getHeight() - f - (this.root.footerRect.getHeight());
            }
            return 0;
        };
        FDSPlot.prototype.sortSeriesInterval = function () {
            if (this.seriesInterval.length !== 0) {
                this.seriesInterval.sort(function (a, b) {
                    if (a.first < b.first) {
                        return -1;
                    }
                    else if (a.first > b.first) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                });
            }
        };
        FDSPlot.prototype.getStyleObjectName = function () {
            if (this.isStyleObject) {
                return 'FDSChart';
            }
            else {
                return 'FC_PLOT';
            }
        };
        FDSPlot.prototype.getObjectTypeName = function () {
            return 'FDSPlot';
        };
        FDSPlot.prototype.getChildList = function () {
            var childList = {};
            for (var id in this.children) {
                var child = this.children[id];
                childList[id] = child;
            }
            return childList;
        };
        FDSPlot.prototype.pointInPlot = function (point) {
            return this.plotRect.hit(point);
        };
        FDSPlot.prototype.isPointInSubPlot = function (point) {
            return this.isPointInSubPlotX(point) && this._isPointInSubPlotY(point);
        };
        FDSPlot.prototype._isPointInSubPlotY = function (point) {
            var subRect = this.plotRect.copy();
            subRect.y1 = subRect.y1 + (this.getPlotFactor(2 /* Y */, 'min') * this.plotRect.getHeight());
            subRect.y2 = subRect.y2 - ((1 - this.getPlotFactor(2 /* Y */, 'max')) * this.plotRect.getHeight());
            return subRect.y1 <= point.y && point.y <= subRect.y2;
        };
        FDSPlot.prototype.isPointInSubPlotX = function (point) {
            var subRect = this.plotRect.copy();
            subRect.x1 = subRect.x1 + ((this.getPlotFactor(1 /* X */, 'min')) * this.plotRect.getWidth());
            subRect.x2 = subRect.x2 - ((1 - this.getPlotFactor(1 /* X */, 'max')) * this.plotRect.getWidth());
            return subRect.x1 <= point.x && point.x <= subRect.x2;
        };
        FDSPlot.prototype.getPixelLocationFromDataXY = function (xPt, yPt, series) {
            return new Point((this._getPixelLocationFromData(1 /* X */, xPt, series)), (this._getPixelLocationFromData(2 /* Y */, yPt, series)));
        };
        FDSPlot.prototype._getPixelLocationFromData = function (dim, pt, series) {
            if (!(dim === 1 /* X */ || dim === 2 /* Y */)) {
                return NAN;
            }
            var subPlotPixelPoint = this.subPlotFromNDC(series.getDataPtNDC(dim, pt), dim);
            return subPlotPixelPoint + (dim === 1 /* X */ ? this.plotRect.x1 : this.plotRect.y1);
        };
        FDSPlot.prototype.hitTest = function (x, y, pick$$1, hitShape, mustHitData) {
            var ret;
            if (this._isChartVisible()) {
                var tip = '';
                if (this._selectSubObject(x, y, pick$$1)) {
                    pick$$1.setLevel(2, this.id);
                    pick$$1.setAccessObject(this.id);
                    tip = this.attributeSet.get('TooltipText');
                    if (tip !== '') {
                        pick$$1.setAccessData(tip);
                    }
                    ret = true;
                }
                if (this._isPlotVisible() && this.pointInPlot(new Point(x, y))) {
                    if (mustHitData && ret) {
                        ret = false;
                    }
                    for (var id in this.seriesList) {
                        var series = this.seriesList[id];
                        if (series.isAnnotation && series.drawBelow) {
                            if (this._seriesHitTest(series, x, y, pick$$1, hitShape, mustHitData)) {
                                ret = true;
                            }
                        }
                    }
                    for (var id in this.seriesList) {
                        var series = this.seriesList[id];
                        if (!series.isAnnotation) {
                            if (this._seriesHitTest(series, x, y, pick$$1, hitShape, mustHitData)) {
                                ret = true;
                            }
                        }
                    }
                    for (var id in this.seriesList) {
                        var series = this.seriesList[id];
                        if (series.isAnnotation && !series.drawBelow) {
                            if (this._seriesHitTest(series, x, y, pick$$1, hitShape, mustHitData)) {
                                ret = true;
                            }
                        }
                    }
                }
            }
            return ret;
        };
        FDSPlot.prototype._seriesHitTest = function (series, x, y, pick$$1, hitShape, mustHitData) {
            var ret = false;
            var tip = '';
            var cursor = '';
            var objectPart = '';
            var childHit = '';
            var seriesHitTestRet;
            // first we will try to hit test the children
            for (var id in series.children) {
                var child = series.children[id];
                if (!isSeries(child)) {
                    continue;
                }
                seriesHitTestRet = child.hitTest(x, y);
                if (seriesHitTestRet) {
                    childHit = child.id;
                    break;
                }
            }
            // if we don't hit a child, test the series itself
            if (!seriesHitTestRet) {
                seriesHitTestRet = series.hitTest(x, y);
            }
            // now we either have a child hit or the series hit itself
            if (seriesHitTestRet) {
                var hit = void 0;
                var hitId = void 0;
                var hitSeries = void 0;
                if (childHit === '') {
                    hitId = series.id;
                    hitSeries = series;
                }
                else {
                    hitId = childHit;
                    hitSeries = this.root.getChild(hitId);
                }
                (hit = seriesHitTestRet.hit, tip = seriesHitTestRet.tip, objectPart = seriesHitTestRet.objectPart, cursor = seriesHitTestRet.cursor);
                pick$$1.setLevel(2, this.id);
                pick$$1.setLevel(3, hitId);
                pick$$1.setAccessObject(hitId);
                pick$$1.setAccessSubObject(hit);
                pick$$1.setAccessDrilldown('');
                pick$$1.setAccessData('');
                pick$$1.setAccessObjectPart(objectPart);
                if (cursor.length !== 0) {
                    pick$$1.cursor = cursor;
                }
                if (hitSeries.inTips) {
                    if (tip.length === 0) {
                        pick$$1.setAccessData(hitSeries.getTooltipLabel(hit, false));
                    }
                    else {
                        pick$$1.hoverText = tip;
                    }
                    pick$$1.setAccessDrilldown(hitSeries.getData(6 /* HIT */).getStringAt(hit, 0));
                }
                ret = true;
            }
            return ret;
        };
        FDSPlot.prototype._selectSubObject = function (x, y, pick$$1) {
            for (var i = this.hitShapes.length - 1; i >= 0; i--) {
                var shape = this.hitShapes[i];
                if (shape.onHitTest(x, y)) {
                    var hitName = shape.name;
                    if (hitName === 'RichTextHitRect') {
                        pick$$1.setAccessLClickAction(shape.action);
                        pick$$1.cursor = shape.cursor;
                    }
                    else {
                        pick$$1.setAccessSubObject(hitName.toString());
                    }
                    if (shape.hoverText != null) {
                        pick$$1.hoverText = shape.hoverText; // pass it along
                    }
                    return true;
                }
            }
            return false;
        };
        FDSPlot.prototype.setHitList = function () {
            if (this._hitChartAreaIfTransparent || this.chartBGBrush.style !== 1 /* NULL */) {
                // this is the plot background area
                var width = this.maxXFactor - this.minXFactor;
                var height = this.maxYFactor - this.minYFactor;
                var hitRect = new FDSRectangleHitShape(this.minXFactor, this.minYFactor, width, height);
                hitRect.name = 'Chart';
                this.hitShapes.push(hitRect);
            }
            if (this._hitChartAreaIfTransparent || this.plotBGBrush.style !== 1 /* NULL */) {
                var rect = this.plotRect;
                var hitRect = new FDSRectangleHitShape(rect.x1, rect.y1, rect.getWidth(), rect.getHeight());
                hitRect.name = 'Plot';
                this.hitShapes.push(hitRect);
            }
            var activeLegend = this.isActiveLegendHeatmap() ? this.heatmapLegend : this.legend;
            if (activeLegend.legendProperties.visible) {
                var _a = activeLegend.getLegendOffsetsInsideRectangle(this.legendRect), xOff = _a[0], yOff = _a[1];
                var _b = activeLegend.getCanvasDimensions(), legendWidth = _b[0], legendHeight = _b[1];
                var x = this.legendRect.x1 + xOff;
                var y = this.legendRect.y1 + yOff;
                var rect = new FDSRectangleHitShape(x, y, legendWidth, legendHeight);
                rect.name = 'Legend';
                this.hitShapes.push(rect);
            }
            for (var _i = 0, _c = this.storedAxisRects; _i < _c.length; _i++) {
                var _d = _c[_i], text = _d.text, rect = _d.rect, tag = _d.tag;
                var hitRect = new FDSRectangleHitShape(rect);
                hitRect.name = "" + text + tag;
                hitRect.hoverText = rect['hoverText']; // this only applies for labels
                this.hitShapes.push(hitRect);
            }
            for (var _e = 0, _f = this.storedHeaderRects; _e < _f.length; _e++) {
                var rect = _f[_e];
                this.hitShapes.push(rect);
            }
        };
        FDSPlot.prototype.crosshairsXHitTest = function (p, padding) {
            if (padding === void 0) { padding = 0; }
            var xPlotFactorLeft = this.plotRect.x1;
            if (p.x + padding > xPlotFactorLeft && p.x - padding < xPlotFactorLeft + this.plotRect.getWidth()) {
                return true;
            }
            else {
                return false;
            }
        };
        FDSPlot.prototype.crosshairsYHitTest = function (p, padding) {
            if (padding === void 0) { padding = 0; }
            var yPlotFactorTop = this.plotRect.y1;
            if (p.y + padding > yPlotFactorTop && p.y - padding < yPlotFactorTop + this.plotRect.getHeight()) {
                return true;
            }
            else {
                return false;
            }
        };
        FDSPlot.prototype.serialize = function (level) {
            return this._serializeObject('Plot', level);
        };
        // override this function to not print out legend children
        // unlike FDSChart, our legends are their own objects, with their own attributes
        // but we don't print them out in the XML - their attributes are redirected
        // to the plot.
        FDSPlot.prototype._serializeChildren = function () {
            var axes = '';
            var series = '';
            var beforeAxes = '';
            for (var id in this.children) {
                var child = this.children[id];
                if (isLegend(child)) {
                    continue;
                }
                if (isSeries(child)) {
                    series += "<ChildId>" + cleanString(id) + "</ChildId>";
                }
                else if (isAxis(child)) {
                    if (child.serializeFirst) {
                        beforeAxes = beforeAxes + ("<ChildId>" + cleanString(id) + "</ChildId>");
                    }
                    else {
                        axes = axes + ("<ChildId>" + cleanString(id) + "</ChildId>");
                    }
                }
            }
            return "<FDSChildren>" + beforeAxes + axes + series + "</FDSChildren>";
        };
        // Removes the children in the `children` array from being parented to this plot
        //
        // @param children [Array] array containing string IDs of the objects to be removed from this plot's children
        FDSPlot.prototype.clearChildren = function (children) {
            if (!this.root) {
                return [false, 'Invalid root during clearing'];
            }
            var ret = true;
            var errString = '';
            for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                var child = children_2[_i];
                var childObj = this.root.getTypedObject(child, isSeries);
                if (childObj) {
                    if (!this._removeSeries(childObj)) {
                        errString = "Plot " + this.id + " is unable to remove " + child;
                        ret = false;
                    }
                }
                else {
                    errString = "Plot " + this.id + ": Child " + child + " is not a series.";
                    ret = false;
                }
            }
            return [ret, errString];
        };
        FDSPlot.prototype.formatAsWorldSinglePt = function (pt) {
            var axis = this.findAGoodAxis();
            if (axis === 0 /* NONE */) {
                axis = 4 /* Y */;
            }
            var x = this._normPlotX(pt.x);
            var y = this._normPlotY(pt.y);
            var ret = (this._axisPoint(clamp(x, 0, 1), 2 /* X */)).toString();
            ret += " " + this._axisPoint(clamp(y, 0, 1), axis);
            return ret;
        };
        // Converts two points in pixels to points in the appropriate scale's data space
        //
        // @param pt1 [Point] First point
        // @param pt2 [Point] Second point
        // @param preserveSlope [Boolean] whether or not to preserve slope when clamping points to the plotRect
        FDSPlot.prototype.formatAsWorld = function (pt1, pt2, preserveSlope) {
            if (preserveSlope === void 0) { preserveSlope = false; }
            var axis = this.findAGoodAxis();
            if (axis === 0 /* NONE */) {
                axis = 4 /* Y */;
            }
            var x1 = this.normSubPlot(pt1.x, 1 /* X */);
            var y1 = this.normSubPlot(pt1.y, 2 /* Y */);
            var x2 = this.normSubPlot(pt2.x, 1 /* X */);
            var y2 = this.normSubPlot(pt2.y, 2 /* Y */);
            if (preserveSlope) {
                if (x2 !== x1 && y2 !== y1) {
                    // slope is negative because the canvas coordinates are inverted
                    var slope = (y2 - y1) / (x2 - x1);
                    _a = this._slopedClamp(x1, y1, slope), x1 = _a[0], y1 = _a[1];
                    _b = this._slopedClamp(x2, y2, slope), x2 = _b[0], y2 = _b[1];
                }
            }
            var ret = (this._axisPoint(clamp(x1, 0, 1), 2 /* X */)).toString();
            ret += " " + this._axisPoint(clamp(y1, 0, 1), axis);
            ret += " " + this._axisPoint(clamp(x2, 0, 1), 2 /* X */);
            ret += " " + this._axisPoint(clamp(y2, 0, 1), axis);
            return ret;
            var _a, _b;
        };
        // Gets a point in the appropriate axis' scale space
        //
        // @param ndc [Number] the point in a factor of the axis's space (between 0 and 1)
        // @param dataFlag [DataFlags] Which dimension we want to convert this ndc in
        FDSPlot.prototype._axisPoint = function (ndc, dataFlag) {
            return this._getScale(dataFlag).computeValue(this._getScale(dataFlag).applyRevPlotFactorNDC(ndc));
        };
        // Gets a scale with the scale specifier
        //
        // @param scaleSpecifier [DataFlags] The flag specifying which type of scale we want (X, Y, Y2, etc.)
        FDSPlot.prototype._getScale = function (scaleSpecifier) {
            var axis = this.getAxis(scaleSpecifier);
            if (axis) {
                var scale = axis.getScale();
                if (scale == null) {
                    scale = new FDSScale(this.root, axis.id, axis);
                    axis.scale = scale;
                }
                return scale;
            }
            return null;
        };
        // This is to get an axis from the axisList. axisIdent can be either
        // a scaleSpecifier (IDed by the DataFlags) or the axis name. The
        // isSpecifier flag determines whether or not this will be treated
        // as a specifier.
        FDSPlot.prototype.getAxis = function (axisIdent) {
            if (_$1.isString(axisIdent)) {
                return this.getChild(axisIdent);
            }
            else {
                for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                    var axis = _a[_i];
                    if (!axis) {
                        continue;
                    }
                    if (axis.scaleSpecifier === axisIdent) {
                        return axis;
                    }
                }
            }
            return undefined;
        };
        // Finds and returns an axis based on dimension
        FDSPlot.prototype.getAxisByDimension = function (dimension) {
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (!axis) {
                    continue;
                }
                if (axis.dimension === dimension) {
                    return axis;
                }
            }
            return null;
        };
        // Tries to find a good choice of axis based on what series this plot has
        // in the following order 'Y', 'Y2', 'Y3', 'Y4'
        //
        // @return [DataFlags] the specifier of our `good` axis
        FDSPlot.prototype.findAGoodAxis = function () {
            var goodAxis = null;
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                if (axis.dimension === 2 /* Y */) {
                    var numberOfRealSeries = 0;
                    for (var id in this.seriesList) {
                        var series = this.seriesList[id];
                        if (!series.isAnnotation) {
                            if (this._useSeriesForAdjust(series, axis)) {
                                if (series.adjustAxes) {
                                    numberOfRealSeries++;
                                }
                            }
                        }
                        if (!goodAxis && numberOfRealSeries > 0) {
                            goodAxis = axis;
                        }
                    }
                }
            }
            if (goodAxis) {
                return goodAxis.scaleSpecifier;
            }
            return 0 /* NONE */;
        };
        // Determines if the series is used for adjusting the inputted axis
        //
        // @param series [FDSSeries] The series we are checking
        // @param axis [FDSAxis] the axis we want to check if the series adjusts
        FDSPlot.prototype._useSeriesForAdjust = function (series, axis) {
            if (!series || !axis) {
                return false;
            }
            var seriesAffectsScales = true;
            var plot = series.getPlotParent();
            if (plot) {
                seriesAffectsScales = !plot._axisResetOnDataChange || series.visible;
            }
            var dimension = axis.dimension;
            return (series.getAxis(dimension) === axis) && seriesAffectsScales;
        };
        // Clamps the x,y points between 0 and 1. The clamped values will retain the same inputted slope
        //
        // @param x [Number] ndc of the x-coordinate
        // @param y [Number] ndc of the y-coordinate
        // @param slope [Number] slope to retain when clamping these x and y values
        // @return [Array] Array containing the x,y coordinates of the sloped clamp point
        FDSPlot.prototype._slopedClamp = function (x, y, slope) {
            if (x < 0) {
                y += slope * -x;
            }
            else if (x > 1) {
                y += slope * (1 - x);
            }
            if (slope !== 0) {
                if (y < 0) {
                    x += (-y) / slope;
                }
                else if (y > 1) {
                    x += (1 - y) / slope;
                }
            }
            return [x, y];
        };
        // clears all of the children and the @seriesList from the plot
        FDSPlot.prototype.clear = function () {
            _super.prototype.clear.call(this);
            this.seriesList = {};
            this.legend.seriesArray = [];
            if (this.heatmapLegend) {
                this.heatmapLegend = undefined;
            }
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                axis.associatedSeries = [];
                axis.seriesHaveValidData = false;
            }
            this.attributeSet.setAt('seriesId', 'app', 0);
        };
        // Removes all of the children from the plot.
        FDSPlot.prototype.removeChildren = function () {
            var childList = this.getChildList();
            for (var id in childList) {
                var child = childList[id];
                if (isLegend(child)) {
                    continue;
                }
                if ((child.parent != null) && child.parent === this) {
                    child.parent = null;
                }
                delete this.children[id];
            }
        };
        // Operation that gets performed when one of our (former?) children
        // notifies us of a change
        //
        // @param child [FDSChartObject] The child that informed us of a change
        // @param flags [UpdateMessage] What update our child sent us
        FDSPlot.prototype.onNotify = function (child, flags) {
            if (flags === void 0) { flags = 0 /* REMOVE */; }
            if (isSeries(child)) {
                if (flags === 0 /* REMOVE */) {
                    child.removeSelfFromAxes();
                    this._removeSeries(child);
                    if (this._axisResetOnDataChange) {
                        this.refreshAxis(false);
                    }
                }
                else if (flags === 1 /* CHANGE */ && child.hasValidData) {
                    this._addSeries(child);
                    this.refreshAxis(true);
                }
                else if (flags === 1 /* CHANGE */ && !child.hasValidData) {
                    child.removeSelfFromAxes();
                    if (this._axisResetOnDataChange) {
                        this.refreshAxis(false);
                    }
                }
                else {
                    // Even though the series **probably** exists at this point,
                    // call addSeries on it so we can update the axes' valid flag
                    this._addSeries(child);
                    if (this._axisResetOnDataChange) {
                        this.refreshAxis(false);
                    }
                }
                this.setNeedUpdate(true);
                this.wrapper['seriesListDirty'] = true;
            }
            else if (isAxis(child)) {
                this.wrapper['axisListDirty'] = true;
                if (flags === 0 /* REMOVE */) {
                    this._removeAxis(child);
                    this.setNeedUpdate(true);
                }
            }
        };
        FDSPlot.prototype.simpleZoom = function (pt1, pt2, mode) {
            pt1 = pt1.copy();
            pt2 = pt2.copy();
            switch (mode) {
                case 0 /* UNZOOM */:
                    this._unzoomAxes();
                    return true;
                case 1 /* ZOOM */:
                    return this._zoomAxes(pt1, pt2, this.attributeSet.get('ZoomMode'));
            }
            return false;
        };
        FDSPlot.prototype._unzoomAxes = function () {
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                axis.attributeSet.resetAttribute('ThreshMin');
                axis.attributeSet.resetAttribute('ThreshMax');
                axis.attributeSet.resetAttribute('minPlotFactor');
                axis.attributeSet.resetAttribute('maxPlotFactor');
            }
        };
        FDSPlot.prototype._zoomAxes = function (pt1, pt2, zoomMode) {
            var min$$1 = 0;
            var max$$1 = 0;
            var zoom = false;
            var ret = false;
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                var minPlotFactor = axis.minPlotFactor, maxPlotFactor = axis.maxPlotFactor;
                var computedNDCMin = minPlotFactor;
                var computedNDCMax = maxPlotFactor;
                var scale = axis.getScale();
                if (scale) {
                    if (scale.scaleType === 8 /* DATETIME */) {
                        continue;
                    }
                    switch (axis.dimension) {
                        case 1 /* X */:
                            computedNDCMin = clamp(this.normSubPlot(pt1.x, 1 /* X */), 0, 1);
                            computedNDCMax = clamp(this.normSubPlot(pt2.x, 1 /* X */), 0, 1);
                            min$$1 = scale.computeValue(computedNDCMin);
                            max$$1 = scale.computeValue(computedNDCMax);
                            zoom = (zoomMode === 3 /* XY */) || (zoomMode === 1 /* X */);
                            break;
                        case 2 /* Y */:
                            computedNDCMin = clamp(this.normSubPlot(pt1.y, 2 /* Y */), 0, 1);
                            computedNDCMax = clamp(this.normSubPlot(pt2.y, 2 /* Y */), 0, 1);
                            min$$1 = scale.computeValue(computedNDCMin);
                            max$$1 = scale.computeValue(computedNDCMax);
                            zoom = (zoomMode === 3 /* XY */) || (zoomMode === 2 /* Y */);
                            break;
                        default:
                            zoom = false;
                    }
                    if (zoom) {
                        if (max$$1 < min$$1) {
                            _b = [max$$1, min$$1], min$$1 = _b[0], max$$1 = _b[1];
                        }
                        var threshMin = void 0, threshMax = void 0;
                        if (axis.attributeSet.isInheritedDefault('ThreshMin')) {
                            threshMin = scale.threshMin;
                        }
                        else {
                            threshMin = axis.attributeSet.get('ThreshMin');
                        }
                        if (axis.attributeSet.isInheritedDefault('ThreshMax')) {
                            threshMax = scale.threshMax;
                        }
                        else {
                            threshMax = axis.attributeSet.get('ThreshMax');
                        }
                        if (!(fuzzyEQ(max$$1, min$$1, scale.tolerance)) &&
                            fuzzyGT(Math.abs(max$$1 - min$$1), FDSNDCTolerance)) {
                            if (fuzzyGT(min$$1, threshMin, scale.tolerance)) {
                                axis.attributeSet.setAt('ThreshMin', 'user', min$$1);
                            }
                            if (fuzzyLT(max$$1, threshMax, scale.tolerance)) {
                                axis.attributeSet.setAt('ThreshMax', 'user', max$$1);
                            }
                            if (fuzzyLT(computedNDCMin, minPlotFactor)) {
                                axis.attributeSet.setAt('minPlotFactor', 'user', computedNDCMin);
                            }
                            if (fuzzyGT(computedNDCMax, maxPlotFactor)) {
                                axis.attributeSet.setAt('maxPlotFactor', 'user', computedNDCMax);
                            }
                            ret = true;
                        }
                    }
                }
            }
            return ret;
            var _b;
        };
        FDSPlot.prototype.isResizeAllAxesOnZoom = function () {
            return this._HZoomResizeOtherAxes;
        };
        FDSPlot.prototype.refreshAxis = function (forceAll) {
            var refresh = {
                val: true
            };
            for (var _i = 0, _a = this.axes; _i < _a.length; _i++) {
                var axis = _a[_i];
                var scaleSpecifier = axis.scaleSpecifier;
                if (!forceAll) {
                    refresh.val = axis.isBuiltInAxis ? (scaleSpecifier & this._axisRefreshMask ? true : false) : true;
                    // Axis' RefreshAxis attribute supercedes any masked value
                    axis.lookupRefreshAttr(refresh);
                }
                if (refresh && refresh.val) {
                    var scale = axis.getScale();
                    if (scale) {
                        scale.initialized = false;
                    }
                }
            }
            this.setNeedUpdate(true);
        };
        FDSPlot.prototype.isActiveLegendHeatmap = function () {
            return this.heatmapLegend !== undefined;
        };
        FDSPlot.prototype.shadeHitshapes = function () {
            var ctx = this.root.getUIContext();
            for (var _i = 0, _a = this.hitShapes; _i < _a.length; _i++) {
                var shape = _a[_i];
                shape.shadeShape(ctx);
            }
        };
        FDSPlot.prototype._syncInteractivity = function () {
        };
        FDSPlot.prototype.getInteractivityObjectType = function () {
            return 4 /* PLOT */;
        };
        FDSPlot.prototype.processEventHandling = function (event, pick$$1, point) {
            var args = [point, pick$$1.accessSubObject()];
            this.wrapper.handleEvent(event, args);
        };
        FDSPlot.prototype._applyStyleObjects = function () {
            var styleObject = _super.prototype._applyStyleObjects.call(this);
            if (!(isPlot(styleObject))) {
                return styleObject;
            }
            var stylePlot = styleObject;
            for (var key in this._builtinObjects) {
                var obj = this._builtinObjects[key];
                var styleKey = key;
                if (isAxis(obj)) {
                    styleKey = obj.getDimPrefix();
                }
                if (styleKey) {
                    this._applyStyleObjectToChild(styleKey, obj, styleObject);
                }
            }
            var customXYAxes = this.axes.filter(function (axis) {
                return !axis.isBuiltInAxis && (axis.dimension === 1 /* X */ || axis.dimension === 2 /* Y */);
            });
            for (var _i = 0, customXYAxes_1 = customXYAxes; _i < customXYAxes_1.length; _i++) {
                var axis = customXYAxes_1[_i];
                this._applyStyleObjectToChild(axis.getDimPrefix(), axis, styleObject);
            }
            return styleObject;
        };
        FDSPlot.prototype._applyStyleObjectToChild = function (styleKey, obj, stylePlot) {
            var builtinStyle = stylePlot._builtinObjects[styleKey];
            obj.attributeSet.setParentAttrSet(builtinStyle.attributeSet);
            obj.attributeSet.inheritByIdOnly = true;
            builtinStyle.styleChildren[obj.id] = true;
        };
        FDSPlot.prototype._getRedirectedAttrSet = function (attrKey) {
            var attrSet = undefined;
            // note, its important that Y2, Y3, and Y4 preceed Y, otherwise Y will be greedily matched.
            var match = attrKey.match(/^(X|Y2|Y3|Y4|Y|Z|Legend|COLOR|DSIZE|HIT)((?:[A-Z]\w*)|maxPlotFactor|minPlotFactor)?$/);
            if (match) {
                var obj = this._builtinObjects[match[1]];
                if (obj) {
                    attrSet = obj.attributeSet;
                }
                attrKey = match[2] || match[1]; // "Legend" redirects to "Legend" on the legend object, not ""
            }
            if (!attrSet) {
                attrSet = this.attributeSet;
            }
            return { attrSet: attrSet, attrKey: attrKey };
        };
        FDSPlot.prototype._getAttributesForSerialization = function (genApp, genUser, appAttrs, userAttrs) {
            _super.prototype._getAttributesForSerialization.call(this, genApp, genUser, appAttrs, userAttrs);
            for (var prefix in this._builtinObjects) {
                var builtInObj = this._builtinObjects[prefix];
                if (builtInObj == null) {
                    continue;
                }
                builtInObj._getAttributesForSerialization(genApp, genUser, appAttrs, userAttrs);
            }
        };
        FDSPlot.selector = 'FDSPlot';
        return FDSPlot;
    }(FDSChartObject));
    var FDSPlotStyle = /** @class */ (function (_super) {
        __extends(FDSPlotStyle, _super);
        function FDSPlotStyle(root, id) {
            return _super.call(this, root, id) || this;
        }
        FDSPlotStyle.prototype._init = function (args) {
            this.isStyleObject = true;
            this.type = 13 /* FC_PLOT_STYLE */;
            _super.prototype._init.call(this, args);
        };
        return FDSPlotStyle;
    }(FDSPlot));
    
    var AreaDrawStyle = /** @class */ (function (_super) {
        __extends(AreaDrawStyle, _super);
        function AreaDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AreaDrawStyle.prototype._cumulativelySumData = function (prm, dim) {
            if (dim === void 0) { dim = 2 /* Y */; }
            if (prm.renderCache != null) {
                if (prm.renderCache.valid) {
                    return prm.renderCache.cumulativeSumMap;
                }
            }
            var otherDim;
            var scale;
            var bin;
            if (dim === 1 /* X */) {
                otherDim = 2 /* Y */;
                scale = this._xScale;
                bin = this._xBin;
            }
            else if (dim === 2 /* Y */) {
                otherDim = 1 /* X */;
                scale = this._yScale;
                bin = this._yBin;
            }
            else {
                throw new Error('unexpected dimension, cannot sum data');
            }
            var pointMap = createPointMap(prm.plotSeries, dim, otherDim);
            // we've constructed our buckets now lets create a new map
            // that maps from the 'otherDim' data point to a cumulative sum array of the points
            var sumMap = {};
            for (var key in pointMap) {
                var bucket = pointMap[key];
                var sum$$1 = 0;
                var res = [];
                for (var _i = 0, bucket_1 = bucket; _i < bucket_1.length; _i++) {
                    var num = bucket_1[_i];
                    // keep the sum the same if num is undefined or nan
                    if ((num != null) && !IsSomeNAN(num)) {
                        sum$$1 += num;
                    }
                    res.push(prm.plot.subPlotFromNDC(scale.lookup(sum$$1, bin), dim));
                }
                sumMap[key] = res;
            }
            prm.renderCache.cumulativeSumMap = sumMap;
            prm.renderCache.valid = true;
            return sumMap;
        };
        AreaDrawStyle.prototype._doesSegmentIntersectReferenceLine = function (ref, y1, y2) {
            return !((fuzzyLT(y1, ref) && fuzzyLT(y2, ref)) ||
                (fuzzyGT(y1, ref) && fuzzyGT(y2, ref)));
        };
        AreaDrawStyle.prototype._getReferenceLineIntersectionFromNDC = function (ref, pt1, pt2) {
            if (fuzzyEQ(pt1.x, pt2.x) || fuzzyEQ(pt1.y, ref)) {
                return pt1.x;
            }
            else if (fuzzyEQ(pt2.y, ref)) {
                return pt2.x;
            }
            else {
                var slope = (pt2.y - pt1.y) / (pt2.x - pt1.x);
                var xAxisIntercept = pt1.y - (slope * pt1.x);
                return (ref - xAxisIntercept) / slope;
            }
        };
        AreaDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            var _this = this;
            ctx.save();
            var pen;
            var _switchPenAndBrush = function (color, rect) {
                if (rect === undefined) {
                    rect = prm.plotRect;
                }
                if (color === 'up') {
                    pen = _this.series.seriesFGPen;
                    _this.series.seriesOutlinePen.setOnCanvas(ctx);
                    _this.series.seriesBGBrush.setOnCanvas(ctx, rect);
                }
                else {
                    pen = _this.series.seriesAlternateFGPen;
                    _this.series.seriesAlternateOutlinePen.setOnCanvas(ctx);
                    _this.series.seriesAlternateBGBrush.setOnCanvas(ctx, rect);
                }
            };
            _switchPenAndBrush('up');
            var shouldSkipDrawingPoint = function (newDataPt) {
                return ((newDataPt.x === undefined || newDataPt.y === undefined || IsSomeNAN(newDataPt.y)) && !isStacked);
            };
            // get a reference value. (only yref is used, this gets us the min point (be it y=0 or whatever the minY
            // attribute is set to)
            var worldX;
            var worldY;
            var ndcX;
            var ndcY;
            if (this.series.isStacked) {
                ndcY = this._getNDCReferenceFromAxis(0, 2 /* Y */);
            }
            else {
                (_a = this.computeWorldBarBases(), ndcX = _a.ndcX, ndcY = _a.ndcY, worldX = _a.worldX, worldY = _a.worldY);
            }
            ndcY = clamp(ndcY, 0, 1);
            var minY = ~~(prm.plot.subPlotFromNDC(ndcY, 2 /* Y */)) + pen.getAliasOffset();
            var minX = ~~(prm.plot.subPlotFromNDC(this._xScale.lookup(this._xData.data[0], this._xBin), 1 /* X */)) +
                pen.getAliasOffset();
            var sumMap = this._cumulativelySumData(prm, 2 /* Y */);
            var stackIndex = computeStackIndex(prm, this.series);
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var breakOnNA;
            var breakOnGap;
            var isStacked;
            var x = minY;
            var y = minX;
            if (this.series.seriesBGBrush.style !== 1 /* NULL */) {
                ctx.beginPath();
                // keep track of whether we're beginning a new area section or continuing one
                var newarea_1 = true;
                breakOnNA = this.series.attributeSet.get('BreakOnNA');
                breakOnGap = this.series.breakOnGap;
                isStacked = this.series.isStacked;
                ctx.moveTo(minX, minY);
                // helper function to start a new area after a break (on NA or gap)
                var startNewAreaFill_1 = function (lastX) {
                    ctx.lineTo(lastX, minY);
                    ctx.lineTo(minX, minY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    newarea_1 = true;
                };
                var closeAreaFillOnGap = function (currentIndex, startIndex, newDataPt, scale, lastX) {
                    var hasNAGap = shouldSkipDrawingPoint(newDataPt) && !newarea_1 && breakOnNA;
                    var hasDatapointGap = (currentIndex > startIndex) && scale.gapBetweenDatapoints(prevDataPt_1.x, newDataPt.x) &&
                        breakOnGap;
                    if (hasNAGap || hasDatapointGap) {
                        startNewAreaFill_1(lastX);
                    }
                };
                var getAreaFillPointInPixels = function (index, newDataPt, top) {
                    var y1;
                    var y2;
                    if (isStacked) {
                        var ptMap = sumMap[newDataPt.x];
                        y1 = (ptMap[stackIndex - 1] != null) ? ptMap[stackIndex - 1] : minY;
                        y2 = ptMap[stackIndex];
                    }
                    else {
                        y1 = minY;
                        y2 = prm.plot.subPlotFromNDC(_this._yScale.lookup(newDataPt.y, _this._yBin), 2 /* Y */);
                    }
                    var newX = prm.plot.subPlotFromNDC(_this._xScale.lookup(newDataPt.x, _this._xBin), 1 /* X */);
                    var newY = top ? y2 : y1;
                    return new Point(newX, newY);
                };
                var drawNextAreaFillPoint = function (nextPt) {
                    if (newarea_1) {
                        minX = nextPt.x;
                        ctx.moveTo(nextPt.x, nextPt.y);
                        newarea_1 = false;
                    }
                    else {
                        ctx.lineTo(nextPt.x, nextPt.y);
                    }
                };
                var startNewUpDownFill = function (intercept) {
                    ctx.lineTo(minX, minY);
                    ctx.closePath();
                    ctx.fill();
                    minX = intercept;
                    extremeY_1 = minY;
                    ctx.beginPath();
                };
                var prevDataPt_1 = new Point(0, 0);
                var prevPixelPt_1 = new Point(0, 0);
                var prevDirection = void 0;
                var extremeY_1 = minY;
                for (var j = this._start; j < this._end; j += this._step) {
                    var index = this.series.getSampleIndex(j);
                    var currentDataPt = new Point(this._xData.getAt(index), this._yData.getAt(index));
                    closeAreaFillOnGap(j, this._start, currentDataPt, this._xScale, prevPixelPt_1.x);
                    if (shouldSkipDrawingPoint(currentDataPt)) {
                        continue;
                    }
                    if (isStacked && (currentDataPt.y === undefined || IsSomeNAN(currentDataPt.y))) {
                        currentDataPt.y = 0;
                    }
                    var currentPixelPt = getAreaFillPointInPixels(j, currentDataPt, true);
                    if (this.series.enableAreaTopBottomConditionalColor) {
                        var direction = (currentPixelPt.y < minY) ? 'up' : 'down';
                        if (j > this._start && this._doesSegmentIntersectReferenceLine(minY, prevPixelPt_1.y, currentPixelPt.y)) {
                            var intercept = this._getReferenceLineIntersectionFromNDC(minY, prevPixelPt_1, currentPixelPt);
                            drawNextAreaFillPoint(new Point(intercept, minY));
                            _switchPenAndBrush(prevDirection, new Rectangle(minX, minY, intercept, extremeY_1));
                            startNewUpDownFill(intercept);
                        }
                        if ((direction === 'up' && (currentPixelPt.y < extremeY_1)) ||
                            (direction === 'down' && (currentPixelPt.y > extremeY_1))) {
                            extremeY_1 = currentPixelPt.y;
                        }
                        prevDirection = direction;
                    }
                    drawNextAreaFillPoint(currentPixelPt);
                    prevDataPt_1 = currentDataPt;
                    prevPixelPt_1 = currentPixelPt;
                }
                // We only need to do the complicated reverse drawing if this is stacked, otherwise
                // we can just switch colors if necessary and draw all the way to the ymin then back over to xmin, ymin
                if (isStacked) {
                    for (var j = this._end - 1; j >= this._start; j = j - this._step) {
                        var index = this.series.getSampleIndex(j);
                        var currentDataPt = new Point(this._xData.getAt(index), this._yData.getAt(index));
                        if (shouldSkipDrawingPoint(currentDataPt)) {
                            continue;
                        }
                        if (currentDataPt.y === undefined || IsSomeNAN(currentDataPt.y)) {
                            currentDataPt.y = 0;
                        }
                        var currentPt = getAreaFillPointInPixels(j, currentDataPt, false);
                        drawNextAreaFillPoint(currentPt);
                    }
                }
                else {
                    ctx.lineTo(prevPixelPt_1.x, minY);
                    ctx.lineTo(minX, minY);
                    if (this.series.enableAreaTopBottomConditionalColor) {
                        _switchPenAndBrush(prevDirection, new Rectangle(minX, minY, prevPixelPt_1.x, extremeY_1));
                    }
                }
                ctx.closePath();
                ctx.fill();
            }
            // Draw the outline on the actual data points
            // the seriesOutlinePen is still selected from before
            ctx.beginPath();
            x = minX = ~~(prm.plot.subPlotFromNDC(this._xScale.lookup(this._xData.data[0], this._xBin), 1 /* X */)) +
                pen.getAliasOffset();
            var startY;
            if (this.series.isStacked) {
                startY = sumMap[this._xData.data[0]][0];
            }
            else {
                startY = minY;
            }
            var newline = true;
            var topLineOnly = this.series.attributeSet.get('AreaDrawTopLineOnly');
            var prevPixelPt = new Point(x, startY);
            // helper function to close area
            var startNewAreaLine = function (prevPt) {
                if (!topLineOnly) {
                    pen.drawPolyline(ctx, prevPt, { x: prevPt.x, y: minY });
                    pen.drawPolyline(ctx, { x: prevPt.x, y: minY }, { x: minX, y: minY });
                    pen.drawPolyline(ctx, { x: minX, y: minY }, { x: minX, y: startY });
                }
                pen.closePolyline();
                ctx.stroke();
                newline = true;
                ctx.beginPath();
            };
            var closeAreaLineOnGap = function (currentIndex, startIndex, newDataPt, scale, lastPt) {
                var hasNAGap = shouldSkipDrawingPoint(newDataPt) && breakOnNA;
                var hasDatapointGap = (currentIndex > startIndex) && scale.gapBetweenDatapoints(prevDataPt.x, newDataPt.x) &&
                    breakOnGap;
                if (hasNAGap || hasDatapointGap) {
                    startNewAreaLine(lastPt);
                }
            };
            var getAreaLinePoint = function (currentDataPt, top) {
                var y1;
                var y2;
                if (isStacked) {
                    y1 = (sumMap[currentDataPt.x][stackIndex - 1] != null) ? sumMap[currentDataPt.x][stackIndex - 1] : minY;
                    y2 = sumMap[currentDataPt.x][stackIndex];
                }
                else {
                    y1 = minY;
                    y2 = ~~(prm.plot.subPlotFromNDC(_this._yScale.lookup(currentDataPt.y, _this._yBin), 2 /* Y */)) + pen.getAliasOffset();
                }
                var yDraw;
                var yBase;
                // If we're drawing along the top of the area chart, we're drawing at the datapoint's value and using the
                // minimum as a reference. If we're drawing back along the bottom of the area chart, we're draing at the
                // minimum and using the datapoint's value as a reference.
                if (top) {
                    yDraw = y2;
                    yBase = y1;
                }
                else {
                    yDraw = y1;
                    yBase = y2;
                }
                var xPixels = ~~(prm.plot.subPlotFromNDC(_this._xScale.lookup(currentDataPt.x, _this._xBin), 1 /* X */)) +
                    pen.getAliasOffset();
                return { currentPixelBase: yBase, currentPixelPt: new Point(xPixels, yDraw) };
            };
            var addHitShapes = function (index, prevPt, prevBase, newPt, newBase, top) {
                if (top) {
                    _this.series.addLookupPoint(newPt.x + prm.plotRect.x1, [newPt.y + prm.plotRect.y1], index);
                }
                // Cache the selection marker position
                if ((!_this.series.isStacked) && _this.seriesSelected && _this._selectionSampler.isPointSampled(index)) {
                    _this.cacheSelectable(prm, 0 /* NONE */, newPt.x, newPt.y);
                }
                if (newline) {
                    return;
                }
                else {
                    var midPt = new Point(((prevPt.x + newPt.x) / 2), ((prevPt.y + newPt.y) / 2));
                    var midBase = (prevBase + newBase) / 2;
                    // Make left hitshape
                    var points1 = [new Point(prevPt.x + prm.plotRect.x1, prevBase + prm.plotRect.y1)];
                    points1.push(new Point(prevPt.x + prm.plotRect.x1, prevPt.y + prm.plotRect.y1));
                    points1.push(new Point(midPt.x + prm.plotRect.x1, midPt.y + prm.plotRect.y1));
                    points1.push(new Point(midPt.x + prm.plotRect.x1, midBase + prm.plotRect.y1));
                    var hitPoly1 = new FDSPolygonHitShape(points1);
                    var hitLine1 = new FDSLineHitShape(prevPt.x + prm.plotRect.x1, prevPt.y + prm.plotRect.y1, midPt.x + prm.plotRect.x1, midPt.y + prm.plotRect.y1);
                    hitPoly1.index = index - 1;
                    hitLine1.index = index - 1;
                    _this.series.hitVector.push(hitPoly1);
                    _this.series.hitVector.push(hitLine1);
                    // Make right hitshape
                    var points2 = [new Point(midPt.x + prm.plotRect.x1, midBase + prm.plotRect.y1)];
                    points2.push(new Point(midPt.x + prm.plotRect.x1, midPt.y + prm.plotRect.y1));
                    points2.push(new Point(newPt.x + prm.plotRect.x1, newPt.y + prm.plotRect.y1));
                    points2.push(new Point(newPt.x + prm.plotRect.x1, newBase + prm.plotRect.y1));
                    var hitPoly2 = new FDSPolygonHitShape(points2);
                    var hitLine2 = new FDSLineHitShape(midPt.x + prm.plotRect.x1, midPt.y + prm.plotRect.y1, newPt.x + prm.plotRect.x1, newPt.y + prm.plotRect.y1);
                    hitPoly2.index = index;
                    hitLine2.index = index;
                    _this.series.hitVector.push(hitPoly2);
                    _this.series.hitVector.push(hitLine2);
                    // while we're here, save the pixel points:
                    // save the first one if it's 0, as center of left area
                    var pixX = void 0;
                    var edgeY = void 0;
                    var pixY = void 0;
                    if (index - 1 === 0) {
                        pixX = Math.round(((prevPt.x + midPt.x) / 2) + prm.plotRect.x1);
                        // y is halfway between area baseline and the y point closest to that line
                        // on the other half of that area, either prevY or midY
                        edgeY = top ? Math.min(prevPt.y, midPt.y) : Math.max(prevPt.y, midPt.y);
                        pixY = Math.round(((edgeY + newBase) / 2 + prm.plotRect.y1));
                        pixelPoints[index - 1] = { x: pixX, y: pixY };
                    }
                    // now add the right pixel points as centers of right areas
                    pixX = Math.round(((midPt.x + newPt.x) / 2) + prm.plotRect.x1);
                    // y is computed same as above
                    edgeY = top ? edgeY = Math.min(midPt.y, newPt.y) : Math.max(midPt.y, newPt.y);
                    pixY = Math.round(((edgeY + newBase) / 2) + prm.plotRect.y1);
                    pixelPoints[index] = { x: pixX, y: pixY };
                }
            };
            var drawAreaStrokeAtPoint = function (index, prevPt, newPt) {
                if (newline) {
                    startY = newPt.y;
                    minX = newPt.x;
                    newline = false;
                }
                else {
                    // Draw each data point as a point on a line
                    pen.drawPolyline(ctx, prevPt, { x: newPt.x, y: newPt.y });
                }
            };
            var startNewUpDownLine = function (prevPt) {
                if (!topLineOnly) {
                    pen.drawPolyline(ctx, prevPt, { x: prevPt.x, y: minY });
                    pen.drawPolyline(ctx, { x: prevPt.x, y: minY }, { x: minX, y: minY });
                    pen.drawPolyline(ctx, { x: minX, y: minY }, { x: minX, y: startY });
                }
                minX = prevPt.x;
                startY = prevPt.y;
                pen.closePolyline();
                ctx.stroke();
                ctx.beginPath();
            };
            var prevDataPt = new Point(0, 0);
            var prevPixelBase = minY;
            for (var j = this._start; j < this._end; j += this._step) {
                var index = this.series.getSampleIndex(j);
                var currentDataPt = new Point(this._xData.getAt(index), this._yData.getAt(index));
                closeAreaLineOnGap(j, this._start, currentDataPt, this._xScale, prevPixelPt);
                if (shouldSkipDrawingPoint(currentDataPt)) {
                    continue;
                }
                if (isStacked && (currentDataPt.y === undefined || IsSomeNAN(currentDataPt.y))) {
                    currentDataPt.y = 0;
                }
                var _b = getAreaLinePoint(currentDataPt, true), currentPixelBase = _b.currentPixelBase, currentPixelPt = _b.currentPixelPt;
                addHitShapes(j, prevPixelPt, prevPixelBase, currentPixelPt, currentPixelBase, true);
                if (isStacked) {
                    this._markerPositions.push(currentPixelPt);
                    this._labelPositions.push(currentPixelPt.add(new Point(prm.plotRect.x1, prm.plotRect.y1)));
                }
                if (this.series.enableAreaTopBottomConditionalColor) {
                    if (j > this._start && this._doesSegmentIntersectReferenceLine(minY, prevPixelPt.y, currentPixelPt.y)) {
                        var interceptPt = new Point(this._getReferenceLineIntersectionFromNDC(minY, prevPixelPt, currentPixelPt), minY);
                        drawAreaStrokeAtPoint(j, prevPixelPt, interceptPt);
                        startNewUpDownLine(interceptPt);
                        prevPixelPt = interceptPt;
                        prevPixelBase = currentPixelBase;
                    }
                    if (currentPixelPt.y < minY) {
                        _switchPenAndBrush('up');
                    }
                    else if (currentPixelPt.y > minY) {
                        _switchPenAndBrush('down');
                    }
                }
                var ret = drawAreaStrokeAtPoint(j, prevPixelPt, currentPixelPt);
                prevPixelPt = currentPixelPt;
                prevPixelBase = currentPixelBase;
                prevDataPt = currentDataPt;
            }
            if (!topLineOnly && this._end - this._start > 0) {
                if (this.series.isStacked) {
                    var currentDataPt = void 0;
                    for (var j = this._end - 1; j >= this._start; j -= this._step) {
                        var index = this.series.getSampleIndex(j);
                        currentDataPt = new Point(this._xData.getAt(index), this._yData.getAt(index));
                        if (closeAreaLineOnGap(j, this._start, currentDataPt, this._xScale, prevPixelPt)) {
                            continue;
                        }
                        if (isStacked && (currentDataPt.y === undefined || IsSomeNAN(currentDataPt.y))) {
                            currentDataPt.y = 0;
                        }
                        var _c = getAreaLinePoint(currentDataPt, false), currentPixelBase = _c.currentPixelBase, currentPixelPt = _c.currentPixelPt;
                        drawAreaStrokeAtPoint(j, prevPixelPt, currentPixelPt);
                        prevPixelPt = currentPixelPt;
                    }
                    var ptMap = sumMap[currentDataPt.x];
                    var y1 = (ptMap[stackIndex - 1] != null) ? ptMap[stackIndex - 1] : minY;
                    var y2 = ptMap[stackIndex];
                    // finish off the line
                    pen.drawPolyline(ctx, { x: minX, y: y1 }, { x: minX, y: y2 });
                    pen.closePolyline();
                    ctx.closePath();
                }
                else {
                    pen.drawPolyline(ctx, prevPixelPt, { x: prevPixelPt.x, y: minY });
                    pen.drawPolyline(ctx, { x: prevPixelPt.x, y: minY }, { x: minX, y: minY });
                    pen.drawPolyline(ctx, { x: minX, y: minY }, { x: minX, y: startY });
                    pen.closePolyline();
                    ctx.closePath();
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            pen.closePolyline();
            ctx.stroke();
            ctx.restore();
            var _a;
        };
        AreaDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            // use a special thin pen to draw the legend
            var pen = this.series.seriesOutlinePen.with({ width: 1 });
            pen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            ctx.beginPath();
            ctx.moveTo(x - minus, y + minus);
            ctx.lineTo(x - minus, y - halfplus);
            ctx.lineTo(x, y);
            ctx.lineTo(x + halfplus, y - plus);
            ctx.lineTo(x + halfplus, y + minus);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        AreaDrawStyle.prototype.getStackedYPosition = function (prm, xData) {
            if (this.series.isStacked) {
                var stackIndex = prm.renderCache.stackIndexMap[this.series.id];
                return prm.renderCache.cumulativeSumMap[xData.toString()][stackIndex] + prm.plotRect.y1;
            }
            else {
                return undefined;
            }
        };
        AreaDrawStyle.prototype.verify = function () {
            return true;
        };
        AreaDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        AreaDrawStyle.prototype.getClickTooltipArrowPoint = function (x, y, index) {
            if (this.series.isStacked) {
                var parent_1 = this.series.getPlotParent();
                var arrowX = getDimensionPixelPositionFromIndex(this.series, index, 1 /* X */) + parent_1.plotRect.x1;
                var prm = parent_1.renderManager;
                var stackIndex = computeStackIndex(prm, this.series);
                var arrowY = parent_1.renderManager.renderCache.cumulativeSumMap[this.series.getData(1 /* X */).getAt(index)][stackIndex] +
                    parent_1.plotRect.y1;
                return { point: new Point(arrowX, arrowY), position: "above" /* above */ };
            }
            else {
                return _super.prototype.getClickTooltipArrowPoint.call(this, x, y, index);
            }
        };
        return AreaDrawStyle;
    }(BaseDrawStyle));
    
    var NewAreaDrawStyle = /** @class */ (function (_super) {
        __extends(NewAreaDrawStyle, _super);
        function NewAreaDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NewAreaDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this._prm = prm;
            this._aliasOffset = this.series.seriesOutlinePen.getAliasOffset();
            var pixelPoints = this._getSeriesPixelPoints();
            if (_.isEmpty(pixelPoints)) {
                return;
            }
            this._shouldBreakOnGap = this.series.breakOnGap;
            this._shouldBreakOnNA = this.series.attributeSet.get('BreakOnNA');
            this._yRef = this._getYRef();
            var areaShapes = this._createAreaShapes(pixelPoints);
            ctx.save();
            this._drawAreaShapes(ctx, areaShapes);
            ctx.restore();
            this._buildHitShapesFromAreaShapes(areaShapes);
        };
        NewAreaDrawStyle.prototype._getSeriesPixelPoints = function () {
            var seriesPixelPoints = [];
            var prevDataX = null;
            for (var j = this._start; j < this._end; j += this._step) {
                var index = this.series.getSampleIndex(j);
                var dataX = this._xData.getAt(index);
                var dataY = this._yData.getAt(index);
                if (this._shouldDrawDataPoint(dataX, dataY)) {
                    // We don't round down here to prevent unintentional gaps from appearing between the
                    // edges of the area and the plot boundary. This unintentional gap can occur when
                    // DrawTopLineOnly is set to true.
                    var pixelX = this._prm.plot.subPlotFromNDC(this._xScale.lookup(dataX, this._xBin), 1 /* X */) + this._aliasOffset;
                    var pixelY = this._prm.plot.subPlotFromNDC(this._yScale.lookup(dataY, this._yBin), 2 /* Y */) + this._aliasOffset;
                    if (prevDataX !== null && this._xScale.gapBetweenDatapoints(prevDataX, dataX)) {
                        seriesPixelPoints.push(1 /* DATA */);
                    }
                    seriesPixelPoints.push({ x: pixelX, y: pixelY, dataIndex: index });
                    prevDataX = dataX;
                }
                else {
                    seriesPixelPoints.push(0 /* NA */);
                }
            }
            return seriesPixelPoints;
        };
        NewAreaDrawStyle.prototype._shouldDrawDataPoint = function (dataX, dataY) {
            if (dataX == null || dataY == null || IsSomeNAN(dataY)) {
                return false;
            }
            return true;
        };
        NewAreaDrawStyle.prototype._getYRef = function () {
            var ndcY = this.computeWorldBarBases().ndcY;
            ndcY = clamp(ndcY, 0, 1);
            return ~~(this._prm.plot.subPlotFromNDC(ndcY, 2 /* Y */)) + this._aliasOffset;
        };
        NewAreaDrawStyle.prototype._createAreaShapes = function (areaPoints) {
            var _this = this;
            var areaShapes = [];
            // Find the first valid series pixel point, i.e. a point that is not an AreaGap.
            var startIndex = _.findIndex(areaPoints, function (pt) { return !_this._isAreaGap(pt); });
            if (startIndex === -1) {
                return [];
            }
            var prevPt = areaPoints[startIndex];
            var currAreaPts = [];
            currAreaPts.push(prevPt);
            var prevAreaEndPixel = null;
            for (var i = startIndex + 1; i < areaPoints.length; i++) {
                if (this._isAreaGap(areaPoints[i])) {
                    var currGap = areaPoints[i];
                    if (this._shouldCloseAreaOnGap(currGap)) {
                        this._addNewAreaShapeToList(areaShapes, currAreaPts, prevAreaEndPixel, prevPt);
                        prevAreaEndPixel = prevPt;
                        prevPt = null;
                        currAreaPts = [];
                    }
                }
                else {
                    var currPt = areaPoints[i];
                    if (prevPt && this._doesLineCrossYReference(prevPt, currPt)) {
                        // When the line crosses the y-reference, we split the area into two areas: one
                        // before the y-reference intercept and one after.
                        var yRefIntercept = this._getYRefIntercept(prevPt, currPt);
                        currAreaPts.push(yRefIntercept);
                        this._addNewAreaShapeToList(areaShapes, currAreaPts, prevAreaEndPixel, currPt);
                        prevAreaEndPixel = prevPt;
                        prevPt = null;
                        currAreaPts = [];
                        currAreaPts.push(yRefIntercept);
                    }
                    currAreaPts.push(currPt);
                    prevPt = currPt;
                }
            }
            if (currAreaPts.length !== 0) {
                this._addNewAreaShapeToList(areaShapes, currAreaPts, prevAreaEndPixel, null);
            }
            return areaShapes;
        };
        NewAreaDrawStyle.prototype._isAreaGap = function (ptOrGap) {
            return _.isNumber(ptOrGap);
        };
        NewAreaDrawStyle.prototype._shouldCloseAreaOnGap = function (gap) {
            var closeOnNAGap = (gap === 0 /* NA */) && this._shouldBreakOnNA;
            var closeOnDatapointGap = (gap === 1 /* DATA */) && this._shouldBreakOnGap;
            return closeOnNAGap || closeOnDatapointGap;
        };
        NewAreaDrawStyle.prototype._addNewAreaShapeToList = function (areaShapes, areaPoints, prevAreaEndPixel, nextAreaStartPixel) {
            var isAboveYRef = this._isAboveYRef(areaPoints);
            var areaShape = { outlinePixels: areaPoints, isAboveYRef: isAboveYRef, prevAreaEndPixel: prevAreaEndPixel, nextAreaStartPixel: nextAreaStartPixel };
            areaShapes.push(areaShape);
        };
        NewAreaDrawStyle.prototype._doesLineCrossYReference = function (point1, point2) {
            var point1IsAboveYRef = point1.y < this._yRef;
            var point2IsAboveYRef = point2.y < this._yRef;
            return (point1IsAboveYRef !== point2IsAboveYRef);
        };
        NewAreaDrawStyle.prototype._getYRefIntercept = function (point1, point2) {
            var slope = (point2.y - point1.y) / (point2.x - point1.x);
            var b = point1.y - slope * point1.x;
            var x = ~~((this._yRef - b) / slope) + this._aliasOffset;
            return { x: x, y: this._yRef };
        };
        NewAreaDrawStyle.prototype._isAboveYRef = function (areaPixelPoints) {
            for (var _i = 0, areaPixelPoints_1 = areaPixelPoints; _i < areaPixelPoints_1.length; _i++) {
                var point = areaPixelPoints_1[_i];
                if (point && (point.y !== this._yRef)) {
                    return point.y < this._yRef;
                }
            }
            return false;
        };
        NewAreaDrawStyle.prototype._drawAreaShapes = function (ctx, areaShapes) {
            this._setPenAndBrushOnCanvas(ctx);
            for (var _i = 0, areaShapes_1 = areaShapes; _i < areaShapes_1.length; _i++) {
                var shape = areaShapes_1[_i];
                if (this.series.enableAreaTopBottomConditionalColor) {
                    shape.isAboveYRef ? this._setPenAndBrushOnCanvas(ctx) : this._setAltPenAndBrushOnCanvas(ctx);
                }
                this._drawAreaShape(ctx, shape);
            }
        };
        NewAreaDrawStyle.prototype._setPenAndBrushOnCanvas = function (ctx) {
            this.series.seriesOutlinePen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx, this._prm.plotRect);
        };
        NewAreaDrawStyle.prototype._setAltPenAndBrushOnCanvas = function (ctx) {
            this.series.seriesAlternateOutlinePen.setOnCanvas(ctx);
            this.series.seriesAlternateBGBrush.setOnCanvas(ctx, this._prm.plotRect);
        };
        NewAreaDrawStyle.prototype._drawAreaShape = function (ctx, areaShape) {
            if (areaShape.outlinePixels.length < 1) {
                return;
            }
            var startPoint = _.first(areaShape.outlinePixels);
            var endPoint = _.last(areaShape.outlinePixels);
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            for (var i = 1; i < areaShape.outlinePixels.length; i++) {
                var currPt = areaShape.outlinePixels[i];
                ctx.lineTo(currPt.x, currPt.y);
            }
            ctx.lineTo(endPoint.x, this._yRef);
            ctx.lineTo(startPoint.x, this._yRef);
            ctx.closePath();
            ctx.fill();
            if (!this.series.areaDrawTopLineOnly) {
                ctx.stroke();
            }
            else {
                this._drawTopLine(ctx, areaShape);
            }
        };
        NewAreaDrawStyle.prototype._drawTopLine = function (ctx, areaShape) {
            var startPoint = _.first(areaShape.outlinePixels);
            var endPoint = _.last(areaShape.outlinePixels);
            ctx.beginPath();
            ctx.moveTo(startPoint.x, startPoint.y);
            for (var i = 1; i < areaShape.outlinePixels.length; i++) {
                var currPt = areaShape.outlinePixels[i];
                ctx.lineTo(currPt.x, currPt.y);
            }
            ctx.stroke();
        };
        NewAreaDrawStyle.prototype._buildHitShapesFromAreaShapes = function (areas) {
            var pixelPoints = {};
            var polygonHitShapes = [];
            for (var _i = 0, areas_1 = areas; _i < areas_1.length; _i++) {
                var area = areas_1[_i];
                for (var _a = 0, _b = area.outlinePixels; _a < _b.length; _a++) {
                    var point = _b[_a];
                    if (!this._isPointFromData(point)) {
                        continue;
                    }
                    var plotX = point.x + this._prm.plotRect.x1;
                    var plotY = point.y + this._prm.plotRect.y1;
                    this.series.addLookupPoint(plotX, [plotY], point.dataIndex);
                    pixelPoints[point.dataIndex] = { x: plotX, y: plotY };
                    if (this.seriesSelected && this._selectionSampler.isPointSampled(point.dataIndex)) {
                        this.cacheSelectable(this._prm, 0 /* NONE */, point.x, point.y);
                    }
                }
                polygonHitShapes = polygonHitShapes.concat(this._createHitshapesForAreaShape(area));
            }
            this.series.root.pixelPoints[this.series.id] = pixelPoints;
            this.series.hitVector = this.series.hitVector.concat(polygonHitShapes);
        };
        NewAreaDrawStyle.prototype._isPointFromData = function (point) {
            return 'dataIndex' in point;
        };
        NewAreaDrawStyle.prototype._createHitshapesForAreaShape = function (areaShape) {
            if (areaShape.outlinePixels.length < 1) {
                return [];
            }
            var polygonHitShapes = [];
            var currPolygonPts = [];
            var startPoint = areaShape.outlinePixels[0];
            this._addNewHitshapePointToList(currPolygonPts, startPoint.x, this._yRef);
            this._addNewHitshapePointToList(currPolygonPts, startPoint.x, startPoint.y);
            var prevPoint = this._isPointFromData(startPoint) ? startPoint : areaShape.prevAreaEndPixel;
            for (var i = 1; i < areaShape.outlinePixels.length; i++) {
                var currPoint = areaShape.outlinePixels[i];
                // If the current point is from data, we split the hitshape between the previous point's
                // data and the current point's data. Otherwise, if the point is not from data, this must
                // be a point that we added to close the area when it crossed the y-reference. Then, we
                // need to split the hitshape between the previous point's data and the next datapoint
                // that comes after our area.
                var midPoint = this._isPointFromData(currPoint) ? this._calcMidpoint(prevPoint, currPoint) :
                    this._calcMidpoint(prevPoint, areaShape.nextAreaStartPixel);
                this._closeAndStoreCurrentShape(midPoint, currPolygonPts, prevPoint.dataIndex, polygonHitShapes);
                currPolygonPts = [];
                this._addNewHitshapePointToList(currPolygonPts, midPoint.x, this._yRef);
                this._addNewHitshapePointToList(currPolygonPts, midPoint.x, midPoint.y);
                if (this._isPointFromData(currPoint)) {
                    this._addNewHitshapePointToList(currPolygonPts, currPoint.x, currPoint.y);
                    prevPoint = currPoint;
                }
                else {
                    var indexedPoint = { x: currPoint.x, y: currPoint.y, dataIndex: areaShape.nextAreaStartPixel.dataIndex };
                    prevPoint = indexedPoint;
                }
            }
            this._addNewHitshapePointToList(currPolygonPts, prevPoint.x, this._yRef);
            this._addNewHitshapeToList(currPolygonPts, prevPoint.dataIndex, polygonHitShapes);
            return polygonHitShapes;
        };
        NewAreaDrawStyle.prototype._addNewHitshapePointToList = function (points, x, y) {
            points.push(new Point(x + this._prm.plotRect.x1, y + this._prm.plotRect.y1));
        };
        NewAreaDrawStyle.prototype._calcMidpoint = function (point1, point2) {
            var x = (point1.x + point2.x) / 2;
            var y = (point1.y + point2.y) / 2;
            return { x: x, y: y };
        };
        NewAreaDrawStyle.prototype._closeAndStoreCurrentShape = function (endPoint, points, index, hitshapes) {
            this._addNewHitshapePointToList(points, endPoint.x, endPoint.y);
            this._addNewHitshapePointToList(points, endPoint.x, this._yRef);
            this._addNewHitshapeToList(points, index, hitshapes);
        };
        NewAreaDrawStyle.prototype._addNewHitshapeToList = function (points, index, hitshapes) {
            var hitshape = new FDSPolygonHitShape(points);
            hitshape.index = index;
            hitshapes.push(hitshape);
        };
        NewAreaDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            // use a special thin pen to draw the legend
            var pen = this.series.seriesOutlinePen.with({ width: 1 });
            pen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            ctx.beginPath();
            ctx.moveTo(x - minus, y + minus);
            ctx.lineTo(x - minus, y - halfplus);
            ctx.lineTo(x, y);
            ctx.lineTo(x + halfplus, y - plus);
            ctx.lineTo(x + halfplus, y + minus);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        NewAreaDrawStyle.prototype.verify = function () {
            return true;
        };
        NewAreaDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return NewAreaDrawStyle;
    }(BaseDrawStyle));
    
    var AreaStepDrawStyle = /** @class */ (function (_super) {
        __extends(AreaStepDrawStyle, _super);
        function AreaStepDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AreaStepDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            var horizVert = true;
            if (this.series.attributeSet.get('StepDirection') === 1 /* VERT_HORIZ */) {
                horizVert = false;
            }
            ctx.save();
            this.series.seriesOutlinePen.setOnCanvas(ctx);
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                this.series.seriesBGBrush.pushHistory();
                this.series.seriesBGBrush.setAttr('color', this.series.seriesFGPen.color);
            }
            this.series.seriesBGBrush.setOnCanvas(ctx);
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            // set up the pixel point array (and replace it if it existed already)
            pixelPoints = {};
            var minX;
            var minY;
            var breakOnNA;
            if (this.series.seriesBGBrush.style !== 1 /* NULL */) {
                ctx.beginPath();
                var y_1 = minY = prm.plot.subPlotFromNDC(this._yScale.getMinPlotFactor(), 2 /* Y */);
                var x_1 = minX = prm.plot.subPlotFromNDC(this._xScale.lookup(this._xData.data[0], this._xBin), 1 /* X */);
                // keep track of whether we're beginning a new area section or continuing one
                var newarea_1 = true;
                breakOnNA = this.series.attributeSet.get('BreakOnNA');
                var prevItem_1 = 0;
                for (var j = this._start; j < this._end; j += this._step) {
                    var i = this.series.getSampleIndex(j);
                    var dataItem = this._xData.getAt(i);
                    // helper function to break area (on NA or gap)
                    var startNewArea = function () {
                        ctx.lineTo(x_1, minY);
                        ctx.lineTo(minX, minY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.beginPath();
                        newarea_1 = true;
                    };
                    if (dataItem == null || this._yData.getAt(i) == null || isNaN(this._yData.getAt(i))) {
                        if (!newarea_1 && breakOnNA) {
                            startNewArea();
                        }
                        continue;
                    }
                    var dpGap = (j > this._start) && this._xScale.gapBetweenDatapoints(prevItem_1, dataItem);
                    prevItem_1 = dataItem;
                    if (this.series.breakOnGap && dpGap) {
                        startNewArea();
                    }
                    // Draw each data point as a point on a line
                    var oldX = x_1;
                    var oldY = y_1;
                    x_1 = prm.plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */);
                    y_1 = prm.plot.subPlotFromNDC(this._yScale.lookup(this._yData.getAt(i), this._yBin), 2 /* Y */);
                    if (newarea_1) {
                        minX = x_1;
                        ctx.moveTo(x_1, y_1);
                        newarea_1 = false;
                    }
                    else {
                        var midX = x_1;
                        var midY = y_1;
                        if (horizVert) {
                            midY = oldY;
                        }
                        else {
                            midX = oldX;
                        }
                        ctx.lineTo(midX, midY);
                        ctx.lineTo(x_1, y_1);
                        // set up hit shapes. Just like on area, half of each rect points to the previous data point,
                        // and half to the next point
                        var rectX1 = oldX;
                        var rectY1 = midY;
                        var rectW = Math.abs(x_1 - oldX);
                        var rectH = Math.abs(midY - minY);
                        var hitRect1 = new FDSRectangleHitShape(rectX1 + prm.plotRect.x1, rectY1 + prm.plotRect.y1, rectW / 2, rectH);
                        hitRect1.index = i - 1;
                        var hitRect2 = new FDSRectangleHitShape(rectX1 + prm.plotRect.x1 + (rectW / 2), rectY1 + prm.plotRect.y1, rectW / 2, rectH);
                        hitRect2.index = i;
                        this.series.hitVector.push(hitRect1);
                        this.series.hitVector.push(hitRect2);
                        // also add pixel points
                        // add the first point from the left rect
                        if (i - 1 === 0) {
                            var pixX_1 = Math.round(rectX1 + (rectW / 4) + prm.plotRect.x1);
                            var pixY_1 = Math.round(rectY1 + (rectH / 2) + prm.plotRect.y1);
                            pixelPoints[i - 1] = { x: pixX_1, y: pixY_1 };
                        }
                        // and do the rest of the points from the right rect
                        var pixX = Math.round(rectX1 + ((3 * rectW) / 4) + prm.plotRect.x1);
                        var pixY = Math.round(rectY1 + (rectH / 2) + prm.plotRect.y1);
                        pixelPoints[i] = { x: pixX, y: pixY };
                    }
                }
                ctx.lineTo(x_1, minY);
                ctx.lineTo(minX, minY);
                ctx.closePath();
                ctx.fill();
            }
            // Draw the outline on the actual data points
            ctx.beginPath();
            var x = minX = prm.plot.subPlotFromNDC(this._xScale.lookup(this._xData.data[0], this._xBin), 1 /* X */);
            var y = minY;
            var newline = true;
            var prevItem = 0;
            for (var j = this._start; j < this._end; j += this._step) {
                var i = this.series.getSampleIndex(j);
                var dataItem = this._xData.getAt(i);
                // helper function for closing area
                var startNewArea = function () {
                    ctx.lineTo(x, minY);
                    ctx.lineTo(minX, minY);
                    ctx.closePath();
                    ctx.stroke();
                    newline = true;
                    ctx.beginPath();
                };
                if (dataItem == null || this._yData.data[j] == null || isNaN(this._yData.data[j])) {
                    if (breakOnNA) {
                        startNewArea();
                    }
                    continue;
                }
                var dpGap = (j > this._start) && this._xScale.gapBetweenDatapoints(prevItem, dataItem);
                prevItem = dataItem;
                if (this.series.breakOnGap && dpGap) {
                    startNewArea();
                }
                // Draw each data point as a point on a line
                var oldX = x;
                var oldY = y;
                x = prm.plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */);
                y = prm.plot.subPlotFromNDC(this._yScale.lookup(this._yData.data[j], this._yBin), 2 /* Y */);
                if (newline) {
                    ctx.moveTo(x, y);
                    minX = x;
                    newline = false;
                }
                else {
                    var midX = x;
                    var midY = y;
                    if (horizVert) {
                        midY = oldY;
                    }
                    else {
                        midX = oldX;
                    }
                    ctx.lineTo(midX, midY);
                    ctx.lineTo(x, y);
                }
                this.series.addLookupPoint(x + prm.plotRect.x1, [y + prm.plotRect.y1], j);
            }
            ctx.lineTo(x, minY);
            ctx.lineTo(minX, minY);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
            this.root.pixelPoints[this.series.id] = pixelPoints;
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                this.series.seriesBGBrush.popHistory();
            }
        };
        AreaStepDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            var pen = this.series.seriesOutlinePen.with({ width: 1 });
            pen.setOnCanvas(ctx);
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                this.series.seriesBGBrush.pushHistory();
                this.series.seriesBGBrush.setAttr('color', this.series.seriesFGPen.color);
            }
            this.series.seriesBGBrush.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            ctx.beginPath();
            ctx.moveTo(x - minus, y + minus);
            ctx.lineTo(x - minus, y);
            ctx.lineTo(x, y);
            ctx.lineTo(x, y - plus);
            ctx.lineTo(x + halfplus, y - plus);
            ctx.lineTo(x + halfplus, y + minus);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                this.series.seriesBGBrush.popHistory();
            }
        };
        AreaStepDrawStyle.prototype.verify = function () {
            return true;
        };
        AreaStepDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return AreaStepDrawStyle;
    }(BaseDrawStyle));
    
    var ArrowDrawStyle = /** @class */ (function (_super) {
        __extends(ArrowDrawStyle, _super);
        function ArrowDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            if (_this._rc == null) {
                _this._rc = _this.series.renderCache = new BaseRenderCache(_this.series);
            }
            return _this;
        }
        ArrowDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        ArrowDrawStyle.prototype.verify = function () {
            return true;
        };
        ArrowDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        ArrowDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            var width = this.series.arrowSize;
            // select the seriesFGPen to draw with on this canvas
            this.series.seriesFGPen.setOnCanvas(ctx);
            var pixelPoints = {};
            for (var i = 0; i < this.series.size; i += 2) {
                this.series.seriesBGBrush.setOnCanvas(ctx, prm.plotRect);
                if (this.series.useColor) {
                    var colorData = this.series.getData(4 /* COLOR */);
                }
                var xPt1 = this._xData.getAt(i);
                var yPt1 = this._yData.getAt(i);
                var xPt2 = this._xData.data[i + 1];
                var yPt2 = this._yData.data[i + 1];
                if ((isNaN(xPt1)) || (isNaN(xPt2)) || (isNaN(yPt1)) ||
                    (isNaN(yPt2))) {
                    ctx.restore();
                    return;
                }
                var x1 = (prm.plot.subPlotFromNDC(this._xScale.lookup(xPt1, this._xBin), 1 /* X */));
                var x2 = (prm.plot.subPlotFromNDC(this._xScale.lookup(xPt2, this._xBin), 1 /* X */));
                var y1 = (prm.plot.subPlotFromNDC(this._yScale.lookup(yPt1, this._yBin), 2 /* Y */));
                var y2 = (prm.plot.subPlotFromNDC(this._yScale.lookup(yPt2, this._yBin), 2 /* Y */));
                var wscale = this.series.arrowWidthScale;
                var hscale = this.series.arrowLengthScale;
                if (width === 0 || wscale === 0 || hscale === 0) {
                    ctx.restore();
                    return;
                }
                var vx = x2 - x1;
                var vy = y1 - y2;
                var length_1 = Math.sqrt(Math.pow(vx, 2.0) + Math.pow(vy, 2.0));
                if (this.series.arrowScalesWithLength && this._rc.prevLength !== length_1) {
                    if (this._rc.prevLength !== -1) {
                        var ratio = length_1 / this._rc.prevLength;
                        width *= ratio;
                    }
                    this._rc.prevLength = length_1;
                    this.series.arrowSize = width;
                }
                if (length_1 === 0.0) {
                    ctx.restore();
                    return;
                }
                var npx = vy / length_1;
                var npy = vx / length_1;
                if ((width * hscale) > length_1) {
                    width = length_1 / hscale;
                }
                var hnpw = (npx * width) / 2;
                var hnpl = (npy * width) / 2;
                var p1 = new Point(x1 + hnpw, y1 + hnpl);
                var p2 = new Point(x1 - hnpw, y1 - hnpl);
                var p3 = new Point(x2 - hnpw - (hscale * hnpl * 2), (y2 - hnpl) + (hscale * hnpw * 2));
                var p4 = new Point(x2 - (wscale * hnpw) - (hscale * hnpl * 2), (y2 - (wscale * hnpl)) + (hscale * hnpw * 2));
                var p5 = new Point(x2, y2);
                var p6 = new Point((x2 + (wscale * hnpw)) - (hscale * hnpl * 2), y2 + (wscale * hnpl) + (hscale * hnpw * 2));
                var p7 = new Point((x2 + hnpw) - (hscale * hnpl * 2), y2 + hnpl + (hscale * hnpw * 2));
                var p8 = new Point(x1, y1);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.lineTo(p5.x, p5.y);
                ctx.lineTo(p6.x, p6.y);
                ctx.lineTo(p7.x, p7.y);
                ctx.lineTo(p1.x, p1.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                // hitShapes
                var lineHitShapes = [];
                var pointHitShapes = [];
                var points = [];
                points.push(p1);
                points.push(p2);
                points.push(p3);
                points.push(p4);
                points.push(p5);
                points.push(p6);
                points.push(p7);
                points.push(p8);
                for (var j = 0; j <= points.length - 2; j++) {
                    var tmp1 = new Point(points[j].x, points[j].y);
                    var tmp2 = new Point(points[j + 1].x, points[j + 1].y);
                    // loop back around
                    if (points[j + 1] === p8) {
                        tmp2 = new Point(p1.x, p1.y);
                    }
                    var midX_1 = tmp1.x + ((tmp2.x - tmp1.x) / 2);
                    var midY_1 = tmp1.y + ((tmp2.y - tmp1.y) / 2);
                    var lineTemp1_1 = new FDSLineHitShape(tmp1.x + prm.plotRect.x1, tmp1.y + prm.plotRect.y1, midX_1 + prm.plotRect.x1, midY_1 + prm.plotRect.y1);
                    lineTemp1_1.index = i;
                    lineTemp1_1.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    lineTemp1_1.name = 5 /* SERIESHIT */;
                    var lineTemp2_1 = new FDSLineHitShape(midX_1 + prm.plotRect.x1, midY_1 + prm.plotRect.y1, tmp2.x + prm.plotRect.x1, tmp2.y + prm.plotRect.y1);
                    lineTemp2_1.index = i;
                    lineTemp2_1.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    lineTemp2_1.name = 5 /* SERIESHIT */;
                    lineHitShapes.push(lineTemp2_1);
                    lineHitShapes.push(lineTemp1_1);
                }
                var midX = p8.x + ((p5.x - p8.x) / 2);
                var midY = p8.y + ((p5.y - p8.y) / 2);
                var lineTemp1 = new FDSLineHitShape(p8.x + prm.plotRect.x1, p8.y + prm.plotRect.y1, midX + prm.plotRect.x1, midY + prm.plotRect.y1);
                lineTemp1.index = i;
                lineTemp1.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                lineTemp1.name = 5 /* SERIESHIT */;
                var lineTemp2 = new FDSLineHitShape(midX + prm.plotRect.x1, midY + prm.plotRect.y1, p5.x + prm.plotRect.x1, p5.y + prm.plotRect.y1);
                lineTemp2.index = i + 1;
                lineTemp2.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                lineTemp2.name = 5 /* SERIESHIT */;
                lineHitShapes.push(lineTemp2);
                lineHitShapes.push(lineTemp1);
                var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
                var rectTemp1 = new FDSRectangleHitShape((p8.x + prm.plotRect.x1) - dpSize, (p8.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rectTemp1.index = i;
                rectTemp1.name = 3 /* DATAPOINT */;
                var rectTemp2 = new FDSRectangleHitShape((p5.x + prm.plotRect.x1) - dpSize, (p5.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rectTemp2.index = i + 1;
                rectTemp2.name = 3 /* DATAPOINT */;
                pointHitShapes.push(rectTemp2);
                pointHitShapes.push(rectTemp1);
                // also save some pixelPoints
                var pixX = Math.round((lineTemp1.x1 + lineTemp1.x2) / 2);
                var pixY = Math.round((lineTemp1.y1 + lineTemp1.y2) / 2);
                pixelPoints[i] = { x: pixX, y: pixY };
                pixX = Math.round((lineTemp2.x1 + lineTemp2.x2) / 2);
                pixY = Math.round((lineTemp2.y1 + lineTemp2.y2) / 2);
                pixelPoints[i + 1] = { x: pixX, y: pixY };
                this.series.hitVector = this.series.hitVector.concat(lineHitShapes);
                this.series.hitVector = this.series.hitVector.concat(pointHitShapes);
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        ArrowDrawStyle.prototype.drawSelectionMarkers = function (prm, ctx) {
            if (!this.series.isSelected() || !this.series.visible) {
                return;
            }
            ctx.save();
            ctx.translate(prm.plotRect.x1, prm.plotRect.y1);
            this._setupSelectionMarkerPenAndBrush(this.root.canvasDifferenceSupported(), ctx);
            var xPt1 = this._xData.getAt(0);
            var yPt1 = this._yData.getAt(0);
            var xPt2 = this._xData.getAt(1);
            var yPt2 = this._yData.getAt(1);
            if ((isNaN(xPt1)) || (isNaN(xPt2)) || (isNaN(yPt1)) ||
                (isNaN(yPt2))) {
                ctx.restore();
                return;
            }
            var x1 = (prm.plot.subPlotFromNDC(this._xScale.lookup(xPt1, this._xBin), 1 /* X */));
            var x2 = (prm.plot.subPlotFromNDC(this._xScale.lookup(xPt2, this._xBin), 1 /* X */));
            var y1 = (prm.plot.subPlotFromNDC(this._yScale.lookup(yPt1, this._yBin), 2 /* Y */));
            var y2 = (prm.plot.subPlotFromNDC(this._yScale.lookup(yPt2, this._yBin), 2 /* Y */));
            var circleSize = this.series.interactionHandleSize;
            var circleMarkerFunctor = getMarkerDrawFunctor(1 /* CIRCLE */, circleSize * 2);
            ctx.beginPath();
            circleMarkerFunctor(ctx, x1, y1);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            circleMarkerFunctor(ctx, x2, y2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            // save pixel points for all selected points
            this.root.interactionHandlePixelPoints[this.series.id] = [
                { x: x1 + prm.plotRect.x1, y: y1 + prm.plotRect.y1 },
                { x: x2 + prm.plotRect.x1, y: y2 + prm.plotRect.y1 }
            ];
        };
        return ArrowDrawStyle;
    }(BaseDrawStyle));
    
    var BarIndicatorDrawstyle = /** @class */ (function (_super) {
        __extends(BarIndicatorDrawstyle, _super);
        function BarIndicatorDrawstyle(series) {
            var _this = _super.call(this, series, getDimFromSeries(series)) || this;
            if (_this._dim === 1 /* X */) {
                _this._otherDim = 2 /* Y */;
                _this._lineDataToPoints = function (lineData, offset) { return ({
                    pt1: new Point(~~lineData.startPixel + offset.x, ~~lineData.valuePixel + offset.y),
                    pt2: new Point(lineData.endPixel + offset.x, ~~lineData.valuePixel + offset.y),
                }); };
                _this._appendLineToPath = function (ctx, startPixel, endPixel, valuePixel) { return ctx.appendHorizontalLineToPath(startPixel, endPixel, valuePixel); },
                    _this._appendMarkerToPath = function (ctx, x, y, markerDims, aliasOffset) {
                        ctx.moveTo(x + markerDims.length, ~~y + aliasOffset);
                        ctx.lineTo(x, ~~y - (markerDims.size / 2) + aliasOffset);
                        ctx.lineTo(x, ~~y + (markerDims.size / 2) + aliasOffset);
                        ctx.closePath();
                    };
                _this._legendMarker = function (ctx, x, y, offset, markerDim) { return _this._appendMarkerToPath(ctx, x - offset - 0.5, y, markerDim, 0.5); };
                _this._binnedInfo = {
                    data: _this._xData,
                    scale: _this._xScale,
                    bin: _this._xBin,
                };
                _this._valueInfo = {
                    data: _this._yData,
                    scale: _this._yScale,
                    bin: _this._yBin,
                };
            }
            else {
                _this._otherDim = 1 /* X */;
                _this._lineDataToPoints = function (lineData, offset) { return ({
                    pt1: new Point(~~lineData.valuePixel + offset.x, ~~lineData.startPixel + offset.y),
                    pt2: new Point(~~lineData.valuePixel + offset.x, ~~lineData.endPixel + offset.y),
                }); };
                _this._appendLineToPath = function (ctx, startPixel, endPixel, valuePixel) { return ctx.appendVerticalLineToPath(startPixel, endPixel, valuePixel); },
                    _this._appendMarkerToPath = function (ctx, y, x, markerDims, aliasOffset) {
                        ctx.moveTo(~~x + aliasOffset, y + markerDims.length);
                        ctx.lineTo(~~x - (markerDims.size / 2) + aliasOffset, y);
                        ctx.lineTo(~~x + (markerDims.size / 2) + aliasOffset, y);
                        ctx.closePath();
                    },
                    _this._legendMarker = function (ctx, x, y, offset, markerDim) { return _this._appendMarkerToPath(ctx, y - offset - 0.5, x, markerDim, 0.5); };
                _this._binnedInfo = {
                    data: _this._yData,
                    scale: _this._yScale,
                    bin: _this._yBin,
                };
                _this._valueInfo = {
                    data: _this._xData,
                    scale: _this._xScale,
                    bin: _this._xBin,
                };
            }
            return _this;
        }
        BarIndicatorDrawstyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.setPen(this.series.seriesOutlinePen);
            var aliasOffset = this.series.seriesOutlinePen.getAliasOffset();
            this.series.seriesOutlinePen.useAsFill(ctx);
            ctx.beginPath();
            var plot = prm.plot;
            var markerDims = getMarkerSizeFromSeries(this.series);
            var lines = this._getDrawnMarkerLines(plot, markerDims);
            // Draw the lines first in one pass (saves on calls to stroke / fill)
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var _a = lines_1[_i], startPixel = _a.startPixel, endPixel = _a.endPixel, valuePixel = _a.valuePixel;
                this._appendLineToPath(ctx, startPixel, endPixel, valuePixel);
            }
            ctx.stroke();
            // Draw the triangle markers in an additional pass
            for (var _b = 0, lines_2 = lines; _b < lines_2.length; _b++) {
                var _c = lines_2[_b], startPixel = _c.startPixel, valuePixel = _c.valuePixel;
                this._appendMarkerToPath(ctx, startPixel, valuePixel, markerDims, aliasOffset);
            }
            ctx.fill();
            this._buildHitShapes(prm, lines);
        };
        BarIndicatorDrawstyle.prototype._buildHitShapes = function (prm, lineData) {
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            var offset = { x: prm.plotRect.x1, y: prm.plotRect.y1 };
            var infoboxPosition = this._dim === 2 /* Y */ ? "above" /* above */ : "left";
            for (var _i = 0, lineData_1 = lineData; _i < lineData_1.length; _i++) {
                var line = lineData_1[_i];
                var _a = this._lineDataToPoints(line, offset), pt1 = _a.pt1, pt2 = _a.pt2;
                pixelPoints[line.index] = { x: (pt1.x + pt2.x) / 2, y: (pt1.y + pt2.y) / 2 };
                infoboxPixelPoints[line.index] = { point: pt1, position: infoboxPosition };
                var hitshape = new FDSLineHitShape(pt1.x, pt1.y, pt2.x, pt2.y);
                hitshape.index = line.index;
                this.series.hitVector.push(hitshape);
                if (this.seriesSelected && this._selectionSampler.isPointSampled(line.index)) {
                    this.cacheSelectableInChartSpace(prm, 0 /* NONE */, pt1);
                    this.cacheSelectableInChartSpace(prm, 0 /* NONE */, pt2);
                }
            }
            // save those pixel points (and overwrite any old data)
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
        };
        BarIndicatorDrawstyle.prototype._getDrawnMarkerLines = function (plot, markerDims) {
            var drawnLines = [];
            var binFactor = this._binnedInfo.scale.getBinFactor();
            var barOffset = (1 - clamp(binFactor, 0, 1)) / 2;
            var markerOffset = markerDims.length / 2;
            // Horizontal bar charts need to be adjusted by one pixel for the marker to line up well.
            var startAdjustment = this._dim === 2 /* Y */ ? 1 : 0;
            for (var j = this._start; j < this._end; j += this._step) {
                var index = this.series.getSampleIndex(j);
                var ndcInfo = this._getRangeSpan(index);
                if (!ndcInfo) {
                    continue;
                }
                var startPixel = plot.subPlotFromNDC(ndcInfo.range.start, this._dim);
                var endPixel = plot.subPlotFromNDC(ndcInfo.range.end, this._dim);
                if (startPixel > endPixel) {
                    _a = [endPixel, startPixel], startPixel = _a[0], endPixel = _a[1];
                }
                var barOffsetPixels = (endPixel - startPixel) * barOffset;
                var barStart = startPixel + barOffsetPixels + startAdjustment;
                var barEnd = endPixel - barOffsetPixels;
                startPixel = Math.floor(Math.max(startPixel, barStart - markerOffset));
                endPixel = Math.ceil(Math.min(endPixel, barEnd + markerOffset));
                for (var _i = 0, _b = ndcInfo.values; _i < _b.length; _i++) {
                    var valueNdc = _b[_i];
                    var valuePixel = plot.subPlotFromNDC(valueNdc, this._otherDim);
                    drawnLines.push({ valuePixel: valuePixel, startPixel: startPixel, endPixel: endPixel, index: index });
                }
            }
            return drawnLines;
            var _a;
        };
        BarIndicatorDrawstyle.prototype._getRangeSpan = function (index) {
            var _a = this, _binnedInfo = _a._binnedInfo, _valueInfo = _a._valueInfo;
            var rangeVal = _binnedInfo.data.getAt(index);
            if (IsSomeInternalNAN(rangeVal)) {
                return undefined;
            }
            var _b = _binnedInfo.scale.lookupRange(rangeVal, _binnedInfo.bin), low = _b[1], high = _b[2];
            var range = new Range(low, high);
            var values$$1 = [];
            for (var d = 0; d < _valueInfo.data.getDimension(); d++) {
                var valueVal = _valueInfo.data.getAt(index, d);
                if (!IsSomeInternalNAN(rangeVal)) {
                    values$$1.push(_valueInfo.scale.lookup(valueVal, _valueInfo.bin));
                }
            }
            return { range: range, values: values$$1 };
        };
        BarIndicatorDrawstyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesOutlinePen.useAsFill(ctx);
            var markerDim = getMarkerSizeFromSeries(this.series);
            var centerOffset = Math.round(markerDim.length / 2);
            ctx.beginPath();
            this._legendMarker(ctx, x, y, centerOffset, markerDim);
            ctx.fill();
        };
        BarIndicatorDrawstyle.prototype.drawMarkersToBuffer = function (prm, ctx) {
            // Intentionally not implemented.
        };
        BarIndicatorDrawstyle.prototype.verify = function () {
            if (!this._xScale || !this._yScale) {
                return false;
            }
            // This is only a valid drawstyle if x or y are binned, but not both.
            return this._xScale.getBinned() !== this._yScale.getBinned();
        };
        BarIndicatorDrawstyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        return BarIndicatorDrawstyle;
    }(BaseDrawStyle));
    function getMarkerSizeFromSeries(series) {
        var size = devicePixelRatio * series.markerSize;
        var length = getHeightOfEquilateralTriangle(size);
        return { size: size, length: length };
    }
    function getDimFromSeries(series) {
        if (checkScale(1 /* X */)) {
            return 1 /* X */;
        }
        else if (checkScale(2 /* Y */)) {
            return 2 /* Y */;
        }
        else {
            return undefined;
        }
        function checkScale(dim) {
            var scale = series.getScale(dim);
            return scale && scale.getBinned();
        }
    }
    function getHeightOfEquilateralTriangle(sideLength) {
        return sideLength * 0.5 * Math.sqrt(3);
    }
    
    var OldBarsDrawStyle = /** @class */ (function (_super) {
        __extends(OldBarsDrawStyle, _super);
        function OldBarsDrawStyle(series) {
            var _this = _super.call(this, series, 2 /* Y */) || this;
            _this.is3D = false;
            _this.isThin = false;
            return _this;
        }
        OldBarsDrawStyle.prototype.computeWorldBarBases = function () {
            var barBases = _super.prototype.computeWorldBarBases.call(this);
            if (this.series.isStacked) {
                var xAxis = this.series.getAxis(1 /* X */);
                if (this.series.attributeSet.isInheritedDefault('SeriesXReference') &&
                    xAxis.attributeSet.isInheritedDefault('Reference')) {
                    barBases.ndcX = this._xScale.lookup(0);
                }
            }
            return barBases;
        };
        OldBarsDrawStyle.prototype.getCoordinates = function (prm, i, passedVals, retVals) {
            var initOffset = 0.0;
            _a = this._yScale.lookupRange(passedVals.yval1), retVals.y1 = _a[1], retVals.y2 = _a[2], initOffset = _a[3];
            if (fuzzyLT(initOffset, 0.001)) {
                initOffset = 0.0;
            }
            var delta = ((retVals.y2 - initOffset) - (retVals.y1 + initOffset)) / prm.nVerticalBars;
            retVals.y1 = retVals.y1 + initOffset + (delta * this.series.barNumber * Number(prm.useDelta));
            retVals.y1 = retVals.y2 = (prm.plot.subPlotFromNDC(retVals.y1, 2 /* Y */) +
                prm.plot.subPlotFromNDC(retVals.y1 + delta, 2 /* Y */)) / 2.0;
            retVals.x1 = prm.plot.subPlotFromNDC(this._xScale.lookup(passedVals.xval1), 1 /* X */);
            return retVals;
            var _a;
        };
        OldBarsDrawStyle.prototype._drawThinBarBracket = function (ctx, barBasePixels, topEdgePixels, bottomEdgePixels, lineWidth) {
            var bracketSize = scaleByDevicePixelRatio(4);
            // Bracket legs
            ctx.fillRect(barBasePixels - bracketSize, topEdgePixels, bracketSize, lineWidth);
            ctx.fillRect(barBasePixels - bracketSize, bottomEdgePixels - lineWidth, bracketSize, lineWidth);
            // Bracket body
            ctx.fillRect(barBasePixels - lineWidth, topEdgePixels, lineWidth, bottomEdgePixels - topEdgePixels);
        };
        OldBarsDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            var _this = this;
            // Determine if we are rendering in the outlier style
            if (this._xScale.outlierActive() && this.series.seriesOutlierIndicator) {
                this._outlierDrawToBuffer(prm, ctx);
                return;
            }
            if (this.series.isStacked) {
                if (prm.renderCache.barsSumMap == null) {
                    prm.renderCache.barsSumMap = {};
                }
            }
            ctx.save();
            var plot = prm.plot, nVerticalBars = prm.nVerticalBars;
            var ndcX = this.computeWorldBarBases().ndcX;
            // clamping to prevent drawing off the canvas
            var xRef = clamp(ndcX, 0, 1);
            // Adding 0.5 here for rounding to the nearest integer
            // and the +1 is to make it draw left of the axis line for
            // negative bars, and on the axis line for positive bars
            var x1 = (~~((plot.subPlotFromNDC(xRef, 1 /* X */)) + 0.5)) + 1;
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            var _a = this._choosePens(ctx, false), brush = _a.brush, pen = _a.pen, penProps = _a.penProps;
            // set up a list of indices so we can control what order the points are printed in
            var indices = [];
            for (var i = 0; i < this.series.size; i++) {
                indices.push(i);
            }
            if (this.is3D) {
                // sort them by their y value so they print from top to bottom
                indices.sort(function (a, b) { return _this._yData.data[b] -
                    _this._yData.data[a]; });
            }
            var selectionIndex = 0;
            for (var k = 0; k < indices.length; k += this._step) {
                var j = indices[k];
                var i = this.series.getSampleIndex(j);
                var yPoint = this._yData.getAt(i);
                var xPoint = this._xData.getAt(i);
                if (xPoint == null || yPoint == null || isNaN(xPoint) || IsSomeInternalNAN(yPoint)) {
                    continue;
                }
                if (this.series.useColor) {
                    this._setColorMapColor(ctx, brush, colorData.getAt(i), i);
                }
                var y1 = void 0, yValue1 = void 0, y2 = void 0, initOffset = void 0;
                _b = this._yScale.lookupRange(yPoint), yValue1 = _b[0], y1 = _b[1], y2 = _b[2], initOffset = _b[3];
                var offset = initOffset >= 0.001 ? initOffset : 0;
                var offset3d = offset * (prm.plotRect.y2 - prm.plotRect.y1);
                var binPlacementInfo = {
                    binStartNdc: y1,
                    binEndNdc: y2,
                    binFactorOffsetNdc: offset,
                };
                var innerBinPadding = BaseRectangularDrawStyle.getInnerBinPaddingAsNdc(this._yScale.axis, binPlacementInfo);
                var subBinPosition = BaseRectangularDrawStyle.getSubBinPosition(this.series.barNumber, nVerticalBars, binPlacementInfo, innerBinPadding);
                y1 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinStartNdc, 2 /* Y */));
                y2 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinEndNdc, 2 /* Y */));
                var bracketY1 = y1;
                var bracketY2 = y2;
                if (this.isThin) {
                    y1 = y2 = Math.round((y1 + y2) / 2);
                }
                // Stacked 2.0
                var positiveStacking = false;
                var x2 = void 0;
                var nx1 = void 0, nx2 = void 0;
                if (this.series.isStacked) {
                    _c = this.stackSegmentDistance(prm, 1 /* X */, yPoint, false), nx1 = _c[0], x1 = _c[1];
                    _d = this.stackSegmentDistance(prm, 1 /* X */, yPoint, true), nx2 = _d[0], x2 = _d[1];
                    x1 = ~~(plot.subPlotFromNDC(x1, 1 /* X */));
                    positiveStacking = (nx1 === nx2);
                }
                else {
                    x2 = this._xScale.lookup(xPoint, this._xBin);
                }
                x2 = ~~(plot.subPlotFromNDC(x2, 1 /* X */));
                if (!this.isThin && (y1 <= y2)) {
                    y1 = y2 + 1;
                }
                // we want to always draw from the top left corner
                // of the bar. The -1 comes from the PC chart drawing negative bars
                // 1px below the axis line and positive bars on the axis line
                var baseX1 = Math.min(x1, x2) - 1;
                var baseX2 = baseX1 + Math.abs(x1 - x2);
                // these are the coords that the bar will draw on
                var drawX1 = baseX1;
                var drawX2 = baseX2;
                var drawY1 = y1;
                var drawY2 = y2;
                if (this.series.isStacked) {
                    if (!positiveStacking) {
                        nx1 = ~~(plot.subPlotFromNDC(nx1, 1 /* X */));
                        nx2 = ~~(plot.subPlotFromNDC(nx2, 1 /* X */));
                        drawX1 = nx1;
                        drawX2 = nx2;
                    }
                    // save points to a cache
                    if (prm.renderCache.barsSumMap[yPoint] == null) {
                        prm.renderCache.barsSumMap[yPoint] = {};
                    }
                    prm.renderCache.barsSumMap[yPoint][this.series.id] = drawX2;
                }
                var drawWidth = Math.abs(drawX1 - drawX2);
                var drawHeight = Math.abs(drawY1 - drawY2);
                // save the pixel points, including the space before/above the plot rect
                var pR = prm.plot.plotRect;
                var x = Math.min(drawX1, drawX2);
                var y = Math.min(drawY1, drawY2);
                x = Math.round(x + (drawWidth / 2));
                y = Math.round(y + (drawHeight / 2));
                pixelPoints[i] = { x: x + pR.x1, y: y + pR.y1 };
                var isLeftOfReferenceLine = this.series.isStacked ? !positiveStacking : x1 > x2;
                if (isLeftOfReferenceLine) {
                    infoboxPixelPoints[i] = {
                        point: { x: Math.min(drawX1, drawX2) + pR.x1, y: y + pR.y1 },
                        position: "left" /* left */
                    };
                }
                else {
                    infoboxPixelPoints[i] = {
                        point: { x: Math.max(drawX1, drawX2) + pR.x1, y: y + pR.y1 },
                        position: "right" /* right */
                    };
                }
                if (!this.series.barColumn3dDepthFactorDefault) {
                    // they give us the depth, we need to get the x and y offset
                    x = this.series.barColumn3dDepthFactor * drawHeight;
                    offset3d = Math.sqrt((x * x) / 2);
                }
                if (this.is3D) {
                    if (this.series.isStacked) {
                        var obj = {
                            x1: Math.min(drawX1, drawX2),
                            x2: Math.max(drawX1, drawX2),
                            y1: drawY1,
                            y2: drawY2,
                            brush: brush,
                            pen: pen,
                            offset3D: offset3d,
                            series: this.series
                        };
                        if (prm.stacked3DBars[y1] != null) {
                            prm.stacked3DBars[y1].push(obj);
                        }
                        else {
                            prm.stacked3DBars[y1] = [obj];
                        }
                    }
                    else {
                        // the true tells it to draw the bars going up instead of down
                        this._draw3DBar(drawX1, drawX2, drawY1, drawY2, ctx, pen, brush, offset3d, true);
                    }
                }
                else if (this.isThin) {
                    // Rendering as a rect because it is supposedly more efficient
                    if (this.series.drawThinColumnBrackets) {
                        this._drawThinBarBracket(ctx, drawX1, bracketY1, bracketY2, penProps.lineWidth);
                    }
                    ctx.fillRect(drawX1, drawY1, drawWidth, penProps.lineWidth);
                }
                else if (this.series.isStacked) {
                    var strokeWidth = drawWidth - 1;
                    var strokeHeight = drawHeight - 1;
                    brush.setOnCanvas(ctx, new Rectangle(drawX1, drawY1, drawX2, drawY2));
                    if (positiveStacking) {
                        ctx.fillRect(drawX1, drawY2, drawWidth, drawHeight);
                        ctx.strokeRect(drawX1 + penProps.aliasOffset, drawY2 + penProps.aliasOffset, strokeWidth, strokeHeight);
                    }
                    else {
                        ctx.fillRect(drawX2, drawY2, drawWidth, drawHeight);
                        ctx.strokeRect(drawX2 + penProps.aliasOffset, drawY2 + penProps.aliasOffset, strokeWidth, strokeHeight);
                    }
                }
                else {
                    var strokeWidth = drawWidth - 1;
                    var strokeHeight = drawHeight - 1;
                    brush.setOnCanvas(ctx, new Rectangle(drawX1, drawY1, drawX2, drawY2));
                    ctx.fillRect(drawX1, drawY2, drawWidth, drawHeight);
                    ctx.strokeRect(drawX1 + penProps.aliasOffset, drawY2 + penProps.aliasOffset, strokeWidth, strokeHeight);
                }
                if (this.series.isStacked) {
                    this._addSeriesValuesAndMarkersForStacked(drawHeight, drawWidth, prm, drawX1, drawY1, positiveStacking);
                }
                var minY = Math.min(y1, y2);
                var maxY = Math.max(y1, y2);
                // Stores the selection marker point positions
                var selMarkerX1 = baseX1;
                var selMarkerY1 = minY;
                var selMarkerX2 = baseX2;
                var selMarkerY2 = maxY;
                var hitShape = void 0;
                if (this.is3D && (!this.series.isStacked)) {
                    // the true tells it the bars go up instead of down
                    hitShape = this._make3DHitShape(baseX1 + prm.plotRect.x1, minY + prm.plotRect.y1, baseX2 + prm.plotRect.x1, maxY + prm.plotRect.y1, offset3d, true);
                }
                else if (this.isThin) {
                    var hitH = penProps.lineWidth;
                    hitShape = new FDSLineHitShape(baseX1 + prm.plotRect.x1, minY + prm.plotRect.y1, baseX2 + prm.plotRect.x1, minY + hitH + prm.plotRect.y1);
                    // Selection Marker Positioning
                    selMarkerX2 = baseX1 + Math.abs(x2 - x1);
                    selMarkerY2 = minY + hitH;
                }
                else if (this.series.isStacked) {
                    if (x1 !== x2) {
                        if (this.is3D) {
                            hitShape = this._make3DHitShape(x1 + prm.plotRect.x1, minY + prm.plotRect.y1, x1 + Math.abs(x2 - x1) + prm.plotRect.x1, minY + (maxY - minY) + prm.plotRect.y1, offset3d, true);
                        }
                        else {
                            hitShape = new FDSRectangleHitShape(x1 + prm.plotRect.x1, minY + prm.plotRect.y1, Math.abs(x2 - x1), maxY - minY);
                        }
                        // Selection Marker Positioning
                        selMarkerX1 = x1;
                        selMarkerX2 = x1 + Math.abs(x2 - x1);
                        selMarkerY2 = minY + (maxY - minY);
                    }
                    else {
                        if (this.is3D) {
                            hitShape = this._make3DHitShape(nx2 + prm.plotRect.x1, y2 + prm.plotRect.y1, nx2 + Math.abs(nx2 - nx1) + prm.plotRect.x1, y2 + (maxY - minY) + prm.plotRect.y1, offset3d, true);
                        }
                        else {
                            hitShape = new FDSRectangleHitShape(nx2 + prm.plotRect.x1, y2 + prm.plotRect.y1, Math.abs(nx2 - nx1), maxY - minY);
                        }
                        // Selection Marker Positioning
                        selMarkerX1 = nx2;
                        selMarkerY1 = y2;
                        selMarkerX2 = nx2 + Math.abs(nx2 - nx1);
                        selMarkerY2 = y2 + (maxY - minY);
                    }
                }
                else {
                    var hitH = maxY - minY;
                    hitShape = new FDSRectangleHitShape(baseX1 + prm.plotRect.x1, minY + prm.plotRect.y1, Math.abs(x2 - x1), hitH);
                    // Selection Marker positioning
                    selMarkerX2 = baseX1 + Math.abs(x2 - x1);
                    selMarkerY2 = minY + hitH;
                }
                hitShape.index = i;
                this.series.hitVector.push(hitShape);
                // Cache the selection marker positions
                if (this.seriesSelected && Math.abs(selMarkerX2 - selMarkerX1) >= 1 &&
                    this._selectionSampler.isPointSampled(selectionIndex++)) {
                    this.cacheSelectable(prm, 0 /* NONE */, selMarkerX1, selMarkerY1);
                    this.cacheSelectable(prm, 0 /* NONE */, selMarkerX2, selMarkerY1);
                    if (!this.isThin) {
                        this.cacheSelectable(prm, 0 /* NONE */, selMarkerX2, selMarkerY2);
                        this.cacheSelectable(prm, 0 /* NONE */, selMarkerX1, selMarkerY2);
                    }
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
            this._resetColorMapColor(brush);
            ctx.restore();
            var _b, _c, _d;
        };
        OldBarsDrawStyle.prototype._addSeriesValuesAndMarkersForStacked = function (drawHeight, drawWidth, prm, drawX1, drawY1, positiveStacking) {
            var strokeWidth = drawWidth - 1;
            var strokeHeight = drawHeight - 1;
            if (this.series.seriesValue) {
                var xLocation = drawX1 + strokeWidth + prm.plotRect.x1;
                if (!positiveStacking) {
                    xLocation = drawX1 - strokeWidth + prm.plotRect.x1;
                }
                var point = new Point(xLocation, drawY1 - (strokeHeight / 2) + prm.plotRect.y1);
                this._labelPositions.push(point);
            }
            if (this.series.seriesMarker) {
                var point = new Point(drawX1 + strokeWidth, drawY1 + (strokeHeight / 2));
                this._markerPositions.push(point);
            }
        };
        OldBarsDrawStyle.prototype._outlierDrawToBuffer = function (prm, ctx) {
            ctx.save();
            var plot = prm.plot, nVerticalBars = prm.nVerticalBars;
            var ndcX = this.computeWorldBarBases().ndcX;
            // clamping to prevent drawing off the canvas
            var xRef = clamp(ndcX, 0, 1);
            // Adding 0.5 here for rounding to the nearest integer
            // and the +1 is to make it draw left of the axis line for
            // negative bars, and on the axis line for positive bars
            var x1 = (~~((plot.subPlotFromNDC(xRef, 1 /* X */)) + 0.5)) + 1;
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            var _a = this._choosePens(ctx, false), brush = _a.brush, penProps = _a.penProps;
            // Outlier stuff
            var breakSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorBreakSize, plot.plotRect.getWidth()));
            var hatchAngle = this.series.seriesOutlierIndicatorHatchAngle;
            var hatchSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorHatchSize, plot.plotRect.getWidth()));
            var ptMax = this._xScale.threshMax;
            var ptMin = this._xScale.threshMin;
            var valMax = this._xScale.lookup(ptMax, this._xBin);
            var valMin = this._xScale.lookup(ptMin, this._xBin);
            var markerStyle = this.series.seriesOutlierIndicatorMarkerStyle;
            var markerSize = this.series.seriesOutlierIndicatorSize;
            var outlierStyle = this.series.seriesOutlierIndicatorStyle;
            var sign = valMax > valMin ? 1 : -1;
            var aliasOffset = penProps.aliasOffset;
            var selectionIndex = 0;
            for (var j = 0; j < this.series.size; j += this._step) {
                var yPoint = this._yData.data[j];
                var i = this.series.getSampleIndex(j);
                yPoint = this._yData.getAt(i);
                var xPoint = this._xData.getAt(i);
                if (xPoint == null || yPoint == null || isNaN(xPoint) || IsSomeInternalNAN(yPoint)) {
                    continue;
                }
                if (this.series.useColor) {
                    this._setColorMapColor(ctx, brush, colorData.getAt(i), i);
                }
                var yValue1 = void 0, y1 = void 0, y2 = void 0, initOffset = void 0;
                _b = this._yScale.lookupRange(yPoint), yValue1 = _b[0], y1 = _b[1], y2 = _b[2], initOffset = _b[3];
                var offset = initOffset >= 0.001 ? initOffset : 0;
                var binPlacementInfo = {
                    binStartNdc: y1,
                    binEndNdc: y2,
                    binFactorOffsetNdc: offset,
                };
                var innerBinPadding = BaseRectangularDrawStyle.getInnerBinPaddingAsNdc(this._yScale.axis, binPlacementInfo);
                var subBinPosition = BaseRectangularDrawStyle.getSubBinPosition(this.series.barNumber, nVerticalBars, binPlacementInfo, innerBinPadding);
                y1 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinStartNdc, 2 /* Y */));
                y2 = Math.round(plot.subPlotFromNDC(subBinPosition.subBinEndNdc, 2 /* Y */));
                var bracketY1 = y1;
                var bracketY2 = y2;
                if (this.isThin) {
                    y1 = y2 = Math.round((y1 + y2) / 2);
                }
                var x2 = this._xScale.lookup(xPoint, this._xBin);
                x2 = ~~(plot.subPlotFromNDC(x2, 1 /* X */));
                if (!this.isThin && (y1 <= y2)) {
                    y1 = y2 + 1;
                }
                var baseX1 = Math.min(x1, x2) - 1;
                var baseX2 = baseX1 + Math.abs(x1 - x2);
                // Outlier stuff
                var xvalue1 = xPoint;
                valMax = ~~(plot.subPlotFromNDC(this._xScale.lookup(ptMax, this._xBin), 1 /* X */));
                valMin = ~~(plot.subPlotFromNDC(this._xScale.lookup(ptMin, this._xBin), 1 /* X */));
                var _c = this.computeReference(), worldX = _c[0], worldY = _c[1];
                // We always want to draw the stroke outline on any of the shapes rendering below.
                // Using a variable here to increase readability so we're not just blindly passing in true.
                var drawOutline = true;
                // Determines if we just render a normal bar without outlier markings.
                var drawNormal = false;
                if (outlierStyle === 0 /* TEAR */) {
                    if (this.isThin) {
                        if (this.series.drawThinColumnBrackets) {
                            this._drawThinBarBracket(ctx, valMin, bracketY1, bracketY2, penProps.lineWidth);
                        }
                        if ((xvalue1 > ptMax) && (worldX < ptMin)) {
                            drawNormal = OutlierRender.breakThinBarsLong(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, (valMin + (hatchSize * 2)), y2, breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if ((xvalue1 < ptMin) && (worldX > ptMax)) {
                            drawNormal = OutlierRender.breakThinBarsLong(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, (valMin + (hatchSize * 2)), y2, breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (xvalue1 > ptMax) {
                            drawNormal = OutlierRender.breakThinBars(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (xvalue1 < ptMin) {
                            drawNormal = OutlierRender.breakThinBars(ctx, x2, y2, x1, y1, (valMin + (hatchSize * 2)), y2, breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (worldX < ptMin) {
                            drawNormal = OutlierRender.breakThinBars(ctx, x2, y2, x1, y1, (valMin + (hatchSize * 2)), y2, breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else if (worldX > ptMax) {
                            drawNormal = OutlierRender.breakThinBars(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, breakSize, hatchAngle, hatchSize, aliasOffset);
                        }
                        else {
                            drawNormal = true;
                        }
                    }
                    else {
                        if ((xvalue1 > ptMax) && (worldX < ptMin)) {
                            drawNormal = OutlierRender.breakBarsLong(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, (valMin + (hatchSize * 2)), y2, breakSize, drawOutline, aliasOffset);
                        }
                        else if ((xvalue1 < ptMin) && (worldX > ptMax)) {
                            drawNormal = OutlierRender.breakBarsLong(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, (valMin + (hatchSize * 2)), y2, breakSize, drawOutline, aliasOffset);
                        }
                        else if (xvalue1 > ptMax) {
                            drawNormal = OutlierRender.breakBars(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, breakSize, drawOutline, aliasOffset);
                        }
                        else if (xvalue1 < ptMin) {
                            drawNormal = OutlierRender.breakBars(ctx, x2, y2, x1, y1, (valMin + (hatchSize * 2)), y2, breakSize, drawOutline, aliasOffset);
                        }
                        else if (worldX < ptMin) {
                            drawNormal = OutlierRender.breakBars(ctx, x2, y2, x1, y1, (valMin + (hatchSize * 2)), y2, breakSize, drawOutline, aliasOffset);
                        }
                        else if (worldX > ptMax) {
                            drawNormal = OutlierRender.breakBars(ctx, x1, y1, x2, y2, (valMax - (hatchSize * 2)), y2, breakSize, drawOutline, aliasOffset);
                        }
                        else {
                            drawNormal = true;
                        }
                    }
                }
                else {
                    drawNormal = true;
                }
                // Forget outliers, just draw it the normal way!
                if (drawNormal) {
                    if (this.isThin) {
                        ctx.fillRect(x1, y1, (x2 - x1), penProps.lineWidth);
                    }
                    else {
                        var strokeWidth = Math.abs(x2 - x1) - 1;
                        var strokeHeight = Math.abs(y2 - y1) - 1;
                        ctx.fillRect(baseX1, y1, Math.abs(x2 - x1), (y2 - y1));
                        ctx.strokeRect(baseX1 + penProps.aliasOffset, y2 + penProps.aliasOffset, strokeWidth, strokeHeight);
                    }
                }
                // create the hitRects
                var hitRect = new FDSRectangleHitShape(baseX1 + prm.plotRect.x1, Math.min(y1, y2) + prm.plotRect.y1, Math.abs(x2 - x1), Math.abs(y2 - y1));
                hitRect.index = i;
                this.series.hitVector.push(hitRect);
                // create and add hitshapes
                var minY = Math.min(y1, y2);
                var maxY = Math.max(y1, y2);
                // Stores the selection marker point positions
                var selMarkerX1 = baseX1;
                var selMarkerY1 = minY;
                var selMarkerX2 = baseX2;
                var selMarkerY2 = maxY;
                // Cache the selection marker positions
                if (this.seriesSelected && Math.abs(selMarkerX2 - selMarkerX1) >= 1 &&
                    this._selectionSampler.isPointSampled(selectionIndex++)) {
                    var endX = baseX1 + Math.abs(x2 - x1);
                    var endY = minY + Math.abs(y2 - y1);
                    this.cacheSelectable(prm, 0 /* NONE */, baseX1, minY);
                    this.cacheSelectable(prm, 0 /* NONE */, endX, minY);
                    if (!this.isThin) {
                        this.cacheSelectable(prm, 0 /* NONE */, endX, endY);
                        this.cacheSelectable(prm, 0 /* NONE */, baseX1, endY);
                    }
                }
                // Handle outlier markers (These are separate from normal markers!)
                if (outlierStyle === 1 /* MARKER */) {
                    ctx.save();
                    // Set up Pen and Brush
                    this.series.seriesOutlierIndicatorFGPen.setOnCanvas(ctx);
                    this.series.seriesOutlierIndicatorBGBrush.setOnCanvas(ctx);
                    if (xvalue1 > ptMax) {
                        var markerX = valMax - ((markerSize / 2) * sign);
                        var markerY = Math.round((y1 + y2) / 2.0);
                        this.drawOutlierMarkerCorrectly(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    if (xvalue1 < ptMin) {
                        var markerX = valMin + ((markerSize / 2) * sign);
                        var markerY = Math.round((y1 + y2) / 2.0);
                        this.drawOutlierMarkerCorrectly(ctx, markerX, markerY, markerStyle, markerSize);
                    }
                    ctx.restore();
                }
            }
            this._resetColorMapColor(brush);
            ctx.restore();
            var _b;
        };
        // helper function to select the necessary pens and brushes
        // (since the same logic is in both the main draw fn and the legend fn)
        // returns [brush, props]
        OldBarsDrawStyle.prototype._choosePens = function (ctx, legend) {
            var pen;
            var brush;
            if (legend) {
                if (this.isThin) {
                    pen = this.series.seriesFGPen;
                }
                else {
                    pen = this.series.seriesOutlinePen;
                }
                pen = pen.with({ width: 1 });
            }
            else {
                if (this.isThin) {
                    pen = this.series.seriesFGPen;
                }
                else {
                    pen = this.series.seriesOutlinePen;
                }
            }
            if (this.isThin) {
                brush = new FDSBrush();
                brush.color = this.series.seriesFGPen.color;
                brush.style = 0 /* SOLID */;
            }
            else {
                brush = this.series.seriesBGBrush;
            }
            pen.setOnCanvas(ctx);
            brush.setOnCanvas(ctx);
            var penProps = pen.toPropertyObject();
            return { brush: brush, pen: pen, penProps: penProps };
        };
        OldBarsDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, true);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, (~~(height * 0.8)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            var halfminus = ~~(minus / 2);
            ctx.fillRect(x - minus, y - halfminus, plus + minus, halfplus + halfminus);
            ctx.strokeRect(x - minus, y - halfminus, plus + minus, halfplus + halfminus);
        };
        OldBarsDrawStyle.prototype.verify = function () {
            return true;
        };
        OldBarsDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return OldBarsDrawStyle;
    }(BaseRectangularDrawStyle));
    
    var Bars3dDrawStyle = /** @class */ (function (_super) {
        __extends(Bars3dDrawStyle, _super);
        function Bars3dDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this.is3D = true;
            return _this;
        }
        Bars3dDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            // the normal bars style checks if it's 3d and if so calls our 3d draw method before
            // it draws each bar
            _super.prototype.drawToBuffer.call(this, prm, ctx);
        };
        Bars3dDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, true);
            var size = Math.min(height * 0.8, width * 0.8);
            var w = size * 0.8;
            var h = w / 2;
            var w3d = ~~(size * 0.2); // width of the 3d part
            var halfW = ~~(w / 2);
            var halfH = ~~(h / 2);
            // make sure there's room to put the 3d bits on the right
            x -= w3d;
            // first do the 3d bits
            ctx.beginPath();
            ctx.moveTo(x - halfW, y - halfH);
            ctx.lineTo((x - halfW) + w3d, y - halfH - w3d);
            ctx.lineTo(x + halfW + w3d, y - halfH - w3d);
            ctx.lineTo(x + halfW, y - halfH);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + halfW, y - halfH);
            ctx.lineTo(x + halfW + w3d, y - halfH - w3d);
            ctx.lineTo(x + halfW + w3d, (y + halfH) - w3d);
            ctx.lineTo(x + halfW, y + halfH);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // now do the main rect
            // reset w and h to account for rounding nonsense
            w = 2 * halfW;
            h = 2 * halfH;
            ctx.fillRect(x - halfW, y - halfH, w, h);
            ctx.strokeRect(x - halfW, y - halfH, w, h);
        };
        Bars3dDrawStyle.prototype.verify = function () {
            // pc side does some stuff with layers which we don't have so i'll just return
            // true like most of our drawstyles
            return true;
        };
        Bars3dDrawStyle.prototype.hint = function () {
            return 12 /* BARS */;
        };
        return Bars3dDrawStyle;
    }(OldBarsDrawStyle));
    
    var BaseBarDrawStyle = /** @class */ (function (_super) {
        __extends(BaseBarDrawStyle, _super);
        function BaseBarDrawStyle(series, binDimension) {
            var _this = _super.call(this, series, binDimension) || this;
            _this._isVertical = binDimension === 1 /* X */;
            _this._binAxisInfo = _this._getAxisInfo(binDimension);
            _this._valueAxisInfo = _this._getAxisInfo(_this._isVertical ? 2 /* Y */ : 1 /* X */);
            return _this;
        }
        BaseBarDrawStyle.prototype._getAxisInfo = function (dimension) {
            switch (dimension) {
                case 1 /* X */:
                    return {
                        dataset: this._xData,
                        scale: this._xScale,
                        bin: this._xBin,
                        dim: 1 /* X */,
                    };
                case 2 /* Y */:
                    return {
                        dataset: this._yData,
                        scale: this._yScale,
                        bin: this._yBin,
                        dim: 2 /* Y */,
                    };
                default:
                    throw new Error('Unexpected series dimension');
            }
        };
        BaseBarDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this._prm = prm;
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            var outliersActive = this._valueAxisInfo.scale.outlierActive() && this.series.seriesOutlierIndicator;
            if (outliersActive) {
                this._cacheOutlierDrawInfo();
            }
            ctx.setPen(this.series.seriesOutlinePen);
            var barData = this._calculateBarBounds();
            for (var _i = 0, barData_1 = barData; _i < barData_1.length; _i++) {
                var bar = barData_1[_i];
                var rect = bar.rect, color = bar.color, index = bar.index;
                if (this.series.useColor) {
                    var colorBrush = this.series.seriesBGBrush;
                    colorBrush.color = color;
                    ctx.setBrush(colorBrush, rect);
                }
                else {
                    ctx.setBrush(this.series.seriesBGBrush, rect);
                }
                if (outliersActive) {
                    this._drawOutlierBar(bar, ctx);
                }
                else {
                    rect.fill(ctx);
                    rect.strokeInternal(ctx);
                }
                this._addSeriesValueAndMarkerPositions(bar);
                pixelPoints[index] = rect.centerPoint().add(new Point(prm.plotRect.x1, prm.plotRect.y1));
                var infoboxPixelPoint = this._getInfoboxPixelPositionFromBar(bar, rect.centerPoint());
                infoboxPixelPoints[index] = { point: infoboxPixelPoint.point.add(new Point(prm.plotRect.x1, prm.plotRect.y1)), position: infoboxPixelPoint.position };
                this._addHitshape(rect, index);
                this._addSelectionMarkers(rect, index);
            }
            this._resetColorMapColor(this.series.seriesBGBrush);
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
        };
        BaseBarDrawStyle.prototype._cacheOutlierDrawInfo = function () {
            this._threshInfo = this._getThreshInfo(this._valueAxisInfo);
            this._outlierStyle = this.series.seriesOutlierIndicatorStyle;
            switch (this._outlierStyle) {
                case 0 /* TEAR */:
                    this._hatchSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorHatchSize, this._prm.plotRect.getWidth()));
                    this._breakSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorBreakSize, this._prm.plotRect.getWidth()));
                    this._penProps = this.series.seriesOutlinePen.toPropertyObject();
                    break;
                case 1 /* MARKER */:
                    this._markerStyle = this.series.seriesOutlierIndicatorMarkerStyle;
                    this._markerSize = this.series.seriesOutlierIndicatorSize;
            }
        };
        BaseBarDrawStyle.prototype._calculateBarBounds = function () {
            var plot = this._prm.plot;
            var valueDim = this._valueAxisInfo.dim;
            var points = [];
            var colorData = this.series.getData(4 /* COLOR */);
            var _a = this.computeWorldBarBases(), ndcY = _a.ndcY, ndcX = _a.ndcX, worldX = _a.worldX, worldY = _a.worldY;
            var baseNdc = this._isVertical ? ndcY : ndcX;
            var basePixel = Math.round(plot.subPlotFromNDC(clamp(baseNdc, 0, 1), this._valueAxisInfo.dim));
            for (var j = 0; j < this.series.size; j += this._step) {
                var i = this.series.getSampleIndex(j);
                var binDataItem = this._binAxisInfo.dataset.getAt(i);
                var valueDataItem = this._valueAxisInfo.dataset.getAt(i);
                if (binDataItem == null || valueDataItem == null || isNaN(valueDataItem)) {
                    continue;
                }
                var binRange = this._getBinRange(plot, binDataItem);
                var valueNdc = this._valueAxisInfo.scale.lookup(valueDataItem, this._valueAxisInfo.bin);
                var valuePixel = ~~(plot.subPlotFromNDC(valueNdc, valueDim));
                // This is to make it draw left of the axis line for negative bars, and on the axis line for positive bars
                if (!this._isVertical) {
                    valuePixel = valuePixel - 1;
                }
                var rect = void 0;
                if (this._isVertical) {
                    rect = new Rectangle(binRange.startPixel, valuePixel, binRange.endPixel, basePixel);
                }
                else {
                    rect = new Rectangle(valuePixel, binRange.startPixel, basePixel, binRange.endPixel);
                }
                var color = this._calcColorMapColor(this.series.seriesBGBrush.color, colorData.getAt(i), i);
                points.push({ index: i, rect: rect, color: color, value: valueDataItem, base: this._isVertical ? worldY : worldX });
            }
            return points;
        };
        BaseBarDrawStyle.prototype._getBinRange = function (plot, binDataItem) {
            var startNdc, endNdc, initOffset;
            _a = this._binAxisInfo.scale.lookupRange(binDataItem), startNdc = _a[1], endNdc = _a[2], initOffset = _a[3];
            var offset = initOffset >= 0.001 ? initOffset : 0;
            var binPlacementInfo = {
                binStartNdc: startNdc,
                binEndNdc: endNdc,
                binFactorOffsetNdc: offset,
            };
            var innerBinPadding = BaseRectangularDrawStyle.getInnerBinPaddingAsNdc(this._binAxisInfo.scale.axis, binPlacementInfo);
            var subBinPosition = BaseRectangularDrawStyle.getSubBinPosition(this.series.barNumber, this._isVertical ? this._prm.nHorizontalBars : this._prm.nVerticalBars, binPlacementInfo, innerBinPadding);
            return {
                startPixel: Math.round(plot.subPlotFromNDC(subBinPosition.subBinStartNdc, this._binAxisInfo.dim)),
                endPixel: Math.round(plot.subPlotFromNDC(subBinPosition.subBinEndNdc, this._binAxisInfo.dim)),
            };
            var _a;
        };
        BaseBarDrawStyle.prototype._drawOutlierBar = function (bar, ctx) {
            var overlap = this._getOutlierOverlap(bar.base, bar.value);
            switch (this._outlierStyle) {
                case 0 /* TEAR */:
                    this._drawTearOutlier(ctx, overlap, bar);
                    break;
                case 1 /* MARKER */:
                    this._drawMarkerOutlier(ctx, overlap, bar.rect);
                    break;
            }
        };
        BaseBarDrawStyle.prototype._getThreshInfo = function (axisInfo) {
            var scale = axisInfo.scale, bin = axisInfo.bin, dim = axisInfo.dim;
            return {
                min: scale.threshMin,
                max: scale.threshMax,
                maxPixel: ~~(this._prm.plot.subPlotFromNDC(scale.lookup(scale.threshMax, bin), dim)),
                minPixel: ~~(this._prm.plot.subPlotFromNDC(scale.lookup(scale.threshMin, bin), dim))
            };
        };
        BaseBarDrawStyle.prototype._getOutlierOverlap = function (base, value) {
            var valueRange = new Range(base, value);
            var threshRange = new Range(this._threshInfo.min, this._threshInfo.max);
            return Range.CheckForOverlap(valueRange, threshRange);
        };
        BaseBarDrawStyle.prototype._drawTearOutlier = function (ctx, overlap, bar) {
            var breakSign = this._isVertical ? 1 : -1;
            var hatchOffset = (this._hatchSize * 2 * breakSign);
            var max$$1 = this._threshInfo.maxPixel + hatchOffset;
            var min$$1 = this._threshInfo.minPixel - hatchOffset;
            var isPositive = bar.value > bar.base;
            var pt1, pt2, maxPt, minPt;
            var rect = bar.rect;
            if (isPositive) {
                pt1 = new Point(rect.x1, rect.y2);
                pt2 = new Point(rect.x2, rect.y1);
            }
            else {
                pt1 = new Point(rect.x1, rect.y1);
                pt2 = new Point(rect.x2, rect.y2);
            }
            if (this._isVertical) {
                maxPt = new Point(pt2.x, max$$1);
                minPt = new Point(pt2.x, min$$1);
            }
            else {
                // The 1 px offset puts the base of a positive bar on the reference line and a negative bar below it
                pt1 = new Point(Math.min(rect.x1, rect.x2) + 1, pt1.y);
                pt2 = new Point(Math.max(rect.x1, rect.x2) + 1, pt2.y);
                maxPt = new Point(max$$1, pt2.y);
                minPt = new Point(min$$1, pt2.y);
            }
            var successfulDraw = false;
            switch (overlap) {
                case 2 /* AROUND */:
                    successfulDraw = this._tryTearRectAtMinAndMax(ctx, pt1, pt2, maxPt, minPt);
                    break;
                case 1 /* OVERLAP_START */:
                    successfulDraw = this._tryTearRectAtMin(ctx, pt1, pt2, minPt);
                    break;
                case 5 /* OVERLAP_END */:
                    successfulDraw = this._tryTearRectAtMax(ctx, pt1, pt2, maxPt);
                    break;
            }
            if (!successfulDraw) {
                rect.fill(ctx);
                rect.strokeInternal(ctx);
            }
        };
        BaseBarDrawStyle.prototype._drawMarkerOutlier = function (ctx, overlap, rect) {
            rect.fill(ctx);
            rect.strokeInternal(ctx);
            ctx.save();
            this.series.seriesOutlierIndicatorFGPen.setOnCanvas(ctx);
            this.series.seriesOutlierIndicatorBGBrush.setOnCanvas(ctx);
            var markerOffset = this._markerSize / 2;
            var markerSign = this._threshInfo.minPixel > this._threshInfo.maxPixel ? -1 : 1;
            var minMarker = this._threshInfo.minPixel + (markerOffset * markerSign);
            var maxMarker = this._threshInfo.maxPixel - (markerOffset * markerSign);
            switch (overlap) {
                case 0 /* CLEAR_START */:
                case 1 /* OVERLAP_START */:
                    this._drawOutlierMarker(ctx, rect, minMarker);
                    break;
                case 2 /* AROUND */:
                    this._drawOutlierMarker(ctx, rect, minMarker);
                    this._drawOutlierMarker(ctx, rect, maxMarker);
                    break;
                case 5 /* OVERLAP_END */:
                case 6 /* CLEAR_END */:
                    this._drawOutlierMarker(ctx, rect, maxMarker);
                    break;
            }
            ctx.restore();
        };
        BaseBarDrawStyle.prototype._addHitshape = function (rect, index) {
            var hitBox = new FDSRectangleHitShape(rect.x1 + this._prm.plotRect.x1, rect.y1 + this._prm.plotRect.y1, rect.width, rect.height);
            hitBox.index = index;
            this.series.hitVector.push(hitBox);
        };
        BaseBarDrawStyle.prototype._addSelectionMarkers = function (rect, index) {
            var addMarkers = this.seriesSelected && this._selectionSampler.isPointSampled(index);
            if (addMarkers) {
                this.cacheSelectable(this._prm, 0 /* NONE */, rect.x1, rect.y1);
                this.cacheSelectable(this._prm, 0 /* NONE */, rect.x1, rect.y2);
                this.cacheSelectable(this._prm, 0 /* NONE */, rect.x2, rect.y1);
                this.cacheSelectable(this._prm, 0 /* NONE */, rect.x2, rect.y2);
            }
        };
        BaseBarDrawStyle.prototype._addSeriesValueAndMarkerPositions = function (bar) {
            var rect = bar.rect;
            var center = rect.centerPoint();
            if (this.series.seriesValue) {
                var valuePoint = this._getSeriesValuePtFromBar(bar, center);
                this._labelPositions.push(valuePoint.add(new Point(this._prm.plotRect.x1, this._prm.plotRect.y1)));
            }
            if (this.series.seriesMarker) {
                var markerPoint = this._getSeriesMarkerPtFromBar(bar, center);
                this._markerPositions.push(markerPoint);
            }
        };
        BaseBarDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            ctx.setBrush(this.series.seriesBGBrush);
            ctx.setPen(this.series.seriesOutlinePen.with({ width: 1 }));
            // Logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            var size = ~~(Math.min(width, height) * 0.8);
            var heightOffset = ~~(size * 0.4);
            var widthOffset = ~~(heightOffset / 2);
            var glyphRect;
            if (this._isVertical) {
                glyphRect = new Rectangle(x - widthOffset, y - heightOffset, x + widthOffset, y + heightOffset);
            }
            else {
                glyphRect = new Rectangle(x - heightOffset, y - widthOffset, x + heightOffset, y + widthOffset);
            }
            glyphRect.fill(ctx);
            glyphRect.stroke(ctx);
        };
        return BaseBarDrawStyle;
    }(BaseRectangularDrawStyle));
    
    var BarsDrawStyle = /** @class */ (function (_super) {
        __extends(BarsDrawStyle, _super);
        function BarsDrawStyle(series) {
            return _super.call(this, series, 2 /* Y */) || this;
        }
        BarsDrawStyle.prototype._tryTearRectAtMin = function (ctx, pt1, pt2, minPt) {
            return !OutlierRender.breakBars(ctx, pt1.x, pt1.y, pt2.x, pt2.y, minPt.x, minPt.y, this._breakSize, true, this._penProps.aliasOffset);
        };
        BarsDrawStyle.prototype._tryTearRectAtMinAndMax = function (ctx, pt1, pt2, maxPt, minPt) {
            return !OutlierRender.breakBarsLong(ctx, pt1.x, pt1.y, pt2.x, pt2.y, maxPt.x, maxPt.y, minPt.x, minPt.y, this._breakSize, true, this._penProps.aliasOffset);
        };
        BarsDrawStyle.prototype._tryTearRectAtMax = function (ctx, pt1, pt2, maxPt) {
            return !OutlierRender.breakBars(ctx, pt1.x, pt1.y, pt2.x, pt2.y, maxPt.x, maxPt.y, this._breakSize, true, this._penProps.aliasOffset);
        };
        BarsDrawStyle.prototype._drawOutlierMarker = function (ctx, rect, marker) {
            var center = Math.round((rect.y1 + rect.y2) / 2);
            this.drawOutlierMarkerCorrectly(ctx, marker, center, this._markerStyle, this._markerSize);
        };
        BarsDrawStyle.prototype._getSeriesValuePtFromBar = function (bar, center) {
            if (bar.value > bar.base) {
                return new Point(bar.rect.x2 + 1, center.y);
            }
            else {
                return new Point(bar.rect.x1 + 1, center.y);
            }
        };
        BarsDrawStyle.prototype._getSeriesMarkerPtFromBar = function (bar, center) {
            if (bar.value > bar.base) {
                return new Point(bar.rect.x2 + 1, center.y);
            }
            else {
                return new Point(bar.rect.x1 + 1, center.y);
            }
        };
        BarsDrawStyle.prototype._getInfoboxPixelPositionFromBar = function (bar, center) {
            return {
                point: this._getSeriesMarkerPtFromBar(bar, center),
                position: bar.value > bar.base ? "right" /* right */ : "left" /* left */,
            };
        };
        return BarsDrawStyle;
    }(BaseBarDrawStyle));
    
    var BubbleDrawStyle = /** @class */ (function (_super) {
        __extends(BubbleDrawStyle, _super);
        function BubbleDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._sizeScale = _this.series.getAxis(5 /* DSIZE */).getScale();
            _this._sizeData = _this.series.getData(5 /* DSIZE */);
            return _this;
        }
        BubbleDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
        };
        BubbleDrawStyle.prototype.drawMarkersToBuffer = function (prm, ctx) {
            _super.prototype.drawMarkersToBuffer.call(this, prm, ctx, true);
        };
        BubbleDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            if (this.series.drawStyle === -1 /* NONE */) {
                return;
            }
            if (!(this instanceof BubbleDrawStyle)) {
                // Curious... not sure why this code is needed.
                return;
            }
            // If there is no series associated with the DSIZE axis, we treat the entire thing
            // as their indices. So instead of data its just 1-n.
            var treatAsIndex = false;
            ctx.save();
            var xOff = this.series.markerXOffset;
            var yOff = this.series.markerYOffset;
            var markerStyle = this.series.markerStyle;
            var isSimpleMarker = this.isSimpleMarker(markerStyle);
            var _a = this.configureMarkerPens(true, isSimpleMarker, ctx), brush = _a[0], seriesOutlinePenProps = _a[1];
            // Bubble Specific Size Stuff
            var size = this.series.markerSize;
            var maxSize = this.series.markerMaxSize;
            if (size > maxSize) {
                _b = [maxSize, size], size = _b[0], maxSize = _b[1];
            }
            maxSize -= size;
            // Passing in dummy size just so we can confirm that the func is valid.
            var drawFunc = getMarkerDrawFunctor(markerStyle, size + maxSize);
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            if (drawFunc != null) {
                var aliasOffset = seriesOutlinePenProps.aliasOffset;
                for (var j = this._start; j < this._end; j += this._step) {
                    var i = this.series.getSampleIndex(j);
                    var dataItem = this._xData.getAt(i);
                    var yDataItem = this._yData.getAt(i);
                    if (dataItem !== undefined && yDataItem !== undefined && !IsSomeNAN(dataItem) && !IsSomeNAN(yDataItem)) {
                        ctx.beginPath();
                        // Draw each data point as a point on a line
                        var x = (prm.plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */)) + xOff;
                        var y = (prm.plot.subPlotFromNDC(this._yScale.lookup(yDataItem, this._yBin), 2 /* Y */)) - yOff;
                        x = (~~x) + aliasOffset;
                        y = (~~y) + aliasOffset;
                        var sValue = this._sizeData.getAt(i);
                        var sValueNDC = this._sizeScale.lookup(sValue);
                        var markerSize = (size + (maxSize * sValueNDC));
                        drawFunc = getMarkerDrawFunctor(markerStyle, markerSize);
                        drawFunc(ctx, x, y);
                        var halfSize = markerSize / 2;
                        // save the pixel points, including the space before/above the plot rect
                        var pR = prm.plot.plotRect;
                        var pixX = Math.round(x + pR.x1);
                        var pixY = Math.round(y + pR.y1);
                        pixelPoints[i] = { x: pixX, y: pixY };
                        infoboxPixelPoints[i] = { point: { x: pixX, y: pixY - markerSize / 2 }, position: "above" /* above */ };
                        this.series.addLookupPoint(x + prm.plotRect.x1, [y + prm.plotRect.y1], i);
                        var rect = new Rectangle(x - halfSize, y - halfSize, x + halfSize, y + halfSize);
                        if (this.series.useColor) {
                            this._setColorMapColor(ctx, brush, this._colorData.getAt(i), i, rect);
                        }
                        brush.setBubble3dMode(this.series.tryGetMarker3dLightPosition());
                        brush.setOnCanvas(ctx, rect);
                        if (!isSimpleMarker) {
                            ctx.fill();
                            ctx.stroke();
                        }
                        else {
                            ctx.stroke();
                        }
                        // add hitshapes
                        var hitPie = new FDSPieHitShape();
                        hitPie.setCenter(x + prm.plotRect.x1, y + prm.plotRect.y1);
                        hitPie.setRadius((size + (maxSize * sValueNDC)) / 2);
                        hitPie.setAngles(0, 2 * Math.PI);
                        hitPie.setOffset(0);
                        hitPie.index = i;
                        this.series.hitVector.push(hitPie);
                        // Cache point for selection markers
                        if (this.seriesSelected && this._selectionSampler.isPointSampled(i)) {
                            this.cacheSelectable(prm, 0 /* NONE */, x, y);
                        }
                    }
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
            this._resetColorMapColor(brush);
            ctx.restore();
            var _b;
        };
        BubbleDrawStyle.prototype.verify = function () {
            return true;
        };
        BubbleDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        return BubbleDrawStyle;
    }(BaseDrawStyle));
    
    var CandleDrawStyle = /** @class */ (function (_super) {
        __extends(CandleDrawStyle, _super);
        function CandleDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CandleDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            // Select the seriesFGPen for drawing with
            var seriesFGPenProps = this.series.seriesFGPen.toPropertyObject();
            this.series.seriesFGPen.setOnCanvas(ctx);
            // For each point in xData, draw a vertical line from high to low,
            //  marked with a box showing open and close prices
            var plot = prm.plot;
            // construct some brushes to use for drawing positive boxes
            var whiteBrush = new FDSBrush();
            whiteBrush.style = 0 /* SOLID */;
            whiteBrush.color = 16777215 /* WHITE */;
            var posFillBrush = new FDSBrush();
            posFillBrush.style = 0 /* SOLID */;
            posFillBrush.color = this.series.attributeSet.get('CandlePositiveFillColor');
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            var offset = -1.0;
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            for (var j = this._start; j < this._end; j += this._step) {
                var i = this.series.getSampleIndex(j);
                var xPoint = this._xData.getAt(i);
                // these are guaranteed to exist because we checked for them
                // before setting the draw style
                var yClose = this._yData.getDimensionalDataset(0).getAt(i);
                var yHigh = this._yData.getDimensionalDataset(1).getAt(i);
                var yLow = this._yData.getDimensionalDataset(2).getAt(i);
                var yOpen = this._yData.getDimensionalDataset(3).getAt(i);
                // do some @NA checking and skip datapoint otherwise
                if (IsSomeInternalNAN(yOpen) || IsSomeInternalNAN(yHigh) || IsSomeInternalNAN(yLow) ||
                    IsSomeInternalNAN(yClose)) {
                    continue;
                }
                // tiny bit of error checking
                if (yHigh < yLow) {
                    _a = [yLow, yHigh], yHigh = _a[0], yLow = _a[1];
                }
                var x0 = void 0, x1 = void 0, x2 = void 0, initOffset = void 0;
                _b = this._xScale.lookupRange(xPoint), x0 = _b[0], x1 = _b[1], x2 = _b[2], initOffset = _b[3];
                if (offset < 0.0) {
                    offset = initOffset;
                }
                if (offset < 0.001) {
                    offset = 0.0;
                }
                // make sure the x width isn't too big and adjust if necessary
                var delta = ((x2 - offset) - (x1 + offset));
                var maxwidth = this.series.maxElementWidth;
                if (maxwidth > 0.0 && delta > maxwidth) {
                    delta = maxwidth;
                }
                x1 = x0 - (delta / 2);
                x2 = x0 + (delta / 2);
                // get the left and right edge points surrounding the actual x point
                var xPt = ~~(plot.subPlotFromNDC(x0, 1 /* X */));
                var xRPt = ~~(plot.subPlotFromNDC(x2, 1 /* X */));
                var xLPt = ~~(plot.subPlotFromNDC(x1, 1 /* X */));
                if (Math.abs(xLPt - xRPt) <= 1) {
                    xRPt++;
                }
                var yLPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yLow, this._yBin), 2 /* Y */));
                var yHPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yHigh, this._yBin), 2 /* Y */));
                var yCPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yClose, this._yBin), 2 /* Y */));
                var yOPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yOpen, this._yBin), 2 /* Y */));
                this.series.addLookupPoint(xPt + prm.plotRect.x1, [
                    yCPt + prm.plotRect.y1, yHPt + prm.plotRect.y1,
                    yLPt + prm.plotRect.y1, yOPt + prm.plotRect.y1
                ], i);
                // save just in case
                ctx.save();
                // set up the fill brush
                var candleFillBrush = new FDSBrush(); // default - invisible brush
                var topHeight = void 0;
                var bottomHeight = void 0;
                if (yOpen < yClose) {
                    // positive rectangle
                    switch (this.series.candlePositiveFillStyle) {
                        case 1 /* WHITE */:
                            // draw a white box
                            candleFillBrush = whiteBrush;
                            break;
                        case 2 /* PLOT_BG */:
                            // draw a box with the plot bg color
                            candleFillBrush = this.series.getPlotParent().plotBGBrush;
                            break;
                        case 3 /* CANDLE_FILL */:
                            // draw a box with the color from CandlePosFillColor attribute
                            candleFillBrush = posFillBrush;
                            break;
                    }
                    candleFillBrush.pushHistory();
                    topHeight = yCPt - yHPt;
                    bottomHeight = yOPt - yLPt;
                }
                else {
                    // negative rectangle
                    candleFillBrush = this.series.seriesBGBrush;
                    candleFillBrush.pushHistory();
                    if (this.series.useColor) {
                        candleFillBrush.setAttr('color', this._calcColorMapColor(candleFillBrush.color, colorData.getAt(i), i));
                    }
                    topHeight = yOPt - yHPt;
                    bottomHeight = yCPt - yLPt;
                }
                var outlinePen = this.series.seriesOutlinePen;
                // set up the outline pen
                if (this.series.candleLineColorFollowsFillColor &&
                    !(yOpen < yClose && this.series.candlePositiveFillStyle === 0 /* TRANSPARENT */)) {
                    // match line to fill unless it's an invisible positive rectangle
                    outlinePen = outlinePen.with({ color: candleFillBrush.color });
                }
                // draw the vertical high-low line
                // Note: draw lines as rectangles because that's faster
                // when they're not at an angle
                var width = seriesFGPenProps.lineWidth;
                // center the line
                var xStart = xPt - ~~(width / 2);
                outlinePen.useAsFill(ctx);
                ctx.fillRect(xStart, yHPt, width, topHeight);
                ctx.fillRect(xStart, yLPt, width, bottomHeight);
                // save the pixel points, including the space before/above the plot rect
                var pR = prm.plot.plotRect;
                var pixY = Math.round((yHPt + yLPt) / 2);
                pixelPoints[i] = { x: xStart + pR.x1, y: pixY + pR.y1 };
                // draw the open-close box
                width = xRPt - xLPt;
                var height = Math.abs(yOPt - yCPt);
                if (fuzzyLTE(yOpen, yClose)) {
                    // positive rectangle
                    if (this.series.candlePositiveFillStyle !== 0 /* TRANSPARENT */) {
                        candleFillBrush.setOnCanvas(ctx);
                        ctx.fillRect(xLPt, yCPt, width, height);
                    }
                    // check if we should be drawing an outline
                    if (this.series.candleDrawRectOutline) {
                        outlinePen.setOnCanvas(ctx);
                        // add in the offset since we're drawing an outline
                        ctx.strokeRect(xLPt + seriesFGPenProps.aliasOffset, yCPt + seriesFGPenProps.aliasOffset, width, height);
                    }
                }
                else {
                    // negative rectangle
                    candleFillBrush.setOnCanvas(ctx);
                    ctx.fillRect(xLPt, yOPt, width, height);
                }
                // create hitrects
                var hitRect = new FDSRectangleHitShape(xLPt + prm.plotRect.x1, yHPt + prm.plotRect.y1, xRPt - xLPt, yLPt - yHPt);
                hitRect.index = i;
                this.series.hitVector.push(hitRect);
                // Cache the selection marker position
                if (this.seriesSelected && this._selectionSampler.isPointSampled(i)) {
                    this.cacheSelectable(prm, 0 /* NONE */, xLPt + (width / 2), yCPt);
                }
                candleFillBrush.popHistory();
                // restore old settings
                ctx.restore();
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
            var _a, _b;
        };
        CandleDrawStyle.prototype.verify = function () {
            var H = this._yData.getDimensionalDataset(1);
            var L = this._yData.getDimensionalDataset(2);
            var O = this._yData.getDimensionalDataset(3);
            var dl = this._yData.data.length;
            return H && L && O && H.data.length >= dl && L.data.length >= dl && O.data.length >= dl;
        };
        CandleDrawStyle.prototype.hint = function () {
            return 2 /* HLC */;
        };
        CandleDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            // set up pens to draw a negative box
            // use a special thin pen to draw the legend
            var pen = this.series.seriesOutlinePen.with({ width: 1 });
            pen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, (~~(height * 0.8)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfminus = ~~(minus / 2);
            var halfplus = ~~(plus / 2);
            ctx.beginPath();
            ctx.moveTo(x, y - plus);
            ctx.lineTo(x, y + minus);
            ctx.stroke();
            ctx.fillRect(x - halfminus, y - halfminus, halfplus + halfminus, halfplus + halfminus);
            ctx.strokeRect(x - halfminus, y - halfminus, halfplus + halfminus, halfplus + halfminus);
        };
        return CandleDrawStyle;
    }(BaseDrawStyle));
    
    var FDSGeographicScale = /** @class */ (function (_super) {
        __extends(FDSGeographicScale, _super);
        function FDSGeographicScale(root, id, axis, bbox) {
            var _this = _super.call(this, root, id, axis) || this;
            _this._plotDim = _this.axis.dimension;
            if (bbox) {
                _this.initBbox(bbox);
            }
            else {
                _this.min = 0;
                _this.max = 1;
            }
            if (_this.userThreshEnabled) {
                // this scale might be initialized from a bounding box
                // *after* syncMembers would be called on chart load,
                // which would mean that the thresholds might have already been set from
                // attribute load, and we shouldn't overwrite them with the bounding box
                // at this particular juncture.
                _this.threshMin = _this.min;
                _this.threshMax = _this.max;
            }
            return _this;
            // TODO: KML maps used latitude and longitude as their coordinate system (projected into screen space)
            // This value of -180 likely no longer makes sense, but we might need to do some other handling here.
            // this.tolerance = -180.0;
        }
        FDSGeographicScale.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this._resetBbox();
            this.adjustForAspectRatio();
        };
        FDSGeographicScale.prototype._copyBbox = function (bbox) {
            return ({
                width: bbox.width,
                height: bbox.height,
                x: bbox.x,
                y: bbox.y
            });
        };
        FDSGeographicScale.prototype._getNextTick = function () {
            return null;
        };
        FDSGeographicScale.prototype._getNextLabel = function (plain) {
            return null;
        };
        FDSGeographicScale.prototype.initBbox = function (bbox) {
            // we should be passed in a reference to some bbox (not the actual SVG viewbox) that's shared between X and Y
            // geographic scales this is necessary because for aspect ratio reasons I need to know about both width and
            // height accurately
            // save this to use when resetting
            this._bbox = bbox;
            this._originalBbox = this._copyBbox(this._bbox);
            // save the threshMins/Maxes if they're set
            if (this._plotDim === 1 /* X */) {
                if (!this.axis.attributeSet.isDefault('ThreshMin')) {
                    var x2 = this._bbox.x + this._bbox.width;
                    this._bbox.x = this.axis.attributeSet.get('ThreshMin');
                    this._bbox.width = x2 - this._bbox.x;
                }
                if (!this.axis.attributeSet.isDefault('ThreshMax')) {
                    this._bbox.width = this.axis.attributeSet.get('ThreshMax') - this._bbox.x;
                }
            }
            else if (this._plotDim === 2 /* Y */) {
                if (!this.axis.attributeSet.isDefault('ThreshMin')) {
                    var y2 = this._bbox.y + this._bbox.height;
                    this._bbox.y = this.axis.attributeSet.get('ThreshMin');
                    this._bbox.height = y2 - this._bbox.y;
                }
                if (!this.axis.attributeSet.isDefault('ThreshMax')) {
                    this._bbox.height = this.axis.attributeSet.get('ThreshMax') - this._bbox.y;
                }
            }
            // save the thresholds again in case they weren't set (also set @min/@max)
            this._saveThreshes();
        };
        // function to update threshes from bbox
        FDSGeographicScale.prototype._saveThreshes = function () {
            var min$$1;
            var max$$1;
            if (this._plotDim === 1 /* X */) {
                min$$1 = this._bbox.x;
                max$$1 = this._bbox.x + this._bbox.width;
            }
            else {
                min$$1 = this._bbox.y;
                max$$1 = this._bbox.y + this._bbox.height;
            }
            this._setThreshold(min$$1, max$$1, false);
        };
        // called whenever zoom is reset - revert to original bbox
        FDSGeographicScale.prototype._resetBbox = function () {
            this._bbox = this._copyBbox(this._originalBbox);
            this._saveThreshes();
        };
        // this is called whenever we're at a fullsize and need to adjust
        FDSGeographicScale.prototype.adjustForAspectRatio = function () {
            var plot = this.axis.parent;
            var plotW = plot.plotRect.getWidth();
            var plotH = plot.plotRect.getHeight();
            var aspectRatio = this._bbox.width / this._bbox.height;
            var plotRatio = plotW / plotH;
            if (this._plotDim === 1 /* X */ && fuzzyLT(aspectRatio, plotRatio)) {
                var arPlotW = plotH * aspectRatio; // this is in PLOT PIXELS
                var pct = plotW / arPlotW;
                this._bbox.width *= pct;
                // adjust x
                var xOffset = Math.abs((plotW - arPlotW) / 2);
                this._bbox.x -= xOffset * (this._bbox.width / plotW); // convert to svg pixels
            }
            else if (this._plotDim === 2 /* Y */ && fuzzyGT(aspectRatio, plotRatio)) {
                var arPlotH = plotW * aspectRatio; // this is in PLOT PIXELS
                var pct = arPlotH / plotH;
                this._bbox.height *= pct;
                // adjust y
                var yOffset = Math.abs((plotH - arPlotH) / 2);
                this._bbox.y -= yOffset * (this._bbox.height / plotH); // convert to svg pixels
            }
        };
        FDSGeographicScale.prototype.lookup = function (value) {
            if (this._bbox == null) {
                return 0;
            }
            if (this._plotDim === 2 /* Y */) {
                return 1 - ((value - this._bbox.y) / this._bbox.height);
            }
            else if (this._plotDim === 1 /* X */) {
                return (value - this._bbox.x) / this._bbox.width;
            }
            return 0;
        };
        FDSGeographicScale.prototype.computeValue = function (ndc) {
            if (this._bbox == null) {
                return 0;
            }
            if (this._plotDim === 2 /* Y */) {
                return this._bbox.y + (1 - ndc) * this._bbox.height;
            }
            else if (this._plotDim === 1 /* X */) {
                return this._bbox.x + ndc * this._bbox.width;
            }
            return 0;
        };
        FDSGeographicScale.prototype._computeNiceRanges = function (min$$1, max$$1) {
            return [min$$1, max$$1];
        };
        FDSGeographicScale.prototype._setRanges = function (min$$1, max$$1) {
            if (min$$1 === void 0) { min$$1 = NAN; }
            if (max$$1 === void 0) { max$$1 = NAN; }
            if (ISNAN(min$$1)) {
                min$$1 = this.min;
            }
            if (ISNAN(max$$1)) {
                max$$1 = this.max;
            }
            this._setThreshold(min$$1, max$$1, false);
        };
        FDSGeographicScale.prototype._setThreshold = function (min$$1, max$$1, setTickRanges) {
            if (ISNAN(min$$1) && ISNAN(max$$1)) {
                return;
            }
            if (ISNAN(min$$1)) {
                min$$1 = this.threshMin;
            }
            if (ISNAN(max$$1)) {
                max$$1 = this.threshMax;
            }
            if (min$$1 > max$$1) {
                _a = [max$$1, min$$1], min$$1 = _a[0], max$$1 = _a[1];
            }
            this.threshMin = this.min = min$$1;
            this.threshMax = this.max = max$$1;
            if (!IsSomeNAN(min$$1) && !IsSomeNAN(max$$1) && (this._bbox != null)) {
                if (this._plotDim === 2 /* Y */) {
                    this._bbox.y = min$$1;
                    this._bbox.height = max$$1 - min$$1;
                }
                else if (this._plotDim === 1 /* X */) {
                    this._bbox.x = min$$1;
                    this._bbox.width = max$$1 - min$$1;
                }
            }
            var _a;
        };
        return FDSGeographicScale;
    }(FDSScale));
    
    var GeoRenderCache = /** @class */ (function (_super) {
        __extends(GeoRenderCache, _super);
        function GeoRenderCache(series) {
            var _this = _super.call(this, series) || this;
            _this.labels = []; // Array of label objects
            _this.svg = null; // SVG DOM object
            _this.absLeft = 0; // The left offset of the SVG in the page
            _this.absTop = 0; // The top offset of the SVG in the page
            _this.baseWidth = 0; // The default width of the SVG
            _this.baseHeight = 0; // The default height of the SVG
            _this.scaleFactor = 1; // The current zoom ratio
            _this.lastScale = 1; // The previous zoom ratio
            _this.moved = false; // State variable for whether a TouchMove happened
            _this.panning = false; // State variable - one finger dragging
            _this.zooming = false; // State variable - two fingers pinching
            _this.touchCount = 0; // Number of fingers on screen
            _this.tapCount = 0; // Number of taps (touchStart then touchEnd)
            _this.x = 0; // Vector towards center
            _this.y = 0;
            _this.originX = 0; // Stores the SVG position offset between interactions
            _this.originY = 0;
            _this.overflowContainer = null; // div to contain SVG and prevent overflow
            _this.resized = false; // State variable for invalidation after zoom
            _this.font = null; // Label font style
            _this.plotWidth = 0; // The displayed width of the SVG in the page
            _this.plotHeight = 0; // The displayed height of the SVG in the page
            _this.MaxZoom = 4.0;
            _this.MinZoom = 1.0;
            _this.oldColorMap = null;
            _this.oldSeriesColor = null;
            _this.oldBGGradient = null;
            _this.tooltipLeft = -1;
            _this.tooltipRight = -1;
            _this.tooltipTop = -1;
            _this.tooltipPctX = -1;
            _this.tooltipPctY = -1;
            _this.tooltipPersisting = false; // variable to keep track of if the tooltip is currently persisting during
            // drag/zoom
            _this.didCreateScales = false;
            _this.series = series;
            _this.root = series.root;
            var UIContext = _this.root.getUIContext();
            _this.tooltip = new FDSInfoBox(UIContext);
            _this.tooltip.setStyle(1 /* IPAD */, UIContext);
            _this._initAxes();
            return _this;
        }
        /**
         * If the chart is hidden via display:none in the dom hierarchy, all of the svg bbox
         * measurement will return (0,0,0,0). To get around this, we can temporarily move the
         * svg container to document.body to make sure measurement succeeds.
         */
        GeoRenderCache.prototype.moveOverFlowContainerToBodyIfNeeded = function () {
            var containingElement = this.root.containing_element;
            if (containingElement.clientWidth === 0 || containingElement.clientHeight === 0) {
                this.overflowContainer.parentElement.removeChild(this.overflowContainer);
                document.body.appendChild(this.overflowContainer);
            }
        };
        /**
         * If we needed to move the container to document.body for measurement reasons, this
         * function will move it back to be a child of the chart div.
         */
        GeoRenderCache.prototype.ensureOverflowContainerIsChildOfChart = function () {
            if (this.overflowContainer && this.overflowContainer.parentElement !== this.root.containing_element) {
                this.overflowContainer.parentElement.removeChild(this.overflowContainer);
                this.root.containing_element.appendChild(this.overflowContainer);
            }
        };
        GeoRenderCache.prototype._initAxes = function () {
            if (!this.didCreateScales) {
                var xAxis = this.series.getAxis(1 /* X */);
                var yAxis = this.series.getAxis(2 /* Y */);
                var oldXScale = xAxis.getScale();
                var oldYScale = yAxis.getScale();
                var plot = this.series.getPlotParent();
                var xScale = new FDSGeographicScale(this.root, "FC_SCALE_X_" + this.series.id, xAxis);
                var yScale = new FDSGeographicScale(this.root, "FC_SCALE_Y_" + this.series.id, yAxis);
                xScale.userThreshEnabled = oldXScale.userThreshEnabled;
                yScale.userThreshEnabled = oldYScale.userThreshEnabled;
                var oldXMin = xAxis.attributeSet.get('ThreshMin');
                var oldXMax = xAxis.attributeSet.get('ThreshMax');
                var oldYMin = yAxis.attributeSet.get('ThreshMin');
                var oldYMax = yAxis.attributeSet.get('ThreshMax');
                xScale._setThreshold(oldXMin, oldXMax, false);
                yScale._setThreshold(oldYMin, oldYMax, false);
                xAxis.scale = xScale;
                yAxis.scale = yScale;
                this.didCreateScales = true;
            }
        };
        // Determines if interaction has changed any chart attributes that need to be redrawn
        GeoRenderCache.prototype.setInvalidated = function () {
            var resize = false;
            var fontChange = false;
            var colorChange = false;
            var plotChange = true;
            var zoomChanged = this.lastViewBox && this.svg != null && this.svg.getAttribute('viewBox') !== this.lastViewBox;
            if (!_$1.isEqual(this.oldColorMap, this.series.colorMap) || this.oldSeriesColor !== this.series.seriesFGPen.color ||
                this.oldBGGradient !== this.series.BGGradientColor) {
                this.oldColorMap = this.series.colorMap;
                this.oldSeriesColor = this.series.seriesFGPen.color;
                this.oldBGGradient = this.series.BGGradientColor;
                colorChange = true;
            }
            if (this.resized || this.lastScale !== this.scaleFactor) {
                resize = true;
                this.resized = false;
            }
            // redo label name degradation (and possibly positioning?)
            if ((this.font != null) && !this.series.seriesLabelFont.equals(this.font)) {
                fontChange = true;
            }
            return { resize: resize, fontChange: fontChange, colorChange: colorChange, plotChange: plotChange, zoomChanged: zoomChanged };
        };
        GeoRenderCache.prototype.getColorScaleRange = function () {
            var zeroBased = this.series.attributeSet.get('KMLMapUseZeroBasedColors');
            var dataClip = this.series.attributeSet.get('DataClipStdDeviation');
            var yData = this.series.getData(2 /* Y */);
            var minVal = yData.Min()[0];
            var maxVal = yData.Max()[0];
            var _a = yData.statistics, mean = _a.mean, stddev = _a.stddev;
            if (zeroBased) {
                // use the smaller of either the maximum change from
                // zero of the data or the average plus the number of standard
                // deviations to clip.
                var dataChangeMax = Math.max(Math.abs(maxVal), Math.abs(minVal));
                var changeMax = Math.min(dataChangeMax, Math.abs(mean) + stddev * dataClip);
                return { colorMin: -changeMax, colorMax: changeMax, valueMin: minVal, valueMax: maxVal };
            }
            else {
                // use the largest distance from the mean or clipped at `dataClip` standard deviations
                var dataChangeMax = Math.max(maxVal - mean, mean - minVal);
                var changeMax = Math.min(dataChangeMax, stddev * dataClip);
                return { colorMin: mean - changeMax, colorMax: mean + changeMax, valueMin: minVal, valueMax: maxVal };
            }
        };
        return GeoRenderCache;
    }(BaseRenderCache));
    
    var ChoroplethDrawStyle = /** @class */ (function (_super) {
        __extends(ChoroplethDrawStyle, _super);
        // Drawstyles are constructed on each draw event, so all important state
        // variables are stored in the renderCache
        function ChoroplethDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._SVGLoad = _this._SVGLoad.bind(_this);
            _this._handleTouchStart = _this._handleTouchStart.bind(_this);
            _this._handleTouchEnd = _this._handleTouchEnd.bind(_this);
            _this._handleTouchMove = _this._handleTouchMove.bind(_this);
            _this._handleMouseMove = _this._handleMouseMove.bind(_this);
            _this._handleClick = _this._handleClick.bind(_this);
            _this._tapTimeout = _this._tapTimeout.bind(_this);
            _this._divClass = svgDivClassPrefix + "_" + series.id;
            return _this;
        }
        ChoroplethDrawStyle.prototype.getColorScaleRange = function () {
            if (!(this._rc instanceof GeoRenderCache)) {
                if (!(this.series.renderCache instanceof GeoRenderCache)) {
                    var tempCache = new GeoRenderCache(this.series);
                    return tempCache.getColorScaleRange();
                }
                else {
                    return this.series.renderCache.getColorScaleRange();
                }
            }
            else {
                return this._rc.getColorScaleRange();
            }
        };
        // override the base fn to do nothing - we handle our own labels
        ChoroplethDrawStyle.prototype.drawTextToBuffer = function (prm, ctx) {
        };
        // Called for each draw event from the chart
        // Constructs elements if they do not yet exist
        // Otherwise calls setInvalidated() on the renderCache and updates existing objects
        ChoroplethDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            try {
                if (!(this.series.renderCache instanceof GeoRenderCache)) {
                    this.series.renderCache = new GeoRenderCache(this.series);
                }
                this._rc = this.series.renderCache;
                this._rc.prm = prm;
                // disable selection event for this chart type
                this._rc.prm.selectionEnabled = false;
                var date = new Date();
                this._rc.elementID = prm.plot.attributeSet.get('SVGElementID');
                this._rc.ajaxElementID = prm.plot.attributeSet.get('SVGElementIDAJAX');
                // if the draw style was different, we need to force recreation of the map
                // TODO Check if this is necessary - the only place that sets StyleChanged to true also nulls out RC
                if (this.series.styleChanged) {
                    this._rc.svg = null;
                    this._rc.labels = [];
                    this.series.styleChanged = false;
                }
                // checking if the chart is cached
                if (this._rc.svg == null) {
                    this._rc.start = date.getTime();
                    var svgURL = prm.chart.getTypedObject(this._rc.ajaxElementID, isDataSet);
                    if (svgURL == null) {
                        // assume the map is included in the XML
                        var result = this._parseSVGXML(prm);
                        if (!result) {
                            this._drawError(prm, ctx);
                            return;
                        }
                    }
                    else {
                        // TODO We could use JQuery here
                        // pull down the map data from the URL
                        if (this._rc.req == null) {
                            var url = svgURL.data[0];
                            var req = new XMLHttpRequest();
                            req.open('GET', url, true);
                            req.onload = this._SVGLoad;
                            req.send();
                            this._rc.req = req;
                            return;
                        }
                        else {
                            if (this._rc.req.status !== 200) {
                                this._drawError(this._rc.prm, ctx);
                                return;
                            }
                        }
                    }
                    this._updateScalesForBbox();
                }
                this._rc.moveOverFlowContainerToBodyIfNeeded();
                this._dealWithZoom(prm);
                // creating chart elements for first time
                if (this._rc.labels.length === 0) {
                    this._setupRegions();
                    // setting the cache item
                    this._rc.overflowContainer.appendChild(this._rc.svg);
                    // Changes the plot size for orientation change, etc
                    this._resizeSVGContainer(this._rc.svg, prm.plotRect.x1, prm.plotRect.x2, prm.plotRect.y1, prm.plotRect.y2);
                    // constructing labels for the first time
                    this._configureLabels(true);
                }
                // check if any elements are invalid
                var changes = this._rc.setInvalidated();
                if (changes.colorChange) {
                    this._setupRegions();
                }
                if (changes.plotChange) {
                    // A plot resize must occur before font label updates to update the currentRatio
                    this._resizeSVGContainer(this._rc.svg, prm.plotRect.x1, prm.plotRect.x2, prm.plotRect.y1, prm.plotRect.y2);
                }
                if (changes.fontChange || changes.resize || changes.zoomChanged) {
                    this._configureLabels(this._rc.labels.length === 0);
                }
            }
            finally {
                this._rc.ensureOverflowContainerIsChildOfChart();
            }
        };
        // helper function to update the scales with the svg zoom box when it is created
        // TODO rename this to imply only running it on initialization
        ChoroplethDrawStyle.prototype._updateScalesForBbox = function () {
            var xScale = this._rc.series.getAxis(1 /* X */).getScale();
            var yScale = this._rc.series.getAxis(2 /* Y */).getScale();
            // x and y axes share a bbox, which starts off as a copy of the svg viewbox (but then gets adjusted)
            this._rc.savedViewBox = {
                width: this._rc.svg.viewBox.baseVal.width,
                height: this._rc.svg.viewBox.baseVal.height,
                x: this._rc.svg.viewBox.baseVal.x,
                y: this._rc.svg.viewBox.baseVal.y
            };
            // first update them both to have the new, correct box. THEN do any aspect ratio calcs, cause those
            // depend on both x and y being set up correctly
            xScale.initBbox(this._rc.savedViewBox);
            yScale.initBbox(this._rc.savedViewBox);
            // TODO Check if resizing the chart breaks things
            xScale.adjustForAspectRatio();
            yScale.adjustForAspectRatio();
        };
        // function to check threshMin/Maxs and adjust the zoom accordingly
        ChoroplethDrawStyle.prototype._dealWithZoom = function (prm) {
            // Getting the Max Zoom Properties - this needs to be done every time because it might have changed
            this._rc.MaxZoom = prm.plot.maxZoom;
            this._rc.MinZoom = prm.plot.minZoom;
            var xScale = this._rc.series.getAxis(1 /* X */).getScale();
            var yScale = this._rc.series.getAxis(2 /* Y */).getScale();
            var width = xScale.threshMax - xScale.threshMin;
            var height = yScale.threshMax - yScale.threshMin;
            this._rc.svg.style.webkitTransform = '';
            this._rc.lastViewBox = this._rc.svg.getAttribute('viewBox');
            this._rc.svg.setAttribute('viewBox', xScale.threshMin + ' ' + yScale.threshMin + ' ' + width + ' ' + height);
        };
        // Called when the AJAX request for the SVG has completed
        // Processes the response and completes first-time chart construction
        ChoroplethDrawStyle.prototype._SVGLoad = function () {
            if (ENABLE_DEBUG && this.root.commonDebug) {
                console.log('SVGLoad');
            }
            if (this._rc.req.status === 200) {
                // AJAX request succeeded
                var date = new Date();
                this._rc.end = date.getTime();
                var result = this._parseSVGXML(this._rc.prm, this._rc.req.responseXML.documentElement);
                if (!result) {
                    // response could not be parsed (not SVG?)
                    this._drawError(this._rc.prm, this.root.getContext());
                    return false;
                }
                this._rc.prm.draw();
                date = new Date();
                var end2 = date.getTime();
                if (ENABLE_DEBUG && this.root.commonDebug) {
                    console.log("AJAX query time: " + (this._rc.end - this._rc.start));
                }
                if (ENABLE_DEBUG && this.root.commonDebug) {
                    console.log("Total time to display: " + (end2 - this._rc.start));
                }
            }
            else {
                // AJAX request failed, display an error
                if (ENABLE_DEBUG) {
                    console.log('AJAX request failed');
                }
                this._rc.prm.draw();
                return false;
            }
            return true;
        };
        ChoroplethDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
        };
        // Displays the EmptyMessage error to the canvas if an error is encountered
        ChoroplethDrawStyle.prototype._drawError = function (prm, ctx) {
            prm.drawEmptyMessage(ctx);
        };
        // Creates the SVG DOM element from XML data or AJAX SVG
        // Sets properties for SVG scaling in page and interaction event handlers
        ChoroplethDrawStyle.prototype._parseSVGXML = function (prm, mapData) {
            // mapData is undefined if we are loading from the XML itself
            var adopted;
            if (mapData == null) {
                // parsing the XML tree of the SVG to add to DOM
                var mapDataSet = prm.chart.getTypedObject(this._rc.elementID, isDataSet);
                if (mapDataSet == null) {
                    // No SVG data in chart XML
                    return false;
                }
                var SVGparsed = prm.chart._parseXML(mapDataSet.data[0]);
                adopted = document.adoptNode(SVGparsed.documentElement); // the actual SVG element
            }
            else {
                adopted = mapData;
            }
            // the viewbox controls what portion of the SVG is shown
            this._rc.baseWidth = adopted.width.baseVal.value;
            this._rc.baseHeight = adopted.height.baseVal.value;
            adopted.setAttribute('viewBox', "0 0 " + adopted.width.baseVal.value + " " + adopted.height.baseVal.value);
            adopted.style.position = 'absolute';
            adopted.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            adopted.setAttribute('overflow', 'hidden');
            adopted.style.overflow = 'hidden';
            prm.chart.containing_element.style.overflow = 'hidden';
            // set regions with data on top of the z-order
            var regions = this._xData.data.map(function (item) { return adopted.getElementById(item.toString()); });
            for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {
                var region = regions_1[_i];
                if (region !== null) {
                    region.parentNode.appendChild(region);
                }
            }
            // If we have previously rendered an SVG, remove it
            var render = this._getSvgDiv();
            if (render) {
                prm.chart.containing_element.removeChild(render);
            }
            // just in case
            this._hideTooltip();
            // div to contain the SVG itself to prevent overflow
            this._rc.overflowContainer = document.createElement('div');
            this._rc.overflowContainer.setAttribute('class', this._divClass);
            this._rc.overflowContainer.style.overflow = 'hidden';
            this._rc.overflowContainer.style.position = 'relative';
            this._rc.overflowContainer.style.zIndex = 2 /* SVG */.toString();
            prm.chart.containing_element.appendChild(this._rc.overflowContainer);
            adopted.addEventListener('mousedown', this._handleClick);
            adopted.addEventListener('touchmove', this._handleTouchMove);
            adopted.addEventListener('touchend', this._handleTouchEnd);
            adopted.addEventListener('touchstart', this._handleTouchStart);
            adopted.addEventListener('mousemove', this._handleMouseMove);
            this._rc.svg = adopted;
            return true;
        };
        // TODO does this actually belong to colormap?
        ChoroplethDrawStyle.prototype._getColorMapper = function () {
            var _a = this._rc.getColorScaleRange(), colorMin = _a.colorMin, colorMax = _a.colorMax;
            var range = colorMax - colorMin;
            return function (yDataItem) { return (yDataItem - colorMin) / range; };
        };
        // Maps series data to color range and identifies region elements
        ChoroplethDrawStyle.prototype._setupRegions = function () {
            var colorMapper = this._getColorMapper();
            var strokeFDSColor = new FDSColor(this.series.seriesFGPen.color);
            var strokeColor = strokeFDSColor.getHex();
            // find the region in the SVG with the ID of the xData element
            for (var i = 0; i < this._xData.data.length; i++) {
                var dataItem = this._xData.data[i].toString();
                var yDataItem = this._yData.getAt(i);
                if (dataItem != null && yDataItem != null && !isNaN(yDataItem)) {
                    // style the region from xData with the color defined by yData
                    var region = this._rc.svg.getElementById(dataItem);
                    if (region == null) {
                        continue;
                    }
                    region['crosshairIndex'] = i;
                    var colorMapValue = colorMapper(yDataItem);
                    // assign color
                    var color = this.series.colorMap.getColor(colorMapValue);
                    var colorString = color.getHex();
                    if (region.localName === 'g') {
                        // style each path element in the group
                        var childPaths = region.getElementsByTagName('path');
                        // tslint:disable-next-line:prefer-for-of
                        for (var j = 0; j < childPaths.length; j++) {
                            var path = childPaths[j];
                            path.style.fill = colorString;
                            path.style.stroke = strokeColor;
                            path['color'] = color;
                            path['crosshairIndex'] = i;
                        }
                    }
                    else if (region.localName === 'path') {
                        region['color'] = color;
                        region.style.fill = colorString;
                        region.style.stroke = strokeColor;
                    }
                    else {
                        // throw an error
                        if (ENABLE_DEBUG) {
                            console.log('Error: region not g or path element');
                        }
                    }
                }
            }
        };
        ChoroplethDrawStyle.prototype._removeLabels = function () {
            for (var _i = 0, _a = this._rc.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                this._rc.svg.removeChild(label);
            }
            this._rc.labels = [];
        };
        // Creates or updates labels
        ChoroplethDrawStyle.prototype._configureLabels = function (setupNew) {
            if (setupNew === void 0) { setupNew = false; }
            if (!this.series.seriesValue) {
                this._removeLabels();
                return;
            }
            var viewBox = this._rc.svg.viewBox.baseVal;
            // don't draw labels if the area we're working with is 0 in any direction
            if (viewBox.width === 0 || this._rc.baseWidth === 0 || viewBox.height === 0 || this._rc.baseHeight === 0) {
                return;
            }
            var ratio;
            if ((this._rc.baseWidth / this._rc.baseHeight) > (this._rc.plotWidth / this._rc.plotHeight)) {
                // height is being scaled
                ratio = viewBox.width / this._rc.baseWidth;
            }
            else {
                ratio = viewBox.height / this._rc.baseHeight;
            }
            if (this._rc.labelRatio == null) {
                // save this once because we don't want zoom to change it
                this._rc.labelRatio = viewBox.height / this._rc.plotHeight;
            }
            // Upper limit on label size to prevent huge text
            if (ratio > 1.5) {
                ratio = 1.5;
            }
            // loop for updating size and name degredation
            var updateSizeName = function (label, width) {
                while (label.getBBox().width * ratio > width) {
                    label.nameIndex++;
                    if (label.nameIndex >= label.names.length) {
                        break;
                    }
                    label.textContent = label.names[label.nameIndex];
                }
            };
            var items;
            if (setupNew) {
                items = this._xData.data;
            }
            else {
                items = this._rc.labels;
            }
            for (var i = 0; i < items.length; i++) {
                var label = void 0;
                var region = void 0;
                var dataItem = items[i];
                if (setupNew) {
                    region = this._rc.svg.getElementById(dataItem);
                    if (region == null) {
                        continue;
                    }
                    // getting NameDegredations property
                    label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    // TODO Is NameDegredations required? This should break if it's undefined
                    var nameDegs = region.getAttribute('factset:NameDegredations');
                    label.names = nameDegs.split(';');
                    label.nameIndex = 0;
                    label.textContent = label.names[0];
                }
                else {
                    label = dataItem;
                    region = label.parent;
                    if (label.clientWidth === 0) {
                        var oldLabel = label;
                        // we have to remake this one, it's broken
                        this._rc.svg.removeChild(label);
                        label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.names = oldLabel.names;
                        label.textContent = oldLabel.names[0];
                        label.setAttribute('text-anchor', 'middle');
                        label.parent = oldLabel.parent;
                        label.offsetX = oldLabel.offsetX;
                        label.offsetY = oldLabel.offsetY;
                        this._rc.labels[i] = dataItem = label;
                        this._rc.svg.appendChild(label);
                    }
                }
                var bbox = region.getBBox();
                // setting position by defined centroid or center of bounding box
                var offsetX = setupNew ? 0 : label.offsetX;
                var offsetY = setupNew ? 0 : label.offsetY;
                if (region.hasAttribute('factset:centroidX')) {
                    label.setAttribute('x', (~~((Number(region.getAttribute('factset:centroidX')) / ratio) + offsetX)).toString());
                }
                else {
                    label.setAttribute('x', (((~~(bbox.x + (bbox.width / 2))) / ratio) + offsetX).toString());
                }
                if (region.hasAttribute('factset:centroidY')) {
                    label.setAttribute('y', (~~((Number(region.getAttribute('factset:centroidY')) / ratio) + offsetY)).toString());
                }
                else {
                    label.setAttribute('y', (((~~(bbox.y + (bbox.height / 2))) / ratio) + offsetY).toString());
                }
                if (setupNew) {
                    label.setAttribute('text-anchor', 'middle');
                }
                else {
                    // update size and name degradation
                    label.nameIndex = 0;
                    label.textContent = label.names[0];
                    updateSizeName(label, bbox.width);
                }
                var style = this.series.seriesLabelFont.toPropertyObject();
                // need to convert from svg pixels to canvas pixels
                style.height = ~~(style.height * this._rc.labelRatio);
                if (setupNew) {
                    this._rc.font = this.series.seriesLabelFont;
                }
                // we can't just use style.font because we have modified/rescaled the height
                // TODO If we directly modfied font height before getting style we might not have to do this
                // TODO we should call this label<something>Element so the setAttribute is less confusing
                label.setAttribute('style', "font:" + style.italic + " " + style.weight + " " + style.height + "px " + style.family + ";");
                label.setAttribute('fill', style.fillStyle);
                label.setAttribute('pointer-events', 'none');
                label.setAttribute('transform', "scale(" + ratio + ")");
                label.scale = ratio;
                if (setupNew) {
                    label.parent = region;
                    this._rc.labels.push(label);
                    this._rc.svg.appendChild(label);
                    // using NameDegradations
                    // TODO Might be able to put this outside if (we do it above when !setupNew)
                    updateSizeName(label, bbox.width);
                }
            }
            this._repositionLabels();
        };
        // This function controls the SVG container size on the page
        ChoroplethDrawStyle.prototype._resizeSVGContainer = function (svg, x1, x2, y1, y2) {
            // determine svg width and height
            this._rc.overflowContainer.style.left = scaleByDevicePixelRatioInverse(x1) + 'px';
            this._rc.overflowContainer.style.top = scaleByDevicePixelRatioInverse(y1) + 'px';
            this._rc.plotWidth = scaleByDevicePixelRatioInverse(x2 - x1);
            this._rc.plotHeight = scaleByDevicePixelRatioInverse(y2 - y1);
            svg.setAttribute('width', this._rc.plotWidth + 'px');
            svg.setAttribute('height', this._rc.plotHeight + 'px');
            this._rc.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            this._rc.overflowContainer.style.width = this._rc.plotWidth + 'px';
            this._rc.overflowContainer.style.height = this._rc.plotHeight + 'px';
            var parent = svg.parentNode;
            if (parent) {
                var curleft = parent.offsetLeft;
                var curtop = parent.offsetTop;
                var walk = parent;
                while (walk = walk.offsetParent) {
                    curleft += walk.offsetLeft;
                    curtop += walk.offsetTop;
                }
                this._rc.absLeft = curleft;
                this._rc.absTop = curtop;
            }
            else {
                this._rc.absLeft = this._rc.absTop = 0;
            }
        };
        // Resizes SVG to default and applies CSS effects
        ChoroplethDrawStyle.prototype._applyEffects = function () {
            // To zoom out or pan while zoomed, we need to render the whole image
            // The CSS effects only work on the rendered bitmap image
            // so we will have blank spots if we don't resize to default
            this._rc.svg.setAttribute('viewBox', "0 0 " + this._rc.baseWidth + " " + this._rc.baseHeight);
            this._rc.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            var curScale = this._rc.scaleFactor;
            // To not have the original SVG flash on the screen, we retransform it
            var calcX = this._rc.originX;
            var calcY = this._rc.originY;
            this._rc.svg.style.webkitTransform
                = "scale3d(" + curScale + ", " + curScale + ", 1) translate3d(" + calcX + "px, " + calcY + "px, 0)";
        };
        // Also see ChartRenderManager for interaction events
        ChoroplethDrawStyle.prototype._handleTouchStart = function (event) {
            if (this.root.suppressAllInteraction) {
                return;
            }
            event.preventDefault();
            this._rc.moved = false;
            this._rc.touchCount++;
            // error double checking
            if (this._rc.touchCount === 2 && event.touches[1] === undefined) {
                this._rc.touchCount = 1;
            }
            this._rc.target = event.target;
            if (this._rc.touchCount === 2) {
                // If we have two touches, we are zoooming
                var zoomEvent = event;
                this._rc.panning = false;
                this._rc.zooming = true;
                this._rc.lastScale = zoomEvent.scale;
                // The reference point for the zoom (midpoint of first touches)
                this._rc.refX = (this._rc.refX + zoomEvent.touches[1].clientX) / 2;
                this._rc.refY = (this._rc.refY + zoomEvent.touches[1].clientY) / 2;
                // Stores a vector towards the center while zooming
                this._rc.x = 0;
                this._rc.y = 0;
                // Variables to store current panning
                this._rc.panX = 0;
                this._rc.panY = 0;
                // only move the tooltip if it is turned on, persistence is turned on, and it's currently visible
                if (this.root.clickTooltipEnabled && this.root.persist && this._rc.tooltip.isVisible()) {
                    this._rc.tooltipPersisting = true;
                    // calculate tooltip percentage for keeping it in place while zooming
                    var _a = this._calcReals(this._rc.originX, this._rc.originY), realX = _a[0], realY = _a[1], realWidth = _a[2], realHeight = _a[3];
                    this._rc.tooltipPctX = (this._rc.tooltipLeft - scaleByDevicePixelRatio(realX)) /
                        scaleByDevicePixelRatio(realWidth);
                    this._rc.tooltipPctY = (this._rc.tooltipTop - scaleByDevicePixelRatio(realY)) /
                        scaleByDevicePixelRatio(realHeight);
                }
                this._applyEffects();
            }
            else if (this._rc.touchCount === 1) {
                // only move the tooltip if it is turned on, persistence is turned on, and it's currently visible
                if (this.root.clickTooltipEnabled && this.root.persist && this._rc.tooltip.isVisible()) {
                    this._rc.tooltipPersisting = true;
                }
                this._rc.panning = true;
                this._rc.zooming = false;
                this._rc.panX = 0;
                this._rc.panY = 0;
                var clientRect = this.root.containing_element.getBoundingClientRect();
                this._rc.refX = event.touches[0].clientX - clientRect.left;
                this._rc.refY = event.touches[0].clientY - clientRect.top;
            }
        };
        // TODO maybe this should be in the rendercache
        ChoroplethDrawStyle.prototype._handleTouchEnd = function (event) {
            var _this = this;
            if (this.root.suppressAllInteraction) {
                return false;
            }
            event.preventDefault();
            // move has ended so the tooltip isn't currently persisting anymore
            this._rc.tooltipPersisting = false;
            // housekeeping for event variables depending on pan/zoom/tap
            if (this._rc.zooming) {
                var zoomEvent = event;
                if (zoomEvent.scale != null) {
                    this._rc.scaleFactor *= zoomEvent.scale;
                }
                if (this._rc.scaleFactor < this._rc.MinZoom) {
                    this._rc.scaleFactor = this._rc.MinZoom;
                }
                if (this._rc.scaleFactor > this._rc.MaxZoom) {
                    this._rc.scaleFactor = this._rc.MaxZoom;
                }
                this._rc.resized = true;
                this._rc.lastScale = 1;
                this._rc.originX += this._rc.x + this._rc.panX;
                this._rc.originY += this._rc.y + this._rc.panY;
                this._rc.tapCount = 0;
                this._rc.touchCount = 1;
                this._rc.panning = true;
                this._rc.zooming = false;
                this._rc.panX = 0;
                this._rc.panY = 0;
                this.root.renderManager.interactivityMode = 1 /* CROSSHAIRS */;
                if (this.root.clickTooltipEnabled && !this.root.persist) {
                    this._hideTooltip();
                }
                _a = this._adjustPan(this._rc.originX, this._rc.originY), this._rc.originX = _a[0], this._rc.originY = _a[1];
                // we still have one finger down so we're not gonna close out everything yet
                return true;
            }
            else if (this._rc.moved === false) {
                // If we have one finger and haven't moved, tap event
                this._rc.tapCount++;
                this._rc.touchCount--;
                // start a short callback to determine how many taps we have
                if (this._rc.tapCount === 1) {
                    var interval = setTimeout(function () {
                        return _this._tapTimeout();
                    }, CLICK_TIMEOUT_MS);
                }
            }
            else if (this._rc.panning) {
                // One finger and we have moved
                this._rc.tapCount = 0;
                this._rc.touchCount = 0;
            }
            else {
                // Second finger touchend from zoom, or error
                return false;
            }
            this._rc.panning = false;
            this._rc.zooming = false;
            this._rc.panX = 0;
            this._rc.panY = 0;
            // Now that the touch events have ended, we resize the SVG
            // div/0 checks:
            if (this._rc.baseWidth === 0 || this._rc.plotWidth === 0 || this._rc.baseHeight === 0 ||
                this._rc.plotHeight === 0) {
                return false;
            }
            var actualWidth, actualHeight;
            var w, h;
            var left, top;
            // find whether the height or width is scaled due to aspect ratio
            if ((this._rc.baseWidth / this._rc.baseHeight) > (this._rc.plotWidth / this._rc.plotHeight)) {
                // height being scaled here
                // There are basically three coordinate spaces at play here:
                // 1. The screen space with the transformed image
                // 2. The SVG coordinate space
                // 3. The actual displayed SVG coordinate space, after adjusting for aspect ratio being locked
                // We disable the preserveAspectRatio property to make things line up in space #2
                // We need to set the width, height, top, and left in the coordinate space #2
                // To do that, we set the height to fill the viewport given the width
                // We then adjust the top coordinate based on the scaled (actual, space #3) height
                // find the actual height
                actualWidth = this._rc.plotWidth;
                actualHeight = (actualWidth * this._rc.baseHeight) / this._rc.baseWidth;
                w = this._rc.baseWidth / this._rc.scaleFactor; // in base coordinates
                h = (w * this._rc.plotHeight) / this._rc.plotWidth; // in base coordinates
                left = ((this._rc.baseWidth / 2) - (w / 2)) - ((this._rc.originX / this._rc.plotWidth) * this._rc.baseWidth);
                // originally in base coordinates, rendercache is converted to base too
                // take midpoint, offset to top left of viewbox, adjust by origin movement
                top = ((this._rc.baseHeight / 2) - (h / 2)) - ((this._rc.originY / actualHeight) * this._rc.baseHeight);
                // base coordinates - actual coordinates transformed into base
            }
            else {
                // width being scaled here
                // otherwise see above
                actualHeight = this._rc.plotHeight;
                actualWidth = (actualHeight * this._rc.baseWidth) / this._rc.baseHeight;
                h = this._rc.baseHeight / this._rc.scaleFactor;
                w = (h * this._rc.plotWidth) / this._rc.plotHeight;
                left = ((this._rc.baseWidth / 2) - (w / 2)) - ((this._rc.originX / actualWidth) * this._rc.baseWidth);
                top = ((this._rc.baseHeight / 2) - (h / 2)) - ((this._rc.originY / this._rc.plotHeight) * this._rc.baseHeight);
            }
            // Clear transforms and update the viewBox to rerender SVG
            this._rc.svg.style.webkitTransform = '';
            this._rc.svg.setAttribute('preserveAspectRatio', 'none');
            this._rc.svg.setAttribute('viewBox', left + ' ' + top + ' ' + w + ' ' + h);
            this._rc.svg.forceRedraw();
            // Update the labels to adjust for different zoom level
            this._configureLabels();
            if (ENABLE_DEBUG) {
                console.log('TouchEnd');
            } // Workaround for webkit bug - see twiki documentation
            return true;
            var _a;
        };
        ChoroplethDrawStyle.prototype._handleTouchMove = function (event) {
            if (this.root.suppressAllInteraction) {
                return false;
            }
            // Fires every time a finger moves
            event.preventDefault();
            this._rc.moved = true;
            // double error check
            if (this._rc.zooming && event.touches[1] === undefined) {
                this._rc.zooming = false;
                this._rc.panning = true;
                // set up panning variables
                var clientRect = this.root.containing_element.getBoundingClientRect();
                this._rc.refX = event.touches[0].clientX - clientRect.left;
                this._rc.refY = event.touches[0].clientY - clientRect.top;
            }
            // Hiding the tooltip
            if (this.root.clickTooltipEnabled && !this.root.persist) {
                this._hideTooltip();
            }
            var uiCtx = this.root.getUIContext();
            if (this._rc.zooming) {
                var zoomEvent = event;
                // We use the relative scale to find the offset for this adjustment
                var relScale = zoomEvent.scale / this._rc.lastScale;
                var calcVector = true;
                // scaleFactor is the result of the last zoom event
                var curScale = this._rc.scaleFactor * zoomEvent.scale;
                if (curScale < this._rc.MinZoom) {
                    curScale = this._rc.MinZoom;
                    calcVector = false;
                }
                if (curScale > this._rc.MaxZoom) {
                    curScale = this._rc.MaxZoom;
                    calcVector = false;
                }
                this._rc.lastScale = zoomEvent.scale;
                if (calcVector) {
                    // Create a vector towards the center
                    var x = this._rc.refX - this._rc.absLeft - (this._rc.plotWidth / 2);
                    var y = this._rc.refY - this._rc.absTop - (this._rc.plotHeight / 2);
                    // The difference of this particular movement
                    this._rc.x = (-x * (zoomEvent.scale - 1)) / curScale;
                    this._rc.y = (-y * (zoomEvent.scale - 1)) / curScale;
                }
                // calculating pan
                var midX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
                var midY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
                this._rc.panX = (midX - this._rc.refX) / curScale;
                this._rc.panY = (midY - this._rc.refY) / curScale;
                var calcX = this._rc.originX + this._rc.x + this._rc.panX;
                var calcY = this._rc.originY + this._rc.y + this._rc.panY;
                _a = this._adjustPan(calcX, calcY, curScale), calcX = _a[0], calcY = _a[1];
                // only move the tooltip if it is turned on, persistence is turned on, and it's currently persisting
                if (this.root.clickTooltipEnabled && this.root.persist && this._rc.tooltipPersisting) {
                    var pR = this._rc.prm.plotRect;
                    // move the tooltip too
                    var _b = this._calcReals(calcX, calcY, curScale), realX = _b[0], realY = _b[1], realWidth = _b[2], realHeight = _b[3];
                    var newleft = ((this._rc.tooltipPctX * scaleByDevicePixelRatio(realWidth)) +
                        scaleByDevicePixelRatio(realX));
                    var newtop = ((this._rc.tooltipPctY * scaleByDevicePixelRatio(realHeight)) +
                        scaleByDevicePixelRatio(realY));
                    // we can just use the width and height members here cause nothing about the box has changed
                    var newright = newleft + this._rc.tooltip.width;
                    var newbottom = newtop + this._rc.tooltip.height;
                    if (newleft < pR.x1 || newtop < pR.y1 || newright > pR.x2 || newbottom > pR.y2) {
                        // remove it but don't hide it! because a visible offscreen tooltip can be dragged onscreen again
                        this._rc.tooltip.remove(uiCtx);
                    }
                    else {
                        this._rc.tooltip.updatePosition(newleft, newtop, uiCtx);
                        this._rc.tooltip.show(uiCtx);
                    }
                    this._rc.tooltipLeft = newleft;
                    this._rc.tooltipTop = newtop;
                }
                // 3d scale and translate are GPU accelerated, while the regular ones are not
                this._rc.svg.style.webkitTransform
                    = "scale3d(" + curScale + ", " + curScale + ", 1) translate3d(" + calcX + "px, " + calcY + "px, 0)";
            }
            else if (this._rc.panning) {
                var x = event.touches[0].clientX;
                var y = event.touches[0].clientY;
                var curScale = this._rc.scaleFactor;
                if (this._rc.panX !== 0) {
                    var oldX = this._rc.originX;
                    var oldY = this._rc.originY;
                    // Move the origin by however much the move has changed since last time
                    this._rc.originX += (x - this._rc.panX) / curScale;
                    this._rc.originY += (y - this._rc.panY) / curScale;
                    _c = this._adjustPan(this._rc.originX, this._rc.originY), this._rc.originX = _c[0], this._rc.originY = _c[1];
                    // only move the tooltip if it is turned on, persistence is turned on, and it's currently visible
                    if (this.root.clickTooltipEnabled && this.root.persist && this._rc.tooltipPersisting) {
                        // move the tooltip too
                        var newleft = this._rc.tooltipLeft + scaleByDevicePixelRatio((this._rc.originX - oldX) * curScale);
                        var newtop = this._rc.tooltipTop + scaleByDevicePixelRatio((this._rc.originY - oldY) * curScale);
                        // we can just use the width and height members here cause nothing about the box has changed
                        var newright = newleft + this._rc.tooltip.width;
                        var newbottom = newtop + this._rc.tooltip.height;
                        var pR = this._rc.prm.plotRect;
                        if (newleft < pR.x1 || newtop < pR.y1 || newright > pR.x2 || newbottom > pR.y2) {
                            // remove it but don't hide it! because a visible offscreen tooltip can be dragged onscreen again
                            this._rc.tooltip.remove(uiCtx);
                        }
                        else {
                            this._rc.tooltip.updatePosition(newleft, newtop, uiCtx);
                            this._rc.tooltip.show(uiCtx);
                        }
                        this._rc.tooltipLeft = newleft;
                        this._rc.tooltipTop = newtop;
                    }
                    this._rc.panX = x;
                    this._rc.panY = y;
                    this._rc.svg.style.webkitTransform
                        = "scale3d(" + curScale + ", " + curScale + ", 1) translate3d(" + this._rc.originX + "px, " + this._rc.originY + "px, 0)";
                }
                else {
                    // first move event, so do nothing but store variables and prepare
                    this._applyEffects();
                    this._rc.panX = x;
                    this._rc.panY = y;
                }
            }
            else {
                this._rc.touchCount = 0;
            }
            return true;
            var _a, _c;
        };
        // helper fn for hiding the tooltip
        ChoroplethDrawStyle.prototype._hideTooltip = function () {
            this._rc.tooltip.hide(this.root.getUIContext());
            // get rid of stored tooltip info just in case
            this._rc.tooltipPersisting = false;
            this._rc.tooltipPctX = this._rc.tooltipPctY = this._rc.tooltipLeft = this._rc.tooltipRight = -1;
            this.root.geoTooltipVisible = false;
        };
        // helper fn to calculate real coords
        ChoroplethDrawStyle.prototype._calcReals = function (x, y, scale, width, height) {
            if (scale === void 0) { scale = this._rc.scaleFactor; }
            if (width === void 0) { width = this._rc.plotWidth; }
            if (height === void 0) { height = this._rc.plotHeight; }
            var realWidth = width * scale;
            var realX = (x * scale) - ((realWidth - width) / 2);
            var realHeight = height * scale;
            var realY = (y * scale) - ((realHeight - height) / 2);
            return [realX, realY, realWidth, realHeight];
        };
        // helper fn to make sure you haven't panned too far
        ChoroplethDrawStyle.prototype._adjustPan = function (x, y, scale) {
            if (scale === void 0) { scale = this._rc.scaleFactor; }
            // adjusted for scale
            var _a = this._calcReals(x, y, scale), realX = _a[0], realY = _a[1], realWidth = _a[2], realHeight = _a[3];
            // set it so realX/Y is the correct value and reverse engineer the value for originX/Y
            if (realX > 0) {
                x = (realWidth - this._rc.plotWidth) / (scale * 2);
            }
            if (realY > 0) {
                y = (realHeight - this._rc.plotHeight) / (scale * 2);
            }
            if (realX + realWidth < this._rc.plotWidth) {
                x = (this._rc.plotWidth - realWidth) / (scale * 2);
            }
            if (realY + realHeight < this._rc.plotHeight) {
                y = (this._rc.plotHeight - realHeight) / (scale * 2);
            }
            return [x, y];
        };
        ChoroplethDrawStyle.prototype._handleMouseMove = function (event) {
            if (this.root.suppressAllInteraction) {
                return false;
            }
            if (!event.target || event.target['crosshairIndex'] == null) {
                return false;
            }
            if (this.root.rubberBandMode === 0 /* NONE */) {
                // fake a pick and then call into the tooltip handler
                this.root.pick.setAccessObject(this.series.id);
                this.root.pick.setAccessSubObject(event.target['crosshairIndex']);
                this.root.tooltip.doTooltip(true, event);
                this.root.tooltipHandled = true;
            }
            return true;
        };
        // Replace touch interaction for desktop use
        ChoroplethDrawStyle.prototype._handleClick = function (event) {
            if (this.root.suppressAllInteraction) {
                return false;
            }
            this.root.renderManager.interactivityMode = 1 /* CROSSHAIRS */;
            this.series.crosshairIndex = event.target['crosshairIndex'];
            this._hideTooltip();
            if (this.series.crosshairIndex != null) {
                // save the active plot we just clicked on
                this.root.activePlot = this.series.getPlotParent().id;
            }
            else {
                // un-save the active plot
                this.root.activePlot = undefined;
            }
            if ((this.series.crosshairIndex != null) && this.root.clickTooltipEnabled && event.which === 1 /* LEFT */) {
                var clientRect = this.root.containing_element.getBoundingClientRect();
                this._rc.tooltipLeft = event.clientX - clientRect.left;
                this._rc.tooltipTop = event.clientY - clientRect.top;
                this._rc.tooltip.update({
                    visible: true,
                    text: this.root.compiledCrosshairsTooltipText.fromValue(),
                    y: this._rc.tooltipTop,
                    x: this._rc.tooltipLeft
                }, this.root.getUIContext());
                this.root.geoTooltipVisible = true; // save this to prevent chart from drawing over the tooltip
            }
            return true;
        };
        // This method is called CLICK_TIMEOUT_MS ms (defined in globals) after the first tap interaction
        // If we have only 1 tap, we display the tooltip
        // If we have 2 taps (double click), we reset the map zoom and position
        ChoroplethDrawStyle.prototype._tapTimeout = function () {
            if (this.root.suppressAllInteraction) {
                return false;
            }
            if (this._rc.tapCount < 2) {
                // display the tooltip
                this._rc.tapCount = 0;
                if ((this._rc.target['crosshairIndex'] == null) || !this.root.clickTooltipEnabled) {
                    this._hideTooltip();
                    return false;
                }
                this.root.renderManager.interactivityMode = 1 /* CROSSHAIRS */;
                this.series.crosshairIndex = this._rc.target['crosshairIndex'];
                var x = scaleByDevicePixelRatio(this._rc.refX);
                var y = scaleByDevicePixelRatio(this._rc.refY);
                this._rc.tooltip.update({
                    visible: true,
                    text: this.root.compiledCrosshairsTooltipText.fromValue(),
                    y: y,
                    x: x
                }, this.root.getUIContext());
                this._rc.tooltipLeft = x;
                this._rc.tooltipTop = y;
                if (ENABLE_DEBUG) {
                    console.log('Tooltip');
                } // Workaround for webkit bug - see twiki documentation
                this.root.geoTooltipVisible = true; // save this to prevent chart from drawing over the tooltip
            }
            else {
                // reset map position
                // Clear the crosshairs
                this.root.renderManager.interactivityMode = 1 /* CROSSHAIRS */;
                this._hideTooltip();
                this._rc.resized = true;
                this._rc.tapCount = 0;
                this._rc.touchCount = 0;
                this._rc.scaleFactor = 1;
                this._rc.lastScale = 1;
                this._rc.originX = 0;
                this._rc.originY = 0;
                this._rc.svg.style.webkitTransform = '';
                this._rc.svg.setAttribute('viewBox', "0 0 " + this._rc.baseWidth + " " + this._rc.baseHeight);
                this._rc.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                this._rc.svg.forceRedraw();
            }
            return true;
        };
        // Convenience method for repositionLabels
        // determines if two bounding boxes intersect
        ChoroplethDrawStyle.prototype._bboxIntersect = function (a, b) {
            return (Math.abs(a.x - b.x) * 2 < (a.width + b.width)) &&
                (Math.abs(a.y - b.y) * 2 < (a.height + b.height));
        };
        // Ported directly from the PC FDSKMLMap.cpp
        // This function moves the labels to prevent overlapping
        ChoroplethDrawStyle.prototype._repositionLabels = function () {
            var goodlabels = [];
            // setting beginning position for labels
            for (var _i = 0, _a = this._rc.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                label.bbox = label.getBBox();
                // check if it's good to display - in phantomjs, for example, the bbox is all 0s
                if (label.bbox.x === 0 && label.bbox.y === 0 && label.bbox.width === 0 && label.bbox.height === 0) {
                    this._rc.svg.removeChild(label);
                    continue;
                }
                else {
                    goodlabels.push(label);
                }
                // adjust the bounding box for the SVG scale transform
                var center = {
                    x: label.bbox.x + (label.bbox.width / 2),
                    y: label.bbox.y + (label.bbox.height / 2)
                };
                label.origCenter = center;
                label.center = { x: center.x, y: center.y };
            }
            this._rc.labels = goodlabels;
            var maxDist = this.series.seriesValueAutoPositionMaxDistance;
            var damping = 2;
            var stopAfter = 10;
            var numberOfRuns = 0;
            var lastRun = 0;
            var totalAdjustment = 0;
            // We'll apply our repositioning logic in a loop, halting once we hit
            // zero overlap or we've had stopAfter runs with the same amount of
            // change between them
            // TODO This autoposition algorithm could be better
            for (var count = 0; count <= this.series.seriesValueAutoPositionSteps; count++) {
                for (var _b = 0, _c = this._rc.labels; _b < _c.length; _b++) {
                    var v = _c[_b];
                    for (var _d = 0, _e = this._rc.labels; _d < _e.length; _d++) {
                        var u = _e[_d];
                        if (u === v) {
                            continue;
                        }
                        if (this._bboxIntersect(u.bbox, v.bbox)) {
                            // the two labels intersect
                            var intersect = new Rectangle(Math.max(u.bbox.x, v.bbox.x), Math.max(u.bbox.y, v.bbox.y), Math.min(u.bbox.x + u.bbox.width, v.bbox.x + v.bbox.width), Math.min(u.bbox.y + u.bbox.height, v.bbox.y + v.bbox.height));
                            var halfX = intersect.getWidth() / 2;
                            var halfY = intersect.getHeight() / 2;
                            // Clamp the maximum amount of movement since we run this
                            // code multiple times
                            halfX = Math.min(damping, halfX);
                            halfY = Math.min(damping, halfY);
                            // find the center of the two bounding boxes
                            var up = {
                                x: u.bbox.x + (u.bbox.width / 2),
                                y: u.bbox.y + (u.bbox.height / 2)
                            };
                            var vp = {
                                x: v.bbox.x + (v.bbox.width / 2),
                                y: v.bbox.y + (v.bbox.height / 2)
                            };
                            // Calculate the sign of the X and Y movement to move the
                            // two labels apart in a sensible way
                            var vxs = vp.x > up.x ? 1 : -1;
                            var vys = vp.y > up.y ? 1 : -1;
                            var uxs = up.x > vp.x ? 1 : -1;
                            var uys = up.y > vp.y ? 1 : -1;
                            // Only move the label a maximum of maxDist away from its
                            // centroid in either direction
                            vxs = Math.abs(v.center.x - v.origCenter.x) > maxDist ? 0 : vxs;
                            vys = Math.abs(v.center.y - v.origCenter.y) > maxDist ? 0 : vys;
                            uxs = Math.abs(u.center.x - u.origCenter.x) > maxDist ? 0 : uxs;
                            uys = Math.abs(u.center.y - u.origCenter.y) > maxDist ? 0 : uys;
                            // Move the label the minimum distance required in either
                            // direction to resolve the collision. For instance, if
                            // the overlap is two pixels in the X direction and 10
                            // pixels in the Y direction, we only need to move each
                            // label by a pixel left and right, and we'll move it
                            // a pixel up and down just to make it visually pleasing.
                            if (halfX < halfY) {
                                halfY = halfX;
                            }
                            else {
                                halfX = halfY;
                            }
                            // Apply the changes calculated above
                            v.center.x += vxs * halfX;
                            v.center.y += vys * halfY;
                            u.center.x += uxs * halfX;
                            u.center.y += uys * halfY;
                            totalAdjustment += halfX + halfY;
                        }
                    }
                }
                // outside both foreach loops
                if (totalAdjustment === lastRun) {
                    numberOfRuns++;
                }
                else {
                    numberOfRuns = 0;
                }
                // Stop the simulation if we haven't moved any of the labels or if
                // we've moved them the same amount for the past stopAfter runs
                if (totalAdjustment === 0 || numberOfRuns === stopAfter) {
                    break;
                }
                lastRun = totalAdjustment;
            }
            // position the labels
            for (var _f = 0, _g = this._rc.labels; _f < _g.length; _f++) {
                var label = _g[_f];
                label.setAttribute('x', ~~label.center.x + 'px');
                label.setAttribute('y', ~~(label.center.y + (label.bbox.height / 2)) + 'px');
                label.offsetX = label.center.x - label.origCenter.x;
                label.offsetY = label.center.y - label.origCenter.y;
            }
        };
        ChoroplethDrawStyle.prototype._getSvgDiv = function () {
            var elements = this.series.root.containing_element.getElementsByClassName(this._divClass);
            return elements.length === 1 ? elements[0] : undefined;
        };
        return ChoroplethDrawStyle;
    }(BaseDrawStyle));
    
    /**
     * Class for the oval hitshape. Can represent any slice of an oval (up to a full oval)
     * as well as donut-style oval slices/shapes
     *
     * @class FDSOvalHitShape
     * @extends {FDSShape}
     */
    var FDSOvalHitShape = /** @class */ (function (_super) {
        __extends(FDSOvalHitShape, _super);
        /**
         * Creates an instance of FDSOvalHitShape, and sets up a oval with all variables at 0
         */
        function FDSOvalHitShape() {
            var _this = _super.call(this) || this;
            _this.name = 'Oval';
            _this.centerX = _this.centerY = _this.offset = _this.smallerAngle = _this.largerAngle = _this.radiusX = _this.radiusY
                = _this.innerRadiusX = _this.innerRadiusY = 0;
            _this._updateBounds();
            return _this;
        }
        /**
         * Function to update the coordinates of the oval's bounding rectangle
         */
        FDSOvalHitShape.prototype._updateBounds = function () {
            this.y1 = this.centerY - this.radiusY - 1;
            this.y2 = this.centerY + this.radiusY;
            this.x1 = this.centerX - this.radiusX;
            this.x2 = this.centerX + this.radiusX + 1;
        };
        /**
         * Set the center point of the oval hitshape
         *
         * @param cx - the center x-coordinates
         * @param cy - the center x-coordinates
         */
        FDSOvalHitShape.prototype.setCenter = function (cx, cy) {
            this.centerX = cx;
            this.centerY = cy;
            this._updateBounds();
        };
        /**
         * Set the x and y radius values
         *
         * @param rX - the new radius in the x direction
         * @param rY - the new radius in the y direction
         */
        FDSOvalHitShape.prototype.setRadii = function (rX, rY) {
            this.radiusX = rX;
            this.radiusY = rY;
            this._updateBounds();
        };
        /**
         * Set the inner x and y radius values
         *
         * @param rX - the new inner radius in the x direction (for a donut)
         * @param rY - the new inner radius in the y direction (for a donut)
         */
        FDSOvalHitShape.prototype.setInnerRadii = function (rX, rY) {
            this.innerRadiusX = rX;
            this.innerRadiusY = rY;
        };
        /**
         * test for whether a point (or other shape) is inside this oval
         *
         * @param cx - the x-coordinate of the point (or shape) being tested
         * @param cy - the y-coordinates of the point (or shape) being tested
         * @returns whether the point (or shape) is inside the oval
         */
        FDSOvalHitShape.prototype.onHitTest = function (cx, cy) {
            var x = cx - this.centerX;
            var y = cy - this.centerY;
            var x2 = x * x;
            var y2 = y * y;
            // check the point is inside the outer oval
            var r = x2 / (this.radiusX * this.radiusX) + y2 / (this.radiusY * this.radiusY);
            if (r >= 1) {
                return false;
            }
            // check the point isn't inside the inner donut oval
            if (this.innerRadiusX > 0 && this.innerRadiusY > 0) {
                r = x2 / (this.innerRadiusX * this.innerRadiusX) + y2 / (this.innerRadiusY * this.innerRadiusY);
                if (r < 1) {
                    return false;
                }
            }
            // check the point is at the right angle
            var angle = Math.atan2(y, x) - this.offset;
            var angle2;
            if (angle < 0) {
                angle2 = angle + 2 * Math.PI;
            }
            else {
                angle2 = angle - 2 * Math.PI;
            }
            // angle can be between -2PI and 2PI so check both versions of it
            if ((this.smallerAngle <= angle && this.largerAngle >= angle) ||
                (this.smallerAngle <= angle2 && this.largerAngle >= angle2)) {
                return true;
            }
            return false;
        };
        /**
         * Given a shape (this line) and a rectangle that is overlapping it, provide
         * a shift in either the positive or negative y direction to avoid the shape.
         *
         * @param x1 - the x-coordinate of the first corner of the rectangle
         * @param y1 - the y-coordinate of the first corner of the rectangle
         * @param x2 - the x-coordinate of the second corner of the rectangle
         * @param y2 - the y-coordinate of the second corner of the rectangle
         * @param moveUp - whether the shift should be up
         * @returns the amount to shift in the given direction
         */
        FDSOvalHitShape.prototype.getAvoidanceOffset = function (x1, y1, x2, y2, moveUp) {
            var top = this.centerY - this.radiusY - 1;
            var bottom = this.centerY + this.radiusY;
            if (moveUp) {
                return Math.min(-1, -Math.abs(Math.max(y1, y2) - top));
            }
            else {
                return Math.max(1, Math.abs(Math.min(y1, y2) - bottom));
            }
        };
        /**
         * Test whether a given rectangle instersects this oval
         *
         * @param x1 - the x-coordinate of the first corner of the rectangle
         * @param y1 - the y-coordinate of the first corner of the rectangle
         * @param x2 - the x-coordinate of the second corner of the rectangle
         * @param y2 - the y-coordinate of the second corner of the rectangle
         * @returns whether or not the rectangle intersects the oval
         */
        FDSOvalHitShape.prototype.hitTest = function (x1, y1, x2, y2) {
            var ret = this._inXRangeHelper(Math.min(y1, y2), Math.max(y1, y2), Math.min(this.y1, this.y2), Math.max(this.y1, this.y2));
            ret = ret && this._inXRangeHelper(Math.min(x1, x2), Math.max(x1, x2), Math.min(this.x1, this.x2), Math.max(this.x1, this.x2));
            return ret;
        };
        FDSOvalHitShape.prototype.shadeShape = function (ctx) {
            _super.prototype.shadeShape.call(this, ctx);
            if (this.largerAngle === 360) {
                return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.ellipse(this.centerX, this.centerY, this.radiusX, this.radiusY);
            ctx.closePath();
            ctx.clip();
            var radius = Math.max(this.radiusX, this.radiusY);
            var innerRadius = Math.max(this.innerRadiusX, this.innerRadiusY);
            ctx.beginPath();
            if (!(innerRadius > 0)) {
                ctx.moveTo(this.centerX, this.centerY);
            }
            ctx.arc(this.centerX, this.centerY, radius, this.smallerAngle, this.largerAngle, false);
            if (innerRadius > 0) {
                ctx.arc(this.centerX, this.centerY, innerRadius, this.largerAngle, this.smallerAngle, true);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        };
        return FDSOvalHitShape;
    }(FDSShape));
    
    var InteractiveDrawStyle = /** @class */ (function (_super) {
        __extends(InteractiveDrawStyle, _super);
        function InteractiveDrawStyle(series, dim) {
            var _this = _super.call(this, series, dim) || this;
            _this._drawBaseLine = _this.series.baseLineVisible;
            _this._isInteractable = _this.series.isInteractive(2 /* DRAGGABLE */ |
                4 /* RESIZABLE */);
            _this._addNamesToHitshapes = (_this._xData.getSize() <= 2) && _this._isInteractable;
            _this._drawInteractionHandle = _this.seriesSelected && _this._addNamesToHitshapes;
            _this._addDataPointsHitShapes = _this._drawBaseLine || _this._drawInteractionHandle;
            return _this;
        }
        InteractiveDrawStyle.prototype.addBaseLine = function (ctx, pt1, pt2) {
            var pen = this.series.baseLineFGPen;
            ctx.save();
            pen.setOnCanvas(ctx);
            ctx.beginPath();
            ctx.moveTo(pt1.x + pen.getAliasOffset(), pt1.y + pen.getAliasOffset());
            pen.drawPolyline(ctx, pt1, pt2);
            pen.closePolyline();
            ctx.stroke();
            ctx.restore();
        };
        InteractiveDrawStyle.prototype.populateDrawStyleLevels = function (ds) {
            this._yLevels = [];
            var userLevels = this.series.attributeSet.get('DrawingToolsLevels');
            if (userLevels.length !== 0) {
                var strLevels = userLevels.split(';');
                var yLevels = strLevels.map(Number).filter(_$1.negate(isNaN));
                this._yLevels = yLevels.sort(function (a, b) { return a - b; });
            }
            else {
                this._yLevels = DrawingToolsLevels[ds];
            }
        };
        // Draws the interaction handle, typically when a drawing tool has been selected and is editable.
        InteractiveDrawStyle.prototype.addInteractionHandle = function (ctx, prm, pt1, pt2) {
            ctx.save();
            this.series.interactionFGPen.setOnCanvas(ctx);
            ctx.beginPath();
            this.series.interactionFGPen.drawPolyline(ctx, pt1, pt2);
            this.series.interactionFGPen.closePolyline();
            ctx.stroke();
            ctx.restore();
            var _a = this._offsetPointsForHitShapes([pt1, pt2], new Point(prm.plotRect.x1, prm.plotRect.y1)), hsPt1 = _a[0], hsPt2 = _a[1];
            var line = new FDSLineHitShape(hsPt1.x, hsPt1.y, hsPt2.x, hsPt2.y);
            if (!this._drawBaseLine && this.series.isInteractive(2 /* DRAGGABLE */)) {
                line.name = 5 /* SERIESHIT */;
            }
            line.index = -1;
            this.series.hitVector.push(line);
        };
        InteractiveDrawStyle.prototype.addBaseLineHitShape = function (prm, pt1, pt2, invertTipIndex) {
            if (invertTipIndex === void 0) { invertTipIndex = false; }
            if (!this._setHitVector) {
                return;
            }
            pt1 = pt1.roundToInt();
            pt2 = pt2.roundToInt();
            var pt3 = new Point(Math.round((pt1.x + pt2.x) / 2), Math.round((pt1.y + pt2.y) / 2));
            var _a = this._offsetPointsForHitShapes([pt1, pt2, pt3], new Point(prm.plotRect.x1, prm.plotRect.y1)), hsPt1 = _a[0], hsPt2 = _a[1], hsPt3 = _a[2];
            var hitShape = new FDSLineHitShape(hsPt1.x, hsPt1.y, hsPt3.x, hsPt3.y);
            if (this._addNamesToHitshapes && this.series.isInteractive(2 /* DRAGGABLE */)) {
                hitShape.name = 5 /* SERIESHIT */;
            }
            hitShape.index = invertTipIndex ? 1 : 0;
            this.series.hitVector.push(hitShape);
            var hitShape1 = new FDSLineHitShape(hsPt3.x, hsPt3.y, hsPt2.x, hsPt2.y);
            if (this._addNamesToHitshapes && this.series.isInteractive(2 /* DRAGGABLE */)) {
                hitShape1.name = 5 /* SERIESHIT */;
            }
            hitShape1.index = invertTipIndex ? 0 : 1;
            this.series.hitVector.push(hitShape1);
            // while we're here - save the pixel points!
            var pixX = Math.round((hitShape1.x1 + hitShape1.x2) / 2);
            var pixY = Math.round((hitShape1.y1 + hitShape1.y2) / 2);
            this.root.pixelPoints[this.series.id] = [{ x: pixX, y: pixY }];
        };
        InteractiveDrawStyle.prototype._offsetPointsForHitShapes = function (pts, offsetPt) {
            return pts.map(function (p) { return p.add(offsetPt); });
        };
        InteractiveDrawStyle.prototype.addBorderHitShapes = function (xpt1, ypt1, xpt2, ypt2, index1, index2, prm) {
            var plot = prm.plot;
            var plotRect = prm.plotRect;
            var x1 = ~~(plot.subPlotFromNDC(this._xScale.lookup(xpt1), 1 /* X */) + plotRect.x1);
            var y1 = ~~(plot.subPlotFromNDC(this._yScale.lookup(ypt1), 2 /* Y */) + plotRect.y1);
            var x2 = ~~(plot.subPlotFromNDC(this._xScale.lookup(xpt2), 1 /* X */) + plotRect.x1);
            var y2 = ~~(plot.subPlotFromNDC(this._yScale.lookup(ypt2), 2 /* Y */) + plotRect.y1);
            if (this._setHitVector) {
                var dataPt1 = new Point(x1, y1);
                var dataPt2 = new Point(x2, y2);
                var ptb1 = new Point((x1 + x2) / 2, y1);
                var ptb2 = new Point((x1 + x2) / 2, y2);
                var plr1 = new Point(x1, (y1 + y2) / 2);
                var plr2 = new Point(x2, (y1 + y2) / 2);
                var opp1 = new Point(x2, y1);
                var opp2 = new Point(x1, y2);
                var hitShapeSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
                var isUnnamedRect = !this.series.isInteractive(4 /* RESIZABLE */);
                this._appendDataPointHitRect(dataPt1, index1, hitShapeSize, 3 /* DATAPOINT */, isUnnamedRect);
                this._appendDataPointHitRect(dataPt2, index2, hitShapeSize, 3 /* DATAPOINT */, isUnnamedRect);
                this._appendDataPointHitRect(opp1, index1, hitShapeSize, 4 /* DATAPOINTALTX */, isUnnamedRect, index2);
                this._appendDataPointHitRect(opp2, index2, hitShapeSize, 4 /* DATAPOINTALTX */, isUnnamedRect, index1);
                this._appendDataPointHitRect(ptb1, index1, hitShapeSize, 1 /* DATAPOINTNS */, isUnnamedRect);
                this._appendDataPointHitRect(ptb2, index2, hitShapeSize, 1 /* DATAPOINTNS */, isUnnamedRect);
                this._appendDataPointHitRect(plr1, index1, hitShapeSize, 2 /* DATAPOINTWE */, isUnnamedRect);
                this._appendDataPointHitRect(plr2, index2, hitShapeSize, 2 /* DATAPOINTWE */, isUnnamedRect);
            }
            if (this.seriesSelected) {
                x1 -= plotRect.x1;
                x2 -= plotRect.x1;
                y1 -= plotRect.y1;
                y2 -= plotRect.y1;
                var xmid = (x1 + x2) / 2;
                var ymid = (y1 + y2) / 2;
                this.cacheSelectable(prm, 0 /* NONE */, x1, y1);
                this.cacheSelectable(prm, 0 /* NONE */, x2, y2);
                this.cacheSelectable(prm, 0 /* NONE */, x1, y2);
                this.cacheSelectable(prm, 0 /* NONE */, x2, y1);
                this.cacheSelectable(prm, 0 /* NONE */, xmid, y2);
                this.cacheSelectable(prm, 0 /* NONE */, xmid, y1);
                this.cacheSelectable(prm, 0 /* NONE */, x1, ymid);
                this.cacheSelectable(prm, 0 /* NONE */, x2, ymid);
            }
        };
        InteractiveDrawStyle.prototype._appendDataPointHitRect = function (pt, index, size, name, isUnnamedRect, altIndex) {
            if (altIndex === void 0) { altIndex = -1; }
            var rect = new FDSRectangleHitShape(pt.x - size, pt.y - size, size * 2, size * 2);
            if (!isUnnamedRect) {
                rect.name = name;
            }
            rect.index = index;
            if (altIndex !== -1) {
                rect.altIndex = altIndex;
            }
            this.series.hitVector.push(rect);
        };
        return InteractiveDrawStyle;
    }(BaseDrawStyle));
    
    var CircleDrawStyle = /** @class */ (function (_super) {
        __extends(CircleDrawStyle, _super);
        function CircleDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CircleDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        CircleDrawStyle.prototype.verify = function () {
            return true;
        };
        CircleDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        CircleDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            ctx.save();
            this.series.seriesOutlinePen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx, prm.plotRect);
            var pixelPoints = {};
            var width;
            var height;
            for (var i = 0; i < this.series.size; i += 2) {
                var xpt1 = this._xData.getAt(i);
                var xpt2 = this._xData.getAt(i + 1);
                var ypt1 = this._yData.getAt(i);
                var ypt2 = this._yData.getAt(i + 1);
                // skip bad points
                if (isNaN(xpt1) || isNaN(xpt2) || isNaN(ypt1) ||
                    isNaN(ypt2)) {
                    continue;
                }
                var x1 = prm.plot.subPlotFromNDC((this._xScale.lookup(xpt1, this._xBin)), 1 /* X */);
                var y1 = prm.plot.subPlotFromNDC((this._yScale.lookup(ypt1, this._yBin)), 2 /* Y */);
                var x2 = prm.plot.subPlotFromNDC((this._xScale.lookup(xpt2, this._xBin)), 1 /* X */);
                var y2 = prm.plot.subPlotFromNDC((this._yScale.lookup(ypt2, this._yBin)), 2 /* Y */);
                var xMid = x1 + ((x2 - x1) / 2);
                var yMid = y1 + ((y2 - y1) / 2);
                var dataPt1 = new Point(x1, y1);
                var dataPt2 = new Point(x2, y2);
                // draw ellipse
                var x = (dataPt2.x + dataPt1.x) / 2.0;
                var y = (dataPt2.y + dataPt1.y) / 2.0;
                if (dataPt2.y > dataPt1.y) {
                    height = dataPt2.y - dataPt1.y;
                }
                else {
                    height = dataPt1.y - dataPt2.y;
                }
                if (dataPt2.x > dataPt1.x) {
                    width = dataPt2.x - dataPt1.x;
                }
                else {
                    width = dataPt1.x - dataPt2.x;
                }
                var radiusH = height / 2.0;
                var radiusW = width / 2.0;
                ctx.beginPath();
                ctx.ellipse(x, y, radiusW, radiusH);
                ctx.fill();
                ctx.stroke();
                // draw hitshapes
                var o = new FDSOvalHitShape();
                o.setCenter(x + prm.plotRect.x1, y + prm.plotRect.y1);
                o.smallerAngle = 0;
                o.largerAngle = Math.PI * 2;
                if (this.series.bgStyle === 1 /* NULL */) {
                    o.setRadii(radiusW + 13, radiusH + 13);
                    o.setInnerRadii(radiusW - 13, radiusH - 13);
                }
                else {
                    o.setRadii(radiusW, radiusH);
                }
                o.index = i;
                if (this.series.isInteractive(2 /* DRAGGABLE */)) {
                    o.name = 5 /* SERIESHIT */;
                }
                this.series.hitVector.push(o);
                // save pixel points
                var pixX = Math.round(o.centerX);
                // put the pixel point at the top center so we'll hit the outline
                var pixY = Math.round(o.centerY - radiusH);
                pixelPoints[i] = { x: pixX, y: pixY };
                // Hit shapes for multi-directional resizing
                if (this._isInteractable) {
                    this.addBorderHitShapes(xpt1, ypt1, xpt2, ypt2, i, i + 1, prm);
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        return CircleDrawStyle;
    }(InteractiveDrawStyle));
    
    var ColumnsDrawStyle = /** @class */ (function (_super) {
        __extends(ColumnsDrawStyle, _super);
        function ColumnsDrawStyle(series) {
            return _super.call(this, series, 1 /* X */) || this;
        }
        ColumnsDrawStyle.prototype._tryTearRectAtMin = function (ctx, pt1, pt2, minPt) {
            return !OutlierRender.breakColumn(ctx, pt2.x, pt2.y, pt1.x, pt1.y, minPt.x, minPt.y, this._breakSize, true, this._penProps.aliasOffset);
        };
        ColumnsDrawStyle.prototype._tryTearRectAtMinAndMax = function (ctx, pt1, pt2, maxPt, minPt) {
            return !OutlierRender.breakColumnLong(ctx, pt1.x, pt1.y, pt2.x, pt2.y, maxPt.x, maxPt.y, minPt.x, minPt.y, this._breakSize, true, this._penProps.aliasOffset);
        };
        ColumnsDrawStyle.prototype._tryTearRectAtMax = function (ctx, pt1, pt2, maxPt) {
            return !OutlierRender.breakColumn(ctx, pt2.x, pt2.y, pt1.x, pt1.y, maxPt.x, maxPt.y, this._breakSize, true, this._penProps.aliasOffset);
        };
        ColumnsDrawStyle.prototype._drawOutlierMarker = function (ctx, rect, marker) {
            var center = Math.round((rect.x1 + rect.x2) / 2);
            this.drawOutlierMarkerCorrectly(ctx, center, marker, this._markerStyle, this._markerSize);
        };
        ColumnsDrawStyle.prototype._getSeriesValuePtFromBar = function (bar, center) {
            if (bar.value >= bar.base) {
                return new Point(center.x, bar.rect.y1 + 0.5);
            }
            else {
                return new Point(center.x, bar.rect.y2 + 0.5);
            }
        };
        ColumnsDrawStyle.prototype._getSeriesMarkerPtFromBar = function (bar, center) {
            if (bar.value >= bar.base) {
                return new Point(center.x, bar.rect.y1);
            }
            else {
                return new Point(center.x, bar.rect.y2);
            }
        };
        ColumnsDrawStyle.prototype._getInfoboxPixelPositionFromBar = function (bar, center) {
            return {
                point: this._getSeriesMarkerPtFromBar(bar, center),
                position: bar.value >= bar.base ? "above" /* above */ : "below" /* below */,
            };
        };
        return ColumnsDrawStyle;
    }(BaseBarDrawStyle));
    
    var CSplineDrawStyle = /** @class */ (function (_super) {
        __extends(CSplineDrawStyle, _super);
        function CSplineDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CSplineDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            if (!(this.series instanceof FDSSeries)) {
                return;
            }
            this._prm = prm;
            this.prepareToDraw();
            var seriesPoints = this._getSeriesPoints();
            var seriesPointsGroupedByX = _$1.groupBy(seriesPoints, function (point) { return point.x; });
            for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {
                var point = seriesPoints_1[_i];
                if (seriesPointsGroupedByX[point.x].length > 1) {
                    point.hasDuplicatedX = true;
                }
            }
            this._setSortedSeriesPointsForInterpolation(seriesPointsGroupedByX);
            this._setCSplineCoefficients();
            var cSplinePoints = this._calcInterpolatedPixelPoints();
            this._drawCSplineLines(ctx, cSplinePoints);
            // If series markers are not on, we will draw points with duplicate x.
            if (!this.series.seriesMarker) {
                for (var _a = 0, seriesPoints_2 = seriesPoints; _a < seriesPoints_2.length; _a++) {
                    var point = seriesPoints_2[_a];
                    if (point.hasDuplicatedX) {
                        this._drawMarkerForPoint(ctx, point);
                    }
                }
            }
            this._cacheSelectableSeriesPoints(seriesPoints);
            this._addCSplineLineHitShapes(cSplinePoints);
            this._addSeriesHitShapesAndPixelPoints(seriesPoints);
        };
        CSplineDrawStyle.prototype._getSeriesPoints = function () {
            var seriesPoints = [];
            for (var j = this._start; j < this._end; j += this._step) {
                // We obtain the pixel coordinates of each data point.
                var dataIndex = this.series.getSampleIndex(j);
                var x = this._xData.getAt(dataIndex);
                var y = this._yData.getAt(dataIndex);
                if (x == null || y == null || isNaN(y) || IsSomeInternalNAN(x)) {
                    continue;
                }
                x = ~~(this._prm.plot.subPlotFromNDC(this._xScale.lookup(x, this._xBin), 1 /* X */));
                y = ~~(this._prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                seriesPoints.push({ dataIndex: dataIndex, x: x, y: y, hasDuplicatedX: false });
            }
            return seriesPoints;
        };
        CSplineDrawStyle.prototype._cacheSelectableSeriesPoints = function (seriesPoints) {
            for (var _i = 0, seriesPoints_3 = seriesPoints; _i < seriesPoints_3.length; _i++) {
                var point = seriesPoints_3[_i];
                if (this.seriesSelected && this._selectionSampler.isPointSampled(point.dataIndex)) {
                    this.cacheSelectable(this._prm, 0 /* NONE */, point.x, point.y);
                }
            }
        };
        CSplineDrawStyle.prototype._setSortedSeriesPointsForInterpolation = function (seriesPointsGroupedByX) {
            // We replace all points with duplicate x values with a single point who's y value is the a
            // average of the y values of all points with the same x value.
            this._sortedSeriesPointsForInterpolation =
                _$1.map(seriesPointsGroupedByX, function (points) {
                    var newPoint = {
                        x: points[0].x,
                        dataIndex: points[0].dataIndex,
                        hasDuplicatedX: points[0].hasDuplicatedX,
                        y: meanBy(points, function (point) { return point.y; }),
                    };
                    return newPoint;
                }).sort(function (a, b) { return a.x - b.x; });
        };
        CSplineDrawStyle.prototype._setCSplineCoefficients = function () {
            var seriesPoints = this._sortedSeriesPointsForInterpolation;
            var n = seriesPoints.length;
            var h = [];
            var z = [];
            var mu = [];
            var coefficients = {
                c: _$1.times(n),
                b: _$1.times(n - 1),
                d: _$1.times(n - 1)
            };
            for (var i = 0; i < n - 1; i++) {
                h.push(seriesPoints[i + 1].x - seriesPoints[i].x);
            }
            mu.push(0);
            z.push(0);
            coefficients.c[n - 1] = 0.0;
            // Compute the matrix and solve the tridiagonal.
            for (var i = 1; i < n - 1; i++) {
                var alpha = 3.0 / h[i] * (seriesPoints[i + 1].y - seriesPoints[i].y) -
                    3.0 / h[i - 1] * (seriesPoints[i].y - seriesPoints[i - 1].y);
                var l = 2.0 * (seriesPoints[i + 1].x - seriesPoints[i - 1].x) - h[i - 1] * mu[i - 1];
                mu.push(h[i] / l);
                z.push((alpha - h[i - 1] * z[i - 1]) / l);
            }
            // Each part of the cspline is a line with the equation a + bx + cx^2 + dx^3.
            // We do back substitution to find b, c, and d and return them.
            for (var i = n - 2; i >= 0; i--) {
                coefficients.c[i] = z[i] - mu[i] * coefficients.c[i + 1];
                coefficients.b[i] = (seriesPoints[i + 1].y - seriesPoints[i].y) / h[i] - h[i] * (coefficients.c[i + 1] + 2.0 * coefficients.c[i]) / 3.0;
                coefficients.d[i] = (coefficients.c[i + 1] - coefficients.c[i]) / (3.0 * h[i]);
            }
            this._coefficients = coefficients;
        };
        CSplineDrawStyle.prototype._calcInterpolatedPixelPoints = function () {
            var interpolatedPoints = [];
            if (this._sortedSeriesPointsForInterpolation.length === 0) {
                return interpolatedPoints;
            }
            var prevSeriesPoint = this._sortedSeriesPointsForInterpolation[0];
            interpolatedPoints.push({ x: prevSeriesPoint.x, y: prevSeriesPoint.y, dataIndex: this._findClosestValidHitshapeDataIndex(0) });
            for (var i = 1; i <= this._sortedSeriesPointsForInterpolation.length - 1; i++) {
                var currSeriesPoint = this._sortedSeriesPointsForInterpolation[i];
                var prevHalfIndex = this._findClosestValidHitshapeDataIndex(i - 1);
                var currHalfIndex = this._findClosestValidHitshapeDataIndex(i);
                interpolatedPoints = interpolatedPoints.concat(this._interpolateBetweenPoints(prevSeriesPoint, currSeriesPoint, prevHalfIndex, currHalfIndex));
                interpolatedPoints.push({ x: currSeriesPoint.x, y: currSeriesPoint.y, dataIndex: this._findClosestValidHitshapeDataIndex(i) });
                prevSeriesPoint = currSeriesPoint;
            }
            return interpolatedPoints;
        };
        CSplineDrawStyle.prototype._findClosestValidHitshapeDataIndex = function (startIndex) {
            var sortedSeriesPoints = this._sortedSeriesPointsForInterpolation;
            if (!sortedSeriesPoints[startIndex].hasDuplicatedX) {
                return sortedSeriesPoints[startIndex].dataIndex;
            }
            var prevValidIndex = this._findPrevValidIndex(sortedSeriesPoints, startIndex);
            var nextValidIndex = this._findNextValidIndex(sortedSeriesPoints, startIndex);
            if (prevValidIndex && nextValidIndex) {
                return (prevValidIndex.distance <= nextValidIndex.distance) ? prevValidIndex.dataIndex : nextValidIndex.dataIndex;
            }
            else if (prevValidIndex) {
                return prevValidIndex.dataIndex;
            }
            else if (nextValidIndex) {
                return nextValidIndex.dataIndex;
            }
            else {
                return null;
            }
        };
        CSplineDrawStyle.prototype._findPrevValidIndex = function (sortedPoints, currPointIndex) {
            for (var i = currPointIndex - 1; i >= 0; i--) {
                if (!sortedPoints[i].hasDuplicatedX) {
                    return { dataIndex: sortedPoints[i].dataIndex, distance: currPointIndex - i };
                }
            }
            return null;
        };
        CSplineDrawStyle.prototype._findNextValidIndex = function (sortedPoints, currPointIndex) {
            for (var i = currPointIndex + 1; i < sortedPoints.length; i++) {
                if (!sortedPoints[i].hasDuplicatedX) {
                    return { dataIndex: sortedPoints[i].dataIndex, distance: i - currPointIndex };
                }
            }
            return null;
        };
        CSplineDrawStyle.prototype._interpolateBetweenPoints = function (point1, point2, dataIndex1, dataIndex2) {
            // We calculate the distance between our current point and the next to see how many
            // interior points to generate. Ideally, there will be about 1 point for every 5 pixels.
            var interpolatedPoints = [];
            if (point1.x >= point2.x) {
                return interpolatedPoints;
            }
            var distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) +
                Math.pow(point1.y - point2.y, 2));
            var subDivCount = ~~(distance / 5);
            if (subDivCount > 0) {
                var subDivCountHalf = subDivCount / 2;
                for (var subDiv = 1; subDiv < subDivCount; subDiv += 1) {
                    var t = subDiv / subDivCount;
                    var x = point1.x + (point2.x - point1.x) * t;
                    var y = this._spline(x);
                    if (isNaN(y)) {
                        continue;
                    }
                    var dataIndex = (subDiv <= subDivCountHalf) ? dataIndex1 : dataIndex2;
                    interpolatedPoints.push({ x: x, y: y, dataIndex: dataIndex });
                }
            }
            return interpolatedPoints;
        };
        CSplineDrawStyle.prototype._spline = function (x) {
            var i = 0;
            var n = this._sortedSeriesPointsForInterpolation.length;
            if (fuzzyLT(x, this._sortedSeriesPointsForInterpolation[0].x)) {
                return NaN;
            }
            else if (fuzzyGT(x, this._sortedSeriesPointsForInterpolation[n - 1].x)) {
                return NaN;
            }
            // Locate the subinterval that contains x.
            while (i < (n - 1) && fuzzyLT(this._sortedSeriesPointsForInterpolation[i].x, x)) {
                i++;
            }
            i = i - 1;
            var diff = x - this._sortedSeriesPointsForInterpolation[i].x;
            return this._sortedSeriesPointsForInterpolation[i].y +
                this._coefficients.b[i] * diff +
                this._coefficients.c[i] * diff * diff +
                this._coefficients.d[i] * diff * diff * diff;
        };
        CSplineDrawStyle.prototype._drawCSplineLines = function (ctx, cSplinePoints) {
            ctx.save();
            var seriesFGPen = this.series.seriesFGPen;
            seriesFGPen.setOnCanvas(ctx);
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            ctx.beginPath();
            if (cSplinePoints.length > 1) {
                for (var i = 0; i < cSplinePoints.length - 1; i++) {
                    var currPoint = cSplinePoints[i];
                    var nextPoint = cSplinePoints[i + 1];
                    if (this.series.useColor) {
                        seriesFGPen.closePolyline();
                        ctx.stroke();
                        this._setColorMapColor(ctx, seriesFGPen, colorData.getAt(currPoint.dataIndex), currPoint.dataIndex);
                        ctx.beginPath();
                        ctx.moveTo(currPoint.x, currPoint.y);
                    }
                    seriesFGPen.drawPolyline(ctx, currPoint, nextPoint);
                }
                seriesFGPen.closePolyline();
            }
            ctx.stroke();
            ctx.restore();
        };
        CSplineDrawStyle.prototype._drawMarkerForPoint = function (ctx, point) {
            ctx.save();
            var markerStyle = 1;
            var drawFunc = getMarkerDrawFunctor(1 /* CIRCLE */, 5, false);
            var brush = this.series.seriesBGBrush;
            brush.setOnCanvas(ctx);
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            ctx.beginPath();
            drawFunc(ctx, point.x, point.y);
            if (this.series.useColor) {
                var dataIndex = point.dataIndex;
                this._setColorMapColor(ctx, brush, colorData.getAt(dataIndex), dataIndex);
            }
            ctx.fill();
            this._resetColorMapColor(brush);
            ctx.restore();
        };
        CSplineDrawStyle.prototype._addCSplineLineHitShapes = function (cSplinePoints) {
            var lineHitShapes = [];
            if (cSplinePoints.length === 0) {
                return;
            }
            var lineHitShapeStart = cSplinePoints[0];
            var x1 = lineHitShapeStart.x + this._prm.plotRect.x1;
            var y1 = lineHitShapeStart.y + this._prm.plotRect.y1;
            // We will make a line hit shape for every two lines we draw.
            for (var i = 2; i < cSplinePoints.length - 2; i += 2) {
                var lineHitShapeEnd = cSplinePoints[i];
                var x2 = lineHitShapeEnd.x + this._prm.plotRect.x1;
                var y2 = lineHitShapeEnd.y + this._prm.plotRect.y1;
                var lineHitShape = new FDSLineHitShape(x1, y1, x2, y2);
                lineHitShape.index = lineHitShapeEnd.dataIndex;
                lineHitShapes.push(lineHitShape);
                x1 = x2;
                y1 = y2;
            }
            this.series.hitVector = this.series.hitVector.concat(lineHitShapes);
        };
        CSplineDrawStyle.prototype._addSeriesHitShapesAndPixelPoints = function (seriesPoints) {
            var pixelPoints = {};
            var pointHitShapes = [];
            var dpSize = this.series.datapointHitShapeSize;
            for (var _i = 0, seriesPoints_4 = seriesPoints; _i < seriesPoints_4.length; _i++) {
                var point = seriesPoints_4[_i];
                var x = point.x + this._prm.plotRect.x1;
                var y = point.y + this._prm.plotRect.y1;
                pixelPoints[point.dataIndex] = { x: x, y: y };
                var rectHitShape = new FDSRectangleHitShape(x - dpSize, y - dpSize, dpSize * 2, dpSize * 2);
                rectHitShape.index = point.dataIndex;
                if (this.series.isInteractive(4 /* RESIZABLE */)) {
                    rectHitShape.name = 3 /* DATAPOINT */;
                }
                pointHitShapes.push(rectHitShape);
                this.series.addLookupPoint(x, [y], point.dataIndex);
            }
            this.series.root.pixelPoints[this.series.id] = pixelPoints;
            this.series.hitVector = this.series.hitVector.concat(pointHitShapes);
        };
        CSplineDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            var pen = this.series.seriesFGPen;
            // Use square line caps if the line is thick.
            var prop = pen.toPropertyObject();
            pen = pen.with({ lineCap: prop.lineWidth > 2 ? 'square' : 'butt' });
            var xOffset = prop.aliasOffset;
            pen.setOnCanvas(ctx);
            // Logic copied from PC side.
            // Floor everything to avoid half-pixel coordinates.
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var legendPreviewPoints = [
                { x: x - halfwidth, y: y + minus },
                { x: x - minus, y: y + minus },
                { x: x - ~~(minus / 3), y: y + ~~(minus / 3 * 2) },
                { x: x, y: y },
                { x: x + ~~(plus / 3), y: y - ~~(plus / 3 * 2) },
                { x: x + plus, y: y - plus },
                { x: x + halfwidth, y: y - plus }
            ];
            ctx.beginPath();
            ctx.moveTo(legendPreviewPoints[0].x, legendPreviewPoints[0].y);
            for (var i = 1; i < legendPreviewPoints.length; i++) {
                ctx.lineTo(legendPreviewPoints[i].x, legendPreviewPoints[i].y);
                ctx.moveTo(legendPreviewPoints[i].x, legendPreviewPoints[i].y);
            }
            ctx.closePath();
            ctx.stroke();
        };
        CSplineDrawStyle.prototype.verify = function () {
            return true;
        };
        CSplineDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return CSplineDrawStyle;
    }(BaseDrawStyle));
    
    var DraggableMarkerDrawStyle = /** @class */ (function (_super) {
        __extends(DraggableMarkerDrawStyle, _super);
        function DraggableMarkerDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._addNamesToHitshapes = _this._isInteractable;
            return _this;
        }
        DraggableMarkerDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            var markerStyle = this.series.attributeSet.get('SeriesMarkerStyle');
            var drawFunc = getMarkerDrawFunctor(markerStyle, this.series.markerSize);
            var startDatapoint = this.series.startDatapoint;
            var _a = this.series.interpolateBetweenPoints(startDatapoint), index = _a.index, point = _a.point;
            var x = (prm.plot.subPlotFromNDC(this._xScale.lookup(point.x, this._xBin), 1 /* X */));
            var y = (prm.plot.subPlotFromNDC(this._yScale.lookup(point.y, this._yBin), 2 /* Y */));
            ctx.save();
            ctx.beginPath();
            drawFunc(ctx, x, y);
            ctx.stroke();
            ctx.fill();
            ctx.restore();
            var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var hitShape = new FDSRectangleHitShape((x + prm.plotRect.x1) - dpSize, (y + prm.plotRect.y1) - dpSize, 2 * dpSize, 2 * dpSize);
            hitShape.index = -1;
            if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                hitShape.name = 6 /* DATAPOINTLEFT */;
            }
            this.series.hitVector.push(hitShape);
            // save pixel point
            var pixX = Math.round(hitShape.x + (hitShape.width / 2));
            var pixY = Math.round(hitShape.y + (hitShape.width / 2));
            this.root.pixelPoints[this.series.id] = [{ x: pixX, y: pixY }];
        };
        DraggableMarkerDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
        };
        DraggableMarkerDrawStyle.prototype.drawMarkersToBuffer = function (prm, canvas) {
        };
        DraggableMarkerDrawStyle.prototype.verify = function () {
            return true;
        };
        DraggableMarkerDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        return DraggableMarkerDrawStyle;
    }(InteractiveDrawStyle));
    
    var FibArc = /** @class */ (function (_super) {
        __extends(FibArc, _super);
        function FibArc(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(43 /* FIBARC */);
            return _this;
        }
        FibArc.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        FibArc.prototype.verify = function () {
            return true;
        };
        FibArc.prototype.hint = function () {
            return -1 /* NONE */;
        };
        FibArc.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            this.populateDrawStyleLevels(43 /* FIBARC */);
            // context same as Trendline.coffee
            ctx.save();
            // TODO: This is repeated code from the helper functions below. We can probably clean this up further.
            var xPt1 = this._xData.getAt(0);
            var xPt2 = this._xData.getAt(1);
            var yPt1 = this._yData.getAt(0);
            var yPt2 = this._yData.getAt(1);
            var indexPt1 = 0;
            var indexPt2 = 1;
            if (isNaN(xPt1) || isNaN(xPt2) || isNaN(yPt1) || isNaN(yPt2)) {
                ctx.restore();
                return;
            }
            var uptrend = this._yScale.lookup(yPt1) > this._yScale.lookup(yPt2);
            var visibleLevels = this.series.fibonacciLevels;
            // calculate center and end points in screen space
            var _a = this._calculateCenterAndEnd(prm), ptCenter = _a.ptCenter, ptEnd = _a.ptEnd, radValue = _a.radValue;
            this.series.seriesFGPen.setOnCanvas(ctx);
            // draw base line
            if (this._drawBaseLine) {
                this.addBaseLine(ctx, ptCenter, ptEnd);
            }
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptCenter);
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptEnd);
            }
            // ctx.save()
            for (var _i = 0, _b = this._yLevels; _i < _b.length; _i++) {
                var yLevel = _b[_i];
                if ((visibleLevels & 0x1) !== 0) {
                    var radius = radValue * yLevel;
                    // Set up the hit shape for the arc
                    var o = new FDSPieHitShape();
                    o.setCenter(ptCenter.x + prm.plotRect.x1, ptCenter.y + prm.plotRect.y1);
                    var _c = (uptrend) ? [Math.PI, Math.PI * 2] : [0, Math.PI], smallerAngle = _c[0], largerAngle = _c[1];
                    o.name = 0 /* NONE */;
                    o.setAngles(smallerAngle, largerAngle);
                    o.setRadius(radius * 1.05);
                    o.index = indexPt1;
                    o.setInnerRadius(0.95 * radius);
                    this.series.hitVector.push(o);
                    // draw arcs
                    ctx.beginPath();
                    ctx.arc(ptCenter.x, ptCenter.y, radius, smallerAngle, largerAngle, false);
                    ctx.stroke();
                    if (this.seriesSelected) {
                        this.cacheSelectable(prm, 0 /* NONE */, ptCenter.x - radius, ptCenter.y);
                        this.cacheSelectable(prm, 0 /* NONE */, ptCenter.x + radius, ptCenter.y);
                    }
                }
                visibleLevels = visibleLevels >> 1;
            }
            if (this._drawInteractionHandle) {
                this.addInteractionHandle(ctx, prm, ptCenter, ptEnd);
            }
            if (this._drawBaseLine) {
                this.addBaseLineHitShape(prm, ptCenter, ptEnd, true);
            }
            if (this._addDataPointsHitShapes && this._setHitVector) {
                var dpSize = this.series.datapointHitShapeSize + 12;
                var rect1 = new FDSRectangleHitShape((ptCenter.x + prm.plotRect.x1) - dpSize, (ptCenter.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect1.index = 1;
                rect1.name = 3 /* DATAPOINT */;
                if (!this._addNamesToHitshapes || !this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect1.name = 0 /* NONE */;
                }
                var rect2 = new FDSRectangleHitShape((ptEnd.x + prm.plotRect.x1) - dpSize, (ptEnd.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect2.index = 0;
                rect2.name = 3 /* DATAPOINT */;
                if (!this._addNamesToHitshapes || !this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect2.name = 0 /* NONE */;
                }
                this.series.hitVector.push(rect1);
                this.series.hitVector.push(rect2);
            }
            ctx.restore();
            this._drawLabels(prm, ctx, this._yLevels, uptrend);
        };
        FibArc.prototype._drawLabels = function (prm, ctx, yLevels, uptrend) {
            ctx.save();
            if ((this.series.labelsMask & 1 /* LABEL1 */) !== 0) {
                // construct font
                var font = this.series.seriesLabel1Font;
                if (this.series.seriesLabel1ColorFollowsSeriesColor) {
                    if (!this.series.attributeSet.isDefault('SeriesColor')) {
                        font = font.with({ color: this.series.calculatedSeriesColor });
                    }
                    else {
                        font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                    }
                }
                // TODO this is repeated code
                var xPt1 = this._xData.getAt(0);
                var xPt2 = this._xData.getAt(1);
                var yPt1 = this._yData.getAt(0);
                var yPt2 = this._yData.getAt(1);
                var indexPt1 = 0;
                var indexPt2 = 1;
                // set the center of the arcs and start pt of trendline
                var cx = this._xScale.lookup(xPt2, this._xBin);
                var cy = this._yScale.lookup(yPt2, this._yBin);
                font.setOnCanvas(ctx);
                var visibleLevels = this.series.fibonacciLevels;
                var valueFormatter = new FDSFormat();
                // loop through levels
                for (var _i = 0, yLevels_1 = yLevels; _i < yLevels_1.length; _i++) {
                    var yLevel = yLevels_1[_i];
                    if ((visibleLevels & 0x1) !== 0) {
                        var format = this.series.seriesLabel1Format;
                        var value = yLevel * 100;
                        valueFormatter.setNumberFormat(format);
                        var label = valueFormatter.formatAsNumber(value);
                        var xoff = this.series.seriesLabel1XOffset;
                        var yoff = -this.series.seriesLabel1YOffset;
                        var _a = this._calculateCenterAndEnd(prm), ptCenter = _a.ptCenter, ptEnd = _a.ptEnd, radValue = _a.radValue;
                        var radius = radValue * yLevel;
                        var pt1 = new Point(ptCenter.x - radius, ptCenter.y + radius);
                        var pt2 = new Point(ptCenter.x + radius, ptCenter.y - radius);
                        var vertex = pt2.y;
                        if (!uptrend) {
                            vertex = pt1.y;
                        }
                        vertex += Math.round(yoff);
                        pt1.x += Math.round(xoff);
                        pt1.y = ptCenter.y + Math.round(yoff);
                        pt2.x += Math.round(xoff);
                        pt2.y = ptCenter.y + Math.round(yoff);
                        // ignore hitShapes since PC side doesn't actually seem to do anything with them
                        var vPos = this.series.seriesLabel1VPosition;
                        if (!uptrend) {
                            if (vPos === 1 /* V_TOP */) {
                                vPos = 0 /* V_BOTTOM */;
                            }
                            else {
                                if (vPos === 0 /* V_BOTTOM */) {
                                    vPos = 1 /* V_TOP */;
                                }
                            }
                        }
                        var fontHeight = (vPos === 0 /* V_BOTTOM */) ? font.getHeight() : 0;
                        switch (this.series.seriesLabel1HPosition) {
                            case 0 /* LEFT */:
                                ctx.save();
                                ctx.legacyFillText(label, pt1.x, pt1.y + fontHeight, 'left');
                                ctx.restore();
                                break;
                            case 2 /* CENTER */:
                                pt1.x = Math.round((pt1.x + pt2.x) / 2.0);
                                pt1.y = vertex;
                                ctx.save();
                                ctx.legacyFillText(label, pt1.x, pt1.y + fontHeight, 'center');
                                ctx.restore();
                                break;
                            default:
                                // default handles case TEXT_RIGHT
                                ctx.save();
                                ctx.legacyFillText(label, pt1.x + (2 * radius), pt1.y + fontHeight, 'right');
                                ctx.restore();
                        }
                    }
                    visibleLevels = visibleLevels >> 1;
                }
            }
            ctx.restore();
        };
        FibArc.prototype._calculateCenterAndEnd = function (prm) {
            var xPt1 = this._xData.getAt(0);
            var xPt2 = this._xData.getAt(1);
            var yPt1 = this._yData.getAt(0);
            var yPt2 = this._yData.getAt(1);
            var indexPt1 = 0;
            var indexPt2 = 1;
            // set the center of the arcs and start pt of trendline
            var cx = this._xScale.lookup(xPt2, this._xBin);
            var cy = this._yScale.lookup(yPt2, this._yBin);
            // set the end pt of the trendline
            var ex = this._xScale.lookup(xPt1, this._xBin);
            var ey = this._yScale.lookup(yPt1, this._yBin);
            var ptCenter = new Point((prm.plot.subPlotFromNDC(cx, 1 /* X */)), (prm.plot.subPlotFromNDC(cy, 2 /* Y */)));
            var ptEnd = new Point((prm.plot.subPlotFromNDC(ex, 1 /* X */)), (prm.plot.subPlotFromNDC(ey, 2 /* Y */)));
            var radValue = this._calculateRadiusValue(prm, cx, cy, ex, ey);
            return { ptCenter: ptCenter, ptEnd: ptEnd, radValue: radValue, retValue: true };
        };
        FibArc.prototype._calculateRadiusValue = function (prm, cx, cy, ex, ey) {
            var left = (prm.plot.subPlotFromNDC(cx, 1 /* X */));
            var right = (prm.plot.subPlotFromNDC(ex, 1 /* X */));
            var top = (prm.plot.subPlotFromNDC(cy, 2 /* Y */));
            var bottom = (prm.plot.subPlotFromNDC(ey, 2 /* Y */));
            return Math.sqrt(Math.pow(right - left, 2) + Math.pow(top - bottom, 2));
        };
        return FibArc;
    }(InteractiveDrawStyle));
    
    var FibonacciFan = /** @class */ (function (_super) {
        __extends(FibonacciFan, _super);
        function FibonacciFan(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(44 /* FIBFAN */);
            return _this;
        }
        FibonacciFan.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        FibonacciFan.prototype.verify = function () {
            return true;
        };
        FibonacciFan.prototype.hint = function () {
            return -1 /* NONE */;
        };
        FibonacciFan.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            this.populateDrawStyleLevels(this.series.drawStyle);
            ctx.save();
            var xvalue1 = this._xData.getAt(0);
            var xvalue2 = this._xData.getAt(1);
            var yvalue1 = this._yData.getAt(0);
            var yvalue2 = this._yData.getAt(1);
            var indexPt1 = 0;
            var indexPt2 = 1;
            if (isNaN(xvalue1) || isNaN(xvalue2) || isNaN(yvalue1) || isNaN(yvalue2)) {
                return;
            }
            var min$$1 = yvalue1;
            var max$$1 = yvalue2;
            var uptrend = true;
            if (min$$1 > max$$1) {
                _a = [max$$1, min$$1], min$$1 = _a[0], max$$1 = _a[1];
                uptrend = false;
            }
            var deltaY = max$$1 - min$$1;
            var cx = this._xScale.lookup(xvalue1, this._xBin);
            var cy = this._yScale.lookup(yvalue1, this._yBin);
            var ex = this._xScale.lookup(xvalue2, this._xBin);
            var ey = this._yScale.lookup(yvalue2, this._yBin);
            var visibleLevels = this.series.fibonacciLevels;
            var ptOrigin = new Point(prm.plot.subPlotFromNDC(cx, 1 /* X */), prm.plot.subPlotFromNDC(cy, 2 /* Y */));
            var ptEnd = new Point(prm.plot.subPlotFromNDC(ex, 1 /* X */), prm.plot.subPlotFromNDC(ey, 2 /* Y */));
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptOrigin);
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptEnd);
            }
            if (this._drawBaseLine) {
                this.addBaseLine(ctx, ptOrigin, ptEnd);
            }
            this.series.seriesFGPen.setOnCanvas(ctx);
            var yBorderHit = 2;
            var x = 0.0;
            var y = 0.0;
            for (var _i = 0, _b = this._yLevels; _i < _b.length; _i++) {
                var yLevel = _b[_i];
                x = ex;
                if (uptrend) {
                    y = max$$1 - (deltaY * yLevel);
                }
                else {
                    y = min$$1 + (deltaY * yLevel);
                }
                var yBeforeExtendingLine = y;
                var extendLine = this.series.extendLine;
                if (extendLine) {
                    var ccx = this._xScale.compressValue(xvalue1);
                    var ccy = yvalue1;
                    var eex = this._xScale.compressValue(xvalue2);
                    var eey = yvalue2;
                    (_c = this._computeIntersectionPoints(x, y, ccx, ccy, eex, eey), x = _c.x, y = _c.y, yBorderHit = _c.yBorderHit);
                }
                var tempy = this._yScale.lookup(y, this._yBin);
                var pt2 = new Point((prm.plot.subPlotFromNDC(x, 1 /* X */)), (prm.plot.subPlotFromNDC(tempy, 2 /* Y */)));
                if ((visibleLevels & 0x1) !== 0) {
                    var intersection = new Point(pt2.x, pt2.y);
                    (intersection = this._addLabels(ctx, pt2, y, yLevel * 100.0, ptOrigin.x < pt2.x, extendLine, ptOrigin, ptEnd, intersection, yBorderHit).intersection);
                    pt2 = intersection;
                    if (extendLine && (this.series.labelsMask & 4 /* LABEL3 */) !== 0) {
                        var ptNotExtended = new Point((prm.plot.subPlotFromNDC(ex, 1 /* X */)), (prm.plot.subPlotFromNDC((this._yScale.lookup(yBeforeExtendingLine, this._yBin)), 2 /* Y */)));
                        var labelSize = [0, 0];
                        this._addLabel(ctx, ptNotExtended, 2 /* LABEL2 */, yBeforeExtendingLine, (ptOrigin.x < ptNotExtended.x), false, labelSize, ptOrigin, ptEnd, intersection, yBorderHit);
                    }
                    if (this._setHitVector) {
                        var line = new FDSLineHitShape(ptOrigin.x + prm.plotRect.x1, ptOrigin.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                        line.index = -1;
                        this.series.hitVector.push(line);
                    }
                    if (this.seriesSelected) {
                        var fudgeY = 0.1;
                        var fudgeX = 0.1;
                        if (ptOrigin.x > pt2.x) {
                            fudgeX *= -1;
                        }
                        if (ptOrigin.y < pt2.y) {
                            fudgeY *= -1;
                        }
                        this.cacheSelectable(prm, 0 /* NONE */, prm.plot.subPlotFromNDC(x, 1 /* X */) - fudgeX, prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */) - fudgeY);
                    }
                    // draw the line
                    ctx.beginPath();
                    this.series.seriesFGPen.drawPolyline(ctx, ptOrigin, pt2);
                    this.series.seriesFGPen.closePolyline();
                    ctx.stroke();
                }
                visibleLevels = visibleLevels >> 1;
            }
            if (this._drawInteractionHandle) {
                this.addInteractionHandle(ctx, prm, ptOrigin, ptEnd);
            }
            if (this._drawBaseLine) {
                this.addBaseLineHitShape(prm, ptOrigin, ptEnd);
            }
            if (this._addDataPointsHitShapes) {
                var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
                var rect1 = new FDSRectangleHitShape((ptOrigin.x + prm.plotRect.x1) - dpSize, (ptOrigin.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect1.index = 0;
                rect1.name = 3 /* DATAPOINT */;
                var rect2 = new FDSRectangleHitShape((ptEnd.x + prm.plotRect.x1) - dpSize, (ptEnd.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect2.index = 1;
                rect2.name = 3 /* DATAPOINT */;
                this.series.hitVector.push(rect1);
                this.series.hitVector.push(rect2);
            }
            ctx.restore();
            var _a, _c;
        };
        FibonacciFan.prototype._computeIntersectionPoints = function (x, y, ccx, ccy, eex, eey) {
            var ymax = this._yScale.computeValue(1.0);
            var ymin = this._yScale.computeValue(0.0);
            if (this._yScale.reverse) {
                _a = [ymin, ymax], ymax = _a[0], ymin = _a[1];
            }
            var xvalue = 0.0;
            var tmpy = y;
            if (eex === ccx) {
                if (eey > ccy) {
                    y = ymax;
                }
                else {
                    y = ymin;
                }
            }
            else {
                if (eex > ccx) {
                    xvalue = 1.0;
                }
                var xmax = 1.0;
                var xmin = 0.0;
                if (this._xScale.reverse) {
                    xvalue = 1.0 - xvalue;
                    _b = [xmin, xmax], xmax = _b[0], xmin = _b[1];
                }
                var temp1 = new Point(ccx, ccy);
                var temp2 = new Point(eex, y);
                var temp3 = new Point(this._xScale.compressValue(this._xScale.computeValue(xvalue)), xmin);
                var temp4 = new Point(this._xScale.compressValue(this._xScale.computeValue(xvalue)), xmax);
                var intersection = this._intersectLines(temp1, temp2, temp3, temp4).intersection;
                x = this._xScale.lookup(this._xScale.decompressValue(intersection.x), this._xBin);
                y = intersection.y;
            }
            if (y >= ymax) {
                var temp1 = new Point(ccx, ccy);
                var temp2 = new Point(eex, tmpy);
                var temp3 = new Point(0.0, ymax);
                var temp4 = new Point(1.0, ymax);
                var intersection = this._intersectLines(temp1, temp2, temp3, temp4).intersection;
                x = this._xScale.lookup(this._xScale.decompressValue(intersection.x), this._xBin);
                y = ymax;
                return { x: x, y: y, yBorderHit: 1 /* YMAX */ };
            }
            else if (y <= ymin) {
                var temp1 = new Point(ccx, ccy);
                var temp2 = new Point(eex, tmpy);
                var temp3 = new Point(0.0, ymin);
                var temp4 = new Point(1.0, ymin);
                var intersection = this._intersectLines(temp1, temp2, temp3, temp4).intersection;
                x = this._xScale.lookup(this._xScale.decompressValue(intersection.x), this._xBin);
                y = ymin;
                return { x: x, y: y, yBorderHit: 0 /* YMIN */ };
            }
            return { x: x, y: y, yBorderHit: 2 /* YMIDDLE */ };
            var _a, _b;
        };
        FibonacciFan.prototype._intersectLines = function (p1, p2, p3, p4) {
            var intersection = new Point(0, 0);
            var denominatorx = ((p1.x - p2.x) * (p3.y - p4.y)) - ((p1.y - p2.y) * (p3.x - p4.x));
            var denominatory = ((p1.x - p2.x) * (p3.y - p4.y)) - ((p1.y * p2.y) * (p3.x - p4.x));
            if (denominatorx !== 0) {
                intersection.x = ((((p1.x * p2.y) - (p1.y * p2.x)) * (p3.x - p4.x)) -
                    ((p1.x - p2.x) * ((p3.x * p4.y) - (p3.y * p4.x)))) / denominatorx;
            }
            if (denominatory !== 0) {
                intersection.y = ((((p1.x * p2.y) - (p1.y * p2.x)) * (p3.y - p4.y)) -
                    ((p1.y - p2.y) * ((p3.x * p4.y) - (p3.y * p4.x)))) / denominatory;
            }
            return { intersection: intersection };
        };
        FibonacciFan.prototype._addLabels = function (ctx, pt1, value, level, leftToRight, extendLine, center, end, intersection, yborder) {
            var textSize = [0, 0];
            var visibleLabels = this.series.labelsMask;
            if (visibleLabels & 1 /* LABEL1 */) {
                (_a = this._addLabel(ctx, pt1, 1 /* LABEL1 */, level, leftToRight, extendLine, textSize, center, end, intersection, yborder), intersection = _a.intersection, textSize = _a.textSize);
            }
            if (visibleLabels & 2 /* LABEL2 */) {
                (_b = this._addLabel(ctx, pt1, 2 /* LABEL2 */, value, leftToRight, extendLine, textSize, center, end, intersection, yborder), intersection = _b.intersection, textSize = _b.textSize);
            }
            return { intersection: intersection };
            var _a, _b;
        };
        FibonacciFan.prototype._addLabel = function (ctx, pt1, index, level, leftToRight, extendLine, labelSize, center, end, intersection, yborder) {
            ctx.save();
            var textSize = [0, 0];
            var font;
            var format;
            var xoff;
            var yoff;
            if (index === 1 /* LABEL1 */) {
                font = this.series.seriesLabel1Font;
                if (this.series.seriesLabel1ColorFollowsSeriesColor) {
                    if (!this.series.attributeSet.isDefault('SeriesColor')) {
                        font = font.with({ color: this.series.calculatedSeriesColor });
                    }
                    else {
                        font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                    }
                }
                format = this.series.seriesLabel1Format;
                // determine offsets
                xoff = this.series.seriesLabel1XOffset;
                yoff = -this.series.seriesLabel1YOffset;
            }
            else {
                font = this.series.seriesLabel2Font;
                if (this.series.seriesLabel2ColorFollowsSeriesColor) {
                    if (!this.series.attributeSet.isDefault('SeriesColor')) {
                        font = font.with({ color: this.series.calculatedSeriesColor });
                    }
                    else {
                        font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                    }
                }
                format = this.series.seriesLabel2Format;
                // determine offsets
                xoff = this.series.seriesLabel2XOffset;
                yoff = -this.series.seriesLabel2YOffset;
            }
            // Select font
            font.setOnCanvas(ctx);
            // create label
            var valueFormatter = new FDSFormat();
            valueFormatter.setNumberFormat(format);
            var label = valueFormatter.formatAsNumber(level);
            // determine size of the text
            textSize[0] = Math.ceil(ctx.measureTextWidth(label));
            textSize[1] = font.getHeight();
            // ptE is where the label will be drawn
            var ptE = new Point(pt1.x, pt1.y);
            if (yborder === 0 /* YMIN */) {
                if (this._yScale.reverse) {
                    ptE.y += labelSize[1];
                }
                else {
                    ptE.y += labelSize[1] * -1;
                }
            }
            else {
                if (this._yScale.reverse) {
                    ptE.y += labelSize[1] * -1;
                }
                else {
                    ptE.y += labelSize[1];
                }
            }
            ptE.x += Math.round(xoff);
            ptE.y += Math.round(yoff);
            // Offset label up or down to prevent them from disappearing when close to plot borders
            if (yborder === 0 /* YMIN */) {
                if (this._yScale.reverse) {
                    ptE.y += Math.round(textSize[1] / 2.0);
                }
                else {
                    ptE.y += Math.round(textSize[1] / 2.0) * -1;
                }
            }
            else if (yborder === 1 /* YMAX */) {
                if (this._yScale.reverse) {
                    ptE.y -= Math.round(textSize[1] / 2.0);
                }
                else {
                    ptE.y -= Math.round(textSize[1] / 2.0) * -1;
                }
            }
            // TODO Text bounding box coordinates
            var bbox = new Rectangle(0.0, 0.0, textSize[0], textSize[1]);
            // if leftToRight and extendLine
            // draw the labels
            var textAlign;
            if (extendLine) {
                if (leftToRight) {
                    textAlign = 'right';
                }
                else {
                    textAlign = 'left';
                }
            }
            else {
                if (leftToRight) {
                    textAlign = 'left';
                }
                else {
                    textAlign = 'right';
                }
            }
            ctx.legacyFillText(label, ptE.x, ptE.y, textAlign);
            // TODO
            // If the line hits the text bounding box, we have to break it
            ctx.restore();
            return { intersection: intersection, textSize: textSize };
        };
        return FibonacciFan;
    }(InteractiveDrawStyle));
    
    var FibonacciRetracements = /** @class */ (function (_super) {
        __extends(FibonacciRetracements, _super);
        function FibonacciRetracements(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(42 /* FIBRETRACEMENTS */);
            return _this;
        }
        FibonacciRetracements.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        FibonacciRetracements.prototype.verify = function () {
            return true;
        };
        FibonacciRetracements.prototype.hint = function () {
            return -1 /* NONE */;
        };
        FibonacciRetracements.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            this.populateDrawStyleLevels(42 /* FIBRETRACEMENTS */);
            ctx.save();
            var plot = prm.plot;
            if (this._yData.data.length < 2 || this._xData.data.length < 2) {
                return;
            }
            var _a = this._yData.Min(), yvalue1 = _a[0], y1Index = _a[1];
            var xvalue1 = this._xData.getAt(0);
            var x1Index = 0;
            var _b = this._yData.Max(), yvalue2 = _b[0], y2Index = _b[1];
            var xvalue2 = this._xData.getAt(this._xData.data.length - 1);
            var x2Index = this._xData.data.length - 1;
            if (this._xData.data.length > 2) {
                var start = 0;
                var end = this._xData.data.length - 1;
                var step = 0;
                _c = this.series.computeXTrim(this.root.getWidth(), start, end, step), start = _c[0], end = _c[1], step = _c[2];
                if (!NOTNAN(xvalue1)) {
                    xvalue1 = this._xData.getAt(start + 1);
                    x1Index = start + 1;
                }
                if (!NOTNAN(xvalue2)) {
                    xvalue2 = this._xData.getAt(end - 2);
                    x2Index = end - 2;
                }
            }
            if (isNaN(xvalue1) || isNaN(xvalue2) || isNaN(yvalue1) || isNaN(yvalue2)) {
                return;
            }
            var y = 0.0;
            var uptrend = y2Index >= y1Index;
            var min$$1 = yvalue1;
            var max$$1 = yvalue2;
            var deltaY = max$$1 - min$$1;
            if (!uptrend) {
                _d = [yvalue2, yvalue1], yvalue1 = _d[0], yvalue2 = _d[1];
                _e = [y2Index, y1Index], y1Index = _e[0], y2Index = _e[1];
            }
            var extendLines = this.series.extendLine;
            var extendRight = this.series.extendLineRightOrUp;
            var extendLeft = this.series.extendLineLeftOrDown;
            var reverse = this._xScale.reverse;
            var xleft;
            if (extendLines || extendLeft) {
                xleft = this._xScale.getMinPlotFactor();
            }
            else if ((xvalue1 < xvalue2) !== reverse) {
                xleft = this._xScale.lookup(xvalue1, this._xBin);
            }
            else {
                xleft = this._xScale.lookup(xvalue2, this._xBin);
            }
            var xright;
            if (extendLines || extendRight) {
                xright = this._xScale.getMaxPlotFactor();
            }
            else if ((xvalue1 < xvalue2) !== reverse) {
                xright = this._xScale.lookup(xvalue2, this._xBin);
            }
            else {
                xright = this._xScale.lookup(xvalue1, this._xBin);
            }
            var visibleLevels = this.series.fibonacciLevels;
            var fpt100;
            var fpt000;
            if (uptrend) {
                fpt100 = new Point(plot.subPlotFromNDC(this._xScale.lookup(xvalue1, this._xBin), 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(min$$1, this._yBin), 2 /* Y */));
                fpt000 = new Point(plot.subPlotFromNDC(this._xScale.lookup(xvalue2, this._xBin), 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(max$$1, this._yBin), 2 /* Y */));
            }
            else {
                fpt100 = new Point(plot.subPlotFromNDC(this._xScale.lookup(xvalue1, this._xBin), 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(max$$1, this._yBin), 2 /* Y */));
                fpt000 = new Point(plot.subPlotFromNDC(this._xScale.lookup(xvalue2, this._xBin), 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(min$$1, this._yBin), 2 /* Y */));
            }
            var pt100 = new Point(fpt100.x, fpt100.y);
            var pt000 = new Point(fpt000.x, fpt000.y);
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, pt100);
                this.cacheSelectable(prm, 3 /* DATAPOINT */, pt000);
            }
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            // draw line
            if (this._drawBaseLine) {
                this.addBaseLine(ctx, pt000, pt100);
            }
            var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var rectA;
            var rectB;
            if (this._setHitVector) {
                rectA = this.createNamedRectangle(ctx, prm, pt000, dpSize, 1, this._addNamesToHitshapes);
                rectB = this.createNamedRectangle(ctx, prm, pt100, dpSize, 0, this._addNamesToHitshapes);
            }
            for (var _i = 0, _f = this._yLevels; _i < _f.length; _i++) {
                var yLevel = _f[_i];
                if (uptrend || this._xData.data.length > 2) {
                    y = max$$1 - (deltaY * yLevel);
                }
                else {
                    y = min$$1 + (deltaY * yLevel);
                }
                var pt1 = new Point(plot.subPlotFromNDC(xleft, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                var pt2 = new Point(plot.subPlotFromNDC(xright, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                // Adjust for anti-aliasing so the lines aren't blurry
                pt1.x = ~~pt1.x + pen.getAliasOffset();
                pt1.y = ~~pt1.y + pen.getAliasOffset();
                pt2.x = ~~pt2.x + pen.getAliasOffset();
                pt2.y = ~~pt2.y + pen.getAliasOffset();
                var levelIsVisible = visibleLevels & 0x1;
                if (this._setHitVector) {
                    var line = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                    line.index = -1;
                    line.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    if (yLevel === 0.0 || yLevel === 1.0) {
                        var index = Math.round(1.0 - yLevel);
                        line.index = index;
                        if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                            line.name = 1 /* DATAPOINTNS */;
                        }
                    }
                    if (levelIsVisible) {
                        this.series.hitVector.push(line);
                    }
                }
                if (this.seriesSelected) {
                    var directionIsLeftToRight = reverse ? xvalue1 < xvalue2 : xvalue1 > xvalue2;
                    var levelOnRight = directionIsLeftToRight ? 1 : 0;
                    var levelOnLeft = 1 - levelOnRight;
                    if ((levelIsVisible && !fuzzyEQ(yLevel, levelOnLeft)) || extendLines || extendLeft) {
                        this.cacheSelectable(prm, 0 /* NONE */, new Point(plot.subPlotFromNDC(xleft + FDSFudge, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */)));
                    }
                    if ((levelIsVisible && !fuzzyEQ(yLevel, levelOnRight)) || extendLines || extendRight) {
                        this.cacheSelectable(prm, 0 /* NONE */, new Point(plot.subPlotFromNDC(xright - FDSFudge, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */)));
                    }
                }
                if (levelIsVisible) {
                    var _g = this.computeLabelPosition(ctx, pt1, pt2, yLevel * 100, y, uptrend), oxr = _g.oxr, oxl = _g.oxl;
                    pt1.x += oxr;
                    pt2.x -= oxl;
                    ctx.beginPath();
                    pen.closePolyline();
                    pen.drawPolyline(ctx, pt1, pt2);
                    pen.closePolyline();
                    ctx.stroke();
                }
                visibleLevels = visibleLevels >> 1;
            }
            if (this._drawInteractionHandle) {
                this.addInteractionHandle(ctx, prm, pt000, pt100);
            }
            if (this._drawBaseLine) {
                this.addBaseLineHitShape(prm, pt100, pt000);
            }
            if (this._addDataPointsHitShapes) {
                if (rectA != null) {
                    this.series.hitVector.push(rectA);
                }
                if (rectB != null) {
                    this.series.hitVector.push(rectB);
                }
            }
            ctx.restore();
            var _c, _d, _e;
        };
        FibonacciRetracements.prototype.computeLabelPosition = function (ctx, pt1, pt2, level, value, uptrend) {
            var oxl = 0;
            var oxr = 0;
            var h1 = this.series.seriesLabel1HPosition;
            var h2 = this.series.seriesLabel2HPosition;
            var v1 = this.series.seriesLabel1VPosition;
            var v2 = this.series.seriesLabel2VPosition;
            if ((h1 === h1) && (v1 !== v2) && (v2 === 2 /* V_CENTER */)) {
                this._addLabels(ctx, 2, pt1, pt2, value, pt1.x < pt2.x, false, uptrend);
                this._addLabels(ctx, 1, pt1, pt2, level, pt1.x < pt2.x, true, uptrend);
            }
            else {
                this._addLabels(ctx, 1, pt1, pt2, level, pt1.x < pt2.x, true, uptrend);
                this._addLabels(ctx, 2, pt1, pt2, value, pt1.x < pt2.x, false, uptrend);
            }
            return { oxl: oxl, oxr: oxr };
        };
        FibonacciRetracements.prototype._addLabels = function (ctx, labelIndex, pt1, pt2, level, ltr, isLevel, uptrend) {
            ctx.save();
            var visibleLabels = this.series.labelsMask;
            if ((visibleLabels >> (labelIndex - 1)) & 0x1) {
                var font = void 0;
                var format = void 0;
                var xoff = void 0;
                var yoff = void 0;
                if (labelIndex === 1 /* LABEL1 */) {
                    font = this.series.seriesLabel1Font;
                    if (this.series.seriesLabel1ColorFollowsSeriesColor) {
                        if (!this.series.attributeSet.isDefault('SeriesColor')) {
                            font = font.with({ color: this.series.calculatedSeriesColor });
                        }
                        else {
                            font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                        }
                    }
                    format = this.series.seriesLabel1Format;
                    xoff = this.series.seriesLabel1XOffset;
                    yoff = -this.series.seriesLabel1YOffset;
                }
                else {
                    font = this.series.seriesLabel2Font;
                    if (this.series.seriesLabel2ColorFollowsSeriesColor) {
                        if (!this.series.attributeSet.isDefault('SeriesColor')) {
                            font = font.with({ color: this.series.calculatedSeriesColor });
                        }
                        else {
                            font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                        }
                    }
                    format = this.series.seriesLabel2Format;
                    xoff = this.series.seriesLabel2XOffset;
                    yoff = -this.series.seriesLabel2YOffset;
                }
                // Set the font
                font.setOnCanvas(ctx);
                var valueFormatter = new FDSFormat();
                valueFormatter.setNumberFormat(format);
                var label = valueFormatter.formatAsNumber(level);
                var tp1 = new Point(pt1.x, pt1.y);
                var tp2 = new Point(pt2.x, pt2.y);
                tp1.x += Math.round(xoff);
                tp1.y += Math.round(yoff);
                tp2.x += Math.round(xoff);
                tp2.y += Math.round(yoff);
                // TODO
                var vPos = void 0;
                var position = void 0;
                if (isLevel) {
                    position = this.series.seriesLabel1HPosition;
                    vPos = this.series.seriesLabel1VPosition;
                    // if position is @series.seriesLabel2HPosition and vPos is @series.seriesLabel2VPosition
                    if (vPos === 1 /* V_TOP */) {
                        vPos = 0 /* V_BOTTOM */;
                    }
                    else {
                        vPos = 1 /* V_TOP */;
                    }
                }
                else {
                    position = this.series.seriesLabel2HPosition;
                    vPos = this.series.seriesLabel2VPosition;
                    if (position !== this.series.seriesLabel1HPosition) {
                        if (vPos === 1 /* V_TOP */) {
                            vPos = 0 /* V_BOTTOM */;
                        }
                        else {
                            vPos = 1 /* V_TOP */;
                        }
                    }
                }
                var fontHeight = void 0;
                if (vPos === 0 /* V_BOTTOM */) {
                    fontHeight = font.getHeight();
                }
                else {
                    fontHeight = -2;
                }
                var textAlign = void 0;
                var textPos = void 0;
                switch (position) {
                    case 0 /* LEFT */:
                        textAlign = ltr ? 'left' : 'right';
                        textPos = tp1;
                        break;
                    case 2 /* CENTER */:
                        textPos = { x: Math.round((tp1.x + tp2.x) / 2.0), y: tp1.y };
                        textAlign = 'center';
                        break;
                    default:
                        // default handles TEXT_RIGHT
                        textAlign = ltr ? 'right' : 'left';
                        textPos = tp2;
                }
                ctx.legacyFillText(label, textPos.x, textPos.y + fontHeight, textAlign);
            }
            ctx.restore();
        };
        FibonacciRetracements.prototype.createNamedRectangle = function (ctx, prm, pt, hitShapeSize, index, addNamesToHitshapes) {
            hitShapeSize += DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var offsetX = prm.plotRect.x1 - hitShapeSize;
            var offsetY = prm.plotRect.y1 - hitShapeSize;
            var rect = new FDSRectangleHitShape(Math.round(pt.x + offsetX), Math.round(pt.y + offsetY), hitShapeSize * 2, hitShapeSize * 2);
            var name;
            if (addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                name = 3 /* DATAPOINT */;
            }
            else {
                name = 0 /* NONE */;
            }
            rect.name = name;
            rect.index = index;
            return rect;
        };
        return FibonacciRetracements;
    }(InteractiveDrawStyle));
    
    var FibonacciTimeZones = /** @class */ (function (_super) {
        __extends(FibonacciTimeZones, _super);
        function FibonacciTimeZones() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FibonacciTimeZones.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        FibonacciTimeZones.prototype.verify = function () {
            return true;
        };
        FibonacciTimeZones.prototype.hint = function () {
            return -1 /* NONE */;
        };
        FibonacciTimeZones.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            ctx.save();
            if (this._yData.getSize() < 2 || this._xData.getSize() < 2) {
                return;
            }
            var yvalue1 = this._yData.getAt(0);
            var xvalue1 = this._xData.getAt(0);
            var yvalue2 = this._yData.getAt(1);
            var xvalue2 = this._xData.getAt(1);
            var min$$1 = this._xScale.compressValue(xvalue1);
            var max$$1 = this._xScale.compressValue(xvalue2);
            var deltaX = max$$1 - min$$1;
            var extendLines = this.series.extendLine;
            var extendUp = this.series.extendLineRightOrUp;
            var extendDown = this.series.extendLineLeftOrDown;
            var reverse = this._yScale.reverse;
            var ybottom;
            if (extendLines || extendDown) {
                ybottom = this._yScale.getMinPlotFactor();
            }
            else if ((yvalue1 > yvalue2) !== reverse) {
                ybottom = this._yScale.lookup(yvalue2, this._yBin);
            }
            else {
                ybottom = this._yScale.lookup(yvalue1, this._yBin);
            }
            var ytop;
            if (extendLines || extendUp) {
                ytop = this._yScale.getMaxPlotFactor();
            }
            else if ((yvalue1 > yvalue2) !== reverse) {
                ytop = this._yScale.lookup(yvalue1, this._yBin);
            }
            else {
                ytop = this._yScale.lookup(yvalue2, this._yBin);
            }
            var ptStart = new Point((prm.plot.subPlotFromNDC(this._xScale.lookup(xvalue1, this._xBin), 1 /* X */)), (prm.plot.subPlotFromNDC(this._yScale.lookup(yvalue1, this._yBin), 2 /* Y */)));
            var ptEnd = new Point((prm.plot.subPlotFromNDC(this._xScale.lookup(xvalue2, this._xBin), 1 /* X */)), (prm.plot.subPlotFromNDC(this._yScale.lookup(yvalue2, this._yBin), 2 /* Y */)));
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            if (this.series.baseLineVisible) {
                this.addBaseLine(ctx, ptStart, ptEnd);
            }
            var tmin = this._xScale.compressValue(this._xScale.threshMin);
            var tmax = this._xScale.compressValue(this._xScale.threshMax);
            var last$$1 = 0;
            var x = min$$1;
            var i = 0;
            var aliasOffset = pen.getAliasOffset();
            while (x <= tmax) {
                if (fuzzyLTE(deltaX, 0.0) && i > 1) {
                    break;
                }
                last$$1 = i > 1 ? Math.round(last$$1 * PHI) : i;
                x = min$$1 + (deltaX * last$$1);
                if (x < tmin) {
                    continue;
                }
                var xval = ~~(prm.plot.subPlotFromNDC(this._xScale.lookup(this._xScale.decompressValue(x), this._xBin), 1 /* X */)) +
                    aliasOffset;
                var yval1 = ~~(prm.plot.subPlotFromNDC(ybottom, 2 /* Y */)) + aliasOffset;
                var yval2 = ~~(prm.plot.subPlotFromNDC(ytop, 2 /* Y */)) + aliasOffset;
                var pt1 = new Point(xval, yval1);
                var pt2 = new Point(xval, yval2);
                if (pt1.x + prm.plotRect.x1 > prm.plotRect.x2) {
                    break;
                }
                // draw the vertical line
                ctx.beginPath();
                pen.drawPolyline(ctx, pt1, pt2);
                pen.closePolyline();
                ctx.stroke();
                if (this._setHitVector) {
                    var line = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                    line.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    if (i < 2 && this.series.isInteractive(4 /* RESIZABLE */)) {
                        line.index = i;
                    }
                    else {
                        line.index = -1;
                    }
                    this.series.hitVector.push(line);
                }
                if (this.seriesSelected) {
                    xval = prm.plot.subPlotFromNDC(this._xScale.lookup(this._xScale.decompressValue(x)), 1 /* X */);
                    this.cacheSelectable(prm, 5 /* SERIESHIT */, xval, (prm.plot.subPlotFromNDC(ybottom + FDSFudge, 2 /* Y */)));
                    this.cacheSelectable(prm, 5 /* SERIESHIT */, xval, (prm.plot.subPlotFromNDC(ytop - FDSFudge, 2 /* Y */)));
                }
                this._addLabel(ctx, pt1, pt2, last$$1);
                i++;
            }
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptStart);
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptEnd);
            }
            if (this._drawInteractionHandle) {
                this.addInteractionHandle(ctx, prm, ptStart, ptEnd);
            }
            if (this._drawBaseLine) {
                this.addBaseLineHitShape(prm, ptStart, ptEnd);
            }
            if (this._addDataPointsHitShapes) {
                var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
                var rect1 = new FDSRectangleHitShape((ptStart.x + prm.plotRect.x1) - dpSize, (ptStart.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect1.index = 0;
                if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect1.name = 3 /* DATAPOINT */;
                }
                else {
                    rect1.name = 0 /* NONE */;
                }
                var rect2 = new FDSRectangleHitShape((ptEnd.x + prm.plotRect.x1) - dpSize, (ptEnd.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect2.index = 1;
                if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect2.name = 3 /* DATAPOINT */;
                }
                else {
                    rect2.name = 0 /* NONE */;
                }
                this.series.hitVector.push(rect1);
                this.series.hitVector.push(rect2);
            }
            ctx.restore();
        };
        FibonacciTimeZones.prototype._addLabel = function (ctx, pt1, pt2, fibLevel) {
            var font = this.series.seriesLabel1Font;
            if (this.series.seriesLabel1ColorFollowsSeriesColor) {
                if (!this.series.attributeSet.isDefault('SeriesColor')) {
                    font = font.with({ color: this.series.calculatedSeriesColor });
                }
                else {
                    font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                }
            }
            font.setOnCanvas(ctx);
            var format = this.series.seriesLabel1Format;
            var valueFormatter = new FDSFormat();
            valueFormatter.setNumberFormat(format);
            var label = valueFormatter.formatAsNumber(fibLevel);
            var p1 = new Point(pt1.x, pt1.y);
            var p2 = new Point(pt2.x, pt2.y);
            if (this._yScale.reverse) {
                _a = [p2, p1], p1 = _a[0], p2 = _a[1];
            }
            var xoff = this.series.seriesLabel1XOffset;
            var yoff = -this.series.seriesLabel1YOffset;
            var position = this.series.seriesLabel1HPosition;
            var textAlign;
            if (position === 0 /* LEFT */) {
                textAlign = 'left';
            }
            else if (position === 1 /* RIGHT */) {
                textAlign = 'right';
            }
            else {
                textAlign = 'center';
            }
            // TODO for some reason this logic is reversed in order to match the
            // PC side. When they set the SeriesLabel1VPosition to 0, it should be
            // on the bottom, but it ends up being on the top (and vice versa for
            // setting it to 1). Our defaults for the attributes match theirs, so
            // I'm not sure what the problem is.
            var vPos = this.series.seriesLabel1VPosition;
            switch (vPos) {
                case 1 /* V_TOP */:
                    p1.x += xoff;
                    p1.y += yoff;
                    ctx.legacyFillText(label, p1.x, p1.y, textAlign);
                    break;
                case 2 /* V_CENTER */:
                    var pt = new Point(pt1.x, pt1.y);
                    pt.y = Math.round((pt1.y + pt2.y) / 2) + yoff;
                    pt.x += xoff;
                    ctx.legacyFillText(label, pt.x, pt.y, textAlign);
                    break;
                default:
                    // default handles case TEXT_V_BOTTOM
                    p2.x += xoff;
                    p2.y += yoff;
                    ctx.legacyFillText(label, p2.x, p2.y + 10, textAlign);
                    break;
            }
            var _a;
        };
        return FibonacciTimeZones;
    }(InteractiveDrawStyle));
    
    var FibProjection = /** @class */ (function (_super) {
        __extends(FibProjection, _super);
        function FibProjection(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(57 /* FIBPROJECTION */);
            _this._addNamesToHitshapes = _this._isInteractable;
            _this._drawInteractionHandle = _this.seriesSelected && _this._addNamesToHitshapes;
            return _this;
        }
        FibProjection.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            this.populateDrawStyleLevels(57 /* FIBPROJECTION */);
            var plot = prm.plot;
            var hitVector = this.series.hitVector;
            if (this._yData.getSize() < 3 || this._xData.getSize() < 3) {
                return;
            }
            var projValue = this._yData.getAt(2);
            var projXValue = this._xData.getAt(2);
            var value1 = this._yData.getAt(0);
            var xvalue1 = this._xData.getAt(0);
            var value2 = this._yData.getAt(1);
            var xvalue2 = this._xData.getAt(1);
            var y = 0;
            if (NOTNAN(value1) && NOTNAN(xvalue1) && NOTNAN(value2) && NOTNAN(xvalue2) &&
                NOTNAN(projValue) && NOTNAN(projXValue)) {
                ctx.save();
                var pen = this.series.seriesFGPen;
                pen.setOnCanvas(ctx);
                var uptrend = value1 <= value2;
                var min$$1 = value1;
                var max$$1 = value2;
                var deltaY = max$$1 - min$$1;
                var extendLines = this.series.extendLine;
                var extendLeft = this.series.extendLineLeftOrDown;
                var extendRight = this.series.extendLineRightOrUp;
                var reverse = this._xScale.reverse;
                var xleft = void 0;
                if (extendLines || (!reverse && extendLeft) || (reverse && extendRight)) {
                    if (!reverse) {
                        xleft = this._xScale.getMinPlotFactor();
                    }
                    else {
                        xleft = this._xScale.getMaxPlotFactor();
                    }
                }
                else {
                    xleft = this._xScale.lookup(projXValue);
                }
                var xright = void 0;
                if (!reverse) {
                    xright = this._xScale.getMaxPlotFactor();
                }
                else {
                    xright = this._xScale.getMinPlotFactor();
                }
                var visibleLevels = this.series.fibonacciLevels;
                var ptf1 = this._makePxPointFromValue(prm, xvalue1, value1);
                var ptf2 = this._makePxPointFromValue(prm, xvalue2, value2);
                var ptf0 = this._makePxPointFromValue(prm, projXValue, projValue);
                if (this.series.isSelected()) {
                    this.cacheSelectable(prm, 3 /* DATAPOINT */, ptf1);
                    this.cacheSelectable(prm, 3 /* DATAPOINT */, ptf2);
                    // selection marker for the projection point
                    if (extendLines || (!reverse && extendLeft) || (reverse && extendRight)) {
                        this.cacheSelectable(prm, 3 /* DATAPOINT */, ptf0);
                    }
                }
                if (this.series.baseLineVisible) {
                    this.addBaseLine(ctx, ptf1, ptf2);
                    this.addBaseLine(ctx, ptf2, ptf0);
                }
                var hitShapeSize = this.series.datapointHitShapeSize;
                var rectA = void 0;
                var rectB = void 0;
                var rectC = void 0;
                if (this._setHitVector) {
                    rectA = this.createNamedRectangle(ctx, prm, ptf1, hitShapeSize, 0, this._addNamesToHitshapes);
                    rectB = this.createNamedRectangle(ctx, prm, ptf2, hitShapeSize, 1, this._addNamesToHitshapes);
                    rectC = this.createNamedRectangle(ctx, prm, ptf0, hitShapeSize, 2, this._addNamesToHitshapes);
                }
                ctx.beginPath();
                pen.closePolyline();
                for (var _i = 0, _a = this._yLevels; _i < _a.length; _i++) {
                    var level = _a[_i];
                    if (uptrend || this._xData.getSize() > 2) {
                        y = projValue + (deltaY * level);
                    }
                    else {
                        y = projValue - (deltaY * level);
                    }
                    var pt1 = new Point(plot.subPlotFromNDC(xleft, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                    var pt2 = new Point(plot.subPlotFromNDC(xright, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                    var levelIsVisible = visibleLevels & 0x1;
                    if (this._setHitVector) {
                        var line = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.x1);
                        line.index = -1;
                        if (levelIsVisible) {
                            hitVector.push(line);
                        }
                    }
                    if (this.series.isSelected() && levelIsVisible) {
                        var fudge = FDSFudge * (reverse ? -1 : 1);
                        this.cacheSelectable(prm, 0 /* NONE */, new Point(plot.subPlotFromNDC(xleft + fudge, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */)));
                        this.cacheSelectable(prm, 0 /* NONE */, new Point(plot.subPlotFromNDC(xright - fudge, 1 /* X */), plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */)));
                    }
                    if (levelIsVisible) {
                        this.computeLabelPosition(ctx, pt1, pt2, level * 100.0, y, uptrend);
                        ctx.moveTo(~~pt1.x + pen.getAliasOffset(), ~~pt1.y + pen.getAliasOffset());
                        pen.drawPolyline(ctx, pt1, pt2);
                        pen.closePolyline();
                    }
                    visibleLevels = visibleLevels >> 1;
                }
                // stroke the path for the levels before we destroy
                // the path below for additional drawing
                ctx.stroke();
                if (this._drawInteractionHandle) {
                    this.addInteractionHandle(ctx, prm, ptf1, ptf2);
                    this.addInteractionHandle(ctx, prm, ptf2, ptf0);
                }
                if (this._drawBaseLine) {
                    this.addBaseLineHitShape(prm, ptf1, ptf2);
                    this.addBaseLineHitShape(prm, ptf2, ptf0);
                }
                if (this._addDataPointsHitShapes) {
                    hitVector.push(rectA);
                    hitVector.push(rectB);
                    hitVector.push(rectC);
                }
                ctx.restore();
            }
            this.series.hitVector = hitVector;
        };
        FibProjection.prototype._makePxPointFromValue = function (prm, xval, yval) {
            var x = prm.plot.subPlotFromNDC(this._xScale.lookup(xval), 1 /* X */);
            var y = prm.plot.subPlotFromNDC(this._yScale.lookup(yval), 2 /* Y */);
            return new Point(x, y);
        };
        return FibProjection;
    }(FibonacciRetracements));
    
    var GannFan = /** @class */ (function (_super) {
        __extends(GannFan, _super);
        function GannFan(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(46 /* GANNFAN */);
            return _this;
        }
        GannFan.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        GannFan.prototype.verify = function () {
            return true;
        };
        GannFan.prototype.hint = function () {
            return -1 /* NONE */;
        };
        GannFan.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            this.populateDrawStyleLevels(46 /* GANNFAN */);
            ctx.save();
            // Get the 0th and 1st point data for both X,Y data. This is intentional.
            var xPt1 = this._xData.getAt(0);
            var xPt2 = this._xData.getAt(1);
            var yPt1 = this._yData.getAt(0);
            var yPt2 = this._yData.getAt(1);
            // Just call the whole thing off if anything is NaN.
            if ((isNaN(xPt1)) || (isNaN(xPt2)) || (isNaN(yPt1)) || (isNaN(yPt2))) {
                return;
            }
            // Auxilary variables
            var pt1 = new Point(0, 0);
            var pt2 = new Point(0, 0);
            var cx = this._xScale.lookup(xPt1, this._xBin);
            var cy = this._yScale.lookup(yPt1, this._yBin);
            var ex = this._xScale.lookup(xPt2, this._xBin);
            var ey = this._yScale.lookup(yPt2, this._yBin);
            // Center and End Point in NDC
            var center = new Point(cx, cy);
            var endPoint = new Point(ex, ey);
            // Center and End Point in Pixel Coordinates
            var ptCenter = new Point(prm.plot.subPlotFromNDC(cx, 1 /* X */), prm.plot.subPlotFromNDC(cy, 2 /* Y */));
            var ptEnd = new Point(prm.plot.subPlotFromNDC(ex, 1 /* X */), prm.plot.subPlotFromNDC(ey, 2 /* Y */));
            // Amount of visible levels to show
            var visibleLevels = this.series.fibonacciLevels;
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptCenter);
                this.cacheSelectable(prm, 3 /* DATAPOINT */, ptEnd);
            }
            // Scales the lines and such based on the width/height of the plot window.
            var scaleXY = 1.0;
            if (prm.plot.plotRect.getWidth() !== 0) {
                scaleXY = prm.plot.plotRect.getHeight() / prm.plot.plotRect.getWidth();
            }
            var realAngle = this._lineSegmentAngle(center, endPoint, scaleXY);
            var ndcAngle = this._lineSegmentAngle(center, endPoint, 1.0);
            var zeroDegreeLineVisible = false;
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            // Iterate through each level, then handle line, marker or hitshape drawing/setting.
            for (var _i = 0, _a = this._yLevels; _i < _a.length; _i++) {
                var levelVal = _a[_i];
                var result = new Point(0, 0);
                // Believe it or not, this forces the array element to be treated as a number. Without this,
                // addition causes a string append.
                levelVal = levelVal * 1;
                if (fuzzyEQ(levelVal, 0)) {
                    result = this._clip(center, 360 + ndcAngle, 1.0);
                    zeroDegreeLineVisible = (visibleLevels & 0x1) !== 0;
                }
                else {
                    result = this._clip(center, levelVal + 360 + realAngle, scaleXY);
                }
                pt1 = new Point(prm.plot.subPlotFromNDC(cx, 1 /* X */), prm.plot.subPlotFromNDC(cy, 2 /* Y */));
                pt2 = new Point(prm.plot.subPlotFromNDC(result.x, 1 /* X */), prm.plot.subPlotFromNDC(result.y, 2 /* Y */));
                if (visibleLevels & 0x1) {
                    // Hit Shapes
                    if (this._setHitVector) {
                        var line = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                        line.index = -1;
                        if (this._addNamesToHitshapes && fuzzyEQ(levelVal, 0.0) &&
                            this.series.isInteractive(2 /* DRAGGABLE */)) {
                            line.name = 5 /* SERIESHIT */;
                        }
                        this.series.hitVector.push(line);
                    }
                    if (this.seriesSelected) {
                        var fudgeX = void 0, fudgeY = void 0;
                        fudgeX = fudgeY = FDSFudge;
                        if (fuzzyEQ(result.x, 0.0)) {
                            fudgeX *= -1;
                        }
                        if (fuzzyEQ(result.y, 0.0)) {
                            fudgeY *= -1;
                        }
                        this.cacheSelectable(prm, 0 /* NONE */, prm.plot.subPlotFromNDC(result.x - fudgeX, 1 /* X */), prm.plot.subPlotFromNDC(result.y - fudgeY, 2 /* Y */));
                    }
                    ctx.beginPath();
                    pen.drawPolyline(ctx, pt1, pt2);
                    pen.closePolyline();
                    ctx.stroke();
                }
                visibleLevels = visibleLevels >> 1;
            }
            if (this._drawInteractionHandle) {
                this.addInteractionHandle(ctx, prm, ptCenter, ptEnd);
            }
            if (zeroDegreeLineVisible || this._drawInteractionHandle) {
                this.addBaseLineHitShape(prm, ptCenter, ptEnd);
            }
            if (this._addDataPointsHitShapes) {
                var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
                var rect1 = new FDSRectangleHitShape((ptCenter.x + prm.plotRect.x1) - dpSize, (ptCenter.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect1.index = 0;
                if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect1.name = 3 /* DATAPOINT */;
                }
                this.series.hitVector.push(rect1);
                var rect2 = new FDSRectangleHitShape((ptEnd.x + prm.plotRect.x1) - dpSize, (ptEnd.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                rect2.index = 1;
                if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                    rect2.name = 3 /* DATAPOINT */;
                }
                this.series.hitVector.push(rect2);
            }
            ctx.restore();
        };
        GannFan.prototype._lineSegmentAngle = function (pt1, pt2, scaleXY) {
            var radians = Math.atan2((pt2.y - pt1.y) * scaleXY, (pt2.x - pt1.x));
            var degrees = RadToDeg(radians);
            if (degrees < 0.0) {
                degrees = 360.0 + degrees;
            }
            return degrees;
        };
        GannFan.prototype._clip = function (center, angle, s) {
            // This eventually becomes the ultimate end point for drawing the line/marker.
            var result = new Point(1.5, 0.0);
            angle = angle % 360.0;
            _a = this._transform(result.x, result.y, center.x, center.y, 1.0, 1.0 / s, angle), result.x = _a[0], result.y = _a[1];
            _b = this._translate(result.x, result.y, -center.x, -center.y), result.x = _b[0], result.y = _b[1];
            _c = this._scale(result.x, result.y, 1.0, 1.0 / s), result.x = _c[0], result.y = _c[1];
            _d = this._translate(result.x, result.y, center.x, center.y), result.x = _d[0], result.y = _d[1];
            // Essentially, we need to find either the max/min values on both extremes, so let's use NAN and abs NAN
            var slope = 0;
            if (result.y < center.y) {
                slope = NAN;
            }
            else {
                slope = Math.abs(NAN);
            }
            if (!fuzzyEQ(result.x - center.x, 0)) {
                slope = (result.y - center.y) / (result.x - center.x);
            }
            var b = center.y - (slope * center.x);
            // Check edges
            if (!fuzzyEQ(slope, 0)) {
                // Top
                if (0.0 <= angle && angle <= 180.0) {
                    result.x = (1.0 - b) / slope;
                }
                else {
                    result.x = (b * -1) / slope;
                }
            }
            // Right
            if ((angle > 0.0 && angle <= 90.0) || (angle >= 270.0 && angle < 360.0)) {
                result.y = slope + b;
            }
            else {
                result.y = b;
            }
            result.x = clamp(result.x, 0.0, 1.0);
            result.y = clamp(result.y, 0.0, 1.0);
            return result;
            var _a, _b, _c, _d;
        };
        GannFan.prototype._translate = function (x, y, movex, movey) {
            return [x + movex, y + movey];
        };
        GannFan.prototype._scale = function (x, y, scalex, scaley) {
            return [x * scalex, y * scaley];
        };
        GannFan.prototype._rotateByDegrees = function (x, y, rotationAngle) {
            return this._rotate(x, y, Math.cos(DegToRad(rotationAngle)), Math.sin(DegToRad(rotationAngle)));
        };
        GannFan.prototype._rotate = function (x, y, cos, sin) {
            var tmpx = x;
            var tmpy = y;
            x = (tmpx * cos) - (tmpy * sin);
            y = (tmpx * sin) + (tmpy * cos);
            return [x, y];
        };
        GannFan.prototype._transform = function (x, y, tx, ty, scalex, scaley, rotationAngleInDegrees) {
            if (scalex === void 0) { scalex = 1.0; }
            if (scaley === void 0) { scaley = 1.0; }
            if (rotationAngleInDegrees === void 0) { rotationAngleInDegrees = 0.0; }
            _a = this._scale(x, y, scalex, scaley), x = _a[0], y = _a[1];
            _b = this._rotateByDegrees(x, y, rotationAngleInDegrees), x = _b[0], y = _b[1];
            _c = this._translate(x, y, tx, ty), x = _c[0], y = _c[1];
            return [x, y];
            var _a, _b, _c;
        };
        return GannFan;
    }(InteractiveDrawStyle));
    
    var HistogramDrawStyle = /** @class */ (function (_super) {
        __extends(HistogramDrawStyle, _super);
        function HistogramDrawStyle(series) {
            return _super.call(this, series) || this;
        }
        HistogramDrawStyle.prototype._calculateBarBounds = function () {
            var _a = this._prm, plot = _a.plot, plotRect = _a.plotRect;
            var _b = this.computeWorldBarBases(), ndcY = _b.ndcY, ndcX = _b.ndcX;
            var barBasePixel = plotRect.clampValueToBounds(~~(plot.subPlotFromNDC(ndcY, 2 /* Y */)), 2 /* Y */);
            var barBounds = this._getBarBoundsFromSeries();
            var points = [];
            var colorData = this.series.getData(4 /* COLOR */);
            for (var j = this._start; j < this._end; j += this._step) {
                var index = this.series.getSampleIndex(j);
                var currBounds = barBounds[index];
                var value = this._valueAxisInfo.dataset.getAt(index);
                var yDataItem = this._yData.getAt(index);
                if (value == null || yDataItem == null || isNaN(yDataItem) || IsSomeInternalNAN(value)) {
                    continue;
                }
                var yValNdc = this._yScale.lookup(yDataItem, this._yBin);
                var yValPixel = ~~(plot.subPlotFromNDC(yValNdc, 2 /* Y */));
                var rect = new Rectangle(currBounds.x1, yValPixel, currBounds.x2, barBasePixel);
                var color = this._calcColorMapColor(this.series.seriesBGBrush.color, colorData.getAt(index), index);
                points.push({ index: index, rect: rect, color: color, value: value, base: barBasePixel });
            }
            return points;
        };
        HistogramDrawStyle.prototype._getBarBoundsFromSeries = function () {
            var xDim = this._xData.getDimension();
            if (xDim === 0) {
                return [];
            }
            var boundsInNdc;
            boundsInNdc = this._getBarBoundsNdc();
            var boundsInPixels = [];
            var plot = this._prm.plot;
            for (var _i = 0, boundsInNdc_1 = boundsInNdc; _i < boundsInNdc_1.length; _i++) {
                var bound = boundsInNdc_1[_i];
                var boundInPixels = { x1: 0, x2: 0 };
                boundInPixels.x1 = Math.round(plot.subPlotFromNDC(this._xScale.lookup(bound.x1, this._xBin), 1 /* X */));
                boundInPixels.x2 = Math.round(plot.subPlotFromNDC(this._xScale.lookup(bound.x2, this._xBin), 1 /* X */));
                boundsInPixels.push(boundInPixels);
            }
            return boundsInPixels;
        };
        HistogramDrawStyle.prototype._getBarBoundsNdc = function () {
            var barBounds = [];
            for (var index = 0; index < this.series.size; index++) {
                barBounds.push(this._getBinRangeFromIndex(index));
            }
            return barBounds;
        };
        HistogramDrawStyle.prototype._getBinRangeFromIndex = function (index) {
            if (this._xData.getDimension() < 2) {
                return null;
            }
            var x1 = this._xData.getAt(index, 0);
            var x2 = this._xData.getAt(index, 1);
            return { x1: x1, x2: x2 };
        };
        HistogramDrawStyle.prototype.verify = function () {
            // Check whether we have at least two-dimensional x-data.
            return this._xData.getDimension() >= 2;
        };
        HistogramDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return HistogramDrawStyle;
    }(ColumnsDrawStyle));
    
    var OHLCBaseDrawStyle = /** @class */ (function (_super) {
        __extends(OHLCBaseDrawStyle, _super);
        function OHLCBaseDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OHLCBaseDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.actuallyDraw(prm, ctx, false, false);
        };
        OHLCBaseDrawStyle.prototype.actuallyDraw = function (prm, ctx, openline, crossline) {
            // Get a drawing context
            ctx.save();
            var plot = prm.plot;
            // we're gonna use a brush instead of a pen
            var brush = new FDSBrush();
            brush.style = 0 /* SOLID */;
            brush.color = this.series.seriesFGPen.color;
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            else {
                brush.setOnCanvas(ctx);
            }
            var offset = -1.0;
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            // For each point in xData, draw a vertical line from high to low,
            //  marked with a line to the right for closing price and one to
            //  the left for opening price
            for (var j = this._start; j < this._end; j += this._step) {
                var i = this.series.getSampleIndex(j);
                var xPoint = this._xData.getAt(i);
                // these are guaranteed to exist because we checked for them
                // before setting the draw style
                var yClose = this._yData.getDimensionalDataset(0).getAt(i);
                var yHigh = this._yData.getDimensionalDataset(1).getAt(i);
                var yLow = this._yData.getDimensionalDataset(2).getAt(i);
                // get the opendata if it exists
                var openlineprime = openline;
                var yOpen = void 0;
                if (openline) {
                    yOpen = this._yData.getDimensionalDataset(3).getAt(i);
                    openlineprime = !(isNaN(yOpen));
                }
                // we need to do some @NA checking, otherwise we can't draw these lines
                var closeline = !(isNaN(yClose));
                var middleline = !(isNaN(yHigh) || isNaN(yLow));
                // tiny bit of error checking
                if (yHigh < yLow) {
                    _a = [yLow, yHigh], yHigh = _a[0], yLow = _a[1];
                }
                var x0 = void 0, x1 = void 0, x2 = void 0, initOffset = void 0;
                _b = this._xScale.lookupRange(xPoint, this._xBin), x0 = _b[0], x1 = _b[1], x2 = _b[2], initOffset = _b[3];
                if (offset < 0.0) {
                    offset = initOffset;
                }
                if (offset < 0.001) {
                    offset = 0.0;
                }
                var delta = (x2 - offset) - (x1 + offset);
                var maxwidth = this.series.maxElementWidth; // make sure the x width isn't too big and adjust if necessary
                if (maxwidth > 0.0 && delta > maxwidth) {
                    delta = maxwidth;
                }
                x1 = x0 - (delta / 2);
                x2 = x0 + (delta / 2);
                // get the left and right edge points surrounding the actual x point
                var xPt = ~~(plot.subPlotFromNDC(x0, 1 /* X */));
                var xRPt = ~~(plot.subPlotFromNDC(x2, 1 /* X */));
                var xLPt = ~~(plot.subPlotFromNDC(x1, 1 /* X */));
                // account for a minimum size on small bins
                var minWidth = scaleByDevicePixelRatio(5);
                var minSideWidth = scaleByDevicePixelRatio(2);
                var xdeltap = openline ? Math.abs(xRPt - xPt) : Math.abs(xRPt - xLPt);
                if (xdeltap < minSideWidth || Math.abs(xRPt - xLPt) < minWidth) {
                    xdeltap = minSideWidth;
                }
                if (openline) {
                    xLPt = (xPt - xdeltap) + 1;
                    xRPt = xPt + xdeltap;
                }
                else {
                    xRPt = xLPt + xdeltap;
                }
                var yLPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yLow, this._yBin), 2 /* Y */));
                var yHPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yHigh, this._yBin), 2 /* Y */));
                var yCPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yClose, this._yBin), 2 /* Y */));
                var yOPt = void 0;
                if (openline) {
                    yOPt = ~~(plot.subPlotFromNDC(this._yScale.lookup(yOpen, this._yBin), 2 /* Y */));
                }
                var yPts = [];
                yPts.push(yCPt + prm.plotRect.y1);
                if (this.series.useColor) {
                    brush.pushHistory();
                    this._setColorMapColor(ctx, brush, colorData.getAt(i), i);
                }
                // draw the vertical high-low line
                // Note: draw lines as rectangles because that's faster
                // when they're not at an angle
                var width = scaleByDevicePixelRatio(this.series.seriesFGPen.width);
                var height = yLPt - yHPt;
                // center the line if it's HLCross or OHLC
                var drawX = void 0;
                if (openline || crossline) {
                    drawX = xPt;
                }
                else {
                    drawX = xLPt;
                }
                // save the pixel points, including the space before/above the plot rect
                var pR = prm.plot.plotRect;
                var drawY = Math.round(yHPt + (height / 2));
                pixelPoints[i] = { x: drawX + pR.x1, y: drawY + pR.y1 };
                infoboxPixelPoints[i] = { point: { x: drawX + pR.x1, y: yHPt + pR.y1 }, position: "above" /* above */ };
                var seriesPenProps = this.series.seriesFGPen.toPropertyObject();
                if (middleline) {
                    if (openline || crossline) {
                        ctx.fillRect((drawX - (width / 2)) + seriesPenProps.aliasOffset, yHPt, width, height);
                    }
                    else {
                        ctx.fillRect((drawX - (width / 2)) + seriesPenProps.aliasOffset, yHPt, width, height);
                        width = xRPt - xLPt;
                    }
                }
                yPts.push(yHPt + prm.plotRect.y1);
                yPts.push(yLPt + prm.plotRect.y1);
                if (yOPt != null) {
                    yPts.push(yOPt + prm.plotRect.y1);
                }
                // draw the horizontal close line
                // if this is HLOpen, the close line starts in the middle.
                // otherwise it starts on the left
                height = scaleByDevicePixelRatio(this.series.seriesFGPen.width);
                var yStart = ~~(yCPt - (height / 2));
                if (closeline) {
                    if (openline) {
                        width = xRPt - xPt;
                        ctx.fillRect(xPt, yStart, width, height);
                    }
                    else {
                        width = xRPt - xLPt;
                        ctx.fillRect(xLPt, yStart, width, height);
                    }
                }
                // if this is OHLC, draw the horizontal open line
                if (openline && openlineprime) {
                    width = xPt - xLPt;
                    yStart = ~~(yOPt - (height / 2));
                    ctx.fillRect(xLPt, yStart, width, height);
                }
                if (this.series.useColor) {
                    brush.popHistory();
                }
                this.series.addLookupPoint(xPt + prm.plotRect.x1, yPts, i);
                // add the hitrect
                width = xRPt - xLPt;
                height = Math.abs(yLPt - yHPt);
                var hitRect = new FDSRectangleHitShape(xLPt + prm.plotRect.x1, Math.min(yLPt, yHPt) + prm.plotRect.y1, width, height);
                hitRect.index = i;
                this.series.hitVector.push(hitRect);
                // Cache the selection marker position
                if (this.seriesSelected && this._selectionSampler.isPointSampled(i)) {
                    this.cacheSelectable(prm, 0 /* NONE */, xLPt + (width / 2), yCPt);
                }
            }
            this._resetColorMapColor(brush);
            ctx.restore();
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
            var _a, _b;
        };
        // called by children with parameters depending on which lines need to be drawn
        OHLCBaseDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height, openline, crossline) {
            if (openline === void 0) { openline = false; }
            if (crossline === void 0) { crossline = false; }
            ctx.save();
            var pen = this.series.seriesFGPen.with({ style: 0 /* SOLID */, lineCap: 'butt' });
            pen.setOnCanvas(ctx);
            var aliasOffset = pen.getAliasOffset();
            x = ~~x;
            y = ~~y;
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, (~~(height * 0.8)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfminus = ~~(minus / 2);
            var halfplus = ~~(plus / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfminus + aliasOffset, y + minus);
            ctx.lineTo(x - halfminus + aliasOffset, y - plus);
            ctx.moveTo(x - halfminus, y + aliasOffset);
            ctx.lineTo(x + halfplus, y + aliasOffset);
            if (crossline) {
                ctx.moveTo(x - minus, y + aliasOffset);
                ctx.lineTo(x - halfminus, y + aliasOffset);
            }
            // note: openline is ignored since the PC side doesn't draw anything special for OHLC
            ctx.stroke();
            ctx.restore();
        };
        // functions to be overridden by derived classes
        OHLCBaseDrawStyle.prototype.verify = function () {
            return true;
        };
        OHLCBaseDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return OHLCBaseDrawStyle;
    }(BaseDrawStyle));
    
    var HLCDrawStyle = /** @class */ (function (_super) {
        __extends(HLCDrawStyle, _super);
        function HLCDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HLCDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            // Call the actual draw function from the OHLCBase style
            // with both openline and crossline false
            this.actuallyDraw(prm, ctx, false, false);
        };
        HLCDrawStyle.prototype.verify = function () {
            var H = this._yData.getDimensionalDataset(1);
            var L = this._yData.getDimensionalDataset(2);
            var dl = this._yData.data.length;
            return H && L && H.data.length >= dl && L.data.length >= dl;
        };
        HLCDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        HLCDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            _super.prototype.drawLegendPreview.call(this, ctx, x, y, width, height, false, false);
        };
        return HLCDrawStyle;
    }(OHLCBaseDrawStyle));
    
    var HLCrossDrawStyle = /** @class */ (function (_super) {
        __extends(HLCrossDrawStyle, _super);
        function HLCrossDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HLCrossDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            // Call the actual draw function from the OHLCBase style
            // with openline false and crossline true
            this.actuallyDraw(prm, ctx, false, true);
        };
        HLCrossDrawStyle.prototype.verify = function () {
            var H = this._yData.getDimensionalDataset(1);
            var L = this._yData.getDimensionalDataset(2);
            var dl = this._yData.data.length;
            return H && L && H.data.length >= dl && L.data.length >= dl;
        };
        HLCrossDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        HLCrossDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            _super.prototype.drawLegendPreview.call(this, ctx, x, y, width, height, false, true);
        };
        return HLCrossDrawStyle;
    }(OHLCBaseDrawStyle));
    
    var HorizontalDrawStyle = /** @class */ (function (_super) {
        __extends(HorizontalDrawStyle, _super);
        function HorizontalDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HorizontalDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            // Get a drawing context
            ctx.save();
            // select the seriesFGPen to draw with on this canvas
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            // Draw each point in `@yData` as a horizontal line
            // We don't care about factor - span the entire plot
            var plot = prm.plot;
            var x1 = 0;
            var x2 = plot.plotRect.getWidth();
            for (var i = 0; i < this.series.size; i++) {
                var dataItem = this._yData.data[i];
                if (dataItem == null || IsSomeNAN(dataItem)) {
                    continue;
                }
                var yPoint = this._yScale.lookup(dataItem, this._yBin);
                if (this.series.useColor) {
                    this._setColorMapColor(ctx, pen, colorData.getAt(i), i);
                }
                var y = ~~(plot.subPlotFromNDC(yPoint, 2 /* Y */)) + 0.5;
                // save the pixel points, including the space before/above the plot rect
                var pixX = Math.round((x1 + x2) / 2);
                var pixY = Math.round(y);
                var pR = prm.plot.plotRect;
                pixelPoints[i] = { x: pixX + pR.x1, y: pixY + pR.y1 };
                ctx.beginPath();
                pen.drawPolyline(ctx, {
                    x: x1,
                    y: y
                }, {
                    x: x2,
                    y: y
                });
                pen.closePolyline();
                ctx.stroke();
                // create hitshape
                if (this._setHitVector) {
                    var hitLine = new FDSLineHitShape(x1 + prm.plotRect.x1, y + prm.plotRect.y1, x2 + prm.plotRect.x1, y + prm.plotRect.y1);
                    hitLine.index = i;
                    hitLine.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    hitLine.name = 5 /* SERIESHIT */;
                    this.series.hitVector.push(hitLine);
                }
                if (this.seriesSelected) {
                    this.cacheSelectable(prm, 5 /* SERIESHIT */, new Point(x1 + FDSFudge, y));
                    this.cacheSelectable(prm, 5 /* SERIESHIT */, new Point(x2 - FDSFudge, y));
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this._resetColorMapColor(pen);
            ctx.restore();
        };
        HorizontalDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            LineDrawStyle.prototype.drawLegendPreview.call(this, ctx, x, y, width, height);
        };
        HorizontalDrawStyle.prototype.verify = function () {
            return true;
        };
        HorizontalDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return HorizontalDrawStyle;
    }(BaseDrawStyle));
    
    var HorzRectDrawStyle = /** @class */ (function (_super) {
        __extends(HorzRectDrawStyle, _super);
        function HorzRectDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        HorzRectDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            var pen = this._choosePens(ctx, false).pen;
            this.series.seriesBGBrush.setOnCanvas(ctx, prm.plotRect);
            var xAxis = this.series.getAxis(1 /* X */);
            var minX = prm.plot.subPlotFromNDC(xAxis.minPlotFactor, 1 /* X */);
            var maxX = prm.plot.subPlotFromNDC(xAxis.maxPlotFactor, 1 /* X */);
            var y0 = 0;
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            if (this.series.seriesBGBrush.style !== 1 /* NULL */) {
                for (var i = 0; i < this.series.size; i++) {
                    // skip bad points
                    var dataItem = this._yData.data[i];
                    if (dataItem == null || IsSomeNAN(dataItem)) {
                        continue;
                    }
                    // Draw each data point as a point on a line
                    var y = prm.plot.subPlotFromNDC(this._yScale.lookup(dataItem, this._yBin), 2 /* Y */);
                    if (i % 2 === 1) {
                        var y1 = Math.min(y0, y);
                        var y2 = Math.max(y0, y);
                        var h = Math.abs(y0 - y);
                        // every other datapoint defines a rectangle
                        ctx.fillRect(minX, y1, maxX - minX, h);
                        // save the pixel points, including the space before/above the plot rect
                        var pR = prm.plot.plotRect;
                        var pixX = Math.round(((maxX + minX) / 2) + pR.x1);
                        var pixY = Math.round(y1 + (h / 2) + pR.y1);
                        pixelPoints[i] = { x: pixX, y: pixY };
                        // save the even index too, it counts as part of this rect
                        pixelPoints[i - 1] = { x: pixX, y: pixY };
                        // stroke - pen is selected from before
                        ctx.beginPath();
                        pen.drawPolyline(ctx, { x: minX, y: y1 }, { x: minX, y: y2 });
                        pen.drawPolyline(ctx, { x: minX, y: y2 }, { x: maxX, y: y2 });
                        pen.drawPolyline(ctx, { x: maxX, y: y2 }, { x: maxX, y: y1 });
                        pen.drawPolyline(ctx, { x: maxX, y: y1 }, { x: minX, y: y1 });
                        pen.closePolyline();
                        ctx.stroke();
                        // hit shapes
                        var hitRect = new FDSRectangleHitShape(minX + prm.plotRect.x1, y1 + prm.plotRect.y1, maxX - minX, h);
                        // hit rects point to the first of two points (to match PC side)
                        hitRect.index = i - 1;
                        this.series.hitVector.push(hitRect);
                    }
                    else {
                        // save this point for next time
                        y0 = y;
                    }
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        // helper function to select the necessary pens and brushes
        // (since the same logic is in both the main draw fn and the legend fn)
        // return pen for use in drawing polylines
        HorzRectDrawStyle.prototype._choosePens = function (ctx, legend) {
            var newPen;
            if (legend) {
                // use a special thin pen to draw the legend
                newPen = this.series.seriesOutlinePen.with({ width: 1 });
            }
            else {
                // select the seriesOutlinePen for drawing lines
                newPen = this.series.seriesOutlinePen;
            }
            newPen.setOnCanvas(ctx);
            var newBrush;
            // If the brush is hatched, we need to swap the brush color for the
            // foreground pen color.
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                newBrush = this.series.seriesBGBrush.copy();
                newBrush.color = this.series.seriesFGPen.color;
                newBrush.setOnCanvas(ctx);
            }
            else {
                // select the seriesBGBrush for drawing filled areas
                newBrush = this.series.seriesBGBrush;
                newBrush.setOnCanvas(ctx);
            }
            return { brush: newBrush, pen: newPen, penProps: newPen.toPropertyObject() };
        };
        HorzRectDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, true);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            ctx.beginPath();
            ctx.moveTo(x - (width / 2), y + minus);
            ctx.lineTo(x - (width / 2), y - plus);
            ctx.lineTo(x + (width / 2), y - plus);
            ctx.lineTo(x + (width / 2), y + minus);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        HorzRectDrawStyle.prototype.verify = function () {
            return true;
        };
        HorzRectDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return HorzRectDrawStyle;
    }(BaseDrawStyle));
    
    var MarkerDrawStyle = /** @class */ (function (_super) {
        __extends(MarkerDrawStyle, _super);
        function MarkerDrawStyle(series, dim) {
            return _super.call(this, series, dim) || this;
        }
        MarkerDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
        };
        MarkerDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
        };
        MarkerDrawStyle.prototype.drawMarkersToBuffer = function (prm, ctx) {
            _super.prototype.drawMarkersToBuffer.call(this, prm, ctx, true);
        };
        MarkerDrawStyle.prototype.verify = function () {
            return true;
        };
        MarkerDrawStyle.prototype.hint = function () {
            return -1 /* NONE */;
        };
        MarkerDrawStyle.prototype._isMarkerDrawStyle = function () {
            return true;
        };
        return MarkerDrawStyle;
    }(BaseDrawStyle));
    
    var OHLCDrawStyle = /** @class */ (function (_super) {
        __extends(OHLCDrawStyle, _super);
        function OHLCDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        OHLCDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            // Call the actual draw function from the OHLCBase style
            // with openline true and crossline false
            this.actuallyDraw(prm, ctx, true, false);
        };
        OHLCDrawStyle.prototype.verify = function () {
            var H = this._yData.getDimensionalDataset(1);
            var L = this._yData.getDimensionalDataset(2);
            var O = this._yData.getDimensionalDataset(3);
            var dl = this._yData.data.length;
            return H && L && O && H.data.length >= dl && L.data.length >= dl && O.data.length >= dl;
        };
        OHLCDrawStyle.prototype.hint = function () {
            return 2 /* HLC */;
        };
        OHLCDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            _super.prototype.drawLegendPreview.call(this, ctx, x, y, width, height, true, false);
        };
        return OHLCDrawStyle;
    }(OHLCBaseDrawStyle));
    
    var PieExplosionAnimator = /** @class */ (function () {
        function PieExplosionAnimator(animationManager, series) {
            this._series = series;
            this._pieDesc = series.pieDesc;
            this.animationManager = animationManager;
        }
        PieExplosionAnimator.prototype.onTick = function (time) {
            if (this._pieDesc.explodingData.length === 0) {
                return 0 /* NoDrawNeeded */;
            }
            for (var i = this._pieDesc.explodingData.length - 1; i >= 0; i--) {
                var data = this._pieDesc.explodingData[i];
                var pct = smoothstep(clamp((time - data.startTime) / this._pieDesc.animationTime, 0, 1));
                if (data.direction > 0) {
                    data.amount = pct;
                    if (data.amount >= 1) {
                        this._pieDesc.explodedIndices.push(data.index);
                        this._pieDesc.explodingData.splice(i, 1);
                    }
                }
                else {
                    data.amount = 1 - pct;
                    if (data.amount <= 0) {
                        this._pieDesc.explodingData.splice(i, 1);
                    }
                }
            }
            return 10 /* SeriesRedraw */;
        };
        PieExplosionAnimator.prototype.isActive = function () {
            return this._pieDesc.explodingData.length > 0;
        };
        PieExplosionAnimator.prototype.forceCompletion = function () {
            for (var i = this._pieDesc.explodingData.length - 1; i >= 0; i--) {
                var data = this._pieDesc.explodingData[i];
                if (data.direction > 0) {
                    this._pieDesc.explodedIndices.push(data.index);
                }
                this._pieDesc.explodingData.splice(i, 1);
            }
        };
        PieExplosionAnimator.prototype.explodePiePiece = function (index) {
            if (index < 0) {
                return;
            }
            var DS = this._series.getEffectiveDrawStyle();
            if (DS !== 19 /* PIE */ && DS !== 36 /* PIE3D */) {
                return;
            }
            var shouldAnimate = this._pieDesc.explodeAnimation && this.animationManager.canAnimate();
            if (this._pieDesc.explodeMode === 2 /* MULTIPLE */) {
                this._toggleSinglePiePiece(index, shouldAnimate);
            }
            else if (this._pieDesc.explodeMode === 1 /* ONE */) {
                var indicesToToggle = _$1.uniq([index].concat(this._pieDesc.explodedIndices, _$1.filter(this._pieDesc.explodingData, function (data) { return data.direction > 0; }).map(function (data) { return data.index; })));
                for (var _i = 0, indicesToToggle_1 = indicesToToggle; _i < indicesToToggle_1.length; _i++) {
                    var indexToToggle = indicesToToggle_1[_i];
                    this._toggleSinglePiePiece(indexToToggle, shouldAnimate);
                }
            }
            this._updateSeriesAttributes();
        };
        PieExplosionAnimator.prototype._updateSeriesAttributes = function () {
            var explodedIndices = this._getExplodedOrExplodingIndicies();
            explodedIndices.sort();
            this._series.attributeSet.preserveCurrentDirtyState(function (attributeSet) {
                attributeSet.setAt('PieExplodedSliceIndices', 'user', explodedIndices);
            });
        };
        PieExplosionAnimator.prototype._getExplodedOrExplodingIndicies = function () {
            var indices = this._pieDesc.explodedIndices.slice();
            for (var _i = 0, _a = this._pieDesc.explodingData; _i < _a.length; _i++) {
                var animatingData = _a[_i];
                if (animatingData.direction > 0) {
                    indices.push(animatingData.index);
                }
            }
            return indices;
        };
        PieExplosionAnimator.prototype._toggleSinglePiePiece = function (index, animate) {
            if (animate) {
                var existingEntry = this._getOrGenerateExplodingDataEntry(index);
                var amtRemaining = (existingEntry.direction > 0) ? 1 - existingEntry.amount : existingEntry.amount;
                var timeRemaining = this._pieDesc.animationTime * amtRemaining;
                existingEntry.startTime = timerFunc() - timeRemaining;
                existingEntry.direction *= -1;
                this.animationManager.update();
            }
            else {
                var indexExploded = _$1.indexOf(this._pieDesc.explodedIndices, index);
                if (indexExploded > -1) {
                    this._pieDesc.explodedIndices.splice(indexExploded, 1);
                }
                else {
                    this._pieDesc.explodedIndices.push(index);
                }
            }
        };
        PieExplosionAnimator.prototype._getOrGenerateExplodingDataEntry = function (index) {
            var existingEntry = _$1.find(this._pieDesc.explodingData, { index: index });
            if (existingEntry) {
                return existingEntry;
            }
            var explodedIndex = _$1.indexOf(this._pieDesc.explodedIndices, index);
            var newEntry;
            if (explodedIndex > -1) {
                this._pieDesc.explodedIndices.splice(explodedIndex, 1);
                newEntry = { index: index, direction: 1, amount: 1, startTime: timerFunc() };
            }
            else {
                newEntry = { index: index, direction: -1, amount: 0, startTime: timerFunc() };
            }
            this._pieDesc.explodingData.push(newEntry);
            return newEntry;
        };
        PieExplosionAnimator.animator_id = 'PieExplosion';
        return PieExplosionAnimator;
    }());
    
    var PieUnwindAnimator = /** @class */ (function (_super) {
        __extends(PieUnwindAnimator, _super);
        function PieUnwindAnimator(animationManager, startAngle, totalAngle) {
            var _this = _super.call(this, animationManager, 0) || this;
            _this._currentAngle = 0;
            _this._isOpening = true;
            _this._startAngle = startAngle;
            _this._targetAngle = totalAngle;
            _this._currentAngle = startAngle;
            _this._updateAngle();
            return _this;
        }
        PieUnwindAnimator.prototype.getCurrentAngle = function () {
            return this._currentAngle;
        };
        PieUnwindAnimator.prototype.getTargetAngle = function () {
            return this._targetAngle;
        };
        PieUnwindAnimator.prototype.onTick = function (time) {
            _super.prototype._updateTime.call(this, time);
            this._updateAngle();
            return 10 /* SeriesRedraw */;
        };
        PieUnwindAnimator.prototype._updateAngle = function () {
            this._currentAngle = this.percentComplete * (this._targetAngle - this._startAngle) + this._startAngle;
        };
        PieUnwindAnimator.prototype.forceCompletion = function () {
            _super.prototype.forceCompletion.call(this);
            this._currentAngle = this._targetAngle;
        };
        PieUnwindAnimator.animator_id = 'PieUnwind';
        return PieUnwindAnimator;
    }(TimedAnimator));
    
    var PieLabelPositioner = /** @class */ (function () {
        function PieLabelPositioner(pieDrawStyle, plotRenderManager, ctx) {
            this._plotRenderManager = plotRenderManager;
            this._pieDrawStyle = pieDrawStyle;
            this._ctx = ctx;
            this._quadrantsMapKeys = [1 /* UPPER_RIGHT */,
                2 /* UPPER_LEFT */,
                3 /* LOWER_LEFT */,
                4 /* LOWER_RIGHT */];
        }
        /**
         * This function auto-positions labels using the follows steps:
         * 1. Groups the labels based on which quadrant of the pie chart that its slice falls in.
         * 2. Checks whether each group of labels can fit vertically in each quadrants area without overlap
         *    and otherwise adjusts which labels are associated with each quadrant to see if labels can be made to fit.
         * 3. If step 2 fails, decrements the font size and goes back to step 1.
         * 4. Pushes the labels vertically against the border of the quadrant that is towards the pie midpoint.
         * 5. Spaces out the labels vertically and proportionally based on their slice heights.
         * 6. Adjusts each label's vertical position to be as close to its slice's midpoint as possible.
         * 7. Determines the label's horizontal position based on its vertical position and the label factor.
         * @param {FDSInfoBox[]} labels - A list of labels that need to be auto-positioned.
         * @returns {AutoPositionerOffset[]} - A list of x and y offsets for each of the input labels.
         */
        PieLabelPositioner.prototype.calcAutoPositionOffsets = function (labels) {
            // We expect a label for each pie slice.
            if (labels.length === 0 || labels.length !== this._pieDrawStyle.slices.length) {
                return [];
            }
            // We consider labels being over the pie to be a collision, so we won't autoposition if the labelFactor is below 1.
            if (this._pieDrawStyle.series.pieDesc.labelFactor < 1) {
                return [];
            }
            var labelInfos = this._initializeLabelInfos(labels);
            this._initializeQuadrantsMap();
            this._createQuadrantsFromLabelInfos(labelInfos);
            if (!this._adjustQuadrantsToFitLabels()) {
                var originalFontHeight = this._pieDrawStyle.series.seriesLabelFont.height;
                var fontDecrementedTooManyTimes = originalFontHeight - 5 > labels[0].font.height;
                if (fontDecrementedTooManyTimes) {
                    this._setLabelsFontSize(labels, originalFontHeight, this._ctx);
                    return [];
                }
                this._setLabelsFontSize(labels, labels[0].font.height - 1, this._ctx);
                return this.calcAutoPositionOffsets(labels);
            }
            this._markQuadrantsNeedingAutoPositioning();
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var key = _a[_i];
                var quadrant = this._quadrantsMap[key];
                if (quadrant.needsAutoPositioning) {
                    this._pushLabelsVerticallyTowardsPieCenter(quadrant);
                    this._spaceOutLabelsVerticallyInQuadrant(quadrant);
                    this._shiftLabelsVerticallyTowardsSliceMidpoint(quadrant);
                    this._pushLabelsHorizontallyTowardsPie(quadrant);
                }
            }
            return _$1.map(labelInfos, function (labelInfo) { return labelInfo.offset; });
        };
        PieLabelPositioner.prototype._initializeQuadrantsMap = function () {
            this._quadrantsMap = { 1: null, 2: null, 3: null, 4: null };
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var key = _a[_i];
                this._quadrantsMap[key] = { labelInfos: [],
                    y1: 0,
                    y2: 0,
                    quadrantPosition: key,
                    totalLabelsHeight: 0,
                    needsAutoPositioning: true };
            }
        };
        PieLabelPositioner.prototype._initializeLabelInfos = function (labels) {
            var labelInfos = [];
            var pieIsReversed = this._pieDrawStyle.isReversed();
            for (var i = 0; i < labels.length; i++) {
                labelInfos.push({ labelRect: new Rectangle(labels[i].x, labels[i].y, labels[i].x + labels[i].width, labels[i].y + labels[i].height),
                    slice: pieIsReversed ? this._pieDrawStyle.slices[labels.length - (i + 1)]
                        : this._pieDrawStyle.slices[i],
                    offset: { x: 0, y: 0 },
                    sliceEndPoint: { x: 0, y: 0 },
                    sliceMidPoint: { x: 0, y: 0 },
                    sliceStartPoint: { x: 0, y: 0 },
                    originalQuadrantPosition: 1 /* UPPER_RIGHT */ });
            }
            return labelInfos;
        };
        PieLabelPositioner.prototype._createQuadrantsFromLabelInfos = function (labelInfos) {
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var key = _a[_i];
                this._quadrantsMap[key].labelInfos = [];
            }
            // We assume that the labels are in the same order as the pie slices.
            for (var _b = 0, labelInfos_1 = labelInfos; _b < labelInfos_1.length; _b++) {
                var labelInfo = labelInfos_1[_b];
                labelInfo.sliceStartPoint = this._pieDrawStyle.calcSliceStartPoint(labelInfo.slice, this._plotRenderManager);
                labelInfo.sliceMidPoint = this._pieDrawStyle.calcSliceMidPoint(labelInfo.slice, this._plotRenderManager);
                labelInfo.sliceEndPoint = this._pieDrawStyle.calcSliceEndPoint(labelInfo.slice, this._plotRenderManager);
                var sliceMidPointAngle = this._getSliceMidpointAngle(labelInfo.slice);
                var quadrantPosition = this._calcQuadrantFromAngle(this._getSliceMidpointAngle(labelInfo.slice));
                labelInfo.originalQuadrantPosition = quadrantPosition;
                this._quadrantsMap[quadrantPosition].labelInfos.push(labelInfo);
                this._quadrantsMap[quadrantPosition].quadrantPosition = quadrantPosition;
            }
            this._sortQuadrantsByDecreasingYDistanceFromPieCenter();
            this._calcQuadrantsBounds();
        };
        PieLabelPositioner.prototype._getSliceMidpointAngle = function (slice) {
            var midpointAngle = slice.angOffset + slice.angSlice / 2;
            return (this._pieDrawStyle.normalizeAngle(midpointAngle));
        };
        PieLabelPositioner.prototype._calcQuadrantFromAngle = function (angle) {
            var normalizedAngle = this._pieDrawStyle.normalizeAngle(angle);
            if (normalizedAngle <= 90) {
                return 1 /* UPPER_RIGHT */;
            }
            else if (normalizedAngle <= 180) {
                return 2 /* UPPER_LEFT */;
            }
            else if (normalizedAngle <= 270) {
                return 3 /* LOWER_LEFT */;
            }
            else {
                return 4 /* LOWER_RIGHT */;
            }
        };
        PieLabelPositioner.prototype._sortQuadrantsByDecreasingYDistanceFromPieCenter = function () {
            var _this = this;
            var _loop_1 = function (quadrantPosition) {
                var labelInfos = this_1._quadrantsMap[quadrantPosition].labelInfos;
                var sortedLabelInfos = [];
                var multiple = 1;
                if (quadrantPosition === 1 /* UPPER_RIGHT */ || quadrantPosition === 3 /* LOWER_LEFT */) {
                    multiple = -1;
                }
                sortedLabelInfos = _$1.sortBy(labelInfos, function (labelInfo) { return multiple * _this._getSliceMidpointAngle(labelInfo.slice); });
                this_1._quadrantsMap[quadrantPosition].labelInfos = sortedLabelInfos;
            };
            var this_1 = this;
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var quadrantPosition = _a[_i];
                _loop_1(quadrantPosition);
            }
        };
        PieLabelPositioner.prototype._calcQuadrantsBounds = function () {
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var quadrantPosition = _a[_i];
                var quadrant = this._quadrantsMap[quadrantPosition];
                quadrant.totalLabelsHeight = this._calcTotalLabelsHeight(quadrant.labelInfos);
                var firstQuadrant = quadrant.labelInfos[0];
                var lastQuadrant = quadrant.labelInfos[quadrant.labelInfos.length - 1];
                if (firstQuadrant !== undefined && lastQuadrant !== undefined) {
                    switch (quadrantPosition) {
                        case 1 /* UPPER_RIGHT */:
                            quadrant.y1 = this._plotRenderManager.plotRect.y1;
                            quadrant.y2 = lastQuadrant.sliceStartPoint.y;
                            break;
                        case 2 /* UPPER_LEFT */:
                            quadrant.y1 = this._plotRenderManager.plotRect.y1;
                            quadrant.y2 = lastQuadrant.sliceEndPoint.y;
                            break;
                        case 3 /* LOWER_LEFT */:
                            quadrant.y1 = lastQuadrant.sliceStartPoint.y;
                            quadrant.y2 = this._plotRenderManager.plotRect.y2;
                            break;
                        case 4 /* LOWER_RIGHT */:
                            quadrant.y1 = lastQuadrant.sliceEndPoint.y;
                            quadrant.y2 = this._plotRenderManager.plotRect.y2;
                            break;
                    }
                }
            }
        };
        PieLabelPositioner.prototype._calcTotalLabelsHeight = function (labelInfos) {
            return _$1.reduce(labelInfos, function (memo, labelInfo) { return memo + labelInfo.labelRect.height; }, 0);
        };
        PieLabelPositioner.prototype._isQuadrantInUpperHalf = function (quadrant) {
            return quadrant === 1 /* UPPER_RIGHT */ || quadrant === 2 /* UPPER_LEFT */;
        };
        PieLabelPositioner.prototype._isQuadrantInRightHalf = function (quadrant) {
            return quadrant === 1 /* UPPER_RIGHT */ || quadrant === 4 /* LOWER_RIGHT */;
        };
        PieLabelPositioner.prototype._adjustQuadrantsToFitLabels = function () {
            var totalPlotHeight = this._plotRenderManager.plotRect.y2 - this._plotRenderManager.plotRect.y1;
            var upperRightLabelsHeight = this._quadrantsMap[1 /* UPPER_RIGHT */].totalLabelsHeight;
            var upperLeftLabelsHeight = this._quadrantsMap[2 /* UPPER_LEFT */].totalLabelsHeight;
            var lowerLeftLabelsHeight = this._quadrantsMap[3 /* LOWER_LEFT */].totalLabelsHeight;
            var lowerRightLabelsHeight = this._quadrantsMap[4 /* LOWER_RIGHT */].totalLabelsHeight;
            this._balanceHorizontallyAdjacentQuadrants(this._quadrantsMap[1 /* UPPER_RIGHT */], this._quadrantsMap[2 /* UPPER_LEFT */]);
            this._balanceHorizontallyAdjacentQuadrants(this._quadrantsMap[3 /* LOWER_LEFT */], this._quadrantsMap[4 /* LOWER_RIGHT */]);
            var rightLabelsAreTallerThanPlot = upperRightLabelsHeight + lowerRightLabelsHeight > totalPlotHeight;
            var leftLabelsAreTallerThanPlot = upperLeftLabelsHeight + lowerLeftLabelsHeight > totalPlotHeight;
            if (rightLabelsAreTallerThanPlot || leftLabelsAreTallerThanPlot) {
                return false;
            }
            return this._tryToFitLabelsInQuadrants();
        };
        PieLabelPositioner.prototype._balanceHorizontallyAdjacentQuadrants = function (quadrant1, quadrant2) {
            // If there are only a few labels on both quadrants, we'll just ignore this.
            if (quadrant1.labelInfos.length <= 3 && quadrant2.labelInfos.length <= 3) {
                return;
            }
            while (quadrant1.labelInfos.length >= quadrant2.labelInfos.length * 3) {
                this._shiftOutermostLabelToHorizontallyAdjacentQuadrant(quadrant1, quadrant2);
            }
            while (quadrant2.labelInfos.length >= quadrant1.labelInfos.length * 3) {
                this._shiftOutermostLabelToHorizontallyAdjacentQuadrant(quadrant2, quadrant1);
            }
        };
        PieLabelPositioner.prototype._shiftOutermostLabelToHorizontallyAdjacentQuadrant = function (sourceQuadrant, targetQuadrant) {
            var sourceQuadrantPosition = sourceQuadrant.quadrantPosition;
            var targetQuadrantPosition = targetQuadrant.quadrantPosition;
            if (sourceQuadrantPosition === targetQuadrantPosition) {
                return;
            }
            var quadrantsAreInDifferentVerticalHalves = this._isQuadrantInUpperHalf(sourceQuadrantPosition) !== this._isQuadrantInUpperHalf(targetQuadrantPosition);
            if (quadrantsAreInDifferentVerticalHalves) {
                return;
            }
            if (sourceQuadrant.labelInfos.length === 0) {
                return;
            }
            // Because of the way we sort the labels, the first label should be the closest to the
            // horizontally adjacent quadrant.
            var firstLabel = sourceQuadrant.labelInfos[0];
            targetQuadrant.labelInfos.splice(0, 0, firstLabel);
            sourceQuadrant.labelInfos.splice(0, 1);
            targetQuadrant.totalLabelsHeight += firstLabel.labelRect.height;
            sourceQuadrant.totalLabelsHeight -= firstLabel.labelRect.height;
        };
        PieLabelPositioner.prototype._tryToFitLabelsInQuadrants = function () {
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var quadrantPosition = _a[_i];
                var quadrant = this._quadrantsMap[quadrantPosition];
                var labelInfos = quadrant.labelInfos;
                if (labelInfos.length === 0) {
                    continue;
                }
                var quadrantIsInUpperHalf = this._isQuadrantInUpperHalf(quadrantPosition);
                var totalQuadrantHeight = (quadrantIsInUpperHalf) ? quadrant.y2 - this._plotRenderManager.plotRect.y1
                    : this._plotRenderManager.plotRect.y2 - quadrant.y1;
                // If a particular upper quadrant is not large enough to fit its labels, try adding the label and space
                // of closest lower label quadrant.
                if (this._quadrantsMap[quadrantPosition].totalLabelsHeight > totalQuadrantHeight) {
                    if (quadrantPosition === 1 /* UPPER_RIGHT */ || quadrantPosition === 4 /* LOWER_RIGHT */) {
                        if (this._quadrantsMap[4 /* LOWER_RIGHT */].labelInfos.length === 0) {
                            return false;
                        }
                        this._moveUpperMostLabelFromBelowToAboveQuadrant(this._quadrantsMap[4 /* LOWER_RIGHT */], this._quadrantsMap[1 /* UPPER_RIGHT */]);
                        return this._tryToFitLabelsInQuadrants();
                    }
                    else if (quadrantPosition === 2 /* UPPER_LEFT */ || quadrantPosition === 3 /* LOWER_LEFT */) {
                        if (this._quadrantsMap[3 /* LOWER_LEFT */].labelInfos.length === 0) {
                            return false;
                        }
                        this._moveUpperMostLabelFromBelowToAboveQuadrant(this._quadrantsMap[3 /* LOWER_LEFT */], this._quadrantsMap[2 /* UPPER_LEFT */]);
                        return this._tryToFitLabelsInQuadrants();
                    }
                }
            }
            return true;
        };
        PieLabelPositioner.prototype._moveUpperMostLabelFromBelowToAboveQuadrant = function (belowQuadrant, aboveQuadrant) {
            if (!this._isQuadrantInUpperHalf(aboveQuadrant.quadrantPosition) || this._isQuadrantInUpperHalf(belowQuadrant.quadrantPosition)) {
                return;
            }
            if (belowQuadrant.labelInfos.length === 0) {
                return;
            }
            // We assume that the quadrants are all ordered from outermost label to innermost.
            // Thus, the uppermost label in the below quadrant should be the last label.
            var lastLabel = belowQuadrant.labelInfos[belowQuadrant.labelInfos.length - 1];
            belowQuadrant.labelInfos.pop();
            belowQuadrant.totalLabelsHeight -= lastLabel.labelRect.height;
            aboveQuadrant.labelInfos.push(lastLabel);
            aboveQuadrant.totalLabelsHeight += lastLabel.labelRect.height;
            var newBorder = Math.max(lastLabel.sliceStartPoint.y, lastLabel.sliceEndPoint.y);
            aboveQuadrant.y2 = newBorder;
            belowQuadrant.y1 = newBorder;
        };
        PieLabelPositioner.prototype._setLabelsFontSize = function (labels, height, ctx) {
            if (labels.length === 0) {
                return;
            }
            var fontOptions = { height: height };
            var newFont = labels[0].font.with(fontOptions);
            for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                var label = labels_1[_i];
                label.update({ font: newFont }, ctx);
            }
        };
        PieLabelPositioner.prototype._markQuadrantsNeedingAutoPositioning = function () {
            var _loop_2 = function (quadrantPosition) {
                var quadrant = this_2._quadrantsMap[quadrantPosition];
                // If there are no collisions and no label has been put into our current quadrant from another quadrant,
                // we can say that the quadrant's labels do not need to be autopositioned.
                if (!this_2._doQuadrantLabelsHaveCollisions(quadrant) &&
                    !_$1.some(quadrant.labelInfos, function (labelInfo) { return labelInfo.originalQuadrantPosition !== quadrant.quadrantPosition; })) {
                    quadrant.needsAutoPositioning = false;
                }
            };
            var this_2 = this;
            for (var _i = 0, _a = this._quadrantsMapKeys; _i < _a.length; _i++) {
                var quadrantPosition = _a[_i];
                _loop_2(quadrantPosition);
            }
        };
        PieLabelPositioner.prototype._doQuadrantLabelsHaveCollisions = function (quadrant) {
            var labelInfos = quadrant.labelInfos;
            for (var _i = 0, labelInfos_2 = labelInfos; _i < labelInfos_2.length; _i++) {
                var labelInfo = labelInfos_2[_i];
                var labelRect = labelInfo.labelRect;
                // Check if any of the labels are out of the quadrant's borders;
                if (labelRect.y1 < quadrant.y1 || labelRect.y2 > quadrant.y2) {
                    return true;
                }
                // Check if any of the labels have a collision with another label in the quadrant.
                for (var _a = 0, labelInfos_3 = labelInfos; _a < labelInfos_3.length; _a++) {
                    var compareLabelInfo = labelInfos_3[_a];
                    if (labelInfo === compareLabelInfo) {
                        continue;
                    }
                    if (Rectangle.doRectanglesIntersect(labelRect, compareLabelInfo.labelRect)) {
                        return true;
                    }
                }
                // Check if any of the labels are over the pie.
                if (this._pieDrawStyle.series.hitTest(labelRect.x1, labelRect.y1)) {
                    return true;
                }
                if (this._pieDrawStyle.series.hitTest(labelRect.x1, labelRect.y2)) {
                    return true;
                }
                if (this._pieDrawStyle.series.hitTest(labelRect.x2, labelRect.y1)) {
                    return true;
                }
                if (this._pieDrawStyle.series.hitTest(labelRect.x2, labelRect.y2)) {
                    return true;
                }
            }
            return false;
        };
        PieLabelPositioner.prototype._updateLabelRectAndOffsetX = function (labelRect, offset, newX) {
            var oldLabelRectX = labelRect.x;
            labelRect.x = newX;
            offset.x += labelRect.x - oldLabelRectX;
        };
        PieLabelPositioner.prototype._updateLabelRectAndOffsetY = function (labelRect, offset, newY) {
            var oldLabelRectY = labelRect.y;
            labelRect.y = newY;
            offset.y += labelRect.y - oldLabelRectY;
        };
        PieLabelPositioner.prototype._pushLabelsVerticallyTowardsPieCenter = function (quadrant) {
            var labelInfos = quadrant.labelInfos;
            if (labelInfos.length === 0) {
                return;
            }
            var shouldMoveLabelsDown = this._isQuadrantInUpperHalf(quadrant.quadrantPosition);
            var prevLabelInfo = labelInfos[labelInfos.length - 1];
            // We move the last label at the end of the quadrant space closest towards the center of the pie.
            if (shouldMoveLabelsDown) {
                this._updateLabelRectAndOffsetY(prevLabelInfo.labelRect, prevLabelInfo.offset, quadrant.y2 - prevLabelInfo.labelRect.height);
            }
            else {
                this._updateLabelRectAndOffsetY(prevLabelInfo.labelRect, prevLabelInfo.offset, quadrant.y1);
            }
            // Move the other labels so that they are all vertically adjacent.
            for (var i = labelInfos.length - 2; i >= 0; i--) {
                var currLabelInfo = labelInfos[i];
                var currLabelRect = currLabelInfo.labelRect;
                if (shouldMoveLabelsDown) {
                    this._updateLabelRectAndOffsetY(currLabelRect, currLabelInfo.offset, prevLabelInfo.labelRect.y1 - currLabelRect.height);
                }
                else {
                    this._updateLabelRectAndOffsetY(currLabelRect, currLabelInfo.offset, prevLabelInfo.labelRect.y2);
                }
                prevLabelInfo = currLabelInfo;
            }
        };
        PieLabelPositioner.prototype._spaceOutLabelsVerticallyInQuadrant = function (quadrant) {
            var labelInfos = quadrant.labelInfos;
            if (labelInfos.length === 0) {
                return;
            }
            var quadrantIsInUpperHalf = this._isQuadrantInUpperHalf(quadrant.quadrantPosition);
            var totalQuadrantHeight;
            totalQuadrantHeight = (quadrantIsInUpperHalf) ? quadrant.y2 - this._plotRenderManager.plotRect.y1 :
                this._plotRenderManager.plotRect.y2 - quadrant.y1;
            var sliceHeights = [];
            var totalSlicesHeight = 0;
            for (var _i = 0, labelInfos_4 = labelInfos; _i < labelInfos_4.length; _i++) {
                var label = labelInfos_4[_i];
                var sliceHeight = Math.abs(label.sliceEndPoint.y - label.sliceStartPoint.y);
                sliceHeights.push(sliceHeight);
                totalSlicesHeight += sliceHeight;
            }
            // We will space out the labels proportionally based on their pie heights, i.e., the y distance between thier start and end points.
            var currOffset = 0;
            var extraSpace = (quadrantIsInUpperHalf) ? -1 * (totalQuadrantHeight - quadrant.totalLabelsHeight) : (totalQuadrantHeight - quadrant.totalLabelsHeight);
            for (var i = labelInfos.length - 2; i > -1; i--) {
                var currLabelInfo = labelInfos[i];
                var checkLabel = labelInfos[i + 1];
                currOffset += sliceHeights[i + 1] / (totalSlicesHeight - sliceHeights[0]) * extraSpace;
                this._updateLabelRectAndOffsetY(currLabelInfo.labelRect, currLabelInfo.offset, currLabelInfo.labelRect.y1 + currOffset);
            }
        };
        PieLabelPositioner.prototype._shiftLabelsVerticallyTowardsSliceMidpoint = function (quadrant) {
            var labelInfos = quadrant.labelInfos;
            if (labelInfos.length === 0) {
                return;
            }
            var quadrantIsInUpperHalf = this._isQuadrantInUpperHalf(quadrant.quadrantPosition);
            // If there is only one label in this quadrant just drop it as close to its slice midpoint as possible.
            if (labelInfos.length === 1) {
                var currLabel = labelInfos[0];
                var currRect = currLabel.labelRect;
                var idealY = (quadrantIsInUpperHalf) ? currLabel.sliceMidPoint.y - currRect.height : currLabel.sliceMidPoint.y;
                if (idealY < currRect.y) {
                    if (idealY >= quadrant.y1) {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, idealY);
                    }
                    else {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, quadrant.y1);
                    }
                }
                else if (idealY > currRect.y) {
                    if (idealY + currRect.height <= quadrant.y2) {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, idealY);
                    }
                    else {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, quadrant.y2 - currRect.height);
                    }
                }
                return;
            }
            // Starting from the innermost label of the quadrant, we shift each label as close
            // to its slice midpoint as possible but only if the slice midpoint is closer towards the pie center.
            for (var i = labelInfos.length - 2; i > -1; i--) {
                var currLabel = labelInfos[i];
                var currRect = currLabel.labelRect;
                var idealY = (quadrantIsInUpperHalf) ? currLabel.sliceMidPoint.y - currRect.height : currLabel.sliceMidPoint.y;
                var idealYIsTowardsPieEdge = (quadrantIsInUpperHalf) ? idealY <= currRect.y : idealY >= currRect.y;
                if (idealYIsTowardsPieEdge) {
                    continue;
                }
                var nextLabel = labelInfos[i + 1];
                var nextLabelBorder = (quadrantIsInUpperHalf) ? nextLabel.labelRect.y1 : nextLabel.labelRect.y2;
                if (quadrantIsInUpperHalf) {
                    if (nextLabelBorder >= idealY + currRect.height) {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, idealY);
                    }
                    else {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, nextLabelBorder - currRect.height);
                    }
                }
                else {
                    if (nextLabelBorder <= idealY) {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, idealY);
                    }
                    else {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, nextLabelBorder);
                    }
                }
            }
            // Now we do the opposite.
            // Starting from the outermost label of the quadrant, we shift each label as close
            // to its slice midpoint as possible but only if the slice midpoint is farther away from the plot.
            for (var i = 1; i < labelInfos.length; i++) {
                var currLabel = labelInfos[i];
                var currRect = currLabel.labelRect;
                var idealY = (quadrantIsInUpperHalf) ? currLabel.sliceMidPoint.y - currRect.height : currLabel.sliceMidPoint.y;
                var idealYIsTowardsPieEdge = (quadrantIsInUpperHalf) ? idealY <= currRect.y : idealY >= currRect.y;
                if (!idealYIsTowardsPieEdge) {
                    continue;
                }
                var prevLabel = labelInfos[i - 1];
                var prevLabelBorder = (quadrantIsInUpperHalf) ? prevLabel.labelRect.y2 : prevLabel.labelRect.y1;
                if (quadrantIsInUpperHalf) {
                    if (prevLabelBorder <= idealY) {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, idealY);
                    }
                    else {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, prevLabelBorder);
                    }
                }
                else {
                    if (prevLabelBorder >= idealY + currRect.height) {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, idealY);
                    }
                    else {
                        this._updateLabelRectAndOffsetY(currLabel.labelRect, currLabel.offset, prevLabelBorder - currRect.height);
                    }
                }
            }
        };
        PieLabelPositioner.prototype._pushLabelsHorizontallyTowardsPie = function (quadrant) {
            var labelInfos = quadrant.labelInfos;
            if (labelInfos.length === 0) {
                return;
            }
            for (var _i = 0, labelInfos_5 = labelInfos; _i < labelInfos_5.length; _i++) {
                var labelInfo = labelInfos_5[_i];
                var labelRect = labelInfo.labelRect;
                var labelCheckY = void 0;
                // If the label is in the top half of the pie, we will need to check one of the
                // bottom corners. Otherwise, we will need to check one of the top corners.
                if (labelRect.centerPoint().y > this._pieDrawStyle.getMidPoint(this._plotRenderManager).y) {
                    labelCheckY = labelRect.y1;
                }
                else {
                    labelCheckY = labelRect.y2;
                }
                var newX = void 0;
                var quadrantIsInRightHalf = this._isQuadrantInRightHalf(quadrant.quadrantPosition);
                var labelIsAbovePie = labelCheckY <= this._pieDrawStyle.getTopLeftPoint(this._plotRenderManager).y;
                var labelIsBelowPie = labelCheckY >= this._pieDrawStyle.getBottomRightPoint(this._plotRenderManager).y;
                if (labelIsAbovePie || labelIsBelowPie) {
                    newX = (quadrantIsInRightHalf) ? labelInfo.sliceMidPoint.x : labelInfo.sliceMidPoint.x - labelRect.width;
                }
                else {
                    var pieLabelXOffset = this._calcLabelXOffsetFromPieMidpointX(labelCheckY, quadrantIsInRightHalf);
                    var pieMidPoint = this._pieDrawStyle.getMidPoint(this._plotRenderManager);
                    newX = (quadrantIsInRightHalf) ? pieMidPoint.x + pieLabelXOffset : pieMidPoint.x - pieLabelXOffset - labelRect.width;
                }
                if (quadrantIsInRightHalf) {
                    // We need to make sure that the new value for x does not violate our plot boundaries.
                    newX = Math.min(this._plotRenderManager.plotRect.x2 - labelRect.width, newX);
                }
                else {
                    newX = Math.max(this._plotRenderManager.plotRect.x1, newX);
                }
                this._updateLabelRectAndOffsetX(labelInfo.labelRect, labelInfo.offset, newX);
            }
        };
        PieLabelPositioner.prototype._calcLabelXOffsetFromPieMidpointX = function (y, quadrantIsInRightHalf) {
            // Given a specific distance from the midpoint and our desired point's y-value, we can
            // obtain the offset from the pie midpoint that our desired point will have.
            var angleInRadians = this._pieDrawStyle.getAngleFromY(y, quadrantIsInRightHalf, this._plotRenderManager);
            var radius = this._pieDrawStyle.getRadiusFromAngleInRadians(angleInRadians);
            var distance = radius * this._pieDrawStyle.series.pieDesc.labelFactor;
            var yOffset = y - this._pieDrawStyle.getMidPoint(this._plotRenderManager).y;
            return Math.sqrt(distance * distance - yOffset * yOffset);
        };
        return PieLabelPositioner;
    }());
    
    var PieDrawStyle = /** @class */ (function (_super) {
        __extends(PieDrawStyle, _super);
        function PieDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._reverse = false;
            _this._percentages = [];
            _this.slices = [];
            _this._labelPositions = [];
            _this._markerPositions = [];
            _this._pieUnwinder = undefined;
            return _this;
        }
        PieDrawStyle.prototype.isReversed = function () { return this._reverse; };
        PieDrawStyle.prototype._canDrawLabels = function () {
            if (this._pieUnwinder && this._pieUnwinder.isActive()) {
                return false;
            }
            return true;
        };
        // this wrapper fn is overridden by inheriting classes
        PieDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this._labelPositions.length = 0;
            this._markerPositions.length = 0;
            ctx.save();
            var _a = this._setupPie(prm, ctx), brush = _a.brush, pen = _a.pen;
            this._dealWithExplosion();
            for (var _i = 0, _b = this.slices; _i < _b.length; _i++) {
                var slice = _b[_i];
                this.drawPieSlice(prm, ctx, slice, brush, pen);
            }
            // Cache the selection marker positions. Check out the 3d pie DrawStyle.ile for an explanation of what's
            // happening here.
            if (this.seriesSelected) {
                this._selectablePointCache = [];
                this.cacheSelectable(prm, 0 /* NONE */, this._midX - this._radius, this._midY - this._radius);
                this.cacheSelectable(prm, 0 /* NONE */, this._midX - this._radius, this._midY + this._radius);
                this.cacheSelectable(prm, 0 /* NONE */, this._midX + this._radius, this._midY - this._radius);
                this.cacheSelectable(prm, 0 /* NONE */, this._midX + this._radius, this._midY + this._radius);
            }
            this._drawCenterLabel(ctx);
            ctx.restore();
        };
        PieDrawStyle.prototype.getTopLeftPoint = function (prm) {
            return { x: this._xTopLeft + prm.plotRect.x1, y: this._yTopLeft + prm.plotRect.y1 };
        };
        PieDrawStyle.prototype.getBottomRightPoint = function (prm) {
            return { x: this._xBottomRight + prm.plotRect.x1, y: this._yBottomRight + prm.plotRect.y1 };
        };
        PieDrawStyle.prototype.getMidPoint = function (prm) {
            return { x: this._midX + prm.plotRect.x1, y: this._midY + prm.plotRect.y1 };
        };
        PieDrawStyle.prototype.getRadiusFromAngleInRadians = function (angle) {
            if (angle === void 0) { angle = 0; }
            return this._radius;
        };
        PieDrawStyle.prototype.calcSliceStartPoint = function (slice, prm) {
            return this.getCartesianPointFromAngleOffset(slice.angOffset, prm);
        };
        PieDrawStyle.prototype.calcSliceEndPoint = function (slice, prm) {
            return this.getCartesianPointFromAngleOffset(slice.angOffset + slice.angSlice, prm);
        };
        PieDrawStyle.prototype.calcSliceMidPoint = function (slice, prm) {
            return this.getCartesianPointFromAngleOffset(slice.angOffset + slice.angSlice / 2, prm);
        };
        PieDrawStyle.prototype.getCartesianPointFromAngleOffset = function (angleInDegrees, prm) {
            var pt = this.getPointOnArc(angleInDegrees, this._radius, 0, 0, true);
            return { x: pt.x + prm.plotRect.x1, y: pt.y + prm.plotRect.y1 };
        };
        PieDrawStyle.prototype.getAngleFromY = function (y, isOnRightSide, prm) {
            // We need to remap the y to the range [-radius, radius] so that y/radius is between
            // -1 and 1 since arcsin is only defined for [-1, 1].
            var pieY = y - prm.plotRect.y1;
            var remappedY = (pieY - this._yTopLeft - this._radius) * -1;
            var angle = Math.asin(remappedY / this._radius);
            var remappedX = this._radius * Math.cos(angle);
            if (!isOnRightSide) {
                remappedX *= -1;
            }
            return Math.atan2(remappedY, remappedX);
        };
        PieDrawStyle.prototype._dealWithExplosion = function () {
            if (this.series.pieDesc.explodeRadius) {
                this._adjustRadiiForExplosion();
            }
            else {
                this._adjustSlicesForExplosion();
                this._explodeSlices();
            }
        };
        PieDrawStyle.prototype._adjustRadiiForExplosion = function () {
            var explosionAmt = this.series.pieDesc.explosionAmt;
            for (var _i = 0, _a = this.slices; _i < _a.length; _i++) {
                var slice = _a[_i];
                slice.radius += slice.explosionAmt * explosionAmt;
            }
        };
        // function to explode every piece of a pie
        // does so by setting the start and end points of every piece to the same exploded point
        // written separately here so it can be called in multiple places
        PieDrawStyle.prototype._explodeWholePie = function () {
            for (var _i = 0, _a = this.slices; _i < _a.length; _i++) {
                var slice = _a[_i];
                var _b = this._getSliceCenterXY(slice), x = _b[0], y = _b[1];
                slice.start = new Point(x, y);
                slice.end = new Point(x, y);
            }
        };
        // function that takes in a slice and returns the x and y based on its center angle
        // and the explosion amount
        // @return [Array<Number>] [x,y] the x and y coordinates of the point along the center
        // angle that is explosion amount away from 0,0
        PieDrawStyle.prototype._getSliceCenterXY = function (slice) {
            var _a = this._getAngles(slice), smallerAngle = _a[0], largerAngle = _a[1];
            return this._getCenterXY(smallerAngle, largerAngle);
        };
        // function that takes two angles and returns the x and y based on their center angle
        // and the explosion amount
        // @return [Array<Number>] [x,y] the x and y coordinates of the point along the center
        // angle that is explosion amount away from 0,0
        PieDrawStyle.prototype._getCenterXY = function (smallerAngle, largerAngle) {
            // error checking
            while (smallerAngle > largerAngle) {
                largerAngle = largerAngle + (Math.PI * 2);
            }
            var expAngle = (smallerAngle + largerAngle) / 2;
            var x = Math.cos(expAngle) * this.series.pieDesc.explosionAmt;
            var y = Math.sin(expAngle) * this.series.pieDesc.explosionAmt;
            return [x, y];
        };
        // function that goes through slices and sets their start and end points
        PieDrawStyle.prototype._adjustSlicesForExplosion = function () {
            if (this.series.pieDesc.exploded) {
                this._explodeWholePie();
            }
            else if (this.series.pieDesc.grouped) {
                // it doesn't mean anything to group slices when the radii are exploding
                this._findAndAdjustGroups(this.series.pieDesc.explodedIndices.concat(this.series.pieDesc.explodingData.map(function (data) { return data.index; })));
            }
            else {
                // we need to deal with slices on an individual basis
                for (var _i = 0, _a = this.slices; _i < _a.length; _i++) {
                    var slice = _a[_i];
                    var trueIndex = slice.trueIndex;
                    if (this.series.pieDesc.explodedIndices.indexOf(trueIndex) > -1) {
                        var _b = this._getSliceCenterXY(slice), x = _b[0], y = _b[1];
                        slice.start = new Point(x, y);
                        slice.end = new Point(x, y);
                    }
                    else if (_$1.find(this.series.pieDesc.explodingData, { index: trueIndex })) {
                        var _c = this._getSliceCenterXY(slice), x = _c[0], y = _c[1];
                        slice.start = new Point(0, 0);
                        slice.end = new Point(x, y);
                    }
                }
            }
        };
        // function to move the slices along their paths based on the amounts of explosion
        PieDrawStyle.prototype._explodeSlices = function () {
            for (var _i = 0, _a = this.slices; _i < _a.length; _i++) {
                var slice = _a[_i];
                if (this.series.pieDesc.explodeRadius) {
                    slice.radius += slice.explosionAmt;
                }
                else {
                    if (slice.start === slice.end) {
                        // just for simplicity
                        slice.offsetX = slice.start.x;
                        slice.offsetY = slice.start.y;
                    }
                    else {
                        slice.offsetX = slice.start.x + ((slice.end.x - slice.start.x) * slice.explosionAmt);
                        slice.offsetY = slice.start.y + ((slice.end.y - slice.start.y) * slice.explosionAmt);
                    }
                }
            }
        };
        // function to find groups in the slices and adjust their coordinates respectively.
        // @param arr [Array<number>] the slice array to look for groups within
        // @param start [Boolean] when true, set the start coordinate of slices found. when false, set the end coordinate.
        PieDrawStyle.prototype._findAndAdjustGroups = function (arr) {
            var i = 0;
            var totalSlices = this.slices.length;
            // find the first non-selected piece
            while (arr.indexOf(i) > -1) {
                i++;
                if (i >= totalSlices) {
                    // do not group a pie where every slice is exploded. just explode every piece separately
                    for (var _i = 0, _a = this.slices; _i < _a.length; _i++) {
                        var slice = _a[_i];
                        var _b = this._getSliceCenterXY(slice), x = _b[0], y = _b[1];
                        slice.end = new Point(x, y);
                    }
                    return;
                }
            }
            // now i points to the first non-exploded piece >= 0
            // this is our starting point. we can go around the circle and find all contiguous groups from here
            var startPoint = i;
            i = (i + 1) % totalSlices;
            while (i !== startPoint) {
                var j = (i + 1) % totalSlices; // in case we skip this whole next bit
                if (arr.indexOf(i) > -1) {
                    var _c = this._getAngles(this.slices[i]), largerAngle = _c[1];
                    // save the pieces we are supposed to explode
                    var expSlices = [i];
                    while (arr.indexOf(j) > -1) {
                        // we know from above there is at least one non-selected piece (start) if not more
                        // so this loop will eventually terminate
                        expSlices.push(j);
                        j = (j + 1) % totalSlices;
                    }
                    // now j points to the first non-selected slice after the group
                    var ind = j - 1;
                    if (ind < 0) {
                        ind = ind + totalSlices;
                    }
                    var smallerAngle = this._getAngles(this.slices[ind])[0];
                    var _d = this._getCenterXY(smallerAngle, largerAngle), x = _d[0], y = _d[1];
                    // adjust every slice in the found group to have the center point as its start or end point
                    for (var _e = 0, expSlices_1 = expSlices; _e < expSlices_1.length; _e++) {
                        var k = expSlices_1[_e];
                        this.slices[k].end = new Point(x, y);
                    }
                }
                i = j % totalSlices;
            }
        };
        // function to set up stuff for drawing the pie, including the slices array
        // @return [Brush] the brush used for drawing
        PieDrawStyle.prototype._setupPie = function (prm, ctx) {
            var _this = this;
            var width, height, centerX, centerY;
            _a = prm.plot.computeEffectiveCenter(), width = _a[0], height = _a[1], centerX = _a[2], centerY = _a[3];
            var radius = (Math.min(width, height)) / 2;
            this._radius = this._getScaledRadius(this.series.pieDesc, radius);
            this.series.cachedPieRadius = this._radius;
            _b = this._applyCenterOffset(this.series.pieDesc, this._radius, centerX, centerY), centerX = _b[0], centerY = _b[1];
            this.setCenterPoint(centerX, centerY, this._radius);
            this._reverse = this._yScale.reverse;
            var pieDesc = this.series.pieDesc;
            prm.chart.animationManager.tryGetAnimator(this.series.id, PieExplosionAnimator.animator_id, function (animationManager) { return new PieExplosionAnimator(animationManager, _this.series); });
            this._setupUnwindAnimator(prm.chart.animationManager, pieDesc.totalAngle);
            this._createPercentages(this.series);
            this._setMinSliceAngle(pieDesc.minSlice);
            this._setOffset(pieDesc.startAngle);
            this._fixChartValues(this._pieUnwinder.getCurrentAngle() / 3.6);
            var angle = 0;
            var offset = this.normalizeAngle(this._offset);
            // set up the pixel point array (and replace it if it existed already)
            this.root.pixelPoints[this.series.id] = {};
            this.root.infoboxPixelPoints[this.series.id] = {};
            var _c = this._choosePens(ctx, false), pen = _c.pen, brush = _c.brush, penProps = _c.penProps;
            var i = 0;
            this.slices = [];
            for (i = 0; i < this._percentages.length; i++) {
                var currData = this._percentages[i];
                var colors = setPieColorMapColors(this.series, brush.color, this._colorData.getAt(i), currData.colorIndex);
                var currSlice = new PieSlice();
                angle = (360 / 100) * currData.percentage;
                currSlice.angSlice = angle;
                currSlice.angOffset = offset;
                currSlice.trueIndex = currData.trueIndex;
                currSlice.bgColor = colors.bgColor;
                currSlice.outlineColor = colors.outlineColor;
                offset += angle;
                if (offset > 360) {
                    offset -= 360;
                }
                var explodingData = _$1.find(pieDesc.explodingData, { index: currData.trueIndex });
                if (explodingData) {
                    currSlice.explosionAmt = explodingData.amount;
                }
                else if (_$1.indexOf(pieDesc.explodedIndices, currData.trueIndex) > -1) {
                    currSlice.explosionAmt = 1;
                }
                this.slices.push(currSlice);
            }
            if ((this.series.pieDesc.explodeMode !== 0 /* NONE */) && this.series.pieDesc.exploded) {
                // for animated pies we convert "exploded" into every piece being on the exploded list,
                // and turn off the exploded attribute, for convenience.
                // all pie slices should be exploded
                this.series.pieDesc.explodedIndices = _$1.times(i);
                var explodedList_1 = this.series.pieDesc.explodedIndices.slice();
                this.series.attributeSet.preserveCurrentDirtyState(function (attributeSet) {
                    attributeSet.setAt('PieExplodedSliceIndices', 'user', explodedList_1);
                    attributeSet.setAt('PieExploded', 'user', false);
                });
                // it's not exploded anymore
                this.series.pieDesc.exploded = false;
            }
            for (var _i = 0, _d = this.slices; _i < _d.length; _i++) {
                var slice = _d[_i];
                slice.radius = this._radius;
            }
            return { brush: brush, pen: pen };
            var _a, _b;
        };
        PieDrawStyle.prototype._setupUnwindAnimator = function (animationManager, totalAngle) {
            var existingUnwinder = animationManager.tryGetAnimator(this.series.id, PieUnwindAnimator.animator_id, function (manager) { return new PieUnwindAnimator(manager, 0, totalAngle); });
            if (existingUnwinder.getTargetAngle() !== totalAngle) {
                this._pieUnwinder = new PieUnwindAnimator(animationManager, existingUnwinder.getCurrentAngle(), totalAngle);
                animationManager.registerAndBeginAnimation(this.series.id, PieUnwindAnimator.animator_id, this._pieUnwinder);
            }
            else {
                this._pieUnwinder = existingUnwinder;
            }
        };
        PieDrawStyle.prototype._drawCenterLabel = function (ctx) {
            // short circuit boring case
            if (this.series.seriesLabel1Text === '') {
                return;
            }
            var labelFont = this.series.seriesLabel1Font;
            if (this.series.seriesLabel1ColorFollowsSeriesColor && this.series.calculatedSeriesColor != null) {
                labelFont = labelFont.with({ color: this.series.calculatedSeriesColor });
            }
            labelFont.setOnCanvas(ctx);
            var _a = RichTextRenderer.measureRichText(ctx, this.series.seriesLabel1Text, labelFont), dims = _a[0], richtext = _a[1];
            var x = (this._midX - (dims.width / 2)) + this.series.seriesLabel1XOffset;
            var y = (this._midY - (dims.height / 2)) + this.series.seriesLabel1YOffset;
            RichTextRenderer.writeRichText(ctx, this.series.seriesLabel1Text, x, y, labelFont, null, richtext);
        };
        PieDrawStyle.prototype._getScaledRadius = function (pieDesc, radius) {
            if (pieDesc.radiusIsFactor && pieDesc.radius > 0) {
                radius *= pieDesc.radius;
            }
            else if (pieDesc.radius > 1) {
                radius = pieDesc.radius;
            }
            return radius;
        };
        PieDrawStyle.prototype._applyCenterOffset = function (pieDesc, radius, centerX, centerY) {
            if (pieDesc.centerIsFactor) {
                centerX += pieDesc.centerOffsetX * radius;
                centerY += pieDesc.centerOffsetY * radius;
            }
            else {
                centerX += pieDesc.centerOffsetX;
                centerY += pieDesc.centerOffsetY;
            }
            return [centerX, centerY];
        };
        // @param angle [Number] the angle to normalize
        // @param total [Number] optional total to normalize to (default is 360 - degrees)
        // @return [Number] an angle between 0 and total
        PieDrawStyle.prototype.normalizeAngle = function (angle, total) {
            if (total === void 0) { total = 360; }
            var modAngle = angle % total;
            if (modAngle < 0) {
                modAngle += total;
            }
            return modAngle;
        };
        PieDrawStyle.prototype._setMinSliceAngle = function (angle) {
            this.minSliceAngle = this.normalizeAngle(angle);
        };
        PieDrawStyle.prototype._setOffset = function (offset) {
            this._offset = this.normalizeAngle(offset);
        };
        // helper fn cause this is done multiple places
        // @return [Array<Float>] angles in radians [smallerAngle,largerAngle]
        PieDrawStyle.prototype._getAngles = function (slice) {
            var angOffset = DegToRad(slice.angOffset);
            var angSlice = DegToRad(slice.angSlice);
            var smallerAngle = -1 * (angOffset + angSlice);
            var largerAngle = -1 * angOffset;
            return [smallerAngle, largerAngle];
        };
        // helper function to get the rectangle to be used for a given slice's gradient
        // @param slice [PieSlice] the slice whose gradient is being drawn currently
        // @return [Rectangle] a rectangle with the position for the slice's gradient
        PieDrawStyle.prototype._getGradientRect = function (slice) {
            // short circuit if we don't need the calculations to be done
            if (this.series.seriesBGBrush.gradientStyle === 0 /* NONE */) {
                return null;
            }
            var x1 = (this._midX + slice.offsetX) - slice.radius;
            var x2 = this._midX + slice.offsetX + slice.radius;
            var y1 = (this._midY + slice.offsetY) - slice.radius;
            var y2 = this._midY + slice.offsetY + slice.radius;
            return new Rectangle(x1, y1, x2, y2);
        };
        PieDrawStyle.prototype.drawPieSlice = function (prm, ctx, slice, brush, pen) {
            if (slice.angSlice < this.minSliceAngle) {
                // still save a point to the position array if necessary
                var p = new Point(0, 0);
                if (this.series.seriesValue) {
                    this._addToPositionArray(this._labelPositions, p);
                    this._addToPositionArray(this._markerPositions, p);
                }
                else if (this.series.seriesMarker) {
                    this._addToPositionArray(this._markerPositions, p);
                }
                return;
            }
            var _a = this._getAngles(slice), smallerAngle = _a[0], largerAngle = _a[1];
            var centerX = this._midX + slice.offsetX;
            var centerY = this._midY + slice.offsetY;
            brush.color = slice.bgColor;
            brush.setOnCanvas(ctx, this._getGradientRect(slice));
            ctx.setPen(pen.with({ color: slice.outlineColor }));
            ctx.beginPath();
            if (!(this._donutRadius > 0) && slice.angSlice !== 360) {
                ctx.moveTo(centerX, centerY);
            }
            ctx.arc(centerX, centerY, slice.radius, smallerAngle, largerAngle, false);
            if (this._donutRadius > 0) {
                ctx.arc(centerX, centerY, this._donutRadius, largerAngle, smallerAngle, true);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // save the pixel points, including the space before/above the plot rect
            // don't do it for 3d pies though, they'll fill theirs in later
            if (!this._is3D) {
                var pixRad = (this._donutRadius + slice.radius) / 2;
                var pixAng1 = this.normalizeAngle(slice.angOffset);
                var pixAng2 = slice.angOffset + slice.angSlice;
                var pixAng = (pixAng1 + pixAng2) / 2;
                var pixPt = this.getPointOnArc(pixAng, pixRad, 0, 0, true);
                var pR = prm.plot.plotRect;
                var pixX = Math.round(pixPt.x + pR.x1);
                var pixY = Math.round(pixPt.y + pR.y1);
                this.root.pixelPoints[this.series.id][slice.trueIndex] = { x: pixX, y: pixY };
                this.root.infoboxPixelPoints[this.series.id][slice.trueIndex] = {
                    point: { x: pixX, y: pixY },
                    position: "above" /* above */
                };
            }
            // create and save hitshapes
            var hitPie = new FDSPieHitShape();
            hitPie.setCenter(centerX + prm.plotRect.x1, centerY + prm.plotRect.y1);
            hitPie.setRadius(slice.radius);
            hitPie.setAngles(smallerAngle, largerAngle);
            hitPie.index = slice.trueIndex;
            if (this._donutRadius > 0) {
                hitPie.setInnerRadius(this._donutRadius);
            }
            this.series.hitVector.push(hitPie);
            // set up the series values and markers arrays
            if (this.series.seriesValue) {
                var midAngle = (smallerAngle + largerAngle) / 2;
                var point = this.getPointOnArc(Math.abs(midAngle), slice.radius * this.series.pieDesc.labelFactor, slice.offsetX, slice.offsetY);
                point.x = point.x + prm.plotRect.x1;
                point.y = point.y + prm.plotRect.y1;
                this._addToPositionArray(this._labelPositions, point);
            }
            if (this.series.seriesMarker || this.series.seriesValue) {
                // series labels with arrows need to know the marker positions too
                var midAngle = (smallerAngle + largerAngle) / 2;
                this._addToPositionArray(this._markerPositions, this.getPointOnArc(Math.abs(midAngle), slice.radius, slice.offsetX, slice.offsetY));
            }
        };
        // helper function for saving points to an array and dealing with reverse
        PieDrawStyle.prototype._addToPositionArray = function (array, point) {
            if (this._reverse) {
                return array.unshift(point);
            }
            else {
                return array.push(point);
            }
        };
        // Computes an (x,y) point on an arc about @midX, @midY
        //
        // @param angle [Float] angle in degrees or radians (as specified by the third argument)
        // @param radius [Float] radius
        // @param degrees [Boolean] when true, angle is in degrees; when false, angle is in radians. Defaults to false
        // @return [Point] the point on the arc
        PieDrawStyle.prototype.getPointOnArc = function (angle, radius, offsetX, offsetY, degrees) {
            if (offsetX === void 0) { offsetX = 0; }
            if (offsetY === void 0) { offsetY = 0; }
            if (degrees === void 0) { degrees = false; }
            if (degrees) {
                angle = DegToRad(angle);
            }
            return new Point(this._midX + offsetX + (radius * Math.cos(angle)), (this._midY + offsetY) - (radius * Math.sin(angle)));
        };
        PieDrawStyle.prototype._createPercentages = function (series) {
            var sliceCount = this._yData.data.length;
            var totalOfAbsVals = this._yData.dataSetSumOfAbsoluteVals(0);
            var offset = this._reverse ? sliceCount - 1 : 0;
            var multiply = this._reverse ? -1 : 1;
            this._percentages = [];
            var piecount = 0;
            for (var i = 0; i < this.series.size; i++) {
                var dum = this._xData.data[i];
                var yValue = this._yData.getAt(offset + (multiply * i));
                var cValue = this._colorData.getAt(offset + (multiply * i));
                var info = new PieSliceInfo();
                if (!IsSomeNAN(yValue)) {
                    info.percentage = (Math.abs(yValue) / totalOfAbsVals) * 100;
                    info.trueIndex = offset + (multiply * i);
                    if (NOTNAN(cValue)) {
                        info.cValue = cValue;
                    }
                    info.colorIndex = piecount;
                    piecount++;
                }
                else {
                    info.percentage = 0;
                    info.colorIndex = 0;
                    info.trueIndex = offset + (multiply * i);
                }
                this._percentages.push(info);
            }
            offset = this._reverse ? piecount - 1 : 0;
            if (this._reverse) {
                for (var _i = 0, _a = this._percentages; _i < _a.length; _i++) {
                    var info = _a[_i];
                    info.colorIndex = (piecount - 1) - info.colorIndex;
                }
            }
        };
        PieDrawStyle.prototype._fixChartValues = function (totalPercentage) {
            if (totalPercentage > 100) {
                totalPercentage = 100;
            }
            var totalAngleSoFar = 0;
            for (var i = 0; i < this._percentages.length; i++) {
                var percent = this._percentages[i];
                if (i + 1 === this._percentages.length) {
                    this._percentages[i].percentage = totalPercentage - totalAngleSoFar;
                    continue;
                }
                percent.percentage = (totalPercentage / 100) * percent.percentage;
                totalAngleSoFar += percent.percentage;
            }
        };
        PieDrawStyle.prototype._getDonutRadius = function () {
            if (this.series == null) {
                return 0;
            }
            var temp = this.series.pieDesc.donutRadius;
            if (temp <= 0) {
                return 0;
            }
            if (temp <= 1) {
                return temp * this._radius;
            }
            return Math.min(this._radius, temp);
        };
        PieDrawStyle.prototype._setRadii = function (pieRadius) {
            // this 2 is here, because without it, the pie is drawn right under the edge of the
            // top of the plotRect, which gets clipped and looks weird
            this._radius = Math.max(pieRadius - 2, 0);
            this._donutRadius = this._getDonutRadius();
        };
        PieDrawStyle.prototype.setCenterPoint = function (x, y, radius) {
            this._setRadii(radius);
            this._midX = x;
            this._midY = y;
            this._xTopLeft = this._midX - this._radius;
            this._yTopLeft = this._midY - this._radius;
            this._xBottomRight = this._midX + this._radius;
            this._yBottomRight = this._midY + this._radius;
            this._xDonutTopLeft = this._midX - this._donutRadius;
            this._yDonutTopLeft = this._midY - this._donutRadius;
            this._xDonutBottomRight = this._midX + this._donutRadius;
            this._yDonutBottomRight = this._midY + this._donutRadius;
        };
        PieDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        PieDrawStyle.prototype.verify = function () {
            return true;
        };
        PieDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            width = ~~(width * 0.8);
            var size = Math.min(width, (~~(height * 0.8)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var xOrigin = x - plus;
            var yOrigin = y + plus;
            ctx.beginPath();
            ctx.moveTo(xOrigin, yOrigin);
            ctx.lineTo(x - plus, y - plus);
            ctx.arc(xOrigin, yOrigin, size, -0.5 * Math.PI, 0, false);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        PieDrawStyle.prototype._choosePens = function (ctx, legend) {
            var penProps = null;
            var pen = this.series.seriesOutlinePen;
            // set up fg color
            if (legend) {
                // use a special thin pen to draw the legend
                pen = pen.with({ width: 1 });
            }
            pen.setOnCanvas(ctx);
            penProps = pen.toPropertyObject();
            // set up bg color
            var brush = this.series.seriesBGBrush;
            brush.setOnCanvas(ctx);
            return { brush: brush, pen: pen, penProps: penProps };
        };
        PieDrawStyle.prototype._getLabelTextColorFromSeriesColor = function (index, defaultColor) {
            var labelFontColor = defaultColor;
            if (this._colorData) {
                var proposedColor = this._colorData.getAt(index);
                labelFontColor = setPieColorMapColors(this.series, labelFontColor, proposedColor, index).bgColor;
            }
            return labelFontColor;
        };
        PieDrawStyle.prototype._shouldSkipSeriesDataItemIndex = function (i) {
            return this.slices[i].angSlice < this.minSliceAngle;
        };
        PieDrawStyle.prototype.autoPositionLabels = function (labels, prm, ctx) {
            if (!this.series.seriesValueAutoPosition) {
                return false;
            }
            var autoPositioner = new PieLabelPositioner(this, prm, ctx);
            var offsets = autoPositioner.calcAutoPositionOffsets(labels);
            if (labels.length !== offsets.length) {
                return false;
            }
            for (var i = 0; i < labels.length; i++) {
                var label = labels[i];
                var offset = offsets[i];
                label.updateX(label.x + offset.x, ctx);
                label.updateY(label.y + offset.y, ctx);
            }
            return true;
        };
        return PieDrawStyle;
    }(BaseDrawStyle));
    var PieSliceInfo = /** @class */ (function () {
        function PieSliceInfo() {
            this.percentage = NaN;
        }
        return PieSliceInfo;
    }());
    var PieSlice = /** @class */ (function () {
        function PieSlice() {
            this.angOffset = 0;
            this.angSlice = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.explosion = 0;
            this.trueIndex = 0;
            this.bgColor = 0;
            this.outlineColor = 0;
            this.radius = 0;
            // stuff for 3D pie slices
            this.frontDropdown = true;
            this.backDropdown = true;
            // stuff for pie animations
            this.start = new Point(0, 0);
            this.end = new Point(0, 0);
            this.explosionAmt = 0;
        }
        PieSlice.prototype.copy = function () {
            var ps = new PieSlice();
            ps.angOffset = this.angOffset;
            ps.angSlice = this.angSlice;
            ps.offsetX = this.offsetX;
            ps.offsetY = this.offsetY;
            ps.explosion = this.explosion;
            ps.trueIndex = this.trueIndex;
            ps.bgColor = this.bgColor;
            ps.outlineColor = this.outlineColor;
            ps.radius = this.radius;
            ps.frontDropdown = this.frontDropdown;
            ps.backDropdown = this.backDropdown;
            ps.start = new Point(this.start.x, this.start.y);
            ps.end = new Point(this.end.x, this.end.y);
            return ps;
        };
        return PieSlice;
    }());
    
    var Pie3dDrawStyle = /** @class */ (function (_super) {
        __extends(Pie3dDrawStyle, _super);
        function Pie3dDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._compareSlices = _this._compareSlices.bind(_this);
            _this._is3D = true;
            return _this;
        }
        Pie3dDrawStyle.prototype.getTopLeftPoint = function (prm) {
            return { x: this._midX - this._getHorizontalRadius() + prm.plotRect.x1,
                y: this._midY - this._getVerticalRadius() + prm.plotRect.y1 };
        };
        Pie3dDrawStyle.prototype.getBottomRightPoint = function (prm) {
            return { x: this._midX + this._getHorizontalRadius() + prm.plotRect.x1,
                y: this._midY + this._getVerticalRadius() + prm.plotRect.y1 };
        };
        Pie3dDrawStyle.prototype.getRadiusFromAngleInRadians = function (angle) {
            if (angle === void 0) { angle = 0; }
            var verticalRadius = this._getVerticalRadius();
            var horizontalRadius = this._getHorizontalRadius();
            var dividend = verticalRadius * horizontalRadius;
            var divisor = Math.sqrt(Math.pow(horizontalRadius * Math.sin(angle), 2) +
                Math.pow(verticalRadius * Math.cos(angle), 2));
            return dividend / divisor;
        };
        Pie3dDrawStyle.prototype.getCartesianPointFromAngleOffset = function (angleInDegrees, prm) {
            var normalizedAngle = this.normalizeAngle(angleInDegrees);
            var angleInRadians = DegToRad(normalizedAngle);
            var x = this._midX + this._getHorizontalRadius() * Math.cos(angleInRadians) + prm.plotRect.x1;
            var y = this._midY - this._getVerticalRadius() * Math.sin(angleInRadians) + prm.plotRect.y1;
            return { x: x, y: y };
        };
        Pie3dDrawStyle.prototype._getVerticalRadius = function () {
            return this._radius * Math.sin(this._tiltAngle);
        };
        Pie3dDrawStyle.prototype._getHorizontalRadius = function () {
            return this._radius;
        };
        Pie3dDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this._labelPositions.length = 0;
            this._markerPositions.length = 0;
            ctx.save();
            var _a = this._setupPie(prm, ctx), brush = _a.brush, pen = _a.pen;
            // depth defaults to 30
            if (this.series.pieDesc.depth <= 0) {
                this.series.pieDesc.depth = 30;
            }
            else if (this.series.pieDesc.depth < 1) {
                this.series.pieDesc.depth = this.series.pieDesc.depth * this._radius;
            }
            this._tiltAngle = DegToRad(this.normalizeAngle(this.series.pieDesc.tiltAngle, 90));
            // adjust center to accomodate depth
            var tiltedDepth = 0;
            if (this._tiltAngle !== 0) {
                tiltedDepth = this.series.pieDesc.depth * Math.cos(this._tiltAngle);
                this.setCenterPoint(this._midX, this._midY - (tiltedDepth / 2), this._radius);
            }
            this._dealWithExplosion();
            var _b = this._splitPieSlices(), backHalfSlices = _b[0], frontHalfSlices = _b[1];
            if (this._tiltAngle === 0) {
                // just draw as if it was 2D, we're looking head on
                for (var _i = 0, _c = this.slices; _i < _c.length; _i++) {
                    var slice = _c[_i];
                    this.drawPieSlice(prm, ctx, slice, brush, pen);
                }
                this._drawCenterLabel;
                return;
            }
            // scale it so the circles we draw will look like ovals when we unscale
            ctx.save();
            // move the canvas x axis to midY and stretch it
            var oldMidY = this._midY;
            ctx.translate(0, this._midY);
            ctx.scale(1, Math.sin(this._tiltAngle));
            // set midY to 0 so it draws in the right place
            this.setCenterPoint(this._midX, 0, this._radius);
            // draw everything!
            this._drawBackSlices(backHalfSlices, ctx, brush, pen);
            this._drawFrontSlices(frontHalfSlices, ctx, brush, pen);
            for (var _d = 0, _e = this.slices; _d < _e.length; _d++) {
                var slice = _e[_d];
                this.drawPieSlice(prm, ctx, slice, brush, pen);
            }
            // restore it so our circle becomes an oval
            ctx.restore();
            this._midY = oldMidY;
            this.setCenterPoint(this._midX, this._midY, this._radius);
            if (this.seriesSelected) {
                this._selectablePointCache = [];
                var tiltedRadius = this._radius * Math.sin(this._tiltAngle);
                this.cacheSelectable(prm, 0 /* NONE */, this._midX - this._radius, this._midY - tiltedRadius);
                this.cacheSelectable(prm, 0 /* NONE */, this._midX - this._radius, this._midY + tiltedRadius + (tiltedDepth));
                this.cacheSelectable(prm, 0 /* NONE */, this._midX + this._radius, this._midY - tiltedRadius);
                this.cacheSelectable(prm, 0 /* NONE */, this._midX + this._radius, this._midY + tiltedRadius + (tiltedDepth));
            }
            this._drawCenterLabel(ctx);
            // adjust the label, marker, and pixel point positions
            var tiltSin = Math.sin(this._tiltAngle);
            var p;
            for (var i1 = 0; i1 < this._labelPositions.length; i1++) {
                p = this._labelPositions[i1];
                p.y = this._adjustYCoordToTilt(p.y, prm);
            }
            for (var j1 = 0; j1 < this._markerPositions.length; j1++) {
                // markers are drawn relative to plot, so we don't need to worry about plot padding
                p = this._markerPositions[j1];
                p.y = (p.y * tiltSin) + this._midY;
            }
            // replace hitpies with hitovals
            for (var i = 0; i < this.series.hitVector.length; i++) {
                var pieShape = this.series.hitVector[i];
                if (!(pieShape instanceof FDSPieHitShape)) {
                    continue;
                }
                var oval = this._makeOvalFromPie(pieShape, prm);
                // replace the old hitshape
                this.series.hitVector[i] = oval;
                // while here, save a pixelPoint
                // get "central" point of the oval sector
                var xRad = oval.innerRadiusX * 0.25 + oval.radiusX * 0.75;
                var yRad = oval.innerRadiusY * 0.25 + oval.radiusY * 0.75;
                // We need to use the angles from before they're modified by the _makeOvalFromPie function
                var angle = (pieShape.smallerAngle + pieShape.largerAngle) / 2;
                var pixX = Math.round(oval.centerX + (Math.cos(angle) * xRad));
                var pixY = Math.round(oval.centerY + (Math.sin(angle) * yRad));
                this.root.pixelPoints[this.series.id][oval.index] = { x: pixX, y: pixY };
                this.root.infoboxPixelPoints[this.series.id][oval.index] = {
                    point: { x: pixX, y: pixY },
                    position: "above" /* above */
                };
            }
            ctx.restore();
        };
        // helper function to create an oval hitshape based on a pie hitshape and the current tilt
        Pie3dDrawStyle.prototype._makeOvalFromPie = function (p, prm) {
            // adjust the hitshape center the same way we adjusted the label positions
            p.centerY = this._adjustYCoordToTilt(p.centerY, prm);
            var smallerAngle, largerAngle;
            if (fuzzyEQ(p.largerAngle - p.smallerAngle, 2 * Math.PI)) {
                // we just have one slice. just make one big hitoval and be done
                smallerAngle = 0;
                largerAngle = 2 * Math.PI;
            }
            else {
                smallerAngle = this._adjustAngle(p.smallerAngle);
                largerAngle = this._adjustAngle(p.largerAngle);
                // make sure the angles are in the right order
                if (smallerAngle > largerAngle) {
                    smallerAngle = smallerAngle - (2 * Math.PI);
                }
            }
            // create a new oval shape with new angles
            var o = new FDSOvalHitShape();
            o.setCenter(p.centerX, p.centerY);
            // don't use the setAngles function because it does its own normalizing that we want to avoid
            o.smallerAngle = smallerAngle;
            o.largerAngle = largerAngle;
            var yRadius = p.radius * Math.sin(this._tiltAngle);
            o.setRadii(p.radius, yRadius);
            var yInnerRadius = p.innerRadius * Math.sin(this._tiltAngle);
            o.setInnerRadii(p.innerRadius, yInnerRadius);
            o.index = p.index;
            return o;
        };
        // helper function to adjust an angle based on the current tilt
        // @param a [Number] the angle to adjust - assumed to be in radians
        // @return [Number] an angle between 0 and 2*PI
        Pie3dDrawStyle.prototype._adjustAngle = function (a) {
            a = this.normalizeAngle(a, Math.PI * 2);
            if (a === Math.PI / 2 || a === (Math.PI * 3) / 2) {
                // these angles stay the same, and the math would break trying to tan them, so...
                return a;
            }
            var adjust = Math.sin(this._tiltAngle);
            // set x to + or -1 based on quadrant
            var x = (a < (Math.PI * 3) / 2) && (a > Math.PI / 2) ? -1 : 1;
            var y = Math.tan(a / x) * adjust;
            var result = Math.atan2(y, x);
            // get rid of things like -5e-16
            if (Math.abs(result) < Math.pow(10, -MAX_PRECISION)) {
                result = 0;
            }
            result = this.normalizeAngle(result, Math.PI * 2);
            return result;
        };
        // helper function to adjust a yposition to match the tilted pie
        // Note: takes into account plot padding, so assumed you're drawing relative to chart
        // @param y [Number] the y-coordinate to be adjusted
        // @param prm [PlotRenderManager] used to find the plot rect y-coord for adjusting
        // @return [Number] the resulting adjusted coordinate
        Pie3dDrawStyle.prototype._adjustYCoordToTilt = function (y, prm) {
            y = y - prm.plotRect.y1; // temporarily remove the plotrect padding
            y = y * Math.sin(this._tiltAngle); // undo the scaling
            y = y + this._midY + prm.plotRect.y1; // undo the translation
            return y;
        };
        // function to sort the slices by whether they're front or back
        // if a slice crosses the x axis, two (or three) slices are created for its front and back sections
        // @return [Array<Array<PieSlice>>] the two resulting arrays of slices: [backHalf, frontHalf]
        Pie3dDrawStyle.prototype._splitPieSlices = function () {
            var backHalf = [];
            var frontHalf = [];
            for (var _i = 0, _a = this.slices; _i < _a.length; _i++) {
                var slice = _a[_i];
                var up = -1 * slice.angOffset;
                var low = -1 * (slice.angOffset + slice.angSlice);
                // get angles to correct amounts: 0 >= U >= -360, U >= L >= -720
                up = up % 360;
                if (up > 0) {
                    up = up - 360;
                }
                low = low % 360;
                while (low > up) {
                    low = low - 360;
                }
                if (low === up && slice.angSlice === 360) {
                    low -= 360;
                }
                // here we go through six cases of where the slice could be positioned
                // in many of them we have to create 2 or 3 new slices for the front and
                // back parts of the slice
                // in those cases we also have to mark some dropdowns as false so they don't
                // get drawn
                // Note: here "up" and "low" represent the lower and upper angles - as you're
                // sweeping out the pie piece, first you would hit "low" and then you would
                // hit "up"
                // for the dropdowns, "front" and "back" actually refer to y-positions, since
                // that's how dropdowns are sorted. so the front dropdown is lower down (has a
                // higher y-value) than the back one.
                // the six cases:
                // 1) the slice is entirely in the top half
                if (this._between(up, 0, -180) && this._between(low, 0, -180)) {
                    backHalf.push(slice);
                    // 2) the slice is entirely in the bottom half
                }
                else if (this._between(up, -180, -360) && this._between(low, -180, -360)) {
                    frontHalf.push(slice);
                    // 3) the slice starts in the top half and ends in the bottom half
                }
                else if (this._between(up, 0, -180) && this._between(low, -180, -360)) {
                    var slice1 = slice.copy();
                    slice1.angSlice = Math.abs(-180 - up);
                    slice1.frontDropdown = false;
                    backHalf.push(slice1);
                    var slice2 = slice.copy();
                    slice2.angOffset = 180;
                    slice2.angSlice = Math.abs(low - -180);
                    slice2.backDropdown = false;
                    frontHalf.push(slice2);
                    // 4) the slice starts in the bottom half and ends in the top half
                }
                else if (this._between(up, -180, -360) && this._between(low, -360, -540)) {
                    var slice1 = slice.copy();
                    slice1.angSlice = Math.abs(-360 - up);
                    slice1.backDropdown = false;
                    frontHalf.push(slice1);
                    var slice2 = slice.copy();
                    slice2.angOffset = 0;
                    slice2.angSlice = Math.abs(low - -360);
                    slice2.frontDropdown = false;
                    backHalf.push(slice2);
                    // 5) the slice starts in the top half, covers the entire bottom half and ends in the top half again
                }
                else if (this._between(up, 0, -180) && this._between(low, -360, -540)) {
                    var slice1 = slice.copy();
                    slice1.angSlice = Math.abs(-180 - up);
                    slice1.frontDropdown = false;
                    backHalf.push(slice1);
                    var slice2 = slice.copy();
                    slice2.angOffset = 0;
                    slice2.angSlice = Math.abs(low - -360);
                    slice2.frontDropdown = false;
                    backHalf.push(slice2);
                    var slice3 = slice.copy();
                    slice3.angOffset = -180;
                    slice3.angSlice = 180;
                    slice3.frontDropdown = slice3.backDropdown = false;
                    frontHalf.push(slice3);
                    // 6) the slice starts in the bottom half, covers the entire top half, and ends in the bottom half again
                }
                else if (this._between(up, -180, -360) && this._between(low, -540, -720)) {
                    var slice1 = slice.copy();
                    slice1.angSlice = Math.abs(-360 - up);
                    slice1.backDropdown = false;
                    frontHalf.push(slice1);
                    var slice2 = slice.copy();
                    slice2.angOffset = 540;
                    slice2.angSlice = Math.abs(low - -540);
                    slice2.backDropdown = false;
                    frontHalf.push(slice2);
                    var slice3 = slice.copy();
                    slice3.angOffset = 0;
                    slice3.angSlice = 180;
                    slice3.frontDropdown = slice3.backDropdown = false;
                    backHalf.push(slice3);
                }
            }
            backHalf.sort(this._compareSlices);
            frontHalf.sort(this._compareSlices);
            return [backHalf, frontHalf];
        };
        // function to take in a slice and return its two angles in degrees
        // note: smallerAngle will be between 0 and 360, and largerAngle will be
        // bigger than smallerAngle.
        Pie3dDrawStyle.prototype._getNormalizedAngles = function (slice) {
            var a1 = this.normalizeAngle(slice.angOffset);
            var a2 = this.normalizeAngle(slice.angOffset + slice.angSlice);
            while (a2 < a1) {
                a2 += 360;
            }
            return [a1, a2];
        };
        Pie3dDrawStyle.prototype._compareSlices = function (sliceA, sliceB) {
            var _a = this._getNormalizedAngles(sliceA), a1 = _a[0], a2 = _a[1];
            var _b = this._getNormalizedAngles(sliceB), b1 = _b[0], b2 = _b[1];
            var yA1 = this.getPointOnArc(DegToRad(a1), this._radius).y;
            var yA2 = this.getPointOnArc(DegToRad(a2), this._radius).y;
            var yB1 = this.getPointOnArc(DegToRad(b1), this._radius).y;
            var yB2 = this.getPointOnArc(DegToRad(b2), this._radius).y;
            var minA = Math.min(yA1, yA2);
            // special cases if pie slices pass 90 or 270
            if (a1 < 90 && a2 > 90) {
                minA = 0;
            }
            if (a1 < 270 && a2 > 270) {
                minA = Infinity;
            }
            var minB = Math.min(yB1, yB2);
            if (b1 < 90 && b2 > 90) {
                minB = 0;
            }
            if (b1 < 270 && b2 > 270) {
                minB = Infinity;
            }
            if (minA > minB) {
                return 1;
            }
            else if (minA < minB) {
                return -1;
            }
            else {
                return 0;
            }
        };
        // helper function to determine if an angle is between two other angles
        // @param x [Number] the angle to compare
        // @param one,two [Number] the angles x should be between
        // @return [Boolean] true if x is between one and two (inclusive), false otherwise
        Pie3dDrawStyle.prototype._between = function (x, angle1, angle2) {
            return (x >= Math.min(angle1, angle2)) && (x <= Math.max(angle1, angle2));
        };
        Pie3dDrawStyle.prototype._drawBackSlices = function (slices, ctx, brush, pen) {
            for (var _i = 0, slices_1 = slices; _i < slices_1.length; _i++) {
                var slice = slices_1[_i];
                this._drawArc(ctx, slice, brush, pen, slice.radius);
                this._drawDropdowns(ctx, slice, brush, pen);
                if (this._donutRadius > 0) {
                    this._drawArc(ctx, slice, brush, pen, this._donutRadius);
                }
            }
        };
        Pie3dDrawStyle.prototype._drawFrontSlices = function (slices, ctx, brush, pen) {
            for (var _i = 0, slices_2 = slices; _i < slices_2.length; _i++) {
                var slice = slices_2[_i];
                if (this._donutRadius > 0) {
                    this._drawArc(ctx, slice, brush, pen, this._donutRadius);
                }
                this._drawDropdowns(ctx, slice, brush, pen);
                this._drawArc(ctx, slice, brush, pen, slice.radius);
            }
        };
        Pie3dDrawStyle.prototype._drawArc = function (ctx, slice, brush, pen, radius) {
            if (slice.angSlice < this.minSliceAngle) {
                return;
            }
            var sliceX = this._midX + slice.offsetX;
            var sliceY = this._midY + slice.offsetY;
            var bgColor = new FDSColor(slice.bgColor);
            bgColor.lightenByFactor(0.5); // darkens it a bit
            brush.color = bgColor.getCOLORREF();
            brush.setOnCanvas(ctx, this._getGradientRect(slice));
            var outlineColor = new FDSColor(slice.outlineColor);
            outlineColor.lightenByFactor(0.5); // darkens it a bit
            ctx.setPen(pen.with({ color: outlineColor.getCOLORREF() }));
            var _a = this._getAngles(slice), smallerAngle = _a[0], largerAngle = _a[1];
            var depth = this.series.pieDesc.depth * Math.cos(this._tiltAngle);
            // adjust depth so it'll be the right height after the canvas is unstretched
            depth = (depth * 1) / Math.sin(this._tiltAngle);
            var newY = sliceY + depth;
            ctx.beginPath();
            ctx.arc(sliceX, newY, radius, smallerAngle, largerAngle, false);
            ctx.arc(sliceX, sliceY, radius, largerAngle, smallerAngle, true);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        Pie3dDrawStyle.prototype._drawDropdowns = function (ctx, slice, brush, pen) {
            var depth = this.series.pieDesc.depth * Math.cos(this._tiltAngle);
            // adjust depth so it'll be the right height after the canvas is unstretched
            depth = (depth * 1) / Math.sin(this._tiltAngle);
            var _a = this._getAngles(slice), a1 = _a[0], a2 = _a[1];
            var outer1 = this.getPointOnArc(-a1, slice.radius, slice.offsetX, slice.offsetY);
            var outer2 = this.getPointOnArc(-a2, slice.radius, slice.offsetX, slice.offsetY);
            var inner1 = this.getPointOnArc(-a1, this._donutRadius, slice.offsetX, slice.offsetY);
            var inner2 = this.getPointOnArc(-a2, this._donutRadius, slice.offsetX, slice.offsetY);
            var outers;
            var inners;
            if (outer1.y > outer2.y) {
                outers = [outer2, outer1];
                inners = [inner2, inner1];
            }
            else {
                outers = [outer1, outer2];
                inners = [inner1, inner2];
            }
            for (var i = 0; i < 2; i++) {
                if (i === 0 && !slice.backDropdown) {
                    continue;
                }
                if (i === 1 && !slice.frontDropdown) {
                    continue;
                }
                var p1 = outers[i];
                var p2 = inners[i];
                var bgColor = new FDSColor(slice.bgColor);
                bgColor.lightenByFactor(0.5); // darkens it a bit
                brush.color = bgColor.getCOLORREF();
                brush.setOnCanvas(ctx, this._getGradientRect(slice));
                var outlineColor = new FDSColor(slice.outlineColor);
                outlineColor.lightenByFactor(0.5); // darkens it a bit
                ctx.setPen(pen.with({ color: outlineColor.getCOLORREF() }));
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p2.x, p2.y + depth);
                ctx.lineTo(p1.x, p1.y + depth);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        };
        return Pie3dDrawStyle;
    }(PieDrawStyle));
    
    var PriceChange = /** @class */ (function (_super) {
        __extends(PriceChange, _super);
        function PriceChange(series) {
            return _super.call(this, series) || this;
        }
        PriceChange.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        PriceChange.prototype.verify = function () {
            return true;
        };
        PriceChange.prototype.hint = function () {
            return -1 /* NONE */;
        };
        PriceChange.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            ctx.save();
            if (this._xData.getSize() < 2 || this._yData.getSize() < 2) {
                return;
            }
            var _a = this._yData.Min(), minValue = _a[0], minValueIndex = _a[1];
            var minXValue = this._xData.getAt(0);
            var minXValueIndex = 0;
            var _b = this._yData.Max(), maxValue = _b[0], maxValueIndex = _b[1];
            var maxXValue = this._xData.getAt(this._xData.getSize() - 1);
            var maxXValueIndex = this._xData.getSize() - 1;
            // Auxiliary variables
            var pt1 = new Point(0, 0);
            var pt2 = new Point(0, 0);
            var y = 0.0;
            // Just call the whole thing off if anything is NaN.
            if (isNaN(minValue) || isNaN(minXValue) || isNaN(maxValue) || isNaN(maxXValue)) {
                return;
            }
            // Uptrend or downtrend (!downtrend)?
            var downtrend = false;
            if (maxValueIndex <= minValueIndex) {
                downtrend = true;
            }
            // not sure if we need this, and not sure why they do this
            if (downtrend) {
                _c = [minValue, maxValue], maxValue = _c[0], minValue = _c[1];
                _d = [minValueIndex, maxValueIndex], maxValueIndex = _d[0], minValueIndex = _d[1];
            }
            var extendLines = this.series.extendLine;
            var xleft = extendLines ? this._xScale.getMinPlotFactor() : this._xScale.lookup(minXValue, this._xBin);
            var xright = extendLines ? this._xScale.getMaxPlotFactor() : this._xScale.lookup(maxXValue, this._xBin);
            // Compute the two datapoint coordinates
            var pt100 = new Point(prm.plot.subPlotFromNDC(this._xScale.lookup(maxXValue, this._xBin), 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(maxValue, this._yBin), 2 /* Y */));
            var pt000 = new Point(prm.plot.subPlotFromNDC(this._xScale.lookup(minXValue, this._xBin), 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(minValue, this._yBin), 2 /* Y */));
            var _e = this.series, positiveColor = _e.positiveColor, negativeColor = _e.negativeColor;
            var color = this.series.calculatedSeriesColor;
            if (downtrend) {
                if (!this.series.attributeSet.isDefault('NegativeColor')) {
                    color = negativeColor;
                }
            }
            else {
                if (!this.series.attributeSet.isDefault('PositiveColor')) {
                    color = positiveColor;
                }
            }
            var pen = this.series.seriesFGPen.with({ color: color });
            pen.setOnCanvas(ctx);
            this.series.seriesBGBrush.pushHistory();
            this.series.seriesBGBrush.setAttr('color', color);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var rectA;
            var rectB;
            for (var i = 0; i < 2; i++) {
                y = i === 0 ? minValue : maxValue;
                pt1 = new Point(prm.plot.subPlotFromNDC(xleft, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                pt2 = new Point(prm.plot.subPlotFromNDC(xright, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                var index = i === 0 ? minValueIndex : maxValueIndex;
                if (this._setHitVector) {
                    // This will also allow the resize to snap, which matches IC. Using a rect because we're assuming
                    // rects resize right now. This needs to be changed in the future for all shapes.
                    var lineSize = new Point(Math.abs(pt2.x - pt1.x), Math.abs(pt2.y - pt1.y));
                    var minX = Math.min(pt1.x, pt2.x);
                    var rect1 = new FDSRectangleHitShape(minX + prm.plotRect.x1, (pt1.y + prm.plotRect.y1) - DRAWINGTOOL_HITSHAPE_LINE, lineSize.x, DRAWINGTOOL_HITSHAPE_LINE * 2);
                    rect1.index = index;
                    if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                        rect1.name = 1 /* DATAPOINTNS */;
                    }
                    this.series.hitVector.push(rect1);
                    if (i === 0) {
                        rectA = this._createNamedRectangle(prm, pt000, dpSize, minValueIndex, this._addNamesToHitshapes);
                    }
                    else {
                        rectB = this._createNamedRectangle(prm, pt100, dpSize, maxValueIndex, this._addNamesToHitshapes);
                    }
                }
                this._drawVerticalLine(prm, ctx, pen, pt100, pt000, Math.round((pt1.x + pt2.x) / 2.0));
                this._drawArrow(prm, ctx, pen, pt100, pt000, Math.round((pt1.x + pt2.x) / 2.0), downtrend);
                if (this.seriesSelected) {
                    var hit1 = 0;
                    var hit2 = 0;
                    if (i === 0) {
                        hit1 = 3 /* DATAPOINT */;
                        hit2 = 0 /* NONE */;
                    }
                    else if (i === 1) {
                        hit1 = 0 /* NONE */;
                        hit2 = 3 /* DATAPOINT */;
                    }
                    this.cacheSelectable(prm, hit1, prm.plot.subPlotFromNDC(xleft + FDSFudge, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                    this.cacheSelectable(prm, hit2, prm.plot.subPlotFromNDC(xright - FDSFudge, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                }
                // Labels oxr and oxl are used to offset the endpoints of the line if the labels overlap with the line
                // TODO: oxr/oxl functionality isn't actually wired up
                var oxr = 0;
                var oxl = 0;
                this._computeLabelPositionAndDraw(prm, ctx, i, pt1, pt2, oxl, oxr, y, color);
                pt1.x += oxl;
                pt2.x -= oxr;
                // Adjust for anti-aliasing so the lines aren't blurry
                var aliasOffset = pen.getAliasOffset();
                pt1.x = Math.floor(pt1.x) + aliasOffset;
                pt1.y = Math.floor(pt1.y) + aliasOffset;
                pt2.x = Math.floor(pt2.x) + aliasOffset;
                pt2.y = Math.floor(pt2.y) + aliasOffset;
                // Draw the horizontal line
                ctx.beginPath();
                pen.drawPolyline(ctx, pt1, pt2);
                pen.closePolyline();
                ctx.stroke();
            }
            if (this._addDataPointsHitShapes) {
                if (rectA != null) {
                    this.series.hitVector.push(rectA);
                }
                if (rectB != null) {
                    this.series.hitVector.push(rectB);
                }
            }
            this.series.seriesBGBrush.popHistory();
            ctx.restore();
            var _c, _d;
        };
        PriceChange.prototype._createNamedRectangle = function (prm, pt, hitShapeSize, index, addNamesToHitshapes) {
            var rect = new FDSRectangleHitShape((pt.x + prm.plotRect.x1) - hitShapeSize, (pt.y + prm.plotRect.y1) - hitShapeSize, hitShapeSize * 2, hitShapeSize * 2);
            rect.index = index;
            if (addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                rect.name = 3 /* DATAPOINT */;
            }
            return rect;
        };
        PriceChange.prototype._computeLabelPositionAndDraw = function (prm, ctx, level, Pt1, Pt2, oxl, oxr, value, color) {
            var pt1 = new Point(Pt1.x, Pt1.y);
            var pt2 = new Point(Pt2.x, Pt2.y);
            var h1 = this.series.seriesLabel1HPosition;
            var h2 = this.series.seriesLabel2HPosition;
            var v1 = this.series.seriesLabel1VPosition;
            var v2 = this.series.seriesLabel2VPosition;
            var s1 = new Point(0, 0);
            var s2 = new Point(0, 0);
            if (h1 === h2) {
                if (v1 === v2) {
                    this._addLabels(prm, ctx, 1 /* LABEL1 */, level, pt1, pt2, value, s1, pt1.x < pt2.x, color);
                    if (v1 === 1 /* V_TOP */) {
                        s2.y = s1.y;
                    }
                    else {
                        s2.y = (s1.y * -1);
                    }
                    this._addLabels(prm, ctx, 2 /* LABEL2 */, level, pt1, pt2, value, s2, pt1.x < pt2.x, color);
                    if (v1 === 2 /* V_CENTER */) {
                        if (h1 === 0 /* LEFT */) {
                            oxl = Math.max(s1.x, s2.x);
                        }
                        else if (h1 === 1 /* RIGHT */) {
                            oxr = Math.max(s1.x, s2.x);
                        }
                    }
                }
                else {
                    if (v1 === 2 /* V_CENTER */ || v2 === 2 /* V_CENTER */) {
                        if (v1 === 2 /* V_CENTER */) {
                            this._addLabels(prm, ctx, 1 /* LABEL1 */, level, pt1, pt2, value, s1, pt1.x < pt2.x, color);
                            if (v2 === 1 /* V_TOP */) {
                                s2.y = (Math.round(s1.y / 2.0) * -1);
                            }
                            else {
                                s2.y = Math.round(s1.y / 2.0);
                            }
                            this._addLabels(prm, ctx, 2 /* LABEL2 */, level, pt1, pt2, value, s2, pt1.x < pt2.x, color);
                            if (h1 === 0 /* LEFT */) {
                                oxl = s1.x;
                            }
                            else if (h1 === 1 /* RIGHT */) {
                                oxr = s1.x;
                            }
                        }
                        else {
                            this._addLabels(prm, ctx, 2 /* LABEL2 */, level, pt1, pt2, value, s2, pt1.x < pt2.x, color);
                            if (v1 === 1 /* V_TOP */) {
                                s1.y = (Math.round(s2.y / 2.0) * -1);
                            }
                            else {
                                s1.y = Math.round(s2.y / 2.0);
                            }
                            this._addLabels(prm, ctx, 1 /* LABEL1 */, level, pt1, pt2, value, s1, pt1.x < pt2.x, color);
                            if (h2 === 0 /* LEFT */) {
                                oxl = s2.x;
                            }
                            else {
                                oxr = s2.x;
                            }
                        }
                    }
                    else {
                        this._addLabels(prm, ctx, 1 /* LABEL1 */, level, pt1, pt2, value, s1, pt1.x < pt2.x, color);
                        this._addLabels(prm, ctx, 2 /* LABEL2 */, level, pt1, pt2, value, s2, pt1.x < pt2.x, color);
                    }
                }
            }
            else {
                this._addLabels(prm, ctx, 1 /* LABEL1 */, level, pt1, pt2, value, s1, pt1.x < pt2.x, color);
                this._addLabels(prm, ctx, 2 /* LABEL2 */, level, pt1, pt2, value, s2, pt1.x < pt2.x, color);
                if (v1 === 2 /* V_CENTER */) {
                    if (h1 === 0 /* LEFT */) {
                        oxl = s1.x;
                    }
                    else if (h1 === 1 /* RIGHT */) {
                        oxr = s1.x;
                    }
                }
                if (v2 === 2 /* V_CENTER */) {
                    if (h2 === 0 /* LEFT */) {
                        oxl += s2.x;
                    }
                    else if (h2 === 1 /* RIGHT */) {
                        oxr += s2.x;
                    }
                }
            }
        };
        PriceChange.prototype._addLabels = function (prm, ctx, labelIndex, level, Pt1, Pt2, value, size, ltr, color) {
            var pt1 = new Point(Pt1.x, Pt1.y);
            var pt2 = new Point(Pt2.x, Pt2.y);
            if (labelIndex === 1 /* LABEL1 */) {
                if (!((this.series.seriesLabel1LevelsMask >> level) & 0x1)) {
                    return;
                }
            }
            else {
                if (!((this.series.seriesLabel2LevelsMask >> level) & 0x1)) {
                    return;
                }
            }
            var visibleLabels = this.series.labelsMask;
            if ((visibleLabels >> (labelIndex - 1)) & 0x1) {
                var seriesFormat = void 0;
                var font = void 0;
                if (labelIndex === 1 /* LABEL1 */) {
                    seriesFormat = this.series.seriesLabel1Format;
                    font = this.series.seriesLabel1Font;
                    if (this.series.seriesLabel1ColorFollowsSeriesColor) {
                        if (color !== undefined) {
                            font = font.with({ color: color });
                        }
                        else {
                            font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                        }
                    }
                }
                else {
                    seriesFormat = this.series.seriesLabel2Format;
                    font = this.series.seriesLabel2Font;
                    if (this.series.seriesLabel2ColorFollowsSeriesColor) {
                        if (color !== undefined) {
                            font = font.with({ color: color });
                        }
                        else {
                            font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                        }
                    }
                }
                font.setOnCanvas(ctx);
                var valueFormatter = new FDSFormat();
                valueFormatter.setNumberFormat(seriesFormat);
                var label = void 0;
                if (labelIndex === 2 /* LABEL2 */) {
                    label = valueFormatter.formatAsNumber(value);
                }
                else {
                    var formatString = this.series.properties.compilePropertyString(seriesFormat);
                    label = formatString.fromValue();
                }
                var fontHeight = font.getHeight(ctx);
                var xoff = void 0, yoff = void 0;
                var position = void 0, vPos = void 0;
                _a = (labelIndex === 1 /* LABEL1 */) ? [
                    this.series.seriesLabel1XOffset,
                    -this.series.seriesLabel1YOffset,
                    this.series.seriesLabel1HPosition,
                    this.series.seriesLabel1VPosition
                ] : [
                    this.series.seriesLabel2XOffset,
                    -this.series.seriesLabel2YOffset,
                    this.series.seriesLabel2HPosition,
                    this.series.seriesLabel2VPosition,
                ], xoff = _a[0], yoff = _a[1], position = _a[2], vPos = _a[3];
                var tp1 = new Point(pt1.x, pt1.y);
                var tp2 = new Point(pt2.x, pt2.y);
                tp1.x += Math.round(xoff);
                tp1.y += Math.round(yoff);
                tp2.x += Math.round(xoff);
                tp2.y += Math.round(yoff);
                tp1.y += fontHeight;
                tp2.y += fontHeight;
                if (this.series.seriesLabel1HPosition === this.series.seriesLabel2HPosition) {
                    if (this.series.seriesLabel1VPosition === this.series.seriesLabel2VPosition) {
                        if (labelIndex !== 1 /* LABEL1 */) {
                            if (vPos === 1 /* V_TOP */) {
                                vPos = 0 /* V_BOTTOM */;
                            }
                            else {
                                vPos = 1 /* V_TOP */;
                            }
                        }
                    }
                }
                // TODO like in FibonacciTimeZones, for some reason this needs to be
                // the opposite in order to match the PC side
                if (vPos === 0 /* V_BOTTOM */) {
                    fontHeight = 2 * font.getHeight();
                }
                else {
                    fontHeight = 0;
                }
                switch (position) {
                    case 0 /* LEFT */:
                        ctx.legacyFillText(label, tp1.x, tp1.y - fontHeight, ltr ? 'left' : 'right');
                        break;
                    case 2 /* CENTER */:
                        tp1.x = Math.round((tp1.x + tp2.x) / 2.0);
                        ctx.legacyFillText(label, tp1.x, tp1.y - fontHeight, 'center');
                        break;
                    default:
                        // default handles TEXT_RIGHT
                        ctx.legacyFillText(label, tp2.x, tp2.y - fontHeight, ltr ? 'right' : 'left');
                        break;
                }
            }
            var _a;
        };
        PriceChange.prototype._drawVerticalLine = function (prm, ctx, pen, Pv1, Pv2, midPoint) {
            var pv1 = new Point(Pv1.x, Pv1.y);
            var pv2 = new Point(Pv2.x, Pv2.y);
            pv1.x = midPoint;
            pv2.x = midPoint;
            // Adjust for anti-aliasing so the lines aren't blurry
            var props = pen.toPropertyObject();
            pv1.x = (~~pv1.x) + props.aliasOffset;
            pv1.y = (~~pv1.y) + props.aliasOffset;
            pv2.x = (~~pv2.x) + props.aliasOffset;
            pv2.y = (~~pv2.y) + props.aliasOffset;
            ctx.beginPath();
            pen.drawPolyline(ctx, pv1, pv2);
            pen.closePolyline();
            ctx.stroke();
            var line1 = new FDSLineHitShape(pv1.x + prm.plotRect.x1, pv1.y + prm.plotRect.y1, pv2.x + prm.plotRect.x1, pv2.y + prm.plotRect.y1);
            line1.index = 0;
            line1.thickness = DRAWINGTOOL_HITSHAPE_LINE;
            line1.name = 5 /* SERIESHIT */;
            var lineHitShapes = line1;
            this.series.hitVector = this.series.hitVector.concat(lineHitShapes);
            // also add series pixel point
            var pixX = Math.round((line1.x1 + line1.x2) / 2);
            var pixY = Math.round((line1.y1 + line1.y2) / 2);
            this.series.root.pixelPoints[this.series.id] = [{ x: pixX, y: pixY }];
        };
        PriceChange.prototype._drawArrow = function (prm, ctx, pen, Pv1, Pv2, midPoint, downtrend) {
            var pv1 = new Point(Pv1.x, Pv1.y);
            var pv2 = new Point(Pv2.x, Pv2.y);
            pv1.x = midPoint;
            var markerSize = this.series.markerSize;
            pv1.y += Math.round(markerSize / 2.0);
            // We're doing some translating so let's make sure we don't mess up the state.
            ctx.save();
            // The next if statement is a simplified form of the following expression:
            // if ((!downtrend && !m_YScale.getReverse()) || (downtrend && m_YScale.getReverse()))
            if (downtrend === this._yScale.reverse) {
                ctx.translate(pv1.x, pv1.y);
            }
            else {
                pv1.y -= Math.round(markerSize); // Cancels the translation of .y and adds half the size of the triangle
                ctx.translate(pv1.x, pv1.y);
                ctx.rotate(Math.PI);
            }
            var triangleMarkerFunctor = getMarkerDrawFunctor(3 /* TRIANGLE */, Math.round(markerSize));
            ctx.beginPath();
            triangleMarkerFunctor(ctx, 0, 0);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        };
        return PriceChange;
    }(InteractiveDrawStyle));
    
    var QuadrantTironeBase = /** @class */ (function (_super) {
        __extends(QuadrantTironeBase, _super);
        function QuadrantTironeBase(series) {
            var _this = _super.call(this, series) || this;
            _this._addNamesToHitshapes = _this._isInteractable;
            _this._drawInteractionHandle = _this.seriesSelected && _this._addNamesToHitshapes;
            return _this;
        }
        QuadrantTironeBase.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        QuadrantTironeBase.prototype.verify = function () {
            return true;
        };
        QuadrantTironeBase.prototype.hint = function () {
            return -1 /* NONE */;
        };
        QuadrantTironeBase.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            ctx.save();
            if (this._yData.data.length < 2 || this._xData.data.length < 2) {
                return;
            }
            var state;
            var startIndex = 0;
            var endIndex = 0;
            var _a = this.series, startDatapoint = _a.startDatapoint, endDatapoint = _a.endDatapoint;
            var value1 = 0;
            var xvalue1 = 0;
            var value2 = 0;
            var xvalue2 = 0;
            _b = this.series.findExtremaInRange(startDatapoint, endDatapoint, startIndex, endIndex, value1, xvalue1, value2, xvalue2, false), state = _b[0], startIndex = _b[1], endIndex = _b[2], value1 = _b[3], xvalue1 = _b[4], value2 = _b[5], xvalue2 = _b[6];
            var start = 0;
            var end = this._xData.data.length - 1;
            var step = 0;
            var miny = value1;
            var maxy = value2;
            var deltaY = maxy - miny;
            var xleft = Math.max(this._xScale.getMinPlotFactor(), this._xScale.lookup(this._xData.getAt(startIndex), this._xBin));
            var xright = Math.min(this._xScale.getMaxPlotFactor(), this._xScale.lookup(this._xData.getAt(endIndex), this._xBin));
            var visibleLevels = this.series.fibonacciLevels;
            var baseLineVisible = false;
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var lineHitShapes = [];
            var pointHitShapes = [];
            for (var _i = 0, _c = this._yLevels; _i < _c.length; _i++) {
                var yLevel = _c[_i];
                if (visibleLevels & 0x1) {
                    var y = miny + (deltaY * yLevel);
                    var pt1 = new Point((prm.plot.subPlotFromNDC(xleft, 1 /* X */)), (prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */)));
                    var pt2 = new Point((prm.plot.subPlotFromNDC(xright, 1 /* X */)), (prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */)));
                    var hitNameL = void 0;
                    var hitNameR = void 0;
                    if (this.seriesSelected) {
                        if (fuzzyEQ(yLevel, 0.5)) {
                            hitNameL = 6 /* DATAPOINTLEFT */;
                            hitNameR = 7 /* DATAPOINTRIGHT */;
                        }
                        else {
                            hitNameL = hitNameR = 0 /* NONE */;
                        }
                        this.cacheSelectable(prm, hitNameL, prm.plot.subPlotFromNDC(xleft + FDSFudge, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                        this.cacheSelectable(prm, hitNameR, prm.plot.subPlotFromNDC(xright - FDSFudge, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                    }
                    var s = this._addLabels(ctx, y, pt1, pt2, true);
                    var leftShift = false;
                    var rightShift = false;
                    var vPos = this.series.seriesLabel1VPosition;
                    var hPos = this.series.seriesLabel1HPosition;
                    if (vPos === 2 /* V_CENTER */) {
                        if (hPos === 0 /* LEFT */) {
                            pt1.x += s.x;
                            leftShift = true;
                        }
                        else if (hPos === 1 /* RIGHT */) {
                            pt2.x -= s.x;
                            rightShift = true;
                        }
                    }
                    // dashed line if baseline, otherwise solid
                    if (yLevel === 0.5) {
                        baseLineVisible = true;
                        if (this._drawInteractionHandle) {
                            this.addInteractionHandle(ctx, prm, pt1, pt2);
                        }
                        ctx.save();
                        ctx.beginPath();
                        this.series.baseLineFGPen.setOnCanvas(ctx);
                        this.series.baseLineFGPen.drawPolyline(ctx, pt1, pt2);
                        this.series.baseLineFGPen.closePolyline();
                        ctx.stroke();
                        ctx.restore();
                    }
                    else {
                        ctx.beginPath();
                        pen.drawPolyline(ctx, pt1, pt2);
                        pen.closePolyline();
                        ctx.stroke();
                    }
                    if (this._setHitVector) {
                        var line = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                        line.index = -1;
                        line.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                        if (fuzzyEQ(yLevel, 0.5) && this._addNamesToHitshapes &&
                            this.series.isInteractive(2 /* DRAGGABLE */)) {
                            line.name = 8 /* SERIESHITLEFTRIGHT */;
                        }
                        this.series.hitVector.push(line);
                        // while I'm here, add the pixel points
                        var pixX = Math.round((line.x1 + line.x2) / 2);
                        var pixY = Math.round((line.y1 + line.y2) / 2);
                        this.root.pixelPoints[this.series.id] = [{ x: pixX, y: pixY }];
                        if (fuzzyEQ(yLevel, 0.5)) {
                            if (leftShift) {
                                pt1.x -= s.x;
                            }
                            var left = new FDSRectangleHitShape((pt1.x + prm.plotRect.x1) - dpSize, (pt1.y + prm.plotRect.y1) - dpSize, 2 * dpSize, 2 * dpSize);
                            left.index = startIndex;
                            if (rightShift) {
                                pt2.x += s.x;
                            }
                            var right = new FDSRectangleHitShape((pt2.x + prm.plotRect.x1) - dpSize, (pt2.y + prm.plotRect.y1) - dpSize, 2 * dpSize, 2 * dpSize);
                            right.index = endIndex;
                            if (this._addNamesToHitshapes && this.series.isInteractive(4 /* RESIZABLE */)) {
                                left.name = 6 /* DATAPOINTLEFT */;
                                right.name = 7 /* DATAPOINTRIGHT */;
                            }
                            this.series.hitVector.push(left);
                            this.series.hitVector.push(right);
                            if (this._drawInteractionHandle) {
                                this._drawExtraInteractionHandle(ctx, prm, pt1, pt2);
                            }
                        }
                    }
                }
                visibleLevels = visibleLevels >> 1;
            }
            // add a baseline if it hasn't been added already
            // if m_drawInteractionHandle
            if (this._drawInteractionHandle && this._setHitVector && !baseLineVisible) {
                var y = miny + (deltaY * 0.5);
                if (this.seriesSelected) {
                    this.cacheSelectable(prm, 3 /* DATAPOINT */, prm.plot.subPlotFromNDC(xleft + FDSFudge, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                    this.cacheSelectable(prm, 3 /* DATAPOINT */, prm.plot.subPlotFromNDC(xright - FDSFudge, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */));
                }
                var pt1 = new Point(prm.plot.subPlotFromNDC(xleft, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                var pt2 = new Point(prm.plot.subPlotFromNDC(xright, 1 /* X */), prm.plot.subPlotFromNDC(this._yScale.lookup(y, this._yBin), 2 /* Y */));
                pen = pen.with({ style: 1 /* DASH */ });
                pen.setOnCanvas(ctx);
                ctx.beginPath();
                pen.drawPolyline(ctx, pt1, pt2);
                pen.closePolyline();
                ctx.stroke();
                var midX = pt1.x + ((pt2.x - pt1.x) / 2);
                var midY = pt1.y + ((pt2.y - pt1.y) / 2);
                var lineTemp1 = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, midX + prm.plotRect.x1, midY + prm.plotRect.y1);
                lineTemp1.index = 0;
                lineTemp1.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                lineTemp1.name = 0 /* NONE */;
                var lineTemp2 = new FDSLineHitShape(midX + prm.plotRect.x1, midY + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                lineTemp2.index = 1;
                lineTemp2.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                lineTemp2.name = 0 /* NONE */;
                lineHitShapes.push(lineTemp2);
                lineHitShapes.push(lineTemp1);
                if (this._addNamesToHitshapes) {
                    this.addInteractionHandle(ctx, prm, pt1, pt2);
                    var line = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                    if (this.series.isInteractive(2 /* DRAGGABLE */)) {
                        line.name = 8 /* SERIESHITLEFTRIGHT */;
                    }
                    this.series.hitVector.push(line);
                    var left = new FDSRectangleHitShape((pt1.x + prm.plotRect.x1) - dpSize, (pt1.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                    left.index = startIndex;
                    left.name = 3 /* DATAPOINT */;
                    this.series.hitVector.push(left);
                    var right = new FDSRectangleHitShape((pt2.x + prm.plotRect.x1) - dpSize, (pt2.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
                    right.index = endIndex;
                    right.name = 3 /* DATAPOINT */;
                    this.series.hitVector.push(right);
                    this._drawExtraInteractionHandle(ctx, prm, pt1, pt2);
                }
            }
            ctx.restore();
            var _b;
        };
        QuadrantTironeBase.prototype._addLabels = function (ctx, value, pt1, pt2, drawLabels) {
            ctx.save();
            var s = new Point(0, 0);
            if (this.series.labelsMask & 1 /* LABEL1 */) {
                var font = this.series.seriesLabel1Font;
                if (this.series.seriesLabel1ColorFollowsSeriesColor) {
                    if (!this.series.attributeSet.isDefault('SeriesColor')) {
                        font = font.with({ color: this.series.calculatedSeriesColor });
                    }
                    else {
                        font = font.with({ color: 16750899 /* SELECT_TOOL_BLUE */ });
                    }
                }
                font.setOnCanvas(ctx);
                var format = this.series.seriesLabel1Format;
                var valueFormatter = new FDSFormat();
                valueFormatter.setNumberFormat(format);
                var label = valueFormatter.formatAsNumber(value);
                s.x = ctx.measureTextWidth(label);
                s.y = font.getHeight();
                if (drawLabels) {
                    var vPos = this.series.seriesLabel1VPosition;
                    var p1 = new Point(pt1.x, pt1.y);
                    var p2 = new Point(pt2.x, pt2.y);
                    if (this._xScale.reverse) {
                        _a = [p2, p1], p1 = _a[0], p2 = _a[1];
                    }
                    var finalPoint = new Point(0, 0);
                    var hPos = this.series.seriesLabel1HPosition;
                    var y = 0;
                    // case center handled in draw
                    switch (vPos) {
                        case 0 /* V_BOTTOM */:
                            y -= 3;
                            break;
                        case 1 /* V_TOP */:
                            y += s.y;
                            break;
                    }
                    var textAlign = void 0;
                    switch (hPos) {
                        case 0 /* LEFT */:
                            finalPoint = p1;
                            textAlign = 'left';
                            break;
                        case 1 /* RIGHT */:
                            finalPoint = p2;
                            textAlign = 'right';
                            break;
                        case 2 /* CENTER */:
                            finalPoint.x = Math.round((p1.x + p2.x) / 2);
                            finalPoint.y = p1.y;
                            textAlign = 'center';
                            break;
                    }
                    finalPoint.x += Math.round(this.series.seriesLabel1XOffset);
                    finalPoint.y -= Math.round(this.series.seriesLabel1YOffset);
                    ctx.legacyFillText(label, finalPoint.x, finalPoint.y + y, textAlign);
                }
            }
            ctx.restore();
            return s;
            var _a;
        };
        QuadrantTironeBase.prototype._drawExtraInteractionHandle = function (ctx, prm, pt1, pt2) {
            var size = this.series.interactionHandleSize;
            ctx.save();
            this.series.interactionFGPen.setOnCanvas(ctx);
            this.series.seriesBGBrush.pushHistory();
            this.series.seriesBGBrush.setAttr('color', this.series.interactionFGPen.color);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            ctx.beginPath();
            ctx.ellipse(pt1.x, pt1.y, 2 * size);
            ctx.ellipse(pt2.x, pt2.y, 2 * size);
            ctx.fill();
            ctx.restore();
            this.series.seriesBGBrush.popHistory();
        };
        return QuadrantTironeBase;
    }(InteractiveDrawStyle));
    
    var QuadrantLines = /** @class */ (function (_super) {
        __extends(QuadrantLines, _super);
        function QuadrantLines(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(47 /* QUADRANTLINES */);
            return _this;
        }
        QuadrantLines.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        return QuadrantLines;
    }(QuadrantTironeBase));
    
    var RaffRegression = /** @class */ (function (_super) {
        __extends(RaffRegression, _super);
        function RaffRegression(series) {
            var _this = _super.call(this, series) || this;
            _this._xRatio = 1;
            _this._yRatio = 1;
            _this._isResizable = _this.series.isInteractive(4 /* RESIZABLE */);
            return _this;
        }
        RaffRegression.prototype._getRaffRegressionData = function () {
            var startDataPoint = this.series.attributeSet.get('StartDatapoint');
            var endDataPoint = this.series.attributeSet.get('EndDatapoint');
            var _a = this.series.getSortedData(), startIndex = _a.startIndex, endIndex = _a.endIndex, data = _a.data;
            if (data.length < 1) {
                return null;
            }
            var _b = this._xData.Max(), xDsMax = _b[0], xDsMaxIndex = _b[1];
            var _c = this._xData.Min(), xDsMin = _c[0], xDsMinIndex = _c[1];
            var _d = this._yData.Max(), yDsMax = _d[0], yDsMaxIndex = _d[1];
            var _e = this._yData.Min(), yDsMin = _e[0], yDsMinIndex = _e[1];
            this._xRatio = this._xScale.compressValue(xDsMax) - this._xScale.compressValue(xDsMin);
            this._yRatio = this._yScale.compressValue(yDsMax) - this._yScale.compressValue(yDsMin);
            if (fuzzyEQ(0.0, this._xRatio)) {
                this._xRatio = 1.0;
            }
            if (fuzzyEQ(0.0, this._yRatio)) {
                this._yRatio = 1.0;
            }
            this._data = this.series.getRegressionData(startIndex, endIndex, null, 1 /* Raff */);
            if (this._data != null) {
                var xmin = this._xScale.lookup(ISNAN(startDataPoint) ? xDsMin : startDataPoint);
                var xmax = this._xScale.lookup(ISNAN(endDataPoint) ? xDsMax : endDataPoint);
                var axisPlotFactorScale = this._xScale.getMaxPlotFactor() - this._xScale.getMinPlotFactor();
                if (axisPlotFactorScale === 0) {
                    axisPlotFactorScale = 1;
                }
                xmin = (xmin - this._xScale.getMinPlotFactor()) / axisPlotFactorScale;
                xmax = (xmax - this._xScale.getMinPlotFactor()) / axisPlotFactorScale;
                xmin = Math.max((0.0 - this._xScale.getMinPlotFactor()) / axisPlotFactorScale, xmin);
                xmax = Math.min((1.0 - this._xScale.getMinPlotFactor()) / axisPlotFactorScale, xmax);
                if (xmax === xmin) {
                    return null;
                }
                var xMinVal = (this._xScale.compressValue(this._xScale.computeValueUnbinned(xmin)) -
                    this._xScale.compressValue(xDsMin)) / this._xRatio;
                var xMaxVal = (this._xScale.compressValue(this._xScale.computeValueUnbinned(xmax)) -
                    this._xScale.compressValue(xDsMin)) / this._xRatio;
                var yMinVal = polyinterp(this._data, 1 /* Raff */ + 1, xMinVal);
                var yMaxVal = polyinterp(this._data, 1 /* Raff */ + 1, xMaxVal);
                var m = 1;
                if (!fuzzyEQ(xMaxVal - xMinVal, 0)) {
                    m = (yMaxVal - yMinVal) / (xMaxVal - xMinVal);
                }
                var b = yMinVal - (xMinVal * m);
                var uptrend = yMinVal < yMaxVal;
                var distance = 0;
                for (var i = startIndex; i < endIndex; i++) {
                    var xPVal = (this._xScale.compressValue(this._xData.getValueOrIndexAt(this._xScale, i)) -
                        this._xScale.compressValue(xDsMin)) / this._xRatio;
                    for (var dim = 0; dim < this._yData.getDimension(); dim++) {
                        var yPVal = (this._yScale.compressValue(this._yData.getValueOrIndexAt(this._yScale, i, dim)) - this._yScale.compressValue(yDsMin)) / this._yRatio;
                        var tmpDistance = yPVal - ((m * xPVal) + b);
                        if (uptrend && tmpDistance > 0) {
                            distance = Math.max(tmpDistance, distance);
                        }
                        else if (!uptrend && tmpDistance < 0) {
                            distance = Math.min(tmpDistance, distance);
                        }
                    }
                }
                return {
                    axisPlotFactorScale: axisPlotFactorScale,
                    xmin: xmin,
                    yMinVal: yMinVal,
                    xmax: xmax,
                    yMaxVal: yMaxVal,
                    startIndex: startIndex,
                    endIndex: endIndex,
                    distance: distance
                };
            }
            else {
                return null;
            }
        };
        RaffRegression.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            var isInteractable = this.series.isInteractive(2 /* DRAGGABLE */ |
                4 /* RESIZABLE */);
            var drawInteractionHandle = this.seriesSelected && isInteractable;
            var ret = this._getRaffRegressionData();
            if (ret) {
                var axisPlotFactorScale = ret.axisPlotFactorScale, xmin = ret.xmin, yMinVal = ret.yMinVal, xmax = ret.xmax, yMaxVal = ret.yMaxVal, startIndex = ret.startIndex, endIndex = ret.endIndex, distance = ret.distance;
                this._drawLine(prm, ctx, axisPlotFactorScale, xmin, yMinVal, xmax, yMaxVal, startIndex, endIndex, false, distance, drawInteractionHandle, true);
            }
        };
        RaffRegression.prototype._makePoint = function (prm, axisPlotFactorScale, x, y, addSelectionMarkers) {
            if (addSelectionMarkers === void 0) { addSelectionMarkers = false; }
            var plot = prm.plot;
            var _a = this._yData.Min(), yDsMin = _a[0], yDsMinIndex = _a[1];
            x = plot.subPlotFromNDC((x * axisPlotFactorScale) + this._xScale.getMinPlotFactor(), 1 /* X */);
            y = plot.subPlotFromNDC(this._yScale.lookup(this._yScale.decompressValue((y * this._yRatio) +
                this._yScale.compressValue(yDsMin))), 2 /* Y */);
            if (addSelectionMarkers) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, x, y);
            }
            return new Point(x, y);
        };
        RaffRegression.prototype._drawLine = function (prm, ctx, axisPlotFactorScale, x1, y1, x2, y2, leftDpIndex, rightDpIndex, isVerticalLine, distance, drawInteractionHandle, baseLine) {
            if (this._xScale.reverse) {
                _a = [x2, x1], x1 = _a[0], x2 = _a[1];
                _b = [y2, y1], y1 = _b[0], y2 = _b[1];
            }
            var hitVector = [];
            var leftPoint = this._makePoint(prm, axisPlotFactorScale, x1, y1, true);
            var rightPoint = this._makePoint(prm, axisPlotFactorScale, x2, y2, true);
            var leftPointTop = this._makePoint(prm, axisPlotFactorScale, x1, y1 + distance);
            var rightPointTop = this._makePoint(prm, axisPlotFactorScale, x2, y2 + distance);
            var leftPointBottom = this._makePoint(prm, axisPlotFactorScale, x1, y1 - distance);
            var rightPointBottom = this._makePoint(prm, axisPlotFactorScale, x2, y2 - distance);
            // used for offsetting points for hitshapes
            var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var dpOffsetX = prm.plotRect.x1 - dpSize;
            var dpOffsetY = prm.plotRect.y1 - dpSize;
            var pixelWidth = prm.plot.subPlotFromNDC((x2 * axisPlotFactorScale) + this._xScale.getMinPlotFactor(), 1 /* X */) -
                prm.plot.subPlotFromNDC((x1 * axisPlotFactorScale) + this._xScale.getMinPlotFactor(), 1 /* X */);
            var div = clamp(Math.round((pixelWidth / 4.0) * 1 /* Raff */), 1.0, 200.0);
            var p = [];
            var ptop = [];
            var pbottom = [];
            if (!this._yScale.getLog() || !this.series.curvedRegressionOnLogScale) {
                div = 1;
            }
            var delta = (x2 - x1) / div;
            if (delta < FDSFudge) {
                delta = 1.0;
            }
            var _c = this._xData.Min(), xDsMin = _c[0], xDsMinIndex = _c[1];
            var count = 0;
            var x = x1;
            while (x <= x2 + FDSFudge) {
                var xm = (this._xScale.compressValue(this._xScale.computeValueUnbinned(x)) -
                    this._xScale.compressValue(xDsMin)) / this._xRatio;
                var ym = polyinterp(this._data, 1 /* Raff */ + 1, xm);
                p.push(this._makePoint(prm, axisPlotFactorScale, x, ym));
                ptop.push(this._makePoint(prm, axisPlotFactorScale, x, ym + distance));
                pbottom.push(this._makePoint(prm, axisPlotFactorScale, x, ym - distance));
                if (this._setHitVector && count > 0) {
                    var line = new FDSLineHitShape(p[count - 1].x + prm.plotRect.x1, p[count - 1].y + prm.plotRect.y1, p[count].x + prm.plotRect.x1, p[count].y + prm.plotRect.y1);
                    line.index = -1;
                    line.name = 8 /* SERIESHITLEFTRIGHT */;
                    line.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    hitVector.push(line);
                }
                x += delta;
                count++;
            }
            ctx.save();
            ctx.beginPath();
            this.series.baseLineFGPen.setOnCanvas(ctx);
            // Draw the middle line
            this.strokePolyline(ctx, this.series.baseLineFGPen, p);
            ctx.restore();
            ctx.save();
            this.series.seriesFGPen.setOnCanvas(ctx);
            // Draw the top line
            this.strokePolyline(ctx, this.series.seriesFGPen, ptop);
            // Draw the bottom line
            this.strokePolyline(ctx, this.series.seriesFGPen, pbottom);
            ctx.restore();
            if (drawInteractionHandle) {
                var size = this.series.attributeSet.get('InteractionHandleSize');
                ctx.save();
                this.series.interactionFGPen.setOnCanvas(ctx);
                this.series.seriesBGBrush.pushHistory();
                this.series.seriesBGBrush.setAttr('color', this.series.interactionFGPen.color);
                this.series.seriesBGBrush.setOnCanvas(ctx);
                // draw main line handle
                this.strokePolyline(ctx, this.series.interactionFGPen, p);
                ctx.beginPath();
                // draw end points
                ctx.ellipse(leftPoint.x, leftPoint.y, 2 * size);
                ctx.ellipse(rightPoint.x, rightPoint.y, 2 * size);
                ctx.fill();
                ctx.beginPath();
                // draw vertical lines
                ctx.moveTo(leftPointTop.x, leftPointTop.y);
                this.series.interactionFGPen.drawPolyline(ctx, leftPointTop, leftPointBottom);
                this.series.interactionFGPen.closePolyline();
                ctx.moveTo(rightPointTop.x, rightPointTop.y);
                this.series.interactionFGPen.drawPolyline(ctx, rightPointTop, rightPointBottom);
                this.series.interactionFGPen.closePolyline();
                ctx.stroke();
                ctx.restore();
                this.series.seriesBGBrush.popHistory();
            }
            if (this._setHitVector) {
                // in lieu of interactivity status, only add these extra hitshapes if the
                // series is selected
                if (this.series.isSelected()) {
                    var lineL = new FDSLineHitShape(leftPointTop.x + prm.plotRect.x1, leftPointTop.y + prm.plotRect.y1, leftPointBottom.x + prm.plotRect.x1, leftPointBottom.y + prm.plotRect.y1);
                    lineL.index = 0;
                    if (this._isResizable) {
                        lineL.name = 6 /* DATAPOINTLEFT */;
                    }
                    hitVector.push(lineL);
                    var lineR = new FDSLineHitShape(rightPointTop.x + prm.plotRect.x1, rightPointTop.y + prm.plotRect.y1, rightPointBottom.x + prm.plotRect.x1, rightPointBottom.y + prm.plotRect.y1);
                    lineR.index = 1;
                    if (this._isResizable) {
                        lineR.name = 7 /* DATAPOINTRIGHT */;
                    }
                    hitVector.push(lineR);
                }
                // end points
                // left point
                var leftPointHitRect = new FDSRectangleHitShape(leftPoint.x + dpOffsetX, leftPoint.y + dpOffsetY, dpSize * 2, dpSize * 2);
                leftPointHitRect.index = 0;
                leftPointHitRect.name = 6 /* DATAPOINTLEFT */;
                hitVector.push(leftPointHitRect);
                // right point
                var rightPointHitRect = new FDSRectangleHitShape(rightPoint.x + dpOffsetX, rightPoint.y + dpOffsetY, dpSize * 2, dpSize * 2);
                rightPointHitRect.index = 1;
                rightPointHitRect.name = 7 /* DATAPOINTRIGHT */;
                hitVector.push(rightPointHitRect);
            }
            this.series.hitVector = hitVector;
            this.series.root.pixelPoints[this.series.id] = this._createPixelPoints(prm, p);
            var _a, _b;
        };
        RaffRegression.prototype._createPixelPoints = function (prm, middlePoints) {
            var pixelPoints = {};
            for (var i = 0; i < middlePoints.length; i++) {
                var x = ~~(middlePoints[i].x + prm.plotRect.x1);
                var y = ~~(middlePoints[i].y + prm.plotRect.y1);
                pixelPoints[i] = { x: x, y: y };
            }
            return pixelPoints;
        };
        return RaffRegression;
    }(BaseDrawStyle));
    
    var RangeBarsDrawStyle = /** @class */ (function (_super) {
        __extends(RangeBarsDrawStyle, _super);
        function RangeBarsDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            var numberOfXDimensions = _this._xData.getDimension();
            // determine if the rangebars are vertical or horizontal
            // here, we favor X to remain consistent with the PC side
            _this.isVertical = !(numberOfXDimensions > 1);
            // Markers are scaled down on bar drawstyles because there are multiple markers per bar
            _this._selectionMarkerScale = 2 / 3;
            return _this;
        }
        RangeBarsDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            this._getAttributesForDrawing(ctx);
            var xInfo = this._getAxisInfo(1 /* X */, prm);
            var yInfo = this._getAxisInfo(2 /* Y */, prm);
            var pixelPoints = {};
            var infoboxPixelPoints = {};
            for (var index = 0; index < this.series.size; index += this._step) {
                var rangebar = this._calculateRangeBarBounds(prm, index, xInfo, yInfo);
                if (rangebar === undefined) {
                    continue;
                }
                var rect = rangebar.rect;
                this._addInteractivityFeatures(prm, rect, index);
                pixelPoints[index] = this._calculatePixelPoints(prm, rect);
                infoboxPixelPoints[index] = {
                    point: this._calculateInfoboxPixelPoints(prm, rect),
                    position: "above" /* above */
                };
                if (this._useOutliers) {
                    this._drawOutlierRangeBar(prm, ctx, index, rangebar, xInfo, yInfo);
                }
                else {
                    this._drawNormalRangeBar(ctx, index, rangebar);
                }
            }
            this._resetColorMapColor(this._brush);
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this.root.infoboxPixelPoints[this.series.id] = infoboxPixelPoints;
            ctx.restore();
        };
        RangeBarsDrawStyle.prototype._addInteractivityFeatures = function (prm, rangeBarRect, index) {
            this._addHitshape(prm, rangeBarRect, index);
            this._addSelectionMarkers(prm, rangeBarRect, index);
        };
        RangeBarsDrawStyle.prototype._drawNormalRangeBar = function (ctx, index, rangebar) {
            var stepLines = this.isVertical ? rangebar.horizontalLines : rangebar.verticalLines;
            this._fillRangeBar(ctx, index, rangebar.rect, stepLines);
            this._drawRangeBarLines(ctx, rangebar);
        };
        RangeBarsDrawStyle.prototype._drawOutlierRangeBar = function (prm, ctx, index, rangebar, xInfo, yInfo) {
            var outlierAxisInfo;
            if (xInfo.numberOfDimensions > 1 && yInfo.numberOfDimensions === 1) {
                outlierAxisInfo = xInfo;
            }
            else if (xInfo.numberOfDimensions === 1 && yInfo.numberOfDimensions > 1) {
                outlierAxisInfo = yInfo;
            }
            else {
                this._drawNormalRangeBar(ctx, index, rangebar);
                return;
            }
            var overlap = this._getOutlierOverlap(index, outlierAxisInfo);
            var outlierStyle = this.series.seriesOutlierIndicatorStyle;
            switch (outlierStyle) {
                case 0 /* TEAR */:
                    this._drawTearOutlier(ctx, prm, index, overlap, rangebar, outlierAxisInfo.threshInfo);
                    break;
                case 1 /* MARKER */:
                    this._drawMarkerOutlier(ctx, index, overlap, rangebar, outlierAxisInfo.threshInfo);
                    break;
            }
        };
        RangeBarsDrawStyle.prototype._getAxisInfo = function (dimension, prm) {
            switch (dimension) {
                case 1 /* X */:
                    return {
                        dataset: this._xData,
                        numberOfDimensions: this._xData.getDimension(),
                        scale: this._xScale,
                        bin: this._xBin,
                        dim: 1 /* X */,
                        threshInfo: {
                            min: this._xScale.threshMin,
                            max: this._xScale.threshMax,
                            maxPixel: ~~(prm.plot.subPlotFromNDC(this._xScale.lookup(this._xScale.threshMax, this._xBin), 1 /* X */)),
                            minPixel: ~~(prm.plot.subPlotFromNDC(this._xScale.lookup(this._xScale.threshMin, this._xBin), 1 /* X */))
                        }
                    };
                case 2 /* Y */:
                    return {
                        dataset: this._yData,
                        numberOfDimensions: this._yData.getDimension(),
                        scale: this._yScale,
                        bin: this._yBin,
                        dim: 2 /* Y */,
                        threshInfo: {
                            min: this._yScale.threshMin,
                            max: this._yScale.threshMax,
                            maxPixel: ~~(prm.plot.subPlotFromNDC(this._yScale.lookup(this._yScale.threshMax, this._yBin), 2 /* Y */)),
                            minPixel: ~~(prm.plot.subPlotFromNDC(this._yScale.lookup(this._yScale.threshMin, this._yBin), 2 /* Y */))
                        }
                    };
                default:
                    return undefined;
            }
        };
        RangeBarsDrawStyle.prototype._calculateRangeBarBounds = function (prm, index, xInfo, yInfo) {
            var xValues = this._getPixelValuesAtIndex(prm, index, xInfo);
            var yValues = this._getPixelValuesAtIndex(prm, index, yInfo);
            if (xValues === undefined || yValues === undefined) {
                return undefined;
            }
            var left = Number.POSITIVE_INFINITY;
            var right = Number.NEGATIVE_INFINITY;
            var top = Number.POSITIVE_INFINITY;
            var bottom = Number.NEGATIVE_INFINITY;
            if (xInfo.numberOfDimensions > 1) {
                left = _$1.min(xValues);
                right = _$1.max(xValues);
            }
            else {
                xValues = (_a = this._getBinInfo(prm, index, xInfo), left = _a[0], right = _a[1], _a);
            }
            if (yInfo.numberOfDimensions > 1) {
                top = _$1.min(yValues);
                bottom = _$1.max(yValues);
            }
            else {
                yValues = (_b = this._getBinInfo(prm, index, yInfo), top = _b[0], bottom = _b[1], _b);
            }
            var verticalLines = this._getRangeBarLines(top, bottom, xValues, true);
            var horizontalLines = this._getRangeBarLines(left, right, yValues, false);
            var rect = new Rectangle(left, top, right, bottom);
            return { verticalLines: verticalLines, horizontalLines: horizontalLines, rect: rect };
            var _a, _b;
        };
        RangeBarsDrawStyle.prototype._getPixelValuesAtIndex = function (prm, index, valuesInfo) {
            var values$$1 = [];
            for (var dimIndex = 0; dimIndex < valuesInfo.dataset.getDimension(); dimIndex++) {
                var val = valuesInfo.dataset.getAt(index, dimIndex);
                if (IsSomeInternalNAN(val)) {
                    return undefined;
                }
                else {
                    values$$1.push(val);
                }
            }
            var pixelValues = _$1.map(values$$1, function (value) {
                return ~~(prm.plot.subPlotFromNDC((valuesInfo.scale.lookup(value, valuesInfo.bin)), valuesInfo.dim));
            });
            return _$1.sortBy(pixelValues);
        };
        RangeBarsDrawStyle.prototype._getBinInfo = function (prm, index, binDataInfo) {
            var point = binDataInfo.dataset.getAt(index);
            var val, bin1, bin2, initOffset;
            _a = binDataInfo.scale.lookupRange(point), val = _a[0], bin1 = _a[1], bin2 = _a[2], initOffset = _a[3];
            var offset = initOffset >= 0.001 ? initOffset : 0;
            var binStartPixel = Math.round(prm.plot.subPlotFromNDC((bin1 + offset), binDataInfo.dim));
            var binEndPixel = Math.round(prm.plot.subPlotFromNDC((bin2 - offset), binDataInfo.dim));
            return [binStartPixel, binEndPixel];
            var _a;
        };
        RangeBarsDrawStyle.prototype._getRangeBarLines = function (start, end, values$$1, drawVertical) {
            return _$1.map(values$$1, function (value) {
                var pt1 = new Point(start, value);
                var pt2 = new Point(end, value);
                if (drawVertical) {
                    pt1 = new Point(pt1.y, pt1.x);
                    pt2 = new Point(pt2.y, pt2.x);
                }
                return Line.constructFromPoints(pt1, pt2);
            });
        };
        RangeBarsDrawStyle.prototype._calculatePixelPoints = function (prm, rect) {
            var pixX = Math.round(((rect.x1 + rect.x2) / 2) + prm.plotRect.x1);
            var pixY = Math.round(((rect.y1 + rect.y2) / 2) + prm.plotRect.y1);
            return { x: pixX, y: pixY };
        };
        RangeBarsDrawStyle.prototype._calculateInfoboxPixelPoints = function (prm, rect) {
            var pixX = Math.round(((rect.x1 + rect.x2) / 2) + prm.plotRect.x1);
            var pixY = Math.round(Math.min(rect.y1, rect.y2) + prm.plotRect.y1);
            return { x: pixX, y: pixY };
        };
        RangeBarsDrawStyle.prototype._addHitshape = function (prm, rect, index) {
            var hitBox = new FDSRectangleHitShape(rect.x1 + prm.plotRect.x1, rect.y1 + prm.plotRect.y1, rect.width, rect.height);
            hitBox.index = index;
            this.series.hitVector.push(hitBox);
        };
        /**
         * Adds selection markers for the series
         *
         * @protected
         * @param {PlotRenderManager} prm Plot render manager for plot
         * @param {Rectangle} rect RangeBar rectangle
         * @param {number} index Datapoint index
         * @param {boolean} [addMarkers] Used when called from a drawstyle that extends rangebars so isPointSampled is not
         *   called twice because each isPointSampled call increments the index.
         * @memberof RangeBarsDrawStyle
         */
        RangeBarsDrawStyle.prototype._addSelectionMarkers = function (prm, rect, index, addMarkers) {
            addMarkers = addMarkers ? addMarkers : this.seriesSelected && this._selectionSampler.isPointSampled(index);
            if (addMarkers) {
                this.cacheSelectable(prm, 0 /* NONE */, rect.x1, rect.y1);
                this.cacheSelectable(prm, 0 /* NONE */, rect.x1, rect.y2);
                this.cacheSelectable(prm, 0 /* NONE */, rect.x2, rect.y1);
                this.cacheSelectable(prm, 0 /* NONE */, rect.x2, rect.y2);
            }
        };
        RangeBarsDrawStyle.prototype._drawRangeBarLines = function (ctx, rangebar) {
            var verticalLines = rangebar.verticalLines, horizontalLines = rangebar.horizontalLines, rect = rangebar.rect;
            this._drawSegmentLines(ctx, verticalLines, horizontalLines);
            rect.stroke(ctx);
        };
        RangeBarsDrawStyle.prototype._drawSegmentLines = function (ctx, verticalLines, horizontalLines) {
            ctx.beginPath();
            // We always skip the first and last line because of the rectangle border
            // If skipping a step and the bar is horizontal, skip the last vertical segment line
            var skipEnd = (this._shouldSkipStep && !this.isVertical) ? 2 : 1;
            for (var index = 1; index < verticalLines.length - skipEnd; index++) {
                var _a = verticalLines[index], pt1 = _a.pt1, pt2 = _a.pt2;
                ctx.appendVerticalLineToPath(pt1.y, pt2.y, pt1.x);
            }
            // If skipping a step and the bar is vertical, skip the first horizontal segment line
            var skipStart = (this._shouldSkipStep && this.isVertical) ? 2 : 1;
            for (var index = skipStart; index < horizontalLines.length - 1; index++) {
                var _b = horizontalLines[index], pt1 = _b.pt1, pt2 = _b.pt2;
                ctx.appendHorizontalLineToPath(pt1.x, pt2.x, pt1.y);
            }
            ctx.stroke();
        };
        RangeBarsDrawStyle.prototype._fillRangeBar = function (ctx, index, rect, stepLines) {
            this._setBrushOnRangeBar(ctx, index, rect);
            if (!this._isStepped || this._useOutliers) {
                this._fillNormalBar(ctx, index, rect);
            }
            else {
                this._fillSteppedBar(ctx, stepLines);
            }
        };
        RangeBarsDrawStyle.prototype._setBrushOnRangeBar = function (ctx, index, rect) {
            if (this.series.useColor) {
                var color = this.series.getData(4 /* COLOR */).data[index];
                if (this._useOutliers) {
                    this._setColorMapColor(ctx, this._brush, color, index);
                }
                else {
                    this._setColorMapColor(ctx, this._brush, color, index, rect);
                }
            }
            else {
                this._brush.setOnCanvas(ctx, rect);
            }
        };
        RangeBarsDrawStyle.prototype._fillNormalBar = function (ctx, index, rect) {
            rect.fill(ctx);
        };
        RangeBarsDrawStyle.prototype._fillSteppedBar = function (ctx, stepLines) {
            var firstColor = this._brush.color;
            var lastColor = this._brush.gradientColor;
            // This is done in order to make the colors are drawn in the same
            // order as in Rangebars (which does this because of PC side)
            if (!this.isVertical) {
                _a = [lastColor, firstColor], firstColor = _a[0], lastColor = _a[1];
            }
            var _b = COLORREFtoRGB(firstColor), rFirst = _b[0], gFirst = _b[1], bFirst = _b[2];
            var _c = COLORREFtoRGB(lastColor), rLast = _c[0], gLast = _c[1], bLast = _c[2];
            // Number of steps is the number of sections in the box, minus the ends, and the skipped step if there is one
            var colorSteps = stepLines.length - ((this._shouldSkipStep) ? 3 : 2);
            var redStep = (rLast - rFirst) / colorSteps;
            var greenStep = (gLast - gFirst) / colorSteps;
            var blueStep = (bLast - bFirst) / colorSteps;
            // If skipping a step and vertical, skip the first line
            var stepIndex = (this._shouldSkipStep && this.isVertical) ? 1 : 0;
            // If skipping a step and horizontal, skip the last line
            var stepMax = (this._shouldSkipStep && !this.isVertical) ? stepLines.length - 2 : stepLines.length - 1;
            var fillBrush = new FDSBrush();
            fillBrush.style = 0 /* SOLID */;
            while (stepIndex < stepMax) {
                fillBrush.color = RGBtoCOLORREF(~~rFirst, ~~gFirst, ~~bFirst);
                var line1 = stepLines[stepIndex];
                var line2 = stepLines[stepIndex + 1];
                var segment = new Rectangle(line1.pt1.x, line1.pt1.y, line2.pt2.x, line2.pt2.y);
                fillBrush.setOnCanvas(ctx, segment);
                segment.fill(ctx);
                stepIndex++;
                rFirst += redStep;
                gFirst += greenStep;
                bFirst += blueStep;
            }
            var _a;
        };
        RangeBarsDrawStyle.prototype._getOutlierOverlap = function (index, dataInfo) {
            var values$$1 = [];
            for (var dimIndex = 0; dimIndex < dataInfo.dataset.getDimension(); dimIndex++) {
                values$$1.push(dataInfo.dataset.getAt(index, dimIndex));
            }
            var currentMin = _$1.min(values$$1);
            var currentMax = _$1.max(values$$1);
            var valueRange = new Range(currentMin, currentMax);
            var threshRange = new Range(dataInfo.threshInfo.min, dataInfo.threshInfo.max);
            return Range.CheckForOverlap(valueRange, threshRange);
        };
        RangeBarsDrawStyle.prototype._drawTearOutlier = function (ctx, prm, index, overlap, rangebar, threshInfo) {
            var verticalLines = rangebar.verticalLines, horizontalLines = rangebar.horizontalLines, rect = rangebar.rect;
            var breakSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorBreakSize, prm.plotRect.getWidth()));
            var hatchSize = scaleByDevicePixelRatio(factorHelper(this.series.seriesOutlierIndicatorHatchSize, prm.plotRect.getWidth()));
            var breakSign = threshInfo.minPixel > threshInfo.maxPixel ? -1 : 1;
            var hatchOffset = (hatchSize * 2 * breakSign);
            var maxPt = threshInfo.maxPixel - hatchOffset;
            var minPt = threshInfo.minPixel + hatchOffset;
            var p1X = rect.x1;
            var p1Y = rect.y2 + 1;
            var p2X = rect.x2 + 1;
            var p2Y = rect.y1;
            var penOffset = this._penProps.aliasOffset;
            this._setBrushOnRangeBar(ctx, index, rect);
            switch (overlap) {
                case 2 /* AROUND */:
                    if (this.isVertical) {
                        OutlierRender.breakColumnLong(ctx, p1X, p1Y, p2X, p2Y, 0, maxPt, 0, minPt, breakSize, true, penOffset);
                    }
                    else {
                        OutlierRender.breakBarsLong(ctx, p1X, p1Y, p2X, p2Y, maxPt, 0, minPt, 0, breakSize, true, penOffset);
                    }
                    break;
                case 1 /* OVERLAP_START */:
                    if (this.isVertical) {
                        OutlierRender.breakColumn(ctx, p1X, p1Y, p2X, p2Y, 0, minPt, breakSize, true, penOffset);
                    }
                    else {
                        OutlierRender.breakBars(ctx, p1X, p1Y, p2X, p2Y, minPt, 0, breakSize, true, penOffset);
                    }
                    break;
                case 5 /* OVERLAP_END */:
                    if (this.isVertical) {
                        OutlierRender.breakColumn(ctx, p1X, p1Y, p2X, p2Y, 0, maxPt, breakSize, true, penOffset);
                    }
                    else {
                        OutlierRender.breakBars(ctx, p1X, p1Y, p2X, p2Y, maxPt, 0, breakSize, true, penOffset);
                    }
                    break;
                default:
                    this._drawNormalRangeBar(ctx, index, rangebar);
                    return;
            }
            this._drawSegmentLines(ctx, verticalLines, horizontalLines);
        };
        RangeBarsDrawStyle.prototype._drawMarkerOutlier = function (ctx, index, overlap, rangebar, threshInfo) {
            var markerStyle = this.series.seriesOutlierIndicatorMarkerStyle;
            var markerSize = this.series.seriesOutlierIndicatorSize;
            this._drawNormalRangeBar(ctx, index, rangebar);
            ctx.save();
            // Set up outlier pen/brush
            this.series.seriesOutlierIndicatorFGPen.setOnCanvas(ctx);
            this.series.seriesOutlierIndicatorBGBrush.setOnCanvas(ctx);
            var rect = rangebar.rect;
            var xCenter = Math.round((rect.x1 + rect.x2 + 1) / 2.0);
            var yCenter = Math.round((rect.y1 + rect.y2 + 1) / 2.0);
            var markerOffset = markerSize / 2;
            var markerSign = threshInfo.minPixel > threshInfo.maxPixel ? -1 : 1;
            var minMarker = threshInfo.minPixel + (markerOffset * markerSign);
            var maxMarker = threshInfo.maxPixel - (markerOffset * markerSign);
            switch (overlap) {
                case 0 /* CLEAR_START */:
                case 1 /* OVERLAP_START */:
                    if (this.isVertical) {
                        this.drawOutlierMarkerCorrectly(ctx, xCenter, minMarker, markerStyle, markerSize);
                    }
                    else {
                        this.drawOutlierMarkerCorrectly(ctx, minMarker, yCenter, markerStyle, markerSize);
                    }
                    break;
                case 2 /* AROUND */:
                    if (this.isVertical) {
                        this.drawOutlierMarkerCorrectly(ctx, xCenter, minMarker, markerStyle, markerSize);
                        this.drawOutlierMarkerCorrectly(ctx, xCenter, maxMarker, markerStyle, markerSize);
                    }
                    else {
                        this.drawOutlierMarkerCorrectly(ctx, minMarker, yCenter, markerStyle, markerSize);
                        this.drawOutlierMarkerCorrectly(ctx, maxMarker, yCenter, markerStyle, markerSize);
                    }
                    break;
                case 5 /* OVERLAP_END */:
                case 6 /* CLEAR_END */:
                    if (this.isVertical) {
                        this.drawOutlierMarkerCorrectly(ctx, xCenter, maxMarker, markerStyle, markerSize);
                    }
                    else {
                        this.drawOutlierMarkerCorrectly(ctx, maxMarker, yCenter, markerStyle, markerSize);
                    }
                    break;
            }
            ctx.restore();
        };
        RangeBarsDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        RangeBarsDrawStyle.prototype.verify = function () {
            if (this._yData.getDimension() > 1) {
                if (this._yData.allRepeatingValues && this.series.rangeBarSameDataToLine) {
                    return false;
                }
                return true;
            }
            if (this._xData.getDimension() > 1) {
                if (this._xData.allRepeatingValues && this.series.rangeBarSameDataToLine) {
                    return false;
                }
                return true;
            }
            return false;
        };
        RangeBarsDrawStyle.prototype._getAttributesForDrawing = function (ctx, legend) {
            if (legend === void 0) { legend = false; }
            this._pen = this.series.seriesOutlinePen;
            if (legend) {
                // use a special thin pen to draw the legend
                this._pen = this._pen.with({ width: 1 });
            }
            this._pen.setOnCanvas(ctx);
            this._penProps = this._pen.toPropertyObject();
            this._brush = this.series.seriesBGBrush;
            this._brush.setOnCanvas(ctx);
            this._isStepped = this.series.attributeSet.get('SeriesBGStyle') === 4 /* STEPPED */;
            this._shouldSkipStep = this.series.attributeSet.get('SteppedSkipFirst');
            var outliersActive = this._xScale.outlierActive() || this._yScale.outlierActive();
            this._useOutliers = this.series.seriesOutlierIndicator && outliersActive;
        };
        RangeBarsDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._getAttributesForDrawing(ctx, true);
            var aliasOffset = this._penProps.aliasOffset;
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.7);
            var size = Math.min(width, (~~(height * 0.7)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            var halfminus = ~~(minus / 2);
            ctx.fillRect(~~x - halfminus + aliasOffset, ~~y - plus + aliasOffset, halfminus + halfplus, minus + plus);
            ctx.strokeRect(~~x - halfminus + aliasOffset, ~~y - plus + aliasOffset, halfminus + halfplus, minus + plus);
            ctx.beginPath();
            ctx.moveTo(~~x - halfminus, ~~y + aliasOffset);
            ctx.lineTo(~~x + halfplus, ~~y + aliasOffset);
            ctx.stroke();
        };
        return RangeBarsDrawStyle;
    }(BaseDrawStyle));
    
    var RangeCandleDrawStyle = /** @class */ (function (_super) {
        __extends(RangeCandleDrawStyle, _super);
        function RangeCandleDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._drawWick = getPixelAlignedFunctor({ isVertical: _this.isVertical });
            _this._drawWickCross = getPixelAlignedFunctor({ isVertical: !_this.isVertical });
            return _this;
        }
        RangeCandleDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            this._getAttributesForDrawing(ctx);
            var xInfo = this._getAxisInfo(1 /* X */, prm);
            var yInfo = this._getAxisInfo(2 /* Y */, prm);
            var mainAxisInfo = this.isVertical ? xInfo : yInfo;
            var multiDimAxisInfo = this.isVertical ? yInfo : xInfo;
            var pixelPoints = {};
            for (var index = 0; index < this.series.size; index += this._step) {
                var rangecandle = this._calculateRangeCandleInfo(prm, index, mainAxisInfo, multiDimAxisInfo);
                if (rangecandle === undefined) {
                    continue;
                }
                pixelPoints[index] = this._addInteractivityFeaturesWithWicks(prm, rangecandle, index);
                this._fillCandle(ctx, index, rangecandle);
                this._drawRangeCandleLines(ctx, rangecandle);
            }
            this._resetColorMapColor(this._brush);
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        RangeCandleDrawStyle.prototype._addInteractivityFeaturesWithWicks = function (prm, rangecandle, index) {
            this._addHitshapesWithWicks(prm, rangecandle, index);
            this._addSelectionMarkersWithWicks(prm, rangecandle, index);
            return _super.prototype._calculatePixelPoints.call(this, prm, rangecandle.rect);
        };
        RangeCandleDrawStyle.prototype._calculateRangeCandleInfo = function (prm, index, binAxisInfo, valuesAxisInfo) {
            var _a = _super.prototype._getBinInfo.call(this, prm, index, binAxisInfo), binStartPixel = _a[0], binEndPixel = _a[1];
            var pixelValues = _super.prototype._getPixelValuesAtIndex.call(this, prm, index, valuesAxisInfo);
            if (pixelValues === undefined) {
                return undefined;
            }
            return this._calculateCandleAndWicks(pixelValues, binStartPixel, binEndPixel);
        };
        RangeCandleDrawStyle.prototype._calculateCandleAndWicks = function (values$$1, start, end) {
            var wickValue1 = _$1.first(values$$1);
            var wickValue2 = _$1.last(values$$1);
            var candleValues = values$$1.slice(1, values$$1.length - 1);
            var candleLines = _super.prototype._getRangeBarLines.call(this, start, end, candleValues, !this.isVertical);
            var rect = new Rectangle(_$1.first(candleLines).pt1.x, _$1.first(candleLines).pt1.y, _$1.last(candleLines).pt2.x, _$1.last(candleLines).pt2.y);
            var rectCenter = rect.centerPoint();
            var wicks = [];
            if (this.isVertical) {
                wicks.push(Line.constructFromValues(~~rectCenter.x, wickValue1, ~~rectCenter.x, rect.y1 + 1));
                wicks.push(Line.constructFromValues(~~rectCenter.x, rect.y2, ~~rectCenter.x, wickValue2 + 1));
            }
            else {
                wicks.push(Line.constructFromValues(wickValue1, ~~rectCenter.y, rect.x1 + 1, ~~rectCenter.y));
                wicks.push(Line.constructFromValues(rect.x2, ~~rectCenter.y, wickValue2 + 1, ~~rectCenter.y));
            }
            return { rect: rect, candleLines: candleLines, wicks: wicks };
        };
        RangeCandleDrawStyle.prototype._addHitshapesWithWicks = function (prm, rangecandle, index) {
            var _this = this;
            _super.prototype._addHitshape.call(this, prm, rangecandle.rect, index);
            var addLineHitshape = function (line) {
                var shape = new FDSLineHitShape(line.pt1.x + prm.plotRect.x1, line.pt1.y + prm.plotRect.y1, line.pt2.x + prm.plotRect.x1, line.pt2.y + prm.plotRect.y1);
                shape.index = index;
                _this.series.hitVector.push(shape);
            };
            addLineHitshape(_$1.first(rangecandle.wicks));
            addLineHitshape(_$1.last(rangecandle.wicks));
            if (this._wickStyle === 1 /* T */) {
                var _a = this._getWickCrossLines(rangecandle), wickCross1 = _a[0], wickCross2 = _a[1];
                addLineHitshape(wickCross1);
                addLineHitshape(wickCross2);
            }
        };
        RangeCandleDrawStyle.prototype._addSelectionMarkersWithWicks = function (prm, rangecandle, index) {
            if (this.seriesSelected && this._selectionSampler.isPointSampled(index)) {
                _super.prototype._addSelectionMarkers.call(this, prm, rangecandle.rect, index, true);
                var wick1 = _$1.first(rangecandle.wicks);
                var wick2 = _$1.last(rangecandle.wicks);
                this.cacheSelectable(prm, 0 /* NONE */, wick1.pt1.x, wick1.pt1.y);
                this.cacheSelectable(prm, 0 /* NONE */, wick2.pt2.x, wick2.pt2.y);
            }
        };
        RangeCandleDrawStyle.prototype._fillCandle = function (ctx, index, rangecandle) {
            _super.prototype._fillRangeBar.call(this, ctx, index, rangecandle.rect, rangecandle.candleLines);
        };
        RangeCandleDrawStyle.prototype._drawRangeCandleLines = function (ctx, rangecandle) {
            if (this.isVertical) {
                _super.prototype._drawRangeBarLines.call(this, ctx, { verticalLines: [],
                    horizontalLines: rangecandle.candleLines,
                    rect: rangecandle.rect });
            }
            else {
                _super.prototype._drawRangeBarLines.call(this, ctx, { verticalLines: rangecandle.candleLines,
                    horizontalLines: [],
                    rect: rangecandle.rect });
            }
            ctx.beginPath();
            this._drawWick(ctx, _$1.first(rangecandle.wicks));
            this._drawWick(ctx, _$1.last(rangecandle.wicks));
            if (this._wickStyle === 1 /* T */) {
                var _a = this._getWickCrossLines(rangecandle), wickCross1 = _a[0], wickCross2 = _a[1];
                this._drawWickCross(ctx, wickCross1);
                this._drawWickCross(ctx, wickCross2);
            }
            ctx.stroke();
        };
        RangeCandleDrawStyle.prototype._getWickCrossLines = function (rangecandle) {
            var rect = rangecandle.rect, wicks = rangecandle.wicks;
            var wickCross1, wickCross2;
            var wick1 = _$1.first(wicks);
            var wick2 = _$1.last(wicks);
            if (this.isVertical) {
                wickCross1 = Line.constructFromValues(rect.x1, wick1.pt1.y, rect.x2 + 1, wick1.pt1.y);
                wickCross2 = Line.constructFromValues(rect.x1, wick2.pt2.y - 1, rect.x2 + 1, wick2.pt2.y - 1);
            }
            else {
                wickCross1 = Line.constructFromValues(wick1.pt1.x, rect.y1, wick1.pt1.x, rect.y2 + 1);
                wickCross2 = Line.constructFromValues(wick2.pt2.x - 1, rect.y1, wick2.pt2.x - 1, rect.y2 + 1);
            }
            return [wickCross1, wickCross2];
        };
        RangeCandleDrawStyle.prototype.hint = function () {
            return 4 /* RANGEBAR */;
        };
        RangeCandleDrawStyle.prototype.verify = function () {
            var xdim = this._xData.getDimension();
            var ydim = this._yData.getDimension();
            if ((xdim === 1 && ydim >= 4) || (xdim >= 4 && ydim === 1)) {
                return true;
            }
            else {
                console.warn("Data dimensions incorrect.  This drawstyle requires 1 x dataset and 4+ y datasets or 4+ x datasets and 1 y dataset.  The series provided has " + xdim + " x datasets and " + ydim + " y datasets.");
                return false;
            }
        };
        RangeCandleDrawStyle.prototype._getAttributesForDrawing = function (ctx, legend) {
            if (legend === void 0) { legend = false; }
            _super.prototype._getAttributesForDrawing.call(this, ctx, legend);
            this._wickStyle = this.series.attributeSet.get('WickStyle');
        };
        RangeCandleDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._getAttributesForDrawing(ctx, true);
            // Floor everything in case it was passed as not a whole number
            x = ~~x;
            y = ~~y;
            width = ~~width;
            height = ~~height;
            // Input x/y are the center of the available space, offset them to the top left corner
            var XYOffset = ~~(Math.min(width, height) / 2);
            // Scale to an appropriate factor to be consistent with other legend markers
            var size = Math.min(~~(width * 0.85), ~~(height * 0.85));
            var sizeOffset = ~~((height - size) / 2);
            // Left/top are x/y plus offsets, minus 1 pixel for consistency with other legend markers
            var left = x - XYOffset + sizeOffset - 1;
            var top = y - XYOffset + sizeOffset - 1;
            var values$$1;
            var legendInfo;
            if (this.isVertical) {
                values$$1 = [top, top + ~~(size * 0.25), top + ~~(size * 0.5), top + ~~(size * 0.75), top + size];
                legendInfo = this._calculateCandleAndWicks(values$$1, left + ~~(size * 0.25), left + ~~(size * 0.75));
            }
            else {
                // Will be translated x,y -> y,x so the values have to start halfway down
                values$$1 = [left + ~~(size * 0.5),
                    left + ~~(size * 0.75),
                    left + size,
                    left + ~~(size * 1.25),
                    left + ~~(size * 1.5)];
                legendInfo = this._calculateCandleAndWicks(values$$1, top + ~~(size * 0.25), top + ~~(size * 0.75));
            }
            this._fillCandle(ctx, 0, legendInfo);
            this._drawRangeCandleLines(ctx, legendInfo);
        };
        return RangeCandleDrawStyle;
    }(RangeBarsDrawStyle));
    
    var RectDrawStyle = /** @class */ (function (_super) {
        __extends(RectDrawStyle, _super);
        function RectDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RectDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            // Don't bother if everything is null.
            if (this.series.seriesFGPen.style === 5 /* NULL */ && this.series.seriesBGBrush.style === 1 /* NULL */) {
                return;
            }
            if (this.series.size < 2) {
                return;
            }
            ctx.save();
            var penProps = this._choosePens(ctx, false).penProps;
            var pixelPoints = {};
            this.series.seriesBGBrush.setOnCanvas(ctx, prm.plotRect);
            var x0 = 0;
            var y0 = 0;
            for (var i = 0; i < this.series.size; i += 2) {
                var xpt1 = this._xData.getAt(i);
                var xpt2 = this._xData.getAt(i + 1);
                var ypt1 = this._yData.getAt(i);
                var ypt2 = this._yData.getAt(i + 1);
                // skip bad points
                if (isNaN(xpt1) || isNaN(xpt2) || isNaN(ypt1) ||
                    isNaN(ypt2)) {
                    continue;
                }
                // Draw each data point as a point on a line
                var x = prm.plot.subPlotFromNDC((this._xScale.lookup(xpt1, this._xBin)), 1 /* X */);
                var y = prm.plot.subPlotFromNDC((this._yScale.lookup(ypt1, this._yBin)), 2 /* Y */);
                x0 = prm.plot.subPlotFromNDC((this._xScale.lookup(xpt2, this._xBin)), 1 /* X */);
                y0 = prm.plot.subPlotFromNDC((this._yScale.lookup(ypt2, this._yBin)), 2 /* Y */);
                var lineHitShapes = [];
                x0 = ~~x0 + penProps.aliasOffset;
                x = ~~x + penProps.aliasOffset;
                y0 = ~~y0 + penProps.aliasOffset;
                y = ~~y + penProps.aliasOffset;
                var xReverse = false;
                var yReverse = false;
                if (x > x0) {
                    xReverse = true;
                }
                if (y > y0) {
                    yReverse = true;
                }
                var x1 = Math.min(x0, x);
                var y1 = Math.min(y0, y);
                var x2 = Math.max(x0, x);
                var y2 = Math.max(y0, y);
                var w = Math.abs(x0 - x);
                var h = Math.abs(y0 - y);
                // save the pixel points, including the space before/above the plot rect
                // put it at the top of the rect so you can hit it when it's just an outline
                var pR = prm.plot.plotRect;
                var pixX = Math.round(x1 + (w / 2) + pR.x1);
                var pixY = Math.round(y1 + pR.y1);
                pixelPoints[i] = { x: pixX, y: pixY };
                // also add for the odd index, since it "counts" as part of this rect
                pixelPoints[i + 1] = { x: pixX, y: pixY };
                ctx.beginPath();
                ctx.rect(x1, y1, w, h);
                ctx.fill();
                ctx.stroke();
                var pt1 = new Point(x1, y1);
                var pt2 = new Point(x1 + w, y1 + h);
                // top line
                var midX = pt1.x + ((pt2.x - pt1.x) / 2);
                var hoverText = this.series.getTooltipLabel(i, false);
                // Just the border is hitshapes
                if (this.series.bgStyle === 1 /* NULL */) {
                    var dataPtOpp1 = new Point(pt2.x, pt1.y);
                    var dataPtOpp2 = new Point(pt1.x, pt2.y);
                    this._appendLine(prm, pt1, dataPtOpp1, hoverText, i);
                    this._appendLine(prm, dataPtOpp1, pt2, hoverText, i);
                    this._appendLine(prm, pt2, dataPtOpp2, hoverText, i);
                    this._appendLine(prm, dataPtOpp2, pt1, hoverText, i);
                }
                else {
                    var rect_1 = new FDSRectangleHitShape(x1 + prm.plotRect.x1, y1 + prm.plotRect.y1, w, h);
                    rect_1.index = i;
                    rect_1.hoverText = hoverText;
                    if (this.series.isInteractive(2 /* DRAGGABLE */)) {
                        rect_1.name = 5 /* SERIESHIT */;
                    }
                    this.series.hitVector.push(rect_1);
                }
                if (this._isInteractable) {
                    this.addBorderHitShapes(xpt1, ypt1, xpt2, ypt2, i, i + 1, prm);
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        RectDrawStyle.prototype._appendLine = function (prm, p1, p2, hoverText, index) {
            var line = new FDSLineHitShape(p1.x + prm.plotRect.x1, p1.y + prm.plotRect.y1, p2.x + prm.plotRect.x1, p2.y + prm.plotRect.y1);
            line.index = index;
            line.hoverText = hoverText;
            if (this.series.isInteractive(2 /* DRAGGABLE */)) {
                line.name = 5 /* SERIESHIT */;
            }
            return this.series.hitVector.push(line);
        };
        // helper function to select the necessary pens and brushes
        // (since the same logic is in both the main draw fn and the legend fn)
        // returns pen for use in drawing polylines
        RectDrawStyle.prototype._choosePens = function (ctx, legend) {
            var newPen = this.series.seriesOutlinePen;
            var newBrush;
            if (legend) {
                // use a special thin pen to draw the legend
                newPen = newPen.with({ width: 1 });
            }
            newPen.setOnCanvas(ctx);
            var penProps = newPen.toPropertyObject();
            // If the brush is hatched, we need to swap the brush color for the
            // foreground pen color.
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                newBrush = this.series.seriesBGBrush.copy();
                newBrush.color = this.series.seriesFGPen.color;
                newBrush.setOnCanvas(ctx);
            }
            else {
                // select the seriesBGBrush for drawing filled areas
                newBrush = this.series.seriesBGBrush;
                newBrush.setOnCanvas(ctx);
            }
            return { brush: newBrush, pen: newPen, penProps: penProps };
        };
        RectDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, true);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, ~~(height * 0.8));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            ctx.beginPath();
            ctx.moveTo(x - minus, y + minus);
            ctx.lineTo(x - minus, y - plus);
            ctx.lineTo(x + plus, y - plus);
            ctx.lineTo(x + plus, y + minus);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        RectDrawStyle.prototype.verify = function () {
            return true;
        };
        RectDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return RectDrawStyle;
    }(InteractiveDrawStyle));
    
    var RelativeAreaDrawStyle = /** @class */ (function (_super) {
        __extends(RelativeAreaDrawStyle, _super);
        function RelativeAreaDrawStyle(series) {
            return _super.call(this, series) || this;
        }
        RelativeAreaDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            var seriesOutlinePen = this.series.seriesOutlinePen;
            var seriesAlternateOutlinePen = this.series.seriesAlternateOutlinePen;
            var seriesPen = this.series.seriesFGPen;
            var seriesAlternatePen = this.series.seriesAlternateFGPen;
            var outlinePen = seriesOutlinePen;
            var currentFGPen = seriesPen;
            var topOnly = this.series.areaDrawTopLineOnly;
            ctx.save();
            var changeFunc = function (canvas, series, direction) {
                if (series.enableSeriesAlternateFGPen) {
                    if (direction === 1 /* UP */) {
                        outlinePen = seriesOutlinePen;
                        currentFGPen = seriesPen;
                        seriesPen.setOnCanvas(canvas);
                    }
                    else {
                        outlinePen = seriesAlternateOutlinePen;
                        currentFGPen = seriesAlternatePen;
                        seriesAlternatePen.setOnCanvas(canvas);
                    }
                }
            };
            var parent = this;
            var renderFunc = function (canvas, pen, p, p2) {
                if (topOnly) {
                    if (outlinePen != null) {
                        ctx.save();
                        outlinePen.setOnCanvas(ctx);
                        parent.strokePolyline(ctx, outlinePen, p2);
                        ctx.restore();
                    }
                    parent.strokePolyline(ctx, currentFGPen, p);
                }
                else {
                    for (var i = p2.length - 1; i >= 0; i--) {
                        p.push(p2[i]);
                    }
                    if (p.length > 0) {
                        p.push(p[0]);
                    }
                    parent.strokePolyline(ctx, currentFGPen, p);
                }
            };
            var tooltipFunc = function (plotRM, pt1, pt2, index1, index2) {
                parent._addLineHitShape(plotRM, pt1, pt2, index1, index2);
            };
            this._drawCore(changeFunc, renderFunc, tooltipFunc, prm, ctx);
            ctx.restore();
        };
        RelativeAreaDrawStyle.prototype.drawBackgroundToBuffer = function (prm, ctx) {
            var seriesBrush = this.series.seriesBGBrush;
            var seriesAlternateBrush = this.series.seriesAlternateBGBrush;
            var bgBrush = seriesBrush;
            ctx.save();
            var changeFunc = function (canvas, series, direction) {
                if (series.enableSeriesAlternateBGBrush) {
                    if (direction === 1 /* UP */) {
                        // seriesBrush should be captured
                        bgBrush = seriesBrush;
                    }
                    else {
                        // seriesAlternateBrush should be captured
                        bgBrush = seriesAlternateBrush;
                    }
                }
            };
            var parent = this;
            var renderFunc = function (canvas, pen, p, p2) {
                for (var i = p2.length - 1; i >= 0; i--) {
                    p.push(p2[i]);
                }
                if (p.length > 0) {
                    p.push(p[0]);
                }
                bgBrush.setOnCanvas(ctx, Rectangle.constructBoundingBoxFromPts(p));
                parent.fillPolygon(canvas, p);
            };
            this._drawCore(changeFunc, renderFunc, (function () {
            }), prm, ctx);
            ctx.restore();
        };
        RelativeAreaDrawStyle.prototype._drawCore = function (handleDirection, handleRender, handleTooltips, prm, ctx) {
            var y1Scale = this._yScale;
            var y2Scale = this._yScale;
            var series2 = this.root.getChild(this.series.attributeSet.get('ReferenceSeriesName'));
            if (isSeries(series2)) {
                if (series2.visible) {
                    var scale = void 0;
                    if (scale = series2.getScale(2 /* Y */)) {
                        y2Scale = scale;
                    }
                }
            }
            if ((y1Scale == null) || (y2Scale == null)) {
                return;
            }
            var p = [];
            var p2 = [];
            var appendPoints = function (pt1, pt2) {
                p.push(pt1);
                p2.push(pt2);
            };
            var replaceLastPoints = function (pt1, pt2) {
                if (p.length <= 0 || p2.length <= 0) {
                    return;
                }
                p[p.length - 1] = pt1;
                p2[p2.length - 1] = pt2;
            };
            var oldIndex = -1;
            var oldPoint = new Point(0, 0);
            var direction = 0;
            var selectionSampler = new FDSSeriesSampler(this.series, 1 /* X */, this._start, this._end, this._step);
            this.series.seriesFGPen.setOnCanvas(ctx);
            this.series.seriesBGBrush.setOnCanvas(ctx);
            var data = new ZippedSeriesData(this.series);
            var iter = data.begin;
            while (!iter.equals(data.end)) {
                var x1 = prm.plot.subPlotFromNDC(this._xScale.lookup(iter.value.X), 1 /* X */);
                var y1 = prm.plot.subPlotFromNDC(y1Scale.lookup(iter.value.Y1), 2 /* Y */);
                var y2 = prm.plot.subPlotFromNDC(y2Scale.lookup(iter.value.Y2), 2 /* Y */);
                var newDirection = 0;
                if (fuzzyLT(y2, y1)) {
                    newDirection = 2 /* DOWN */;
                }
                else if (fuzzyGT(y2, y1)) {
                    newDirection = 1 /* UP */;
                }
                handleDirection(ctx, this.series, direction);
                var pt1 = new Point(x1, y1);
                var pt2 = new Point(x1, y2);
                appendPoints(pt1, pt2);
                var count = p.length;
                if (iter.value.XIndex === iter.value.Y1Index) {
                    handleTooltips(prm, oldPoint, p[count - 1], oldIndex, iter.value.XIndex);
                    oldIndex = iter.value.XIndex;
                    oldPoint = p[count - 1];
                }
                if (newDirection !== direction && direction !== 0 /* NONE */) {
                    if (newDirection === 0 /* NONE */) {
                        handleRender(ctx, this.series.seriesFGPen, p, p2);
                        p = [];
                        p2 = [];
                        appendPoints(pt1, pt2);
                    }
                    else {
                        var intersection = void 0;
                        var lastPt1 = p[count - 2];
                        pt1 = p[count - 1];
                        var lastPt2 = p2[count - 2];
                        pt2 = p2[count - 1];
                        if (intersection = FDSLineHitShape.prototype.tryGetIntersection(p[count - 2], p[count - 1], p2[count - 2], p2[count - 1])) {
                            replaceLastPoints(intersection, intersection);
                            handleRender(ctx, this.series.seriesFGPen, p, p2);
                            p = [];
                            p2 = [];
                            appendPoints(intersection, intersection);
                            appendPoints(pt1, pt2);
                        }
                        else {
                            if (ENABLE_DEBUG) {
                                console.log("RelativeAreaDrawStyle::drawCore y values crossed but segments didnt intersect. Shouldn't happen");
                            }
                        }
                    }
                }
                direction = newDirection;
                iter.increment();
            }
            handleDirection(ctx, this.series, direction);
            handleRender(ctx, this.series.seriesFGPen, p, p2);
        };
        RelativeAreaDrawStyle.prototype._addLineHitShape = function (prm, pt1, pt2, index1, index2) {
            var hitShapeSize = this.series.datapointHitShapeSize;
            var pt3 = new Point((pt1.x + pt2.x) / 2.0, (pt1.y + pt2.y) / 2.0);
            var rect = new FDSRectangleHitShape((pt2.x - hitShapeSize) + prm.plotRect.x1, (pt2.y - hitShapeSize) + prm.plotRect.y1, 2 * hitShapeSize, 2 * hitShapeSize);
            rect.index = index2;
            this.series.hitVector.push(rect);
            if (index1 !== -1) {
                var line1 = new FDSLineHitShape(pt1.x + prm.plotRect.x1, pt1.y + prm.plotRect.y1, pt3.x + prm.plotRect.x1, pt3.y + prm.plotRect.y1);
                var line2 = new FDSLineHitShape(pt3.x + prm.plotRect.x1, pt3.y + prm.plotRect.y1, pt2.x + prm.plotRect.x1, pt2.y + prm.plotRect.y1);
                line1.index = index1;
                line2.index = index2;
                this.series.hitVector.push(line1);
                this.series.hitVector.push(line2);
            }
        };
        RelativeAreaDrawStyle.prototype.verify = function () {
            return this.series.getData(2 /* Y */).getDimension() === 2 ||
                this.series.attributeSet.get('ReferenceSeriesName').length !== 0 ||
                this.series.attributeSet.get('ReferenceSeriesIsRegression');
        };
        RelativeAreaDrawStyle.prototype.hint = function () {
            return 9 /* AREA */;
        };
        RelativeAreaDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            AreaDrawStyle.prototype.drawLegendPreview.call(this, ctx, x, y, width, height);
        };
        return RelativeAreaDrawStyle;
    }(BaseDrawStyle));
    var DataPtTuple = /** @class */ (function () {
        function DataPtTuple(X, Y) {
            this.X = X;
            this.Y = Y;
        }
        return DataPtTuple;
    }());
    var DataTuple = /** @class */ (function () {
        function DataTuple(X, Y1, Y2, XIndex, Y1Index, Y2Index) {
            this.X = X;
            this.Y1 = Y1;
            this.Y2 = Y2;
            this.XIndex = XIndex;
            this.Y1Index = Y1Index;
            this.Y2Index = Y2Index;
        }
        return DataTuple;
    }());
    var RegressionHelper = /** @class */ (function () {
        function RegressionHelper(series, xData, yData) {
            _a = series.getLogRegressionFlags(), this.logRegressionX = _a[0], this.logRegressionY = _a[1];
            this.pXScale = series.getScale(1 /* X */);
            this.pYScale = series.getScale(2 /* Y */);
            this.regressionData = series.getRegressionData();
            this.regressionOrder = series.regressionOrder;
            this.xMin = this.pXScale.compressValue(xData.Min()[0], this.logRegressionX);
            this.yMin = this.pYScale.compressValue(yData.Min()[0], this.logRegressionY);
            this.xScale = this.pXScale.compressValue(xData.Max()[0], this.logRegressionX) - this.xMin;
            this.yScale = this.pYScale.compressValue(yData.Max()[0], this.logRegressionY) - this.yMin;
            var _a;
        }
        RegressionHelper.prototype.getYValueAtX = function (xPt) {
            var xAdjusted = this.pXScale.computeValueUnbinned(this.pXScale.lookup(xPt));
            var xVal = (this.pXScale.compressValue(xAdjusted, this.logRegressionX) - this.xMin) / this.xScale;
            var yVal = polyinterp(this.regressionData, this.regressionOrder + 1, xVal);
            return this.pYScale.decompressValue((yVal * this.yScale) + this.yMin, this.logRegressionY);
        };
        return RegressionHelper;
    }());
    var SortedSeriesDataIterator = /** @class */ (function () {
        function SortedSeriesDataIterator(series, dimension, index) {
            this.series = series;
            this.dimension = dimension;
            this.index = index;
            if ((this.series == null) || (this.dimension == null) || (this.index == null)) {
                return;
            }
            this.xData = this.series.getData(1 /* X */);
            this.yData = this.series.getData(2 /* Y */);
            this.xScale = this.series.getScale(1 /* X */);
            this.yScale = this.series.getScale(2 /* Y */);
            this.isSeriesSorted = true;
            this.value = null;
            this.sortedData = [];
            if (this.dimension < 0) {
                this.regressionHelper = new RegressionHelper(this.series, this.xData, this.yData);
            }
            if (!this.xData.sorted || !this.xData.ascending) {
                for (var i = 0; i < this.series.size; i++) {
                    var pt = this._getDataPt(i);
                    if (NOTNAN(pt.X) && NOTNAN(pt.Y)) {
                        this.sortedData.push(pt);
                    }
                }
                this.sortedData.sort(function (a, b) { return a.X - b.X; });
                if (this.index < this.series.size && this.sortedData.length > 0) {
                    this.value = this.sortedData[0];
                }
                this.isSeriesSorted = false;
            }
            else if (this.index < this.series.size) {
                this.value = this._getDataPt(this.index);
            }
        }
        SortedSeriesDataIterator.prototype.compressX = function (val) {
            return this.xScale.compressValue(val);
        };
        SortedSeriesDataIterator.prototype.compressY = function (val) {
            return this.yScale.compressValue(val);
        };
        SortedSeriesDataIterator.prototype.decompressY = function (val) {
            return this.yScale.decompressValue(val);
        };
        SortedSeriesDataIterator.prototype.increment = function () {
            var _this = this;
            if (this.isSeriesSorted) {
                var func = function () {
                    _this.index++;
                    if (_this.index < _this.series.size) {
                        _this.value = _this._getDataPt(_this.index);
                    }
                };
                var condition = function () {
                    return (ISNAN(_this.value.X) || ISNAN(_this.value.Y)) && _this.index < _this.series.size;
                };
                func();
                while (condition()) {
                    func();
                }
            }
            else {
                this.index++;
                if (this.index < this.sortedData.length) {
                    this.value = this.sortedData[this.index];
                }
            }
        };
        SortedSeriesDataIterator.prototype._getDataPt = function (index) {
            var x = this.xData.getAt(index);
            var y;
            if (this.regressionHelper == null) {
                y = this.yData.getAt(index, this.dimension);
            }
            else {
                y = this.regressionHelper.getYValueAtX(x);
            }
            return new DataPtTuple(x, y);
        };
        SortedSeriesDataIterator.prototype.equals = function (other) {
            return this.index === other.index || (this.index >= this.series.size && other.index >= other.series.size);
        };
        SortedSeriesDataIterator.prototype.assign = function (other) {
            this.index = other.index;
            return this.value = other.value;
        };
        SortedSeriesDataIterator.prototype.copy = function () {
            return new SortedSeriesDataIterator(this.series, this.dimension, this.index);
        };
        return SortedSeriesDataIterator;
    }());
    var SortedSeriesData = /** @class */ (function () {
        function SortedSeriesData(series, dimension) {
            this.series = series;
            this.dimension = dimension;
            this.begin = new SortedSeriesDataIterator(this.series, this.dimension, 0);
            this.end = new SortedSeriesDataIterator(this.series, this.dimension, this.series.size);
        }
        return SortedSeriesData;
    }());
    var ZippedSeriesDataIterator = /** @class */ (function () {
        function ZippedSeriesDataIterator(series, isEnd) {
            this.value = null;
            this.data1 = new SortedSeriesData(series, 0);
            if (series.attributeSet.get('ReferenceSeriesIsRegression')) {
                this.data2 = new SortedSeriesData(series, -1);
            }
            else {
                var refSeriesName = series.attributeSet.get('ReferenceSeriesName');
                var refSeries = series.root.getChild(refSeriesName);
                if (isSeries(refSeries)) {
                    this.data2 = new SortedSeriesData(refSeries, 0);
                }
                else {
                    this.data2 = new SortedSeriesData(series, 1);
                }
            }
            if (!isEnd) {
                this.iter1 = this.data1.begin;
                this.iter2 = this.data2.begin;
            }
            else {
                this.iter1 = this.data1.end;
                this.iter2 = this.data2.end;
            }
            this._findStartValue();
        }
        ZippedSeriesDataIterator.prototype._isAtEnd = function () {
            return this.iter1.equals(this.data1.end) || this.iter2.equals(this.data2.end);
        };
        ZippedSeriesDataIterator.prototype._updateValueImpl = function (iter1, end1, iter2, end2) {
            var intersection;
            var y1;
            var y2;
            var y1Index;
            var y2Index;
            if ((intersection = this._getXIntersection(iter1.copy(), end1, iter2)) != null) {
                if (iter2 === this.iter1) {
                    y1 = this.iter1.value.Y;
                    y1Index = this.iter1.index;
                }
                else {
                    y1 = intersection;
                    y1Index = 0;
                }
                if (iter2 === this.iter2) {
                    y2 = this.iter2.value.Y;
                    y2Index = this.iter2.index;
                }
                else {
                    y2 = intersection;
                    y2Index = 0;
                }
                this.value = new DataTuple(iter2.value.X, y1, y2, iter2.index, y1Index, y2Index);
            }
            else {
                iter2.assign(end2);
            }
        };
        ZippedSeriesDataIterator.prototype._findStartValue = function () {
            var _this = this;
            var findStartImpl = function (iter1, end1, iter2, end2) {
                iter1.assign(_this._increment_dont_pass(iter1, end1, iter2));
                _this._updateValueImpl(iter1, end1, iter2, end2);
            };
            if (!this._isAtEnd()) {
                if (fuzzyLT(this.iter1.value.X, this.iter2.value.X)) {
                    findStartImpl(this.iter1, this.data1.end, this.iter2, this.data2.end);
                }
                else if (fuzzyGT(this.iter1.value.X, this.iter2.value.X)) {
                    findStartImpl(this.iter2, this.data2.end, this.iter1, this.data1.end);
                }
                else {
                    this.value = new DataTuple(this.iter1.value.X, this.iter1.value.Y, this.iter2.value.Y, this.iter1.index, this.iter1.index, this.iter2.index);
                }
            }
        };
        ZippedSeriesDataIterator.prototype._updateValue = function () {
            var last1 = this.iter1.copy();
            var last2 = this.iter2.copy();
            this.iter1.increment();
            this.iter2.increment();
            if (!this._isAtEnd()) {
                if (fuzzyLT(this.iter1.value.X, this.iter2.value.X)) {
                    this._updateValueImpl(last2, this.data2.end, this.iter1, this.data1.end);
                    this.iter2.assign(last2);
                }
                else if (fuzzyGT(this.iter1.value.X, this.iter2.value.X)) {
                    this._updateValueImpl(last1, this.data1.end, this.iter2, this.data2.end);
                    this.iter1.assign(last1);
                }
                else {
                    this.value = new DataTuple(this.iter1.value.X, this.iter1.value.Y, this.iter2.value.Y, this.iter1.index, this.iter1.index, this.iter2.index);
                }
            }
        };
        ZippedSeriesDataIterator.prototype._getXIntersection = function (iter, end, intersectionPt) {
            var intersection;
            var segment = this._increment_until_past(iter, end, intersectionPt.value.X);
            if (segment == null) {
                return null;
            }
            var pt1 = new Point(iter.compressX(segment[0].X), iter.compressY(segment[0].Y));
            var pt2 = new Point(iter.compressX(segment[1].X), iter.compressY(segment[1].Y));
            if (intersection = FDSLineHitShape.tryGetIntersectionWithX(pt1, pt2, iter.compressX(intersectionPt.value.X))) {
                return iter.decompressY(intersection.y);
            }
            else {
                return null;
            }
        };
        ZippedSeriesDataIterator.prototype._increment_dont_pass = function (iter, end, thresh) {
            var last$$1 = null;
            var func = function () {
                last$$1.assign(iter);
                iter.increment();
            };
            var condition = function () { return fuzzyLT(iter.value.X, thresh.value.X) && !iter.equals(end); };
            func();
            while (condition()) {
                func();
            }
            return last$$1;
        };
        ZippedSeriesDataIterator.prototype._increment_until_past = function (iter, end, thresh) {
            var lastValue = null;
            var func = function () {
                lastValue = iter.value;
                iter.increment();
            };
            var condition = function () { return fuzzyLT(iter.value.X, thresh) && !iter.equals(end); };
            func();
            while (condition()) {
                func();
            }
            if (!iter.equals(end)) {
                return [lastValue, iter.value];
            }
            else {
                return null;
            }
        };
        ZippedSeriesDataIterator.prototype.increment = function () {
            if (this._isAtEnd()) {
                return;
            }
            this._updateValue();
        };
        ZippedSeriesDataIterator.prototype.equals = function (other) {
            return this._isAtEnd() && other._isAtEnd();
        };
        return ZippedSeriesDataIterator;
    }());
    var ZippedSeriesData = /** @class */ (function () {
        function ZippedSeriesData(series) {
            this.series = series;
            this.begin = new ZippedSeriesDataIterator(this.series, false);
            this.end = new ZippedSeriesDataIterator(this.series, true);
        }
        return ZippedSeriesData;
    }());
    
    var SpeedResistanceLevels = /** @class */ (function (_super) {
        __extends(SpeedResistanceLevels, _super);
        function SpeedResistanceLevels(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(50 /* SPEED_RESISTANCE_LEVELS */);
            return _this;
        }
        return SpeedResistanceLevels;
    }(FibonacciFan));
    
    var StepDrawStyle = /** @class */ (function (_super) {
        __extends(StepDrawStyle, _super);
        function StepDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StepDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            var vertHoriz = true;
            if ((this.series.attributeSet.get('StepDirection')) === 2 /* HORIZ_VERT */) {
                vertHoriz = false;
            }
            ctx.save();
            this.series.seriesFGPen.setOnCanvas(ctx);
            var breakOnNA = this.series.attributeSet.get('BreakOnNA');
            ctx.beginPath();
            var newline = true;
            var skipDp = false;
            var prevItem = 0;
            var pixelPoints = {};
            var pen = this.series.seriesFGPen;
            var props = pen.toPropertyObject();
            var x0;
            var y0;
            for (var j = this._start; j < this._end; j += this._step) {
                var i = this.series.getSampleIndex(j);
                var dataItem = this._xData.getAt(i);
                var yDataItem = this._yData.getAt(i);
                // helper function to break line (on NA or on gap)
                var startNewLine = function () {
                    pen.closePolyline();
                    ctx.stroke();
                    newline = true;
                    ctx.beginPath();
                };
                if (dataItem === undefined || yDataItem === undefined || isNaN(yDataItem)) {
                    if (breakOnNA) {
                        startNewLine();
                    }
                    continue;
                }
                var dpGap = (j > this._start) && this._xScale.gapBetweenDatapoints(prevItem, dataItem);
                prevItem = dataItem;
                if (this.series.breakOnGap && dpGap) {
                    startNewLine();
                }
                // Draw each data point as a point on a line
                var x = ~~(prm.plot.subPlotFromNDC(this._xScale.lookup(dataItem, this._xBin), 1 /* X */));
                var y = ~~(prm.plot.subPlotFromNDC(this._yScale.lookup(yDataItem, this._yBin), 2 /* Y */));
                if (!newline) {
                    var midpointX = void 0;
                    var midpointY = void 0;
                    if (vertHoriz) {
                        midpointX = x0;
                        midpointY = y;
                    }
                    else {
                        midpointX = x;
                        midpointY = y0;
                    }
                    this.series.seriesFGPen.drawPolyline(ctx, {
                        x: x0 + props.aliasOffset,
                        y: y0 + props.aliasOffset
                    }, {
                        x: midpointX + props.aliasOffset,
                        y: midpointY + props.aliasOffset
                    });
                    // set up hit shapes
                    var hitLine1 = new FDSLineHitShape(x0 + prm.plotRect.x1, y0 + prm.plotRect.y1, midpointX + prm.plotRect.x1, midpointY + prm.plotRect.y1);
                    hitLine1.index = i - 1;
                    var hitLine2 = new FDSLineHitShape(midpointX + prm.plotRect.x1, midpointY + prm.plotRect.y1, x + prm.plotRect.x1, y + prm.plotRect.y1);
                    hitLine2.index = i;
                    this.series.hitVector.push(hitLine1);
                    this.series.hitVector.push(hitLine2);
                    // also set up pixelPoints
                    if (i - 1 === 0) {
                        // add the first point here - halfway along the first hit line
                        var pixX_1 = Math.round(((x0 + midpointX) / 2) + prm.plotRect.x1);
                        var pixY_1 = Math.round(((y0 + midpointY) / 2) + prm.plotRect.y1);
                        pixelPoints[i - 1] = { x: pixX_1, y: pixY_1 };
                    }
                    // now add the next point - halfway along the second hit line
                    var pixX = Math.round(((x + midpointX) / 2) + prm.plotRect.x1);
                    var pixY = Math.round(((y + midpointY) / 2) + prm.plotRect.y1);
                    pixelPoints[i] = { x: pixX, y: pixY };
                    this.series.seriesFGPen.drawPolyline(ctx, {
                        x: midpointX + props.aliasOffset,
                        y: midpointY + props.aliasOffset
                    }, {
                        x: x + props.aliasOffset,
                        y: y + props.aliasOffset
                    });
                }
                x0 = x;
                y0 = y;
                newline = false;
                this.series.addLookupPoint(x + prm.plotRect.x1, [y + prm.plotRect.y1], i);
            }
            this.series.seriesFGPen.closePolyline();
            ctx.stroke();
            ctx.restore();
            this.root.pixelPoints[this.series.id] = pixelPoints;
        };
        StepDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, (~~(height * 0.8)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfminus = ~~(minus / 2);
            ctx.beginPath();
            ctx.moveTo(x - minus, y + halfminus);
            ctx.lineTo(x, y + halfminus);
            ctx.lineTo(x, y - halfminus);
            ctx.lineTo(x + plus, y - halfminus);
            ctx.stroke();
        };
        StepDrawStyle.prototype.verify = function () {
            return true;
        };
        StepDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return StepDrawStyle;
    }(BaseDrawStyle));
    
    var ThinBarsDrawStyle = /** @class */ (function (_super) {
        __extends(ThinBarsDrawStyle, _super);
        function ThinBarsDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this.isThin = true;
            return _this;
        }
        ThinBarsDrawStyle.prototype.verify = function () {
            return true;
        };
        ThinBarsDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return ThinBarsDrawStyle;
    }(OldBarsDrawStyle));
    
    var ThinDrawStyle = /** @class */ (function (_super) {
        __extends(ThinDrawStyle, _super);
        function ThinDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this.isThin = true;
            return _this;
        }
        ThinDrawStyle.prototype.verify = function () {
            return true;
        };
        ThinDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return ThinDrawStyle;
    }(OldColumnsDrawStyle));
    
    var TironeLevels = /** @class */ (function (_super) {
        __extends(TironeLevels, _super);
        function TironeLevels(series) {
            var _this = _super.call(this, series) || this;
            _this.populateDrawStyleLevels(49 /* TIRONELEVELS */);
            return _this;
        }
        TironeLevels.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this.series.seriesFGPen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var halfwidth = ~~(width / 2);
            ctx.beginPath();
            ctx.moveTo(x - halfwidth, y);
            ctx.lineTo(x + halfwidth, y);
            ctx.stroke();
        };
        TironeLevels.prototype.verify = function () {
            return true;
        };
        TironeLevels.prototype.hint = function () {
            return -1 /* NONE */;
        };
        return TironeLevels;
    }(QuadrantTironeBase));
    
    var TreemapContext = /** @class */ (function () {
        function TreemapContext(series) {
            this.series = series;
            if (isPlot(series.parent)) {
                this.plot = series.parent;
            }
            this.root = series.root;
            this.reset(series);
            this.visibleDepthMax = this.depthMax;
        }
        TreemapContext.prototype.getCategoryBGColor = function (depth) {
            return this._categoryColors[depth - 1];
        };
        TreemapContext.prototype.getCategoryBGGradientColor = function (depth) {
            return this._categoryGradientColors[depth - 1];
        };
        TreemapContext.prototype.getCategoryFontColor = function (depth) {
            return this._categoryFontColors[depth - 1];
        };
        TreemapContext.prototype.getCategoryFontHeight = function (depth) {
            return this._categoryFontHeights[depth - 1];
        };
        TreemapContext.prototype.reset = function (series) {
            var _this = this;
            this.series = series;
            if (!this.series) {
                return;
            }
            this.widthMin = this.series.seriesFGPen.width;
            this.widthMax = this.series.hierarchyDesc.seriesWidthMax;
            this.highlightColor = this.series.seriesHighlightColor;
            this.categoryLabelPosition = this.series.hierarchyDesc.TreemapCategoryLabelPosition;
            this.categoryLabelHeight = this.series.hierarchyDesc.TreemapCategoryLabelHeight;
            this.drawLabelsRecursively = this.series.hierarchyDesc.TreemapDrawLabelsRecursively;
            this.fadeLines = this.series.hierarchyDesc.TreemapFadeColorWithHierarchy;
            this.resizeLabels = this.series.hierarchyDesc.TreemapAutoSizeLabels;
            this.forceAllLabels = this.series.hierarchyDesc.TreemapForceAllLabels;
            this.showHighlightRect = this.series.hierarchyDesc.TreemapShowHighlightRect;
            this.treemapHighlightLevel = this.series.treemapHighlightLevel;
            this.treemapHighlightMode = this.series.treemapHighlightMode;
            var xData = this.series.getData(1 /* X */);
            if (xData) {
                var dim = xData.getDimension() - 1;
                this.depthMax = Math.min(this.series.hierarchyDesc.hierarchyDepthMax, dim);
                if (this.depthMax <= 0) {
                    this.depthMax = dim;
                }
                this.totalDepth = dim + 1;
                this.depthMax += 1;
                this.tooltips = this.depthMax === dim + 1;
                this.filled = true;
            }
            var toColorArray = function (commaSepStr, defaultColor) {
                var colors = commaSepStr.split(',');
                var i = 0;
                var retArr = colors.map(function (color) {
                    color = color.trim();
                    var colNum;
                    if (!color || isNaN(colNum = Number(color))) {
                        if (typeof defaultColor === 'number') {
                            colNum = defaultColor;
                        }
                        else {
                            colNum = defaultColor[i];
                        }
                    }
                    i++;
                    return colNum;
                });
                for (i = retArr.length; i < _this.depthMax - 1; i++) {
                    if (typeof defaultColor === 'number') {
                        retArr.push(defaultColor);
                    }
                    else {
                        retArr.push(defaultColor[i]);
                    }
                }
                return retArr;
            };
            this._categoryColors = toColorArray(this.series.hierarchyDesc.TreemapCategoryLabelBGColorList, this.series.treemapCategoryLabelBrush.color);
            this._categoryGradientColors = toColorArray(this.series.hierarchyDesc.TreemapCategoryLabelBGGradientColorList, this._categoryColors);
            this._categoryFontColors = toColorArray(this.series.hierarchyDesc.TreemapCategoryLabelFontColorList, this.series.treemapCategoryLabelFont.color);
            this._categoryFontHeights = toColorArray(this.series.hierarchyDesc.TreemapCategoryLabelFontHeightList, this.series.treemapCategoryLabelFont.height);
        };
        return TreemapContext;
    }());
    
    var TreemapLeaf = /** @class */ (function () {
        function TreemapLeaf(index, area, change) {
            if (index === void 0) { index = 0; }
            if (area === void 0) { area = 1; }
            if (change === void 0) { change = 0; }
            this.index = index;
            this.area = area;
            this.change = change;
            this.scale = 1.0;
            this.depth = 0.0;
            this.x1 = this.y1 = 0;
            this.x2 = this.y2 = 5;
            this.color = new FDSColor(1, 1, 1);
            this.parent = null;
            this.categoryLabelRect = new Rectangle();
            this.levels = [];
        }
        TreemapLeaf.prototype.hasLevel = function () {
            return this.levels.length !== 0;
        };
        TreemapLeaf.prototype.getLevel = function () {
            return this.levels[0];
        };
        TreemapLeaf.prototype.addLevel = function (level) {
            this.levels.unshift(level);
        };
        TreemapLeaf.prototype.popLevel = function () {
            this.levels.shift();
        };
        TreemapLeaf.prototype.setPos = function (x1, y1, x2, y2) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        };
        // Draws the rectangle for this leaf.
        //
        // @param ctx [TreemapContext] The treemap context
        // @param prm [PlotRenderManager] The render manager for our plot
        // @param renderCtx [ChartRenderingContext] The drawing context to use
        // @param depth [Number] the current depth we are drawing at, used to determin thickness of the line
        // @param hightlight [Boolean] Whether or not this leaf is highlighted
        TreemapLeaf.prototype.draw = function (ctx, prm, renderCtx, depth, highlight) {
            if (ctx.root == null) {
                return;
            }
            var plotHeight = prm.plotRect.getHeight();
            // The coordinates we will use for drawing.
            // Note that the @y1 and @y2 coordinates are reversed, so draw_y1 and draw_y2 flip them
            var draw_x1 = Math.round(this.x1);
            var draw_y1 = plotHeight - Math.round(this.y1);
            var draw_x2 = Math.round(this.x2);
            var draw_y2 = Math.abs(Math.round(this.y2) - plotHeight);
            var draw_width = draw_x2 - draw_x1;
            var draw_height = draw_y1 - draw_y2;
            if (draw_x1 === draw_x2 || draw_y1 === draw_y2) {
                return;
            }
            if (draw_width > prm.plotRect.getWidth() || draw_height > prm.plotRect.getHeight()) {
                return;
            }
            var newBrush;
            var newPen;
            if ((ctx.filled && this.getChildCount() === 0) || (depth <= ctx.totalDepth - ctx.depthMax)) {
                newBrush = ctx.series.seriesBGBrush.copy();
                newBrush.color = this.color.getCOLORREF();
                newBrush.style = 0 /* SOLID */;
                newBrush.alpha = ctx.series.attributeSet.get('SeriesBGAlpha');
                newBrush.setOnCanvas(renderCtx, new Rectangle(draw_x1, draw_y2, draw_x1 + draw_width, draw_y2 + draw_height));
                renderCtx.fillRect(draw_x1, draw_y2, draw_width, draw_height);
                if (ctx.tooltips && (ctx.series != null)) {
                    var hitRect = new FDSRectangleHitShape(draw_x1 + prm.plotRect.x1, draw_y2 + prm.plotRect.y1, draw_width, draw_height);
                    hitRect.index = this.index;
                    ctx.series.hitVector.push(hitRect);
                    // also add pixel point
                    var pixX = Math.round(hitRect.x + hitRect.width / 2);
                    var pixY = Math.round(hitRect.y + hitRect.height / 2);
                    ctx.root.pixelPoints[ctx.series.id][this.index] = { x: pixX, y: pixY };
                }
            }
            if (this.shouldDrawCategoryRect(ctx) && depth < ctx.visibleDepthMax) {
                this.drawCategoryRect(renderCtx, ctx, prm);
            }
            var width;
            if (depth === ctx.depthMax) {
                width = ctx.widthMax;
            }
            else if (ctx.depthMax < 2) {
                width = 0;
            }
            else {
                var widthOffset = ctx.widthMax - ctx.widthMin;
                var widthStep = widthOffset / (ctx.depthMax - 1);
                width = Math.round(ctx.widthMin + depth * widthStep);
            }
            if (highlight) {
                width = Math.max(width, 1);
            }
            if (width > 0) {
                var penOptions = {};
                if (ctx.fadeLines) {
                    var lineCol = ctx.series.seriesFGPen.color;
                    var baseCol = ctx.series.colorMap.getColor(0.5);
                    var scale = depth / (ctx.depthMax - 1);
                    var _a = COLORREFtoRGB(lineCol), r1 = _a[0], g1 = _a[1], b1 = _a[2];
                    var _b = [baseCol.r, baseCol.g, baseCol.b], r2 = _b[0], g2 = _b[1], b2 = _b[2];
                    penOptions.color = RGBtoCOLORREF(r1 * scale + r2 * (1 - scale), g1 * scale + g2 * (1 - scale), b1 * scale + b2 * (1 - scale));
                }
                if (highlight && this.parent) {
                    penOptions.color = ctx.highlightColor;
                }
                penOptions.width = width;
                newPen = ctx.series.seriesFGPen.with(penOptions);
                newPen.setOnCanvas(renderCtx);
                var aliasOffset = newPen.getAliasOffset();
                renderCtx.strokeRect(draw_x1 + aliasOffset, draw_y2 + aliasOffset, draw_width, draw_height);
            }
        };
        TreemapLeaf.prototype.drawCategoryRect = function (canvasCtx, ctx, prm) {
            var plotHeight = prm.plotRect.getHeight();
            var categoryBrush = ctx.series.treemapCategoryLabelBrush;
            var drawRect = new Rectangle(this.categoryLabelRect.x1, Math.abs(Math.round(this.categoryLabelRect.y2) - plotHeight), this.categoryLabelRect.x2, Math.abs(Math.round(this.categoryLabelRect.y1) - plotHeight));
            categoryBrush.pushHistory();
            categoryBrush.setAttr('color', ctx.getCategoryBGColor(this.depth));
            categoryBrush.setAttr('gradientColor', ctx.getCategoryBGGradientColor(this.depth));
            categoryBrush.setOnCanvas(canvasCtx, drawRect);
            canvasCtx.fillRect(drawRect.x1, drawRect.y1, drawRect.getWidth(), drawRect.getHeight());
            categoryBrush.popHistory();
            var categoryPen = ctx.series.treemapCategoryLabelPen;
            categoryPen.setOnCanvas(canvasCtx);
            var aliasOffset = categoryPen.getAliasOffset();
            canvasCtx.strokeRect(drawRect.x1 + aliasOffset, drawRect.y1 + aliasOffset, drawRect.getWidth(), drawRect.getHeight());
        };
        TreemapLeaf.prototype.clearCategoryLabelRect = function () {
            this.categoryLabelRect.setRectEmpty();
        };
        TreemapLeaf.prototype.squarify = function (ctx) {
        };
        TreemapLeaf.prototype.getArea = function () {
            return this.area * this.scale;
        };
        TreemapLeaf.prototype.changeMax = function (depth, std_devs_toCull) {
            if (std_devs_toCull === void 0) { std_devs_toCull = null; }
            return this.change;
        };
        TreemapLeaf.prototype.changeAvg = function () {
            return this.change;
        };
        TreemapLeaf.prototype.setScale = function (scale) {
            this.scale = scale;
        };
        TreemapLeaf.prototype.width = function () {
            return this.x2 - this.x1;
        };
        TreemapLeaf.prototype.height = function () {
            return this.y2 - this.y1;
        };
        TreemapLeaf.prototype.setColorByPct = function (ctx, depth, change_max, cm) {
            var change_avg = this.changeAvg();
            if (change_avg === 0 || change_max === 0) {
                this.color = cm.getColor(0.5);
            }
            else {
                this.color = cm.getColor(0.5 + (change_avg / (2 * change_max)));
            }
        };
        TreemapLeaf.prototype.getChildCount = function () {
            return 0;
        };
        // Highlights the leaf based on the mode set in the context
        //
        // @param ctx [TreemapContext] The context
        // @param depth [Number] Depth we are currently in
        // @param prm [PlotRenderManager] The render context
        // @param canvas [HTMLCanvasElement] The canvas to render to
        TreemapLeaf.prototype.highlight = function (ctx, depth, prm, renderCtx) {
            var drawLeaf = TreemapLeaf.prototype.draw.bind(this, ctx, prm, renderCtx);
            switch (ctx.treemapHighlightMode) {
                case 0 /* LEAF_ONLY */:
                    drawLeaf(ctx.depthMax - depth, true);
                    break;
                case 1 /* ALL_LEVELS */:
                    drawLeaf(ctx.depthMax - depth, true);
                    if (this.parent) {
                        this.parent.highlight(ctx, depth - 1, prm, renderCtx);
                    }
                    break;
                case 2 /* DEFINED_LEVEL */:
                    var relDepth = depth - (ctx.depthMax - ctx.visibleDepthMax + 1);
                    if (ctx.treemapHighlightLevel === relDepth) {
                        drawLeaf(ctx.depthMax - depth, true);
                    }
                    else {
                        if (this.parent) {
                            this.parent.highlight(ctx, depth - 1, prm, renderCtx);
                        }
                    }
                    break;
                default:
                    if (this.parent && depth > (ctx.depthMax - ctx.visibleDepthMax + 1)) {
                        this.parent.highlight(ctx, depth - 1, prm, renderCtx);
                    }
                    else {
                        drawLeaf(ctx.depthMax - depth, true);
                    }
            }
        };
        // Set's the parameter `rect` to this instances rect coordinates as
        // well as returns the set rectangle
        //
        // @param rect [Rectangle] the rectangle to set
        TreemapLeaf.prototype.getRect = function (rect) {
            if (rect instanceof Rectangle) {
                rect.setRect(~~this.x1, ~~this.y1, ~~this.x2, ~~this.y2);
                return rect;
            }
            else {
                return new Rectangle(~~this.x1, ~~this.y1, ~~this.x2, ~~this.y2);
            }
        };
        // Resolve's the seriesValue text from the series
        //
        // @param series [FDSSeries] the series we are getting the label text for
        TreemapLeaf.prototype.getLabel = function (series) {
            return series.compiledSeriesValueText.fromValueRT({ seriesIndex: this.index });
        };
        // determines whether or not we need to drop the category label
        //
        // @param ctx [TreemapContext] the treemap context
        TreemapLeaf.prototype.shouldDrawCategoryRect = function (ctx) {
            var maxDepth = Number.MAX_VALUE;
            if (!ctx.drawLabelsRecursively) {
                maxDepth = ctx.depthMax - ctx.visibleDepthMax + 1;
            }
            return ctx.series &&
                ctx.series.seriesValue &&
                ctx.categoryLabelPosition === 2 /* TOP */ &&
                this.depth > 0 && this.depth <= maxDepth &&
                this.getChildCount() > 0;
        };
        // Helper to determine if this leaf is a descendant of the given leaf
        //
        // @param leaf [TreemapLeaf] the leaf to check if this a descendant of
        TreemapLeaf.prototype.isDescendantOf = function (leaf) {
            var parent = this.parent;
            while (parent) {
                if (parent === leaf) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        };
        TreemapLeaf.prototype.getIndex = function () {
            return this.index;
        };
        return TreemapLeaf;
    }());
    
    var TreemapNode = /** @class */ (function (_super) {
        __extends(TreemapNode, _super);
        function TreemapNode(label) {
            if (label === void 0) { label = 'Full Chart'; }
            var _this = _super.call(this) || this;
            _this.label = label;
            _this.remaining = new TreemapLeaf();
            _this.child_set = [];
            return _this;
        }
        // The function we will use to sort our leaves by area. If
        // the area is the same then we will use their index
        TreemapNode._sortFunc = function (a, b) {
            if (a.getArea() !== b.getArea()) {
                return a.getArea() - b.getArea();
            }
            else {
                return a.index - b.index;
            }
        };
        // Sets the position of this node in the treemap drawing
        TreemapNode.prototype.setPos = function (x1, y1, x2, y2) {
            _super.prototype.setPos.call(this, x1, y1, x2, y2);
            this.remaining.setPos(x1, y1, x2, y2);
            this._calc_width();
        };
        // Helper for the squarify algorithm. It gives you the highest aspect ratio
        // of a row
        //
        // @param sum [Number] the area of the row so far
        // @param r_max [Number] the maximum area in the row so far
        // @param r_min [Number] the minimum area in the row so far
        // @return [Number] the highest aspect ratio
        TreemapNode.prototype._worst = function (sum$$1, r_max, r_min) {
            var w_sq = this.smallerSideWidth * this.smallerSideWidth;
            var sum_sq = sum$$1 * sum$$1;
            return Math.max(w_sq * r_max / sum_sq, sum_sq / (w_sq * r_min));
        };
        // Gets the width of the node
        TreemapNode.prototype._calc_width = function () {
            var width = this.remaining.width();
            var height = this.remaining.height();
            this.useWidth = width < height;
            this.smallerSideWidth = this.useWidth ? width : height;
        };
        // Returns the number of children this node has
        TreemapNode.prototype.getChildCount = function () {
            return this.child_set.length;
        };
        // Squarify algorithm. The gist of this algorithm is that it lays out the
        // rows and places the rectangles if it `improves` the aspect ratio. The goal is
        // to be as square as possible.
        //
        // See (http://www.win.tue.nl/~vanwijk/stm.pdf) for complete details
        //
        // @param ctx [TreemapContext] The treemap context
        TreemapNode.prototype.squarify = function (ctx) {
            var waiting_set = this.child_set.slice();
            this.child_set = [];
            waiting_set.sort(TreemapNode._sortFunc);
            var row = [];
            var row_area = 0;
            while (waiting_set.length > 0) {
                var leaf = waiting_set[waiting_set.length - 1];
                var c_area = leaf.getArea();
                if (row.length > 0) {
                    var row_max = row[0].getArea();
                    var row_min = row[row.length - 1].getArea();
                    var worst_a = this._worst(row_area, row_max, row_min);
                    var worst_b = this._worst(row_area + c_area, (Math.max(row_max, c_area)), (Math.min(row_min, c_area)));
                    // if it is `worse` to add this leaf to the current row, we will configure the current row
                    // and push and add this leaf to the next row
                    if (worst_a <= worst_b) {
                        this._layout_row(ctx, row, row_area);
                        row_area = 0;
                        continue;
                    }
                }
                // Otherwise, we add it to this row and keep going
                waiting_set.pop();
                row.push(leaf);
                row_area += c_area;
            }
            this._layout_row(ctx, row, row_area);
        };
        // Calls draw on everything in its child set. Drawing is recursive, since we have a tree
        // structure
        //
        // @param ctx [TreemapContext] The treemap contex
        // @param prm [PlotRenderManager] The plot render context
        // @param renderCtx [ChartRenderingContext] The rendering context we are drawing with
        // @param depth [Number] Current depth we are drawing at
        // @param highlight [Boolean] Whether or not we need to highlight this current node
        TreemapNode.prototype.draw = function (ctx, prm, renderCtx, depth, highlight) {
            if (depth > ctx.totalDepth - ctx.depthMax) {
                for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.draw(ctx, prm, renderCtx, depth - 1, highlight);
                }
            }
            _super.prototype.draw.call(this, ctx, prm, renderCtx, depth, highlight);
        };
        // This configures the current row, which may or may not have to recursively squarify itself
        //
        // @param ctx [TreemapContext] The treemap context
        // @param row [Array] The current row of rectangles
        // @param area [Number] The area of the row
        TreemapNode.prototype._layout_row = function (ctx, row, area) {
            var width = this.remaining.width();
            var height = this.remaining.height();
            var y1 = this.remaining.y1;
            var x1 = this.remaining.x1;
            var w1 = area / (this.useWidth ? width : height);
            for (var _i = 0, row_1 = row; _i < row_1.length; _i++) {
                var leaf = row_1[_i];
                var w2 = leaf.getArea() / w1;
                var r_w = this.useWidth ? w2 : w1;
                var r_h = this.useWidth ? w1 : w2;
                if (leaf.shouldDrawCategoryRect(ctx)) {
                    var categoryLabelHeight = Math.min(ctx.categoryLabelHeight, r_h + 1);
                    leaf.setPos(x1, y1, x1 + r_w, (y1 + r_h) - categoryLabelHeight);
                    leaf.y2 += categoryLabelHeight;
                    width = r_w;
                    height = r_h - categoryLabelHeight;
                    var visible_area = width * height;
                    leaf.setScale(1.0);
                    var scale = visible_area / leaf.getArea();
                    leaf.setScale(scale);
                    leaf.categoryLabelRect.setRect(Math.round(x1), Math.round(y1 + r_h - categoryLabelHeight), Math.round(x1 + r_w), Math.round(y1 + r_h));
                }
                else {
                    leaf.setPos(x1, y1, x1 + r_w, y1 + r_h);
                    leaf.clearCategoryLabelRect();
                }
                leaf.squarify(ctx);
                this.child_set.push(leaf);
                if (this.useWidth) {
                    x1 += w2;
                }
                else {
                    y1 += w2;
                }
            }
            ArrayUtils.clear(row);
            if (this.useWidth) {
                this.remaining.y1 += w1;
            }
            else {
                this.remaining.x1 += w1;
            }
            this._calc_width();
        };
        // Adds a child to this node
        //
        // @param child [TreemapLeaf] The node (or leaf) we are adding
        TreemapNode.prototype.add = function (child) {
            this.child_set.push(child);
            return child.parent = this;
        };
        // Gets the total area this node takes up by recursively calling getArea() on its
        // children
        //
        // @return [Number] The area this node takes up
        TreemapNode.prototype.getArea = function () {
            return _$1.sum(this.child_set.map(function (child) { return child.getArea(); }));
        };
        // Computes the maximum change of this node, used to color the leaves
        //
        // @param depth [Number] The current depth
        // @param std_devs_toCull [Optional] The number of std deviations to clip
        TreemapNode.prototype.changeMax = function (depth, std_devs_toCull) {
            if (depth === 0) {
                return this.changeAvg();
            }
            // If std_devs_toCull is null or negative, ignore it and call the
            // helper function. The `changeMax` function is overloaded on the PC-side
            // so this is how I deal with that
            if (std_devs_toCull < 0 || std_devs_toCull == null) {
                return this._changeMaxHelper(depth);
            }
            var change_avg = this.changeAvg();
            var std_dev = 0;
            var change_max = 0;
            // computes the std deviation for the change in each of this node's children
            // to compute the maximum change
            for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                var node = _a[_i];
                var delta = Math.abs(node.changeMax(depth - 1)) - change_avg;
                std_dev += delta * delta;
                change_max = Math.max(change_max, change_avg + std_devs_toCull * Math.sqrt(std_dev / this.child_set.length));
            }
            return Math.min(change_max, change_avg + std_devs_toCull * Math.sqrt(std_dev / this.child_set.length));
        };
        TreemapNode.prototype._changeMaxHelper = function (depth) {
            var change_max = 0;
            for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                var node = _a[_i];
                change_max = Math.max(Math.abs(node.changeMax(depth - 1)), change_max);
            }
            return change_max;
        };
        // Computes the average change for this node to use for the stddev computation
        TreemapNode.prototype.changeAvg = function () {
            var change_sum = 0;
            var area_sum = 0;
            for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                var node = _a[_i];
                var area = node.getArea();
                var change = Math.abs(node.changeAvg());
                area_sum += area;
                change_sum += change * area;
            }
            return area_sum === 0 ? 0 : change_sum / area_sum;
        };
        // Recursively set the scale on this and all of its children
        TreemapNode.prototype.setScale = function (scale) {
            _super.prototype.setScale.call(this, scale);
            for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                var child = _a[_i];
                child.setScale(scale);
            }
        };
        // Divides this nodes children up into their categories/subcategories
        TreemapNode.prototype.subdivide = function (depth) {
            var direct_children = {};
            var naCategory = [];
            this.depth = depth;
            if (this.child_set.length > 0) {
                for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                    var node = _a[_i];
                    var str = '@NA';
                    if (node.hasLevel()) {
                        str = node.getLevel();
                        node.popLevel();
                    }
                    node.depth = depth + 1;
                    if (!IsSomeInternalNAN(str)) {
                        if (direct_children[str] == null) {
                            var n = new TreemapNode(str);
                            direct_children[str] = n;
                            n.index = node.index;
                        }
                        direct_children[str].add(node);
                    }
                    else {
                        naCategory.push(node);
                    }
                }
                ArrayUtils.clear(this.child_set);
                for (var _b = 0, naCategory_1 = naCategory; _b < naCategory_1.length; _b++) {
                    var node = naCategory_1[_b];
                    this.add(node);
                }
                for (var s in direct_children) {
                    var node = direct_children[s];
                    node.subdivide(depth + 1);
                    this.add(node);
                }
                direct_children = {};
            }
        };
        // Sets the colors based on their change
        TreemapNode.prototype.setColorByPct = function (ctx, depth, change_max, cm) {
            if (depth === (ctx.totalDepth - ctx.depthMax)) {
                _super.prototype.setColorByPct.call(this, ctx, depth, change_max, cm);
            }
            else {
                for (var _i = 0, _a = this.child_set; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.setColorByPct(ctx, depth - 1, change_max, cm);
                }
            }
        };
        // Sets the position and scale of this node
        TreemapNode.prototype.setPosAndScale = function (p1, p2) {
            this.setPos(p1.x, p1.y, p2.x, p2.y);
            var width = p2.x - p1.x;
            var height = p2.y - p1.y;
            var visible_area = width * height;
            this.setScale(1.0);
            var scale = visible_area / this.getArea();
            this.setScale(scale);
        };
        // Sets color based on their change vs the max
        TreemapNode.prototype.setColorByPctVsMax = function (ctx, depth, cm, std_devs_toCull, minChange) {
            if (std_devs_toCull === void 0) { std_devs_toCull = 1.5; }
            if (minChange === void 0) { minChange = 0; }
            this.setColorByPct(ctx, depth, Math.max(minChange, this.changeMax(depth, std_devs_toCull)), cm);
        };
        // Label for this node
        TreemapNode.prototype.getLabel = function (series) {
            return new RichTextString(this.label);
        };
        // gets the index of the first leaf node contained as a child
        TreemapNode.prototype.getIndex = function () {
            if (this.child_set.length > 0) {
                return this.child_set[0].getIndex();
            }
            else {
                return -1;
            }
        };
        return TreemapNode;
    }(TreemapLeaf));
    
    var WHEEL_DELTA = 120;
    var TreemapRenderCache = /** @class */ (function (_super) {
        __extends(TreemapRenderCache, _super);
        function TreemapRenderCache(ctx, graph, leafMap, seriesUpdateCount, point1, point2) {
            var _this = _super.call(this, ctx.series) || this;
            _this.ctx = ctx;
            _this.graph = graph;
            _this.leafMap = leafMap;
            _this.seriesUpdateCount = seriesUpdateCount;
            _this.point1 = point1;
            _this.point2 = point2;
            _this.visibleRoot = graph;
            _this.seriesName = ctx.series.id;
            _this.redrawLabels = true;
            _this.categoryLabelHitShapes = [];
            _this._tapCount = 0;
            _this.zoomStack = [];
            return _this;
        }
        // Sets the status of the render cache as invalid
        // @param isInvalidated [Boolean] Whether or not we should be invalidating
        TreemapRenderCache.prototype.setInvalidated = function (isInvalidated) {
            if (isInvalidated === void 0) { isInvalidated = true; }
            this.valid = !isInvalidated;
        };
        // Resets the graph by recomputing and squarifying the leaves
        TreemapRenderCache.prototype.resetGraph = function () {
            this._setPosAndScale();
            this.visibleRoot.squarify(this.ctx);
            this.setupColors();
        };
        // Draws the treemap.
        //
        // @param prm [PlotRenderManager] The render manager that gives us context for the plot
        // @param canvas [HTMLCanvasElement] The canvas we are drawing on
        TreemapRenderCache.prototype.draw = function (prm, canvasCtx) {
            if (this.ctx.categoryLabelPosition === 2 /* TOP */ && this.ctx.drawLabelsRecursively) {
                var parent_1 = this.visibleRoot;
                while (parent_1 !== this.graph) {
                    if (parent_1.shouldDrawCategoryRect(this.ctx)) {
                        parent_1.drawCategoryRect(canvasCtx, this.ctx, prm);
                    }
                    parent_1 = parent_1.parent;
                }
            }
            this.visibleRoot.draw(this.ctx, prm, canvasCtx, this.ctx.visibleDepthMax, false);
            if (this.highlightedLeaf && this.ctx.showHighlightRect) {
                this.highlightedLeaf.highlight(this.ctx, this.highlightedLeaf.depth, prm, canvasCtx);
            }
        };
        // Computes the position and scale of each of the leaves in the tree for rendering
        // later. The scale determines how large the leaves appear, so a larger scale with the
        // same aspect ratio just means the rectangles for each of the leaves are drawn larger
        TreemapRenderCache.prototype._setPosAndScale = function () {
            var plot = this.ctx.plot;
            if (plot == null) {
                return;
            }
            var root = this.ctx.root;
            if (root == null) {
                return;
            }
            var x1 = plot.subPlotFromNDC(0, 1 /* X */);
            var y1 = plot.subPlotFromNDC(1, 2 /* Y */);
            var x2 = plot.subPlotFromNDC(1, 1 /* X */);
            var y2 = plot.subPlotFromNDC(0, 2 /* Y */);
            if (this.ctx.categoryLabelPosition === 2 /* TOP */ && this.ctx.drawLabelsRecursively) {
                var parents = [];
                var parent_2 = this.visibleRoot;
                while (parent_2 !== this.graph) {
                    parents.push(parent_2);
                    parent_2 = parent_2.parent;
                }
                parents = parents.reverse();
                for (var _i = 0, parents_1 = parents; _i < parents_1.length; _i++) {
                    parent_2 = parents_1[_i];
                    parent_2.categoryLabelRect.setRect(x1, y2 - this.ctx.categoryLabelHeight, x2, y2);
                    y2 -= this.ctx.categoryLabelHeight;
                }
            }
            var point1 = new Point(x1, y1);
            var point2 = new Point(x2, y2);
            this.visibleRoot.setPosAndScale(point1, point2);
        };
        // Sets the colors for the visible leaves. The colors will be recomputed
        // When the visibleRoot is changed.
        TreemapRenderCache.prototype.setupColors = function () {
            var series = this.ctx.series;
            if (series == null) {
                return;
            }
            var colorMap;
            if (series.useColorMap) {
                colorMap = series.colorMap;
            }
            else {
                colorMap = new ColorMap(7 /* GREENRED */);
                colorMap.setMap(7 /* GREENRED */);
                series.setColorMap(colorMap);
            }
            this.visibleRoot.setColorByPctVsMax(this.ctx, this.ctx.depthMax, colorMap, this.ctx.series.hierarchyDesc.DataClipStdDeviation, this.ctx.series.hierarchyDesc.TreemapRestrictColorRange);
        };
        // Zooms out to the top level of the tree.
        TreemapRenderCache.prototype.unzoom = function () {
            if (this.ctx.series.root.suppressAllInteraction) {
                return;
            }
            this.visibleRoot = this.graph;
            this.ctx.visibleDepthMax = this.ctx.depthMax;
            this.zoomStack = [];
        };
        // Zooms in one level towards the leaf with the given index
        //
        // @param index [Number] The index of the leaf to zoom in towards
        TreemapRenderCache.prototype.zoomIn = function (index) {
            if (!this.ctx.series.treemapAllowDrilldown || this.ctx.series.root.suppressAllInteraction) {
                return false;
            }
            if (this.ctx.visibleDepthMax > this.ctx.totalDepth - this.ctx.depthMax) {
                if (this.leafMap[index] != null) {
                    var tmpHighlightedNode = this.leafMap[index];
                    // if you are trying to zoomIn into a node that is not currently visible, return
                    if (!tmpHighlightedNode.isDescendantOf(this.visibleRoot)) {
                        return false;
                    }
                    this.highlightedLeaf = tmpHighlightedNode;
                    var parent_3 = this.highlightedLeaf.parent;
                    if (parent_3 && parent_3 !== this.visibleRoot) {
                        var newRoot = parent_3;
                        parent_3 = newRoot.parent;
                        while (parent_3 && parent_3 !== this.visibleRoot) {
                            newRoot = parent_3;
                            parent_3 = newRoot.parent;
                        }
                        this.visibleRoot = newRoot;
                        this.ctx.visibleDepthMax -= 1;
                        this.highlightedLeaf = null;
                        // Push the node we just zoomed into onto the zoom stack if it isnt already
                        if (this.zoomStack.length === 0 ||
                            this.visibleRoot.label !== this.zoomStack[this.zoomStack.length - 1]) {
                            this.zoomStack.push(this.visibleRoot.label);
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        // Zooms out one level
        TreemapRenderCache.prototype._zoomOut = function () {
            if (!this.ctx.series.treemapAllowDrilldown || this.ctx.series.root.suppressAllInteraction) {
                return false;
            }
            if (this.visibleRoot.parent) {
                this.visibleRoot = this.visibleRoot.parent;
                this.zoomStack.pop();
                this.ctx.visibleDepthMax += 1;
                return true;
            }
            return false;
        };
        // Event Handler for the mousewheel event
        //
        // @param e [MouseWheelEvent] The event to extra wheeldelta from
        TreemapRenderCache.prototype.handleMouseWheel = function (e) {
            if (!this.ctx.series.treemapAllowDrilldown) {
                return;
            }
            var delta = e.wheelDeltaY;
            var pick$$1 = this.ctx.root.pick;
            if (delta > 0) {
                this._zoomInHandler(pick$$1, delta);
            }
            else if (delta < 0) {
                this._zoomOutHandler(pick$$1, delta);
            }
            e.preventDefault();
        };
        // More specific handler for zooming in
        //
        // @param pick [Object] The `pick event` we are going to use to get the object to zoom in on from
        // @param scrollDelta [Number] the amount we need to scroll in
        TreemapRenderCache.prototype._zoomInHandler = function (pick$$1, scrollDelta) {
            var retVal = false;
            // adjust scrollDelta by the sensitivity scale
            var delta = ~~(scrollDelta / WHEEL_DELTA);
            if (pick$$1.accessObject() === this.ctx.series.id) {
                var index = this.getIndexFromPick(pick$$1);
                while (delta > 0) {
                    retVal = this.zoomIn(index) || retVal;
                    delta--;
                }
                if (retVal) {
                    this.setInvalidated();
                    // call redraw from in here since nothing else will call it
                    this.ctx.root.invalidate();
                }
            }
            return retVal;
        };
        // More specific handler for zooming out
        //
        // @param pick [Object] The `pick event` we are going to use to get the object to zoom out from
        // @param scrollDelta [Number] the amount we need to zoom out
        TreemapRenderCache.prototype._zoomOutHandler = function (pick$$1, scrollDelta) {
            var retVal = false;
            var delta = Math.ceil(scrollDelta / WHEEL_DELTA);
            if (pick$$1.accessObject() === this.ctx.series.id) {
                while (delta < 0) {
                    retVal = this._zoomOut() || retVal;
                    delta++;
                }
                if (retVal) {
                    this.setInvalidated();
                    this.ctx.root.invalidate();
                }
            }
            return retVal;
        };
        TreemapRenderCache.prototype.handleTouchEnd = function () {
            var _this = this;
            // we just ended a single-finger tap
            // set up timeout counter
            if (this.ctx.series.treemapAllowDrilldown) {
                this._tapCount++;
                if (this._tapCount === 1) {
                    this._tapTimeoutHandle = window.setTimeout((function () { return _this._tapCount = 0; }), CLICK_TIMEOUT_MS);
                }
                else {
                    this._handleDblTapZoom();
                    clearTimeout(this._tapTimeoutHandle);
                    this._tapCount = 0;
                }
            }
        };
        TreemapRenderCache.prototype._handleDblTapZoom = function () {
            var pick$$1 = this.ctx.root.pick;
            if (pick$$1.accessObject() === this.ctx.series.id) {
                this.zoomIn(this.getIndexFromPick(pick$$1));
                this.ctx.root.invalidate();
            }
        };
        TreemapRenderCache.prototype.handleTouchMove = function (e) {
            if (e.touches.length === 1) {
                this.handleMouseMove(e);
            }
        };
        TreemapRenderCache.prototype.handleMouseClick = function (event) {
            this.handleTouchEnd();
        };
        TreemapRenderCache.prototype.handleTouchStart = function (e) {
            var rm = this.ctx.root.renderManager;
            if (rm != null) {
                var point = rm.getCursorPos(e);
                this.ctx.root.doPick('LButtonDown', point);
            }
            this.handleMouseMove(e);
        };
        TreemapRenderCache.prototype.getIndexFromPick = function (pick$$1) {
            var index = Number(this.ctx.root.pick.accessSubObject());
            function tryGetChild(node, childName) {
                for (var _i = 0, _a = node.child_set; _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (child instanceof TreemapNode) {
                        if (child.label === childName) {
                            return child;
                        }
                    }
                }
                return null;
            }
            var pickObjectPart = this.ctx.root.pick.accessObjectPart();
            // Category headings require special handling to select a leaf-node within that category
            if (index === -1 && _$1.isString(pickObjectPart)) {
                var path = pickObjectPart.split('::');
                // If the category heading we are hovering is above our current visible level, we need to ignore it.
                if (path.length <= this.visibleRoot.depth) {
                    return -1;
                }
                var node = this.graph;
                while (path.length > 0) {
                    var childName = path.shift();
                    node = tryGetChild(node, childName);
                    if (node == null) {
                        return -1;
                    }
                }
                return node.getIndex();
            }
            else {
                return index;
            }
        };
        // Handler for redrawing the node that is being moused/touched to highlight
        TreemapRenderCache.prototype.handleMouseMove = function (e) {
            if ((!this.ctx.showHighlightRect) || this.ctx.series.root.suppressAllInteraction) {
                return false;
            }
            var redraw = false;
            // get the `pick event` from the chart
            var pick$$1 = this.ctx.root.pick;
            var obj = this.ctx.root.getObject(pick$$1.accessObject());
            if (isSeries(obj)) {
                if (obj.id !== this.ctx.series.id) {
                    this.highlightedLeaf = null;
                    return false;
                }
            }
            else {
                this.highlightedLeaf = null;
                return false;
            }
            // if we actually have a valid pick, get the index
            var index = this.getIndexFromPick(this.ctx.root.pick);
            if (!(this.leafMap[index] != null)) {
                if ((this.highlightedLeaf != null)) {
                    // if the index from our hit isn't in the leafmap and we had a highlighted leaf, clear it and return
                    this.highlightedLeaf = null;
                    redraw = true;
                }
                else {
                    // otherwise just return
                    redraw = false;
                }
            }
            else {
                // otherwise we are moused over a leaf
                var leaf = this.leafMap[index];
                var seriesName = obj.id;
                if ((!this.highlightedLeaf) || ((this.highlightedLeaf !== leaf) && (this.ctx.visibleDepthMax > 1))) {
                    // if we dont have a highlighted leave or the highlighted leaf is different from the leaf
                    // we are moused over and we can actually see that leaf
                    var oldParent = null;
                    if (this.highlightedLeaf) {
                        oldParent = this.highlightedLeaf.parent;
                        while (oldParent && oldParent.parent && oldParent.parent !== this.visibleRoot) {
                            oldParent = oldParent.parent;
                        }
                    }
                    else {
                        redraw = true;
                    }
                    this.highlightedLeaf = leaf;
                    var newParent = leaf.parent;
                    if (this.ctx.visibleDepthMax > 1) {
                        while (newParent && newParent.parent && newParent.parent !== this.visibleRoot) {
                            newParent = newParent.parent;
                        }
                        // for us, we need to redraw if the parent isn't the same because we don't a crosshair event or
                        // something
                        // to cause a refresh, so we will refresh always if we are in one of the modes where a leaf is being
                        // highlighted
                        redraw = redraw || (newParent !== oldParent) ||
                            this.ctx.treemapHighlightMode === 0 /* LEAF_ONLY */ ||
                            this.ctx.treemapHighlightMode === 1 /* ALL_LEVELS */;
                    }
                }
                else {
                    // otherwise redraw if this leaf is actually different
                    redraw = index !== this.highlightedLeaf.index;
                    this.highlightedLeaf = leaf;
                }
            }
            if (redraw) {
                // This bit of hackery is to prevent the labels from redrawing which
                // is a rather expensive operation. We don't need to redraw the labels because they
                // are on their own canvas and this highlighting shouldn't affect them in any way
                // also don't hide the tooltips on this redraw
                this.redrawLabels = false;
                this.ctx.root.preserveTreemapTooltip = true;
                this.ctx.root.renderManager.draw();
                this.redrawLabels = true;
                this.ctx.root.preserveTreemapTooltip = false;
            }
            return redraw;
        };
        TreemapRenderCache.prototype.handleMouseOut = function () {
            this.highlightedLeaf = null;
            return this.ctx.showHighlightRect;
        };
        TreemapRenderCache.prototype.getColorScaleRange = function (hierarchyDesc) {
            if (hierarchyDesc === void 0) { hierarchyDesc = this.ctx.series.hierarchyDesc; }
            var max$$1 = Math.max(hierarchyDesc.TreemapRestrictColorRange, this.visibleRoot.changeMax(this.ctx.depthMax, hierarchyDesc.DataClipStdDeviation));
            var unclippedMax = this.visibleRoot.changeMax(this.ctx.depthMax);
            return { colorMin: -max$$1, colorMax: max$$1, valueMin: -unclippedMax, valueMax: unclippedMax };
        };
        return TreemapRenderCache;
    }(BaseRenderCache));
    
    var TreemapDrawStyle = /** @class */ (function (_super) {
        __extends(TreemapDrawStyle, _super);
        function TreemapDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._labelPadding = 2; // we don't want the text to go fully edge-to-edge, otherwise the outline pen will overlap
            if (!(isPlot(_this.series.parent))) {
                return null;
            }
            // Fetch the stored render cache from the series if it exists
            if (_this.series.renderCache instanceof TreemapRenderCache) {
                _this._rc = _this.series.renderCache;
            }
            var plot = _this.series.getPlotParent();
            var point1 = new Point(plot.subPlotFromNDC(0, 1 /* X */), plot.subPlotFromNDC(0, 2 /* Y */));
            var point2 = new Point(plot.subPlotFromNDC(1, 1 /* X */), plot.subPlotFromNDC(1, 2 /* Y */));
            if (_this._rc && _this._rc.seriesUpdateCount === _this.series.updateCount) {
                // if the render cache exists and the @series data hasn't changed on us,
                // just update any of the attributes or size stuff that might have changed,
                // no need to recompute the entire graph
                var lastCategoryLabelPosition = _this._rc.ctx.categoryLabelPosition;
                var lastCategoryLabelHeight = _this._rc.ctx.categoryLabelHeight;
                _this._rc.ctx.reset(_this.series);
                if (_this._rc.point1 !== point1
                    || _this._rc.point2 !== point2
                    || !_this._rc.valid
                    || lastCategoryLabelPosition !== _this._rc.ctx.categoryLabelPosition
                    || lastCategoryLabelHeight !== _this._rc.ctx.categoryLabelHeight) {
                    _this._rc.resetGraph();
                    _this._rc.point1 = point1;
                    _this._rc.point2 = point2;
                    _this._rc.setupColors();
                }
            }
            else {
                // Reconstruct the render cache if the data from the series has changed, or if
                // we never had one
                var highlightedIndex = -1;
                var oldZoomStack = [];
                if (_this._rc) {
                    if (_this._rc.highlightedLeaf) {
                        highlightedIndex = _this._rc.highlightedLeaf.getIndex();
                    }
                    oldZoomStack = _this._rc.zoomStack.slice();
                }
                var graph = new TreemapNode();
                var leafMap = {};
                _this._subdivide(graph, leafMap);
                _this._rc = new TreemapRenderCache(new TreemapContext(_this.series), graph, leafMap, _this.series.updateCount, point1, point2);
                _this.series.renderCache = _this._rc;
                // restore previously highlighted leaf
                if (highlightedIndex !== -1) {
                    _this._rc.highlightedLeaf = _this._rc.leafMap[highlightedIndex];
                }
                // restore zoom level
                // for (let i = 0; i < oldZoomStack.length; i++) {
                //    const label = oldZoomStack[i];
                //    this.rc.zoomIn(label);
                // }
                _this._rc.resetGraph();
            }
            _this._rc.setInvalidated(false);
            return _this;
        }
        TreemapDrawStyle.prototype.getColorScaleRange = function () {
            return this._rc.getColorScaleRange();
        };
        // Divides up the plot region into the rectangles. This actually just constructs
        // the graph and the leafMap, then calls `graph.subdivide` which will actually
        // divide up the area and try to squarify
        //
        // @param graph [TreemapNode] The root node of the tree
        // @param leafMap [Object] The map of (int, TreemapLeaf) that will help us later
        TreemapDrawStyle.prototype._subdivide = function (graph, leafMap) {
            var xData = this.series.getData(1 /* X */);
            var yData = this.series.getData(2 /* Y */);
            if (xData === null || yData === null) {
                return;
            }
            var size = xData.getSize();
            var dim = xData.getDimension();
            for (var i = 0; i < size; i++) {
                var str = xData.getAt(i);
                // default area is 1, assume everything is the same size
                var area_dim = yData.getDimension() > 0 ? yData.getAt(i, 0) : 1;
                // default is 0, assume there is no change info so everything is the same color
                var color_dim = yData.getDimension() > 1 ? yData.getAt(i, 1) : 0;
                if (IsSomeNAN(color_dim)) {
                    color_dim = 0;
                }
                if (!IsSomeNAN(area_dim) && area_dim > 0) {
                    var leaf = new TreemapLeaf(i, area_dim, color_dim);
                    for (var jj = 1; jj < dim; jj++) {
                        var dim_str = xData.getAt(i, jj);
                        if (!IsSomeInternalNAN(dim_str)) {
                            leaf.addLevel(dim_str.toString());
                        }
                    }
                    graph.add(leaf);
                    leafMap[i] = leaf;
                }
            }
            graph.subdivide(0);
        };
        // Pass drawing call to the render cache
        TreemapDrawStyle.prototype.drawToBuffer = function (prm, canvasCtx) {
            if (this._rc == null) {
                return;
            }
            this._rc.draw(prm, canvasCtx);
        };
        // Draws the labels on the treemap
        TreemapDrawStyle.prototype.drawTextToBuffer = function (prm, ctx) {
            if (!this._rc || !this.series.seriesValue) {
                return;
            }
            if (!this._rc.redrawLabels) {
                ctx.drawLayer(this._rc.textImageCache);
                this.series.hitVector = this.series.hitVector.concat(this._rc.categoryLabelHitShapes);
                return;
            }
            else {
                this._rc.categoryLabelHitShapes = [];
                this._rc.textImageCache = this.root.createRenderingLayer(this.root.getWidth(), this.root.getHeight());
                var cacheCtx = this._rc.textImageCache.context;
                var rect = new Rectangle();
                var valueFont = this.series.seriesLabelFont;
                valueFont.setOnCanvas(cacheCtx);
                var categoryLabelFont = this.series.treemapCategoryLabelFont;
                var plotHeight = prm.plotRect.getHeight();
                var valueBrush = this.series.seriesLabelBrush;
                var valuePen = this.series.seriesLabelPen;
                var graph = this._rc.ctx.categoryLabelPosition === 2 /* TOP */ ?
                    this._rc.graph :
                    this._rc.visibleRoot;
                var traversalQueue = [];
                traversalQueue.push(graph);
                while (traversalQueue.length > 0) {
                    var currentNode = traversalQueue.shift();
                    for (var _i = 0, _a = currentNode.child_set; _i < _a.length; _i++) {
                        var nextNode = _a[_i];
                        if (nextNode !== this._rc.visibleRoot && !nextNode.isDescendantOf(this._rc.visibleRoot) &&
                            !this._rc.visibleRoot.isDescendantOf(nextNode)) {
                            continue;
                        }
                        if (nextNode instanceof TreemapNode) {
                            traversalQueue.push(nextNode);
                            if (this.series.hierarchyDesc.TreemapCategoryLabelPosition === 0 /* NONE */) {
                                continue;
                            }
                        }
                        if (!this.series.hierarchyDesc.TreemapDrawLabelsRecursively &&
                            nextNode.depth !== this._rc.visibleRoot.depth + 1) {
                            continue;
                        }
                        var isCategoryRect = void 0;
                        var currentFont = void 0;
                        if (nextNode.shouldDrawCategoryRect(this._rc.ctx)) {
                            isCategoryRect = true;
                            rect = nextNode.categoryLabelRect;
                            currentFont = categoryLabelFont;
                        }
                        else {
                            isCategoryRect = false;
                            nextNode.getRect(rect);
                            currentFont = valueFont;
                        }
                        currentFont.setOnCanvas(cacheCtx);
                        var dvd = new DelayedValue(this.series);
                        dvd.annotStr = nextNode.getLabel(this.series);
                        if (dvd.annotStr.isEmpty()) {
                            continue;
                        }
                        var minFontSize = void 0;
                        if (isCategoryRect) {
                            currentFont = currentFont.with({ height: this._rc.ctx.getCategoryFontHeight(nextNode.depth) });
                            minFontSize = this.series.hierarchyDesc.TreemapCategoryLabelFontHeightMin;
                        }
                        else {
                            minFontSize = this.series.hierarchyDesc.TreemapLabelFontHeightMin;
                        }
                        dvd.annotRect = rect.copy();
                        var labelFitInSpace = true;
                        var textSize = RichTextRenderer.measureRichText(cacheCtx, dvd.annotStr, currentFont)[0];
                        if (this._rc.ctx.resizeLabels) {
                            labelFitInSpace = labelFitInSpace &&
                                this._autoSizeLabels(currentFont, rect, textSize, dvd, cacheCtx, minFontSize);
                        }
                        var draw = true;
                        if (!this._rc.ctx.forceAllLabels) {
                            labelFitInSpace = labelFitInSpace && !this._isTextTooBig(textSize, rect);
                            if (!labelFitInSpace) {
                                if (isCategoryRect && currentFont.truncate === -1 /* DEFAULT */) {
                                    dvd.customHeight = minFontSize;
                                    currentFont = currentFont.with({
                                        truncate: 1 /* TRUNCATE */,
                                        height: dvd.customHeight,
                                        widthHint: dvd.widthHint,
                                    });
                                    textSize = RichTextRenderer.measureRichText(cacheCtx, dvd.annotStr, currentFont)[0];
                                    if (this._isTextTooBig(textSize, rect)) {
                                        draw = false;
                                    }
                                }
                                else {
                                    draw = false;
                                }
                            }
                        }
                        if (draw) {
                            var half_width = textSize.width / 2;
                            var half_height = textSize.height / 2;
                            dvd.annotRect.x1 = rect.centerPoint().x - half_width;
                            dvd.annotRect.y1 = plotHeight - (rect.centerPoint().y - half_height);
                            dvd.annotRect.x2 = rect.centerPoint().x + half_width;
                            dvd.annotRect.y2 = Math.abs((rect.centerPoint().y + half_height) - plotHeight);
                            // dvd.annotRect.offsetRect(prm.plotRect.x1, prm.plotRect.y1);
                            dvd.valueBrush = valueBrush;
                            dvd.valuePen = valuePen;
                            dvd.annotIndex = 0;
                            dvd.hitRect = false;
                            var center = dvd.annotRect.centerPoint();
                            if (!isCategoryRect) {
                                dvd.valueBrush.setOnCanvas(cacheCtx, dvd.annotRect);
                                cacheCtx.fillRect(dvd.annotRect.x1, dvd.annotRect.y2, dvd.annotRect.getWidth(), dvd.annotRect.getHeight());
                                dvd.valuePen.setOnCanvas(cacheCtx);
                                cacheCtx.strokeRect(dvd.annotRect.x1, dvd.annotRect.y2, dvd.annotRect.getWidth(), dvd.annotRect.getHeight());
                            }
                            if (dvd.customWidthHint) {
                                currentFont = currentFont.with({ widthHint: dvd.widthHint });
                            }
                            if (dvd.customHeight > 0) {
                                currentFont = currentFont.with({ height: dvd.customHeight });
                            }
                            if (this.series.hierarchyDesc.TreemapLabelMaximumContrast && !isCategoryRect) {
                                var backcolor = (dvd.valueBrush.style === 1 /* NULL */) ?
                                    nextNode.color :
                                    new FDSColor(dvd.valueBrush.color);
                                currentFont = currentFont.with({ color: backcolor.getContrastYIQ() });
                            }
                            else if (this.series.hierarchyDesc.TreemapCategoryLabelMaximumContrast && isCategoryRect) {
                                var backcolor = new FDSColor(this._rc.ctx.getCategoryBGColor(nextNode.depth));
                                currentFont = currentFont.with({ color: backcolor.getContrastYIQ() });
                            }
                            else if (isCategoryRect) {
                                currentFont = currentFont.with({ color: this._rc.ctx.getCategoryFontColor(nextNode.depth) });
                            }
                            currentFont.setOnCanvas(cacheCtx);
                            var x = ~~(center.x - (dvd.annotRect.getWidth() / 2));
                            var y = ~~(center.y - (dvd.annotRect.getHeight() / 2));
                            RichTextRenderer.writeRichText(cacheCtx, dvd.annotStr, x, y, currentFont);
                            dvd.valueFont = currentFont;
                        }
                        // set up hitshapes
                        if (isCategoryRect) {
                            var parent_1 = nextNode;
                            var nodePath = [];
                            while (parent_1 !== this._rc.graph) {
                                nodePath.push(parent_1.label);
                                parent_1 = parent_1.parent;
                            }
                            var categoryRect = rect.copy();
                            categoryRect.y1 = plotHeight - categoryRect.y1;
                            categoryRect.y2 = plotHeight - categoryRect.y2;
                            categoryRect.offsetRect(prm.plotRect.x1, prm.plotRect.y1);
                            var hitRect = new FDSRectangleHitShape(categoryRect);
                            hitRect.name = 'Category Heading';
                            hitRect.objectPart = nodePath.reverse().join('::');
                            hitRect.index = -1;
                            if (currentFont.truncate === 1 /* TRUNCATE */) {
                                hitRect.hoverText = RichTextRenderer.convertToHTML(dvd.annotStr);
                            }
                            this._rc.categoryLabelHitShapes.push(hitRect);
                            this.series.hitVector.push(hitRect);
                        }
                    }
                }
                ctx.drawLayer(this._rc.textImageCache);
            }
        };
        // Used to size the labels so they will fit within their rectangle
        //
        // @param valueFont [FDSFont] the font we are drawing with
        // @param rect [Rectangle] the rectangle we need to fit in
        // @param textSize [Object] the initial measurement of the font
        // @param dvd [DelayedValue] the object to store our drawing information
        // @param ctx [ChartRenderingContext] Canvas context to use for recomputing the size later
        TreemapDrawStyle.prototype._autoSizeLabels = function (valueFont, rect, textSize, dvd, ctx, minSize) {
            if (!valueFont || !dvd) {
                return false;
            }
            var retVal = true;
            var oldPoint = valueFont.height;
            valueFont = valueFont.with({ widthHint: Number.POSITIVE_INFINITY });
            if (!this._autoSizeBisection(valueFont, rect, textSize, dvd, Math.max((oldPoint * 3) / 4, minSize), oldPoint, ctx)) {
                valueFont = valueFont.with({ widthHint: rect.getWidth() - this._labelPadding });
                if (!this._autoSizeBisection(valueFont, rect, textSize, dvd, minSize, oldPoint, ctx)) {
                    retVal = false;
                }
            }
            dvd.widthHint = valueFont.widthHint;
            dvd.customWidthHint = true;
            return retVal;
        };
        // Used to find a valid height for the font that fits in the rectangle
        //
        // @param valueFont [FDSFont] font we are drawing with
        // @param rect [Rectangle] the rectangle that we need to fit in
        // @param textSize [Object] the size of the text that was measured before
        // @param dvd [DelayedValue] The object to store our drawing information
        // @param MinSize [Number] the minimum size for our font
        // @param MaxSize [Number] the maximum size for our font
        // @param ctx [ChartRenderingContext] The canvas context used for measuring font sizes
        TreemapDrawStyle.prototype._autoSizeBisection = function (valueFont, rect, textSize, dvd, MinSize, MaxSize, ctx) {
            var minSize = MinSize - 1;
            var maxSize = MaxSize;
            var midSize = Math.ceil((maxSize + minSize) / 2);
            while (minSize < maxSize) {
                dvd.customHeight = midSize;
                valueFont = valueFont.with({ height: dvd.customHeight });
                var textSizeInternal = RichTextRenderer.measureRichText(ctx, dvd.annotStr, valueFont)[0];
                if (this._isTextTooBig(textSizeInternal, rect)) {
                    maxSize = midSize - 1;
                }
                else {
                    minSize = midSize;
                }
                midSize = Math.ceil((maxSize + minSize) / 2);
            }
            dvd.customHeight = midSize;
            valueFont = valueFont.with({ height: dvd.customHeight });
            var tempSize = RichTextRenderer.measureRichText(ctx, dvd.annotStr, valueFont)[0];
            for (var key in tempSize) {
                var val = tempSize[key];
                textSize[key] = val;
            }
            return midSize !== MinSize - 1;
        };
        // Helper function to determine if the text fits in the given rectangle
        TreemapDrawStyle.prototype._isTextTooBig = function (textSize, rect) {
            return textSize.width > (rect.getWidth() - this._labelPadding) || textSize.height > rect.getHeight();
        };
        TreemapDrawStyle.prototype.verify = function () {
            return true;
        };
        TreemapDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        TreemapDrawStyle.prototype.drawMarkersToBuffer = function (prm, ctx) {
            // intentionally left blank
        };
        TreemapDrawStyle.prototype.getClickTooltipArrowPoint = function (x, y, index) {
            return { point: new Point(x, y), position: "above" /* above */ };
        };
        return TreemapDrawStyle;
    }(BaseDrawStyle));
    /** Simple container of information used by SeriesValue labels during the calculation phase, but prior to being drawn. */
    var DelayedValue = /** @class */ (function () {
        /**
         * @constructor
         */
        function DelayedValue(series) {
            this.hitRect = true;
            this.customWidthHint = false;
            this.widthHint = 0;
            this.customHeight = 0;
            this.series = series;
        }
        return DelayedValue;
    }());
    /**
     * Container of cached attribute values pertaining to treemaps.
     */
    var HeirarchyDesc = /** @class */ (function () {
        /**
         * @constructor
         */
        function HeirarchyDesc() {
            this.seriesWidthMax = 8;
            this.hierarchyDepthMax = -1;
            this.DataClipStdDeviation = 1.5;
            this.TreemapRestrictColorRange = 0.0;
            this.TreemapFadeColorWithHierarchy = true;
            this.TreemapAutoSizeLabels = true;
            this.TreemapLabelMaximumContrast = false;
            this.TreemapLabelFontHeightMin = 6;
            this.TreemapForceAllLabels = false;
            this.TreemapShowHighlightRect = true;
            this.TreemapDrawLabelsRecursively = false;
            this.TreemapCategoryLabelPosition = 1 /* CENTER */;
            this.TreemapCategoryLabelHeight = 18;
            this.TreemapCategoryLabelFontHeightMin = 8;
            this.TreemapCategoryLabelMaximumContrast = false;
            this.TreemapCategoryLabelBGColorList = '';
            this.TreemapCategoryLabelBGGradientColorList = '';
            this.TreemapCategoryLabelFontColorList = '';
            this.TreemapCategoryLabelFontHeightList = '';
        }
        return HeirarchyDesc;
    }());
    
    var Trendline = /** @class */ (function (_super) {
        __extends(Trendline, _super);
        function Trendline(series) {
            return _super.call(this, series) || this;
        }
        Trendline.prototype.drawSelectionMarkers = function (prm, ctx) {
            if (!this.series.isSelected()) {
                return;
            }
            ctx.save();
            ctx.translate(prm.plotRect.x1, prm.plotRect.y1);
            this._setupSelectionMarkerPenAndBrush(this.root.canvasDifferenceSupported(), ctx);
            var xPt1 = this.series.getFirstValidPoint(1 /* X */);
            var xPt2 = this.series.getLastValidPoint(1 /* X */);
            var yPt1 = this._yData.getAt(xPt1.index);
            var yPt2 = this._yData.getAt(xPt2.index);
            var _a = this._calculatePoints(prm, xPt1.value, xPt2.value, yPt1, yPt2, true), linePt1 = _a.linePt1, linePt2 = _a.linePt2, dataPt1 = _a.dataPt1, dataPt2 = _a.dataPt2, ndcY1 = _a.ndcY1, ndcY2 = _a.ndcY2;
            var circleSize = this.series.interactionHandleSize;
            var circleMarkerFunctor = getMarkerDrawFunctor(1 /* CIRCLE */, circleSize * 2);
            ctx.beginPath();
            circleMarkerFunctor(ctx, linePt1.x, linePt1.y);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            circleMarkerFunctor(ctx, linePt2.x, linePt2.y);
            ctx.fill();
            ctx.stroke();
            // save pixel points for all selected points
            var x1 = Math.round(linePt1.x + prm.plotRect.x1);
            var y1 = Math.round(linePt1.y + prm.plotRect.y1);
            var x2 = Math.round(linePt2.x + prm.plotRect.x1);
            var y2 = Math.round(linePt2.y + prm.plotRect.y1);
            this.root.interactionHandlePixelPoints[this.series.id] = [{ x: x1, y: y1 }, { x: x2, y: y2 }];
            ctx.restore();
        };
        Trendline.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            var xPt1 = this.series.getFirstValidPoint(1 /* X */);
            var xPt2 = this.series.getLastValidPoint(1 /* X */);
            if (xPt1.index === xPt2.index) {
                ctx.restore();
                return;
            }
            var yPt1 = this._yData.getAt(xPt1.index);
            var yPt2 = this._yData.getAt(xPt2.index);
            var _a = this._calculatePoints(prm, xPt1.value, xPt2.value, yPt1, yPt2), linePt1 = _a.linePt1, linePt2 = _a.linePt2, dataPt1 = _a.dataPt1, dataPt2 = _a.dataPt2, ndcY1 = _a.ndcY1, ndcY2 = _a.ndcY2;
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            ctx.beginPath();
            pen.drawPolyline(ctx, linePt1, linePt2);
            pen.closePolyline();
            ctx.fill();
            ctx.stroke();
            // add hit shapes
            var midX = linePt1.x + ((linePt2.x - linePt1.x) / 2);
            var midY = linePt1.y + ((linePt2.y - linePt1.y) / 2);
            var line1 = new FDSLineHitShape(linePt1.x + prm.plotRect.x1, linePt1.y + prm.plotRect.y1, midX + prm.plotRect.x1, midY + prm.plotRect.y1);
            line1.index = xPt1.index;
            line1.thickness = DRAWINGTOOL_HITSHAPE_LINE;
            var line2 = new FDSLineHitShape(midX + prm.plotRect.x1, midY + prm.plotRect.y1, linePt2.x + prm.plotRect.x1, linePt2.y + prm.plotRect.y1);
            line2.index = xPt2.index;
            line2.thickness = DRAWINGTOOL_HITSHAPE_LINE;
            if (this.series.isInteractive(2 /* DRAGGABLE */)) {
                line1.name = 5 /* SERIESHIT */;
                line2.name = 5 /* SERIESHIT */;
            }
            var lineHitShapes = [line2, line1];
            var dpSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var rect1 = new FDSRectangleHitShape((dataPt1.x + prm.plotRect.x1) - dpSize, (dataPt1.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
            rect1.index = xPt1.index;
            var rect2 = new FDSRectangleHitShape((dataPt2.x + prm.plotRect.x1) - dpSize, (dataPt2.y + prm.plotRect.y1) - dpSize, dpSize * 2, dpSize * 2);
            rect2.index = xPt2.index;
            if (this.series.isInteractive(4 /* RESIZABLE */)) {
                rect1.name = 3 /* DATAPOINT */;
                rect2.name = 3 /* DATAPOINT */;
            }
            var rectangleHitShapes = [rect2, rect1];
            var pixX = Math.round(midX + prm.plotRect.x1);
            var pixY = Math.round(midY + prm.plotRect.y1);
            this.root.pixelPoints[this.series.id][0] = { x: pixX, y: pixY };
            this.series.hitVector = this.series.hitVector.concat(lineHitShapes);
            this.series.hitVector = this.series.hitVector.concat(rectangleHitShapes);
            ctx.restore();
        };
        Trendline.prototype._calculatePoints = function (prm, xPt1, xPt2, yPt1, yPt2, ignoreExtend) {
            if (ignoreExtend === void 0) { ignoreExtend = false; }
            var extendLine = this.series.extendLine;
            var extendLD = this.series.extendLineLeftOrDown;
            var extendRU = this.series.extendLineRightOrUp;
            var reverse = this._xScale.reverse;
            var x1 = this._xScale.lookup(xPt1, this._xBin);
            var x2 = this._xScale.lookup(xPt2, this._xBin);
            var y1 = this._yScale.lookup(yPt1, this._yBin);
            var y2 = this._yScale.lookup(yPt2, this._yBin);
            var dataPt1 = new Point((prm.plot.subPlotFromNDC(x1, 1 /* X */)), (prm.plot.subPlotFromNDC(y1, 2 /* Y */)));
            var dataPt2 = new Point((prm.plot.subPlotFromNDC(x2, 1 /* X */)), (prm.plot.subPlotFromNDC(y2, 2 /* Y */)));
            var ndcY1 = y1;
            var ndcY2 = y2;
            var linePt1 = new Point(~~(prm.plot.subPlotFromNDC(x1, 1 /* X */)), ~~(prm.plot.subPlotFromNDC(y1, 2 /* Y */)));
            var linePt2 = new Point(~~(prm.plot.subPlotFromNDC(x2, 1 /* X */)), ~~(prm.plot.subPlotFromNDC(y2, 2 /* Y */)));
            if ((extendLine || extendLD) && (!ignoreExtend)) {
                if (fuzzyEQ(x1, x2)) {
                    ndcY1 = y1 > y2 ? this._yScale.getMaxPlotFactor() : this._yScale.getMinPlotFactor();
                    linePt1 = new Point(~~(prm.plot.subPlotFromNDC(x1, 1 /* X */)), ~~(prm.plot.subPlotFromNDC(ndcY1, 2 /* Y */)));
                }
                else {
                    var slope = (y2 - y1) / (x2 - x1);
                    ndcY1 = y1 + (slope * (this._xScale.getMinPlotFactor() - x1));
                    linePt1 = new Point(~~(prm.plot.subPlotFromNDC(this._xScale.getMinPlotFactor(), 1 /* X */)), ~~(prm.plot.subPlotFromNDC(ndcY1, 2 /* Y */)));
                }
            }
            if ((extendLine || extendRU) && (!ignoreExtend)) {
                if (fuzzyEQ(x1, x2)) {
                    ndcY2 = y1 > y2 ? this._yScale.getMinPlotFactor() : this._yScale.getMaxPlotFactor();
                    linePt2 = new Point(~~(prm.plot.subPlotFromNDC(x2, 1 /* X */)), ~~(prm.plot.subPlotFromNDC(ndcY2, 2 /* Y */)));
                }
                else {
                    var slope = (y2 - y1) / (x2 - x1);
                    ndcY2 = y2 + (slope * (this._xScale.getMaxPlotFactor() - x2));
                    linePt2 = new Point(~~(prm.plot.subPlotFromNDC(this._xScale.getMaxPlotFactor(), 1 /* X */)), ~~(prm.plot.subPlotFromNDC(ndcY2, 2 /* Y */)));
                }
            }
            return { linePt1: linePt1, linePt2: linePt2, dataPt1: dataPt1, dataPt2: dataPt2, ndcY1: ndcY1, ndcY2: ndcY2 };
        };
        Trendline.prototype.hint = function () {
            return 0 /* LINE */;
        };
        Trendline.prototype.verify = function () {
            return true;
        };
        return Trendline;
    }(BaseDrawStyle));
    
    var VerticalDrawStyle = /** @class */ (function (_super) {
        __extends(VerticalDrawStyle, _super);
        function VerticalDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VerticalDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            ctx.save();
            // select a copy of the seriesFGPen to draw with on this canvas
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            var colorData;
            if (this.series.useColor) {
                colorData = this.series.getData(4 /* COLOR */);
            }
            // Draw each point in `@xData` as a vertical line
            // We don't care about factor - span the entire plot
            var plot = prm.plot;
            var y1 = 0;
            var y2 = plot.plotRect.getHeight();
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            for (var i = 0; i < this.series.size; i++) {
                var dataItem = this._xData.data[i];
                if (dataItem == null || IsSomeNAN(dataItem)) {
                    continue;
                }
                var xPoint = this._xScale.lookup(dataItem);
                if (this.series.useColor) {
                    this._setColorMapColor(ctx, pen, colorData.getAt(i), i);
                }
                var x = (~~(plot.subPlotFromNDC(xPoint, 1 /* X */))) + 0.5;
                // save the pixel points, including the space before/above the plot rect
                var pixX = Math.round(x);
                var pixY = Math.round((y1 + y2) / 2);
                var pR = prm.plot.plotRect;
                pixelPoints[i] = { x: pixX + pR.x1, y: pixY + pR.y1 };
                // save the pixel points, including the space before/above the plot rect
                pixX = Math.round(x);
                pixY = Math.round((y1 + y2) / 2);
                pR = prm.plot.plotRect;
                pixelPoints[i] = { x: pixX + pR.x1, y: pixY + pR.y1 };
                ctx.beginPath();
                pen.drawPolyline(ctx, {
                    x: x,
                    y: y1
                }, {
                    x: x,
                    y: y2
                });
                pen.closePolyline();
                ctx.stroke();
                // add the hitshape
                if (this._setHitVector) {
                    var hitLine = new FDSLineHitShape(x + prm.plotRect.x1, y1 + prm.plotRect.y1, x + prm.plotRect.x1, y2 + prm.plotRect.y1);
                    hitLine.index = i;
                    hitLine.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                    hitLine.name = 5 /* SERIESHIT */;
                    this.series.hitVector.push(hitLine);
                }
                if (this.seriesSelected) {
                    this.cacheSelectable(prm, 5 /* SERIESHIT */, new Point(x, y1 + FDSFudge));
                    this.cacheSelectable(prm, 5 /* SERIESHIT */, new Point(x, y2 - FDSFudge));
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            this._resetColorMapColor(pen);
            ctx.restore();
        };
        VerticalDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = (width * 0.8) | 0;
            height = (height * 0.8) | 0;
            var size = Math.min(width, height);
            var offset = (size * 0.4) | 0;
            ctx.beginPath();
            pen.drawPolyline(ctx, {
                x: x,
                y: y - offset
            }, {
                x: x,
                y: y + offset
            });
            pen.closePolyline();
            ctx.stroke();
        };
        VerticalDrawStyle.prototype.verify = function () {
            return true;
        };
        VerticalDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return VerticalDrawStyle;
    }(BaseDrawStyle));
    
    var VertRectDrawStyle = /** @class */ (function (_super) {
        __extends(VertRectDrawStyle, _super);
        function VertRectDrawStyle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VertRectDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            ctx.save();
            var pen = this._choosePens(ctx, false).pen;
            this.series.seriesBGBrush.setOnCanvas(ctx, prm.plotRect);
            // set up the pixel point array (and replace it if it existed already)
            var pixelPoints = {};
            var yAxis = this.series.getAxis(2 /* Y */);
            var bottomY = prm.plot.subPlotFromNDC(yAxis.minPlotFactor, 2 /* Y */);
            var topY = prm.plot.subPlotFromNDC(yAxis.maxPlotFactor, 2 /* Y */);
            var x0 = 0;
            if (this.series.seriesBGBrush.style !== 1 /* NULL */) {
                for (var i = 0; i < this.series.size; i++) {
                    // skip bad points
                    var dataItem = this._xData.data[i];
                    if (dataItem == null || IsSomeNAN(dataItem)) {
                        continue;
                    }
                    // Draw each data point as a point on a line
                    var x = prm.plot.subPlotFromNDC((this._xScale.lookup(dataItem, this._xBin)), 1 /* X */);
                    if (i % 2 === 1) {
                        var x1 = Math.min(x0, x);
                        var x2 = Math.max(x0, x);
                        var w = Math.abs(x0 - x);
                        // save the pixel points, including the space before/above the plot rect
                        var pR = prm.plot.plotRect;
                        var pixX = Math.round(x1 + (w / 2) + pR.x1);
                        var pixY = Math.round(((bottomY + topY) / 2) + pR.y1);
                        pixelPoints[i - 1] = { x: pixX, y: pixY };
                        // save for the current (odd) index too, it counts as part of this rect
                        pixelPoints[i] = { x: pixX, y: pixY };
                        // every other datapoint defines a rectangle
                        ctx.fillRect(x1, topY, w, bottomY - topY);
                        // stroke - pen is selected from before
                        ctx.beginPath();
                        pen.drawPolyline(ctx, { x: x1, y: topY }, { x: x1, y: bottomY });
                        pen.drawPolyline(ctx, { x: x1, y: bottomY }, { x: x2, y: bottomY });
                        pen.drawPolyline(ctx, { x: x2, y: bottomY }, { x: x2, y: topY });
                        pen.drawPolyline(ctx, { x: x2, y: topY }, { x: x1, y: topY });
                        pen.closePolyline();
                        ctx.stroke();
                        // hit shapes
                        var hitRect = new FDSRectangleHitShape(x1 + prm.plotRect.x1, topY + prm.plotRect.y1, w, bottomY - topY);
                        // hit rects point to the first of two points (to match PC side)
                        hitRect.index = i - 1;
                        this.series.hitVector.push(hitRect);
                    }
                    else {
                        // save this point for next time
                        x0 = x;
                    }
                }
            }
            this.root.pixelPoints[this.series.id] = pixelPoints;
            ctx.restore();
        };
        // helper function to select the necessary pens and brushes
        // (since the same logic is in both the main draw fn and the legend fn)
        // returns pen for use in drawing polylines
        VertRectDrawStyle.prototype._choosePens = function (ctx, legend) {
            var newPen = this.series.seriesOutlinePen;
            if (legend) {
                // use a special thin pen to draw the legend
                newPen = newPen.with({ width: 1 });
            }
            newPen.setOnCanvas(ctx);
            var props = newPen.toPropertyObject();
            var newBrush;
            // If the brush is hatched, we need to swap the brush color for the
            // foreground pen color.
            if (this.series.seriesBGBrush.style === 2 /* HATCHED */) {
                newBrush = this.series.seriesBGBrush.copy();
                newBrush.color = this.series.seriesFGPen.color;
                newBrush.setOnCanvas(ctx);
            }
            else {
                // select the seriesBGBrush for drawing filled areas
                newBrush = this.series.seriesBGBrush;
                newBrush.setOnCanvas(ctx);
            }
            return { brush: newBrush, pen: newPen, penProps: props };
        };
        VertRectDrawStyle.prototype.drawLegendPreview = function (ctx, x, y, width, height) {
            this._choosePens(ctx, true);
            // logic copied from PC side
            // floor everything to avoid half-pixel coordinates
            width = ~~(width * 0.8);
            var size = Math.min(width, (~~(height * 0.8)));
            var plus = ~~(size * 0.4);
            var minus = ~~(size * 0.4);
            var halfplus = ~~(plus / 2);
            var halfminus = ~~(minus / 2);
            ctx.fillRect(x - halfminus, y - plus, halfminus + halfplus, minus + plus);
            ctx.strokeRect(x - halfminus, y - plus, halfminus + halfplus, minus + plus);
        };
        VertRectDrawStyle.prototype.verify = function () {
            return true;
        };
        VertRectDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        return VertRectDrawStyle;
    }(BaseDrawStyle));
    
    var ZigZagDrawStyle = /** @class */ (function (_super) {
        __extends(ZigZagDrawStyle, _super);
        function ZigZagDrawStyle(series) {
            var _this = _super.call(this, series) || this;
            _this._finalListOfPoints = [];
            _this._tipIndices = [];
            _this._hitVector = [];
            _this._isResizable = _this.series.isInteractive(4 /* RESIZABLE */);
            _this._addNamesToHitshapes = _this._isInteractable;
            _this._drawInteractionHandle = _this.seriesSelected && _this._addNamesToHitshapes;
            return _this;
        }
        ZigZagDrawStyle.prototype.drawToBuffer = function (prm, ctx) {
            this.prepareToDraw();
            if (this._yData.getSize() < 2 || this._xData.getSize() < 2) {
                return;
            }
            this._finalListOfPoints = [];
            this._tipIndices = [];
            this._hitVector = [];
            var _a = this.series.getSortedData(), data = _a.data, startIndex = _a.startIndex, endIndex = _a.endIndex;
            if (data.length <= 1) {
                return;
            }
            ctx.save();
            var pen = this.series.seriesFGPen;
            pen.setOnCanvas(ctx);
            var xLeft = Math.max(this._xScale.getMinPlotFactor(), this._xScale.lookup(this._xData.getAt(startIndex)));
            var xRight = Math.min(this._xScale.getMaxPlotFactor(), this._xScale.lookup(this._xData.getAt(endIndex)));
            var yLeft = Math.max(this._yScale.getMinPlotFactor(), this._yScale.lookup(this._yData.getAt(startIndex)));
            var yRight = Math.min(this._yScale.getMaxPlotFactor(), this._yScale.lookup(this._yData.getAt(endIndex)));
            var change = 1 + this.series.zigZagThreshold;
            var negativeChange = 1 - this.series.zigZagThreshold;
            var currentValue = this._yData.getAt(startIndex);
            var lastPointIndex, lastMaxIndex, lastMinIndex;
            var lastPointValue, lastMaxIndexValue, lastMinIndexValue;
            lastPointIndex = lastMaxIndex = lastMinIndex = startIndex;
            lastPointValue = lastMaxIndexValue = lastMinIndexValue = currentValue;
            var lastPointX = data[0].point.x;
            var tmpMax = 0.0;
            var tmpMin = 0.0;
            var ptlast = new Point(0, 0);
            var pt1 = new Point(prm.plot.subPlotFromNDC(xLeft, 1 /* X */), prm.plot.subPlotFromNDC(yLeft, 2 /* Y */));
            var pt2 = new Point(prm.plot.subPlotFromNDC(xRight, 1 /* X */), prm.plot.subPlotFromNDC(yRight, 2 /* Y */));
            this._tipIndices.push(startIndex);
            if (this.series.zigZagDimensionsMask === 0) {
                return;
            }
            for (var i = 0; i < data.length; i++) {
                // skip the first point because we initialized it all up top
                var el = data[i];
                if (i === 0) {
                    continue;
                }
                var _b = this._yData.getDataBounds(el.index, this.series.zigZagDimensionsMask), min$$1 = _b.min, max$$1 = _b.max;
                tmpMin = min$$1;
                tmpMax = max$$1;
                var positiveChangeFromLastPoint = lastPointValue * change;
                var negativeChangeFromLastPoint = lastPointValue * negativeChange;
                var maxNegativeChangeFromLastMax = lastMaxIndexValue * negativeChange;
                var maxPositiveChangeFromLastMin = lastMinIndexValue * change;
                if (lastMaxIndexValue > positiveChangeFromLastPoint && tmpMin < maxNegativeChangeFromLastMax &&
                    !fuzzyEQ(el.point.x, lastPointX)) {
                    if (this._finalListOfPoints.length === 0) {
                        ptlast = this._addFirstDpAndSelectionMarker(prm, ptlast, pt1, startIndex, false, this.series.zigZagDimensionsMask);
                    }
                    ptlast = this._storeCurrentPoint(prm, lastMaxIndex, lastMaxIndexValue, el.index, ptlast);
                    lastPointIndex = lastMaxIndex;
                    lastPointValue = lastMaxIndexValue;
                    lastMinIndex = el.index;
                    lastMinIndexValue = tmpMin;
                    lastPointX = el.point.x;
                }
                if (lastMinIndexValue < negativeChangeFromLastPoint && tmpMax > maxPositiveChangeFromLastMin &&
                    !fuzzyEQ(el.point.x, lastPointX)) {
                    if (this._finalListOfPoints.length === 0) {
                        ptlast = this._addFirstDpAndSelectionMarker(prm, ptlast, pt1, startIndex, true, this.series.zigZagDimensionsMask);
                    }
                    ptlast = this._storeCurrentPoint(prm, lastMinIndex, lastMinIndexValue, el.index, ptlast);
                    lastPointIndex = lastMinIndex;
                    lastPointValue = lastMinIndexValue;
                    lastMaxIndex = el.index;
                    lastMaxIndexValue = tmpMax;
                    lastPointX = el.point.x;
                }
                if (lastMaxIndexValue < tmpMax) {
                    lastMaxIndexValue = tmpMax;
                    lastMaxIndex = el.index;
                }
                if (lastMinIndexValue > tmpMin) {
                    lastMinIndexValue = tmpMin;
                    lastMinIndex = el.index;
                }
            }
            if (this._finalListOfPoints.length === 0) {
                this._addFirstDpAndSelectionMarker(prm, ptlast, pt1, startIndex, tmpMin < lastPointValue, this.series.zigZagDimensionsMask);
            }
            if (tmpMax > lastPointValue) {
                this._calculatePtAndAddSelectionMarker(prm, ptlast, pt2, this._xData.getAt(endIndex), tmpMax);
            }
            else if (tmpMin < lastPointValue) {
                this._calculatePtAndAddSelectionMarker(prm, ptlast, pt2, this._xData.getAt(endIndex), tmpMin);
            }
            this._finalListOfPoints.push(pt2);
            var lastPt;
            ctx.beginPath();
            if (this._finalListOfPoints.length > 2) {
                for (var i = 0; i < this._finalListOfPoints.length; i++) {
                    var pt = this._finalListOfPoints[i];
                    if (0 < i && i < this._finalListOfPoints.length - 1 && this._setHitVector) {
                        var rect = new FDSRectangleHitShape(prm.plotRect.x1 + pt.x, prm.plotRect.y1 + pt.y, this.series.datapointHitShapeSize, this.series.datapointHitShapeSize);
                        rect.index = this._tipIndices[i];
                        rect.name = 0 /* NONE */;
                        this._hitVector.push(rect);
                    }
                    if (i === 0) {
                        ctx.moveTo(pt.x, pt.y);
                    }
                    else {
                        pen.drawPolyline(ctx, lastPt, pt);
                    }
                    lastPt = pt;
                }
            }
            else {
                this._addHitShape(prm, pt1, pt2);
                ctx.moveTo(pt1.x, pt2.x);
                pen.drawPolyline(ctx, pt1, pt2);
            }
            pen.closePolyline();
            ctx.stroke();
            ctx.restore();
            if (this._drawInteractionHandle) {
                this._addZigZagInteractionHandle(ctx, prm, this._finalListOfPoints);
            }
            if (this._setHitVector) {
                this._addEndpointsHitShapes(prm, pt1, pt2, startIndex, endIndex);
            }
            this.series.root.pixelPoints[this.series.id] = this._createPixelPoints(prm);
            this.series.hitVector = this._hitVector;
        };
        ZigZagDrawStyle.prototype._addZigZagInteractionHandle = function (ctx, prm, points) {
            ctx.save();
            var pen = this.series.interactionFGPen;
            pen.setOnCanvas(ctx);
            ctx.beginPath();
            var lastPt;
            for (var i = 0; i < points.length; i++) {
                var pt = points[i];
                if (i === 0) {
                    ctx.moveTo(pt.x, pt.y);
                }
                else {
                    pen.drawPolyline(ctx, lastPt, pt);
                }
                lastPt = pt;
            }
            ctx.stroke();
            ctx.restore();
        };
        ZigZagDrawStyle.prototype._addEndpointsHitShapes = function (prm, pt1, pt2, startIndex, endIndex) {
            var hitShapeSize = this.series.datapointHitShapeSize + DRAWINGTOOL_HITSHAPE_INTERACTIONMARKER;
            var left = new FDSRectangleHitShape((prm.plotRect.x1 + pt1.x) - hitShapeSize, (prm.plotRect.y1 + pt1.y) - hitShapeSize, 2 * hitShapeSize, 2 * hitShapeSize);
            left.index = startIndex;
            left.name = 6 /* DATAPOINTLEFT */;
            var right = new FDSRectangleHitShape((prm.plotRect.x1 + pt2.x) - hitShapeSize, (prm.plotRect.y1 + pt2.y) - hitShapeSize, 2 * hitShapeSize, 2 * hitShapeSize);
            right.index = endIndex;
            right.name = 7 /* DATAPOINTRIGHT */;
            this._hitVector.push(left);
            this._hitVector.push(right);
        };
        // stores the new point in the final list of points
        // and adds the hitshape for it. Returns the new point to be
        // assigned to ptLast
        ZigZagDrawStyle.prototype._storeCurrentPoint = function (prm, lastIndex, value, index, ptLast) {
            var plot = prm.plot;
            var x = plot.subPlotFromNDC(this._xScale.lookup(this._xData.getAt(lastIndex)), 1 /* X */);
            var y = plot.subPlotFromNDC(this._yScale.lookup(value), 2 /* Y */);
            var ptCurrent = new Point(x, y);
            this._finalListOfPoints.push(ptCurrent);
            this._tipIndices.push(index);
            this._addHitShape(prm, ptLast, ptCurrent);
            return ptCurrent;
        };
        ZigZagDrawStyle.prototype._addFirstDpAndSelectionMarker = function (prm, ptlast, pt, index, useMax, zigZagDimensionsMask) {
            var _a = this._yData.getDataBounds(index, zigZagDimensionsMask), max$$1 = _a.max, min$$1 = _a.min;
            var plot = prm.plot;
            pt.x = plot.subPlotFromNDC(this._xScale.lookup(this._xData.getAt(index)), 1 /* X */);
            pt.y = plot.subPlotFromNDC(this._yScale.lookup(useMax ? max$$1 : min$$1), 2 /* Y */);
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, pt.x, pt.y);
            }
            this._finalListOfPoints.push(pt);
            return pt;
        };
        ZigZagDrawStyle.prototype._calculatePtAndAddSelectionMarker = function (prm, ptlast, pt, x, y) {
            var plot = prm.plot;
            pt.x = plot.subPlotFromNDC(this._xScale.lookup(x), 1 /* X */);
            pt.y = plot.subPlotFromNDC(this._yScale.lookup(y), 2 /* Y */);
            if (this.seriesSelected) {
                this.cacheSelectable(prm, 3 /* DATAPOINT */, pt.x, pt.y);
            }
            this._addHitShape(prm, ptlast, pt);
        };
        ZigZagDrawStyle.prototype._addHitShape = function (prm, pt1, pt2) {
            if (this._setHitVector) {
                var plotX1 = prm.plotRect.x1;
                var plotY1 = prm.plotRect.y1;
                var line = new FDSLineHitShape(pt1.x + plotX1, pt1.y + plotY1, pt2.x + plotX1, pt2.y + plotY1);
                line.index = -1;
                line.name = 8 /* SERIESHITLEFTRIGHT */;
                line.thickness = DRAWINGTOOL_HITSHAPE_LINE;
                this._hitVector.push(line);
            }
        };
        ZigZagDrawStyle.prototype._createPixelPoints = function (prm) {
            var pixelPoints = {};
            for (var i = 0; i < this._finalListOfPoints.length; i++) {
                var x = ~~(this._finalListOfPoints[i].x + prm.plotRect.x1);
                var y = ~~(this._finalListOfPoints[i].y + prm.plotRect.y1);
                pixelPoints[i] = { x: x, y: y };
            }
            return pixelPoints;
        };
        ZigZagDrawStyle.prototype.hint = function () {
            return 0 /* LINE */;
        };
        ZigZagDrawStyle.prototype.verify = function () {
            return true;
        };
        return ZigZagDrawStyle;
    }(InteractiveDrawStyle));
    
    var getDrawStyleFromEnum = function (name, isStacked) {
        switch (name) {
            case 9 /* AREA */:
                return (isStacked) ? AreaDrawStyle : NewAreaDrawStyle;
            case 17 /* HORIZONTAL */:
                return HorizontalDrawStyle;
            case 16 /* VERTICAL */:
                return VerticalDrawStyle;
            case 6 /* COLUMNS */:
                return (isStacked) ? OldColumnsDrawStyle : ColumnsDrawStyle;
            case 7 /* THIN */:
                return ThinDrawStyle;
            case 3 /* MARKER */:
                return MarkerDrawStyle;
            case 41 /* KMLMAP */:
                return ChoroplethDrawStyle;
            case 2 /* HLC */:
                return HLCDrawStyle;
            case 22 /* OHLC */:
                return OHLCDrawStyle;
            case 37 /* HLCROSS */:
                return HLCrossDrawStyle;
            case 23 /* CANDLE */:
                return CandleDrawStyle;
            case 4 /* RANGEBAR */:
                return RangeBarsDrawStyle;
            case 12 /* BARS */:
                return (isStacked) ? OldBarsDrawStyle : BarsDrawStyle;
            case 13 /* THINBARS */:
                return ThinBarsDrawStyle;
            case 14 /* STEP */:
                return StepDrawStyle;
            case 18 /* AREASTEP */:
                return AreaStepDrawStyle;
            case 19 /* PIE */:
                return PieDrawStyle;
            case 31 /* BUBBLE */:
                return BubbleDrawStyle;
            case 36 /* PIE3D */:
                return Pie3dDrawStyle;
            case 27 /* RECT */:
                return RectDrawStyle;
            case 28 /* VERTRECT */:
                return VertRectDrawStyle;
            case 29 /* HORZRECT */:
                return HorzRectDrawStyle;
            case -1 /* NONE */:
                return BaseDrawStyle;
            case 11 /* BARS3D */:
                return Bars3dDrawStyle;
            case 5 /* COLUMNS3D */:
                return Columns3dDrawStyle;
            case 53 /* TRENDLINE */:
                return Trendline;
            case 38 /* TREEMAP */:
                return TreemapDrawStyle;
            case 43 /* FIBARC */:
                return FibArc;
            case 42 /* FIBRETRACEMENTS */:
                return FibonacciRetracements;
            case 44 /* FIBFAN */:
                return FibonacciFan;
            case 45 /* FIBTIMEZONES */:
                return FibonacciTimeZones;
            case 46 /* GANNFAN */:
                return GannFan;
            case 21 /* REGRESSION */:
                return Regression;
            case 54 /* PRICE_CHANGE */:
                return PriceChange;
            case 55 /* ELLIPSE */:
                return CircleDrawStyle;
            case 56 /* ARROW */:
                return ArrowDrawStyle;
            case 49 /* TIRONELEVELS */:
                return TironeLevels;
            case 47 /* QUADRANTLINES */:
                return QuadrantLines;
            case 58 /* RELATIVE_AREA */:
                return RelativeAreaDrawStyle;
            case 51 /* ZIGZAG */:
                return ZigZagDrawStyle;
            case 48 /* RAFFREGRESSION */:
                return RaffRegression;
            case 50 /* SPEED_RESISTANCE_LEVELS */:
                return SpeedResistanceLevels;
            case 57 /* FIBPROJECTION */:
                return FibProjection;
            case 59 /* DRAGGABLE_MARKER */:
                return DraggableMarkerDrawStyle;
            case 20 /* CSPLINE */:
                return CSplineDrawStyle;
            case 61 /* RANGECANDLE */:
                return RangeCandleDrawStyle;
            case 62 /* HISTOGRAM */:
                return HistogramDrawStyle;
            case 63 /* BARINDICATOR */:
                return BarIndicatorDrawstyle;
            case 64 /* HISTOGRAM_AS_COLUMNS */:
                return ColumnsDrawStyle;
            default:
                return LineDrawStyle;
        }
    };
    
    var FDSSeriesDataCache = /** @class */ (function () {
        function FDSSeriesDataCache(series) {
            this._series = series;
            this.setDirty();
        }
        FDSSeriesDataCache.prototype.setDirty = function () {
            this._sortedXIsDirty = true;
            this._sortedYIsDirty = true;
            this._sortedXIndices = [];
            this._sortedYIndices = [];
        };
        FDSSeriesDataCache.prototype.getIndexAndValueOfMin = function (dimension) {
            return this._getIndexHelper(dimension, _$1.first);
        };
        FDSSeriesDataCache.prototype.getIndexAndValueOfMax = function (dimension) {
            return this._getIndexHelper(dimension, _$1.last);
        };
        FDSSeriesDataCache.prototype._getIndexHelper = function (dimension, firstOrLast) {
            var indices = dimension === 1 /* X */ ? this._getSortedXIndices() : this._getSortedYIndices();
            if (indices.length > 0) {
                var data = firstOrLast(indices);
                return { index: data.index, value: data.sortedValue };
            }
            else {
                return { index: -1, value: NAN };
            }
        };
        FDSSeriesDataCache.prototype._getSortedXIndices = function () {
            if (this._sortedXIsDirty) {
                this._sortedXIndices = this._getIndicesSortedByDimension(1 /* X */);
                this._sortedXIsDirty = false;
            }
            return this._sortedXIndices;
        };
        FDSSeriesDataCache.prototype._getSortedYIndices = function () {
            if (this._sortedYIsDirty) {
                this._sortedYIndices = this._getIndicesSortedByDimension(2 /* Y */);
                this._sortedYIsDirty = false;
            }
            return this._sortedYIndices;
        };
        FDSSeriesDataCache.prototype._getIndicesSortedByDimension = function (sortedDimension) {
            var otherDimension = sortedDimension === 1 /* X */ ? 2 /* Y */ : 1;
            var sortedDataSet = this._series.getData(sortedDimension);
            var otherDataSet = this._series.getData(otherDimension);
            var numDataItems = Math.min(sortedDataSet.getSize(), otherDataSet.getSize());
            var filteredData = _$1.times(numDataItems).reduce(function (result, index) {
                var sortedValue = Number(sortedDataSet.getAt(index));
                var otherValue = otherDataSet.getAt(index);
                if (!isNaN(sortedValue) && !IsSomeInternalNAN(otherValue)) {
                    result.push({ index: index, sortedValue: sortedValue, otherValue: otherValue });
                }
                return result;
            }, []);
            return _$1.sortBy(filteredData, function (data) { return data.sortedValue; });
        };
        return FDSSeriesDataCache;
    }());
    
    var FDSSeries = /** @class */ (function (_super) {
        __extends(FDSSeries, _super);
        function FDSSeries(root, id, wrapper) {
            var _this = _super.call(this, root, id, 2 /* FC_SERIES */) || this;
            _this.wrapper = wrapper;
            _this.dimensionalChildren = {};
            _this._dimensionalAxes = {};
            _this.defined = {};
            _this.hasValidData = false;
            _this.hasValidPrimaryData = true; // Used for tracking X/Y/Z only.
            _this._dataCache = new FDSSeriesDataCache(_this);
            _this._setData();
            _this.seriesFGPen = new FDSPen();
            _this.seriesOutlinePen = new FDSPen();
            _this.seriesBGBrush = new FDSBrush();
            _this.seriesMarkerFGPen = new FDSPen();
            _this.seriesMarkerOutlinePen = new FDSPen();
            _this.seriesMarkerBGBrush = new FDSBrush();
            _this.bgStyle = 0 /* SOLID */;
            _this._onXAxis = 'X';
            _this._onYAxis = 'Y';
            _this.seriesAlternateBGBrush = new FDSBrush();
            _this.seriesAlternateBGBrush.style = 0 /* SOLID */;
            _this.seriesAlternateFGPen = new FDSPen();
            _this.seriesAlternateOutlinePen = new FDSPen();
            _this.seriesLabelBrush = new FDSBrush();
            _this.seriesLabelBrush.style = 0 /* SOLID */;
            _this.seriesLabelPen = new FDSPen({ color: 6710886 /* TICK_FG_GREY */ });
            _this.seriesLabelFont = new FDSFont({ height: 10, alignment: 2 /* CENTER */ });
            _this.seriesLabel1Font = new FDSFont();
            _this.seriesLabel2Font = new FDSFont();
            _this.seriesArrowBrush = new FDSBrush();
            _this.seriesArrowPen = new FDSPen();
            _this.seriesArrowLinePen = new FDSPen();
            _this.seriesValueDisplayMargins = 0.0;
            // Quick label font and label font attributes live on the series, and the font size
            // defaults to 10px, bold, and the color to a light grey.
            _this.quickLabelFont = new FDSFont({ height: 10, color: 13421772 /* PLOT_FG_GREY */, weight: 800 /* EXTRABOLD */ });
            // Quick label backgrounds default to white
            _this.quickLabelFGPen = new FDSPen();
            _this.quickLabelBGBrush = new FDSBrush();
            _this.quickLabelBGBrush.style = 0 /* SOLID */;
            _this.quickLabelBGBrush.color = 16777215 /* WHITE */;
            _this.seriesMarkerFont = new FDSFont();
            _this.seriesBGBrush.style = 0 /* SOLID */;
            _this.seriesMarkerBGBrush.style = 0 /* SOLID */;
            _this.seriesLabelBrush.style = 0 /* SOLID */;
            _this.seriesArrowBrush.style = 0 /* SOLID */;
            _this.treemapCategoryLabelPen = new FDSPen({ color: 2105376 /* TREEMAP_GREY */ });
            _this.treemapCategoryLabelBrush = new FDSBrush();
            _this.treemapCategoryLabelBrush.color = 16777215 /* WHITE */;
            _this.treemapCategoryLabelBrush.style = 0 /* SOLID */;
            _this.treemapCategoryLabelFont = new FDSFont({ alignment: 2 /* CENTER */ });
            _this._valueFormatter = new FDSFormat();
            _this._valueFormatter.setNumberFormat('#.2F');
            _this._crosshairsSwapIndexedAxis = false;
            _this._crosshairsFallbackOnLinear = false;
            _this.drawingToolType = 0 /* NONE */;
            _this.zigZagThreshold = 0.05;
            _this.zigZagDimensionsMask = -1;
            _this.hitVector = [];
            _this.barNumber = 0;
            _this.drawStyle = 0;
            _this.size = 0;
            _this.updateCount = 0;
            _this.drawBelow = true;
            _this.seriesXReference = 0;
            _this.seriesYReference = 0;
            _this.visible = true;
            _this.interactiveVisibleOverride = false;
            _this.curvedRegressionOnLogScale = false;
            _this.annotationFollowsParentValue = true;
            _this._annotationDisappearOnNoValidXData = false;
            _this._annotationDisappearOnNoValidYData = false;
            _this._annotationMode = 0 /* DEFAULT */;
            _this._parentDataPointIndex = [];
            _this.baseLineVisible = true;
            _this.baseLineFGPen = new FDSPen({ color: RGBtoCOLORREF(30, 30, 30) });
            _this.interactionFGPen = new FDSPen({ width: 8, color: RGBtoCOLORREF(34, 34, 34) });
            _this._hitShapeName = 0 /* NONE */;
            _this._initialOffsets = new Point(0, 0);
            _this._offsetDifference = new Point(0, 0);
            _this._initialSize = new Point(0, 0);
            _this._currentAnnotationTextBoxSize = new Point(0, 0);
            _this._availableSurroundingSpace = new Rectangle(0, 0, 0, 0);
            _this.hittableShapeIdentifier = 'AnnotRectangle';
            _this._cursor = Cursor.DEFAULT;
            _this.controlKeyDownWhileInteracting = false;
            _this.altKeyDownWhileInteracting = false;
            _this._leftMouseButtonDownWhileInteracting = false;
            _this._lastInteractionPoint = new Point(0, 0);
            _this.minimumWidth = 0;
            _this.minimumHeight = 0;
            _this.offsetSigns = new Point(0, 0);
            _this._seriesValueMinimumTextBoxSize = 2;
            _this._offsetMouseCoordinatesBy = new Point(0, 0);
            _this._initialOffsetMouseCoordinatesBy = new Point(0, 0);
            _this.annotationTextpoints = [];
            _this._autoPositionYOffset = 0;
            _this._autoPositionYOffsetLinkedAnnotation = 0;
            _this._previousToolTipStatus = null;
            _this._sizingModeBeforeInteraction = 1 /* CUSTOM_HINT */;
            _this._interactivityClamping = true;
            _this._initialHitShapeType = -1 /* NONE */;
            // We use this to sync the crosshairIndex when multiple properties are using it.
            // Right now, the index is synced based on the crosshairIndex FDSProperty. If this
            // index is ever -1, just use the normal @crosshairIndex. If we do not sync, it's
            // possible to encounter situations where labels using similar properties will display
            // different values.
            _this._syncCrosshairIndex = -1;
            // Set up dynamic property handlers. By setting the key to `true` instead
            // of a function object, the dispatcher will use a bound instance of the
            // member function named by the property key (e.g. `FDSLastY`) prepended
            // with `_prop` (e.g. `_propFDSLastY`)
            _this._setDynamicProperties({
                'FDSFirstX': true,
                'FDSFirstY': true,
                'FDSLastX': true,
                'FDSLastY': true,
                'FDSZoomedFirstX': true,
                'FDSZoomedFirstY': true,
                'FDSZoomedLastX': true,
                'FDSZoomedLastY': true,
                'FDSZoomedMinX': true,
                'FDSZoomedMaxX': true,
                'FDSZoomedMinY': true,
                'FDSZoomedMaxY': true,
                'FDSZoomedIndexFirst': true,
                'FDSZoomedIndexLast': true,
                'FDSZoomedIndexAtMaxX': true,
                'FDSZoomedIndexAtMinX': true,
                'FDSZoomedIndexAtMaxY': true,
                'FDSZoomedIndexAtMinY': true,
                'FDSLegendLabel': true,
                'FDSCrosshairIndex': true,
                'FDSSelectionIndex': true,
                'FDSDataX': true,
                'FDSDataY': true,
                'FDSDataZ': true,
                'FDSDataColor': true,
                'FDSDataDSize': true,
                'FDSDataLabel': true,
                'FDSDataTooltip': true,
                'FDSTooltipText': true,
                'FDSIndex': true,
                'FDSDataValue': true,
                'FDSMinX': true,
                'FDSMinY': true,
                'FDSMaxX': true,
                'FDSMaxY': true,
                'FDSMinXAll': true,
                'FDSMaxXAll': true,
                'FDSMinYAll': true,
                'FDSMaxYAll': true,
                'FDSAverageX': true,
                'FDSAverageY': true,
                'FDSStdDevX': true,
                'FDSStdDevY': true,
                'FDSVarianceX': true,
                'FDSVarianceY': true,
                'FDSCountValidX': true,
                'FDSCountValidY': true,
                'FDSDataTypeX': true,
                'FDSDataTypeY': true,
                'FDSAxisNameX': true,
                'FDSAxisNameY': true,
                'FDSPlotName': true,
                'FDSAxisFormatX': true,
                'FDSAxisFormatY': true,
                'FDSAxisTypeX': true,
                'FDSAxisTypeY': true,
                'FDSRegressionFormula': true
            });
            // `pointLookup` will be filled with rendered reference points when we
            // draw; we use it for two purposes:
            // 1. we'll use @pointLookup[x,y[0]] to correlate crosshair position with data points.
            // 2. we'll use @pointLookup[x,y[0...length] to support multiple y snapping when drawing.
            _this._pointLookup = { sorted: true, min: Number.MAX_VALUE, max: Number.MIN_VALUE, points: [] };
            _this.crosshairIndex = -1;
            _this.leftSelectIndex = -1;
            _this.rightSelectIndex = -1;
            // custom series color stuff
            _this.useColor = false;
            _this.cycleColorIndex = false;
            _this.useColorIndex = false;
            _this._useCondColor = false;
            _this.colorMap = null;
            _this.useColorMap = false;
            _this.BGGradientColor = null;
            // flag to keep track of if the DrawStyle.hanges (to prevent unnecessary redraws)
            _this.styleChanged = false;
            _this._oldDS = null;
            _this.isAnnotation = false;
            _this.highAnnotation = false;
            _this.lowAnnotation = false;
            _this.extendLine = false;
            _this.extendLineRightOrUp = false;
            _this.extendLineLeftOrDown = false;
            // Helper object for managing pie attributes
            _this.pieDesc = {
                piePercent: true,
                labelFactor: 1.0,
                minSlice: 0.0,
                tiltAngle: 30.0,
                startAngle: 0.0,
                totalAngle: 360,
                depth: 0.0,
                percentFormat: ' (#F%)',
                donutRadius: 0.0,
                radius: 1.0,
                radiusIsFactor: false,
                centerOffsetX: 0.0,
                centerOffsetY: 0.0,
                centerIsFactor: false,
                exploded: false,
                explodedIndices: [],
                explosionAmt: 20,
                explodingData: [],
                explodeAnimation: false,
                explodeMode: 0 /* NONE */,
                explodeRadius: false,
                grouped: false,
                animationTime: 500,
            };
            // for fetching the pie radius - default to PieRadius' def value
            _this.cachedPieRadius = 1;
            // Outlier Attributes
            _this.seriesOutlierIndicatorFGPen = new FDSPen({ width: 1 });
            _this.seriesOutlierIndicatorBGBrush = new FDSBrush();
            _this.seriesOutlierIndicatorBGBrush.style = 0 /* SOLID */;
            _this.seriesOutlierIndicatorBGBrush.color = RGBtoCOLORREF(255, 0, 0);
            _this.seriesOutlierIndicator = true;
            _this.seriesOutlierIndicatorStyle = 0;
            _this.seriesOutlierIndicatorSize = 12;
            _this.seriesOutlierIndicatorMarkerStyle = 22;
            _this.seriesOutlierIndicatorBreakSize = 5.0;
            _this.seriesOutlierIndicatorHatchAngle = 45;
            _this.seriesOutlierIndicatorHatchSize = 5.0;
            _this.hierarchyDesc = new HeirarchyDesc();
            _this.treemapHighlightMode = 2 /* DEFINED_LEVEL */;
            _this.treemapHighlightLevel = 0;
            _this.seriesHighlightColor = 16777215 /* WHITE */;
            // Sampling
            _this._indices = [];
            _this.stepSize = 1;
            _this.lastValidIndex = 0;
            _this.selectableItemSamplingEnabled = false;
            _this.selectableItemSamplingMinPixelsPerMarker = 20;
            _this.selectableItemPointMarkerSize = 6;
            _this._selectableItemPointMarkerType = 2 /* SQUARE */;
            _this.sampleMode = 3 /* MINMAX */;
            _this.xStart = 0;
            _this.xEnd = 0;
            _this.yStart = 0;
            _this.yEnd = 0;
            // Drawing Tools
            _this.seriesLabel1HPosition = 0 /* LEFT */;
            _this.seriesLabel2HPosition = 1 /* RIGHT */;
            _this.seriesLabel1VPosition = 1 /* V_TOP */;
            _this.seriesLabel2VPosition = 1 /* V_TOP */;
            _this.seriesLabel1XOffset = 0;
            _this.seriesLabel1YOffset = 0;
            _this.seriesLabel2XOffset = 0;
            _this.seriesLabel2YOffset = 0;
            _this.seriesLabel1ColorFollowsSeriesColor = true;
            _this.seriesLabel2ColorFollowsSeriesColor = true;
            _this.seriesLabel1Format = '#.1F';
            _this.seriesLabel2Format = '#.1F';
            _this.seriesLabel1Text = '';
            _this.seriesLabel2Text = '';
            _this._seriesSetHitVector = true;
            // Colors for PriceChange
            _this.positiveColor = RGBtoCOLORREF(0, 255, 0);
            _this.negativeColor = 255;
            // Pricechange levels
            _this.seriesLabel1LevelsMask = -1;
            _this.seriesLabel2LevelsMask = -2;
            // Interactive Draw Styles
            _this.interactionHandleSize = 5;
            // Arrow DrawStyle.tuff
            _this.arrowSize = 10;
            _this.arrowWidthScale = 2;
            _this.arrowLengthScale = 2;
            _this.arrowScalesWithLength = false;
            // Regression DrawStyle.tuff
            _this.regressionOrder = 1;
            _this.regressionType = 0 /* POLYNOMIAL */;
            _this.regressionStdDevBands = 0;
            _this.regressionStdDevOffset = 0;
            _this.regressionStdDevMirror = true;
            _this._regressionZeroOrderIsMedian = false;
            _this._regressionZeroOrderIsHarmonicMean = false;
            _this._regressionFormulaInterceptIsMin = false;
            _this._regressionFormulaExpandPolynomial = true;
            _this._regressionFormulaY = 'y = ';
            _this._regressionFormulaX = 'x';
            _this._regressionFormulaFormat = '#.2F';
            _this._regressionFormulaCollapseInts = true;
            _this._regressionFormulaSpaces = true;
            _this._regressionFormulaParens = false;
            _this.stdDevFromRegression = 0;
            // Stores calculated regression information
            _this._regressionData = [];
            // Quadrant and Tirone Drawing Tool Stuff
            _this._startIndexCached = 0;
            _this._endIndexCached = 0;
            _this._startPointYValueCached = 0;
            _this._startPointXValueCached = 0;
            _this._endPointYValueCached = 0;
            _this._endPointXValueCached = 0;
            _this.startDatapoint = NAN;
            _this.endDatapoint = NAN;
            _this.adjustAxes = true;
            _this.sysPickable = true;
            _this._sortedData = [];
            _this._startPointCached = Number.NEGATIVE_INFINITY;
            _this._endPointCached = Number.POSITIVE_INFINITY;
            // This allows us to revert the offset for textbox annotations
            // if we determine we should not have moved
            _this._seriesValueXOffsetOld = NAN;
            _this._seriesValueYOffsetOld = NAN;
            _this.enableSeriesAlternateBGBrush = false;
            _this.enableSeriesAlternateFGPen = false;
            if (!_this.wrapper) {
                _this.wrapper = new FDSSeriesWrapper(_this);
            }
            _this.histogramBinsCreator = new HistogramBinsCreator({});
            _this.histogramAsColumnsBinsCreator = new HistogramAsColumnsBinsCreator({});
            _this._setAttributes();
            return _this;
        }
        FDSSeries.prototype._init = function () {
            this._defMapID = 'DEF_SERIES';
            _super.prototype._init.call(this);
        };
        FDSSeries.prototype.clearRenderCache = function () {
            this.renderCache = null;
        };
        // Apply a theme based on what was passed into the FDSChart constructor
        FDSSeries.prototype._applyTheme = function () {
            if (!_super.prototype._applyTheme.call(this)) {
                return false;
            }
            var themeAttrs = {};
            var theme = this.root.getTheme();
            if (theme === 2 /* CARBON */) {
                themeAttrs['SeriesValueFontColor'] = 16777215 /* WHITE */;
            }
            else if (theme === 1 /* QUARTZ */) {
                themeAttrs['SeriesValueFontColor'] = 0 /* BLACK */;
            }
            for (var key in themeAttrs) {
                this.attributeSet.setAt(key, 'app', themeAttrs[key]);
            }
            return true;
        };
        // Check whether or not the drawstyle attribute was changed. If so,
        // we clear the context menu and that of the parent plot.
        FDSSeries.prototype._updateContextMenu = function () {
            var oldDrawStyle = this.drawStyle;
            this.drawStyle = this.attributeSet.get('DrawStyle');
            if (oldDrawStyle !== this.drawStyle) {
                var parent_1 = this.parent;
                if (isPlot(parent_1)) {
                    parent_1.simpleZoomEnabled = parent_1.attributeSet.get('SimpleZoom');
                }
            }
        };
        FDSSeries.prototype.syncMembers = function () {
            var _this = this;
            if (!this.attributeSet.isDirty()) {
                return;
            }
            _super.prototype.syncMembers.call(this);
            this._updateContextMenu();
            this._applyTheme();
            // If we don't have any `dimensionalChildren` or if our dataset children
            // aren't valid, then we don't have any valid data.
            this.hasValidData = false;
            _$1.forIn(this.dimensionalChildren, function (object, key) {
                object.syncMembers();
                _this.hasValidData = object.valid || _this.hasValidData;
            });
            // Saves on property access and minified file size
            var getAttribute = this.attributeSet.get.bind(this.attributeSet);
            this._seriesNumber = getAttribute('SeriesNumber');
            this.seriesColor = getAttribute('SeriesColor');
            this.enableSeriesAlternateBGBrush = getAttribute('SeriesEnableAlternateBGBrush');
            this.enableSeriesAlternateFGPen = getAttribute('SeriesEnableAlternateFGPen');
            this.seriesLabelFont = FDSFont.constructFromAttributes(this.attributeSet, 'SeriesValueFont');
            this.seriesLabel1Font = FDSFont.constructFromAttributes(this.attributeSet, 'SeriesLabel1Font');
            this.seriesLabel2Font = FDSFont.constructFromAttributes(this.attributeSet, 'SeriesLabel2Font');
            this.barNumber = getAttribute('SeriesBin');
            this.drawStyle = getAttribute('DrawStyle');
            this.drawingToolType = getAttribute('DrawingToolType');
            this.visible = getAttribute('Visible');
            this.legendTextFollowsSeriesColor = getAttribute('LegendTextFollowsSeriesColor');
            this.inLegend = getAttribute('InLegend');
            this.legendOrderIndex = getAttribute('LegendOrderIndex');
            if (this.drawStyle !== this._oldDS) {
                if (this._oldDS != null) {
                    this.styleChanged = true;
                    this.renderCache = null;
                }
                this._oldDS = this.drawStyle;
            }
            else {
                this.styleChanged = false;
            }
            this.seriesXReference = getAttribute('SeriesXReference');
            this.seriesYReference = getAttribute('SeriesYReference');
            this.maxElementWidth = getAttribute('MaxElementWidth');
            this._seriesCondColorProp = getAttribute('SeriesConditionalColorProperty');
            this._seriesCondColorDim = getAttribute('SeriesConditionalColorDimension');
            this._seriesCondColorAdvanced = getAttribute('SeriesConditionalColorAdvanced');
            this._seriesCondColorIsIndex = getAttribute('SeriesConditionalColorIsIndex');
            this.BGGradientColor = getAttribute('SeriesBGGradientColor');
            this.annotationArrowFraction = getAttribute('AnnotationArrowFraction');
            this.datapointHitShapeSize = getAttribute('DatapointHitShapeSize');
            this._tooltipText = {
                main: this.properties.compilePropertyString(this.attributeSet.get('TooltipText')),
                alt: this.properties.compilePropertyString(this.attributeSet.get('TooltipAltText')),
                center: this.properties.compilePropertyString(this.attributeSet.get('TooltipCenterText'))
            };
            this._tooltipDataMask = getAttribute('TooltipDataMask');
            this._tooltipLabelMask = getAttribute('TooltipLabelMask');
            this._tooltipSublabelMask = getAttribute('TooltipSublabelMask');
            this._tooltipShowLabel = getAttribute('TooltipShowLabel');
            this.inTips = getAttribute('InTips');
            this._crosshairsSwapIndexedAxis = getAttribute('CrosshairsSwapIndexedAxis');
            this._crosshairsFallbackOnLinear = getAttribute('CrosshairsFallbackOnLinear');
            this.crosshairsDrawMarker = getAttribute('CrosshairsDrawMarker');
            this.crosshairsMarkerColor = getAttribute('CrosshairsMarkerColor');
            this.crosshairsMarkerSize = getAttribute('CrosshairsMarkerSize');
            this.crosshairsMarkerStyle = getAttribute('CrosshairsMarkerStyle');
            this._seriesMarker3D = getAttribute('SeriesMarker3D');
            this._seriesMarker3DLightPosition = getAttribute('SeriesMarker3DLightPosition');
            this.bgStyle = getAttribute('SeriesBGStyle');
            this._maxLabels = clamp(getAttribute('MaxLabels'), 1, 500);
            this.breakOnGap = getAttribute('BreakOnGap');
            this.extendLine = getAttribute('ExtendLine');
            this.extendLineRightOrUp = getAttribute('ExtendLineRightOrUp');
            this.extendLineLeftOrDown = getAttribute('ExtendLineLeftOrDown');
            this.selectableItemSamplingEnabled = getAttribute('SelectableItemSamplingEnabled');
            this.selectableItemSamplingMinPixelsPerMarker = getAttribute('SelectableItemSamplingMinPixelsPerMarker');
            this.selectableItemPointMarkerSize = getAttribute('SelectableItemPointMarkerSize');
            this._selectableItemPointMarkerType = getAttribute('SelectableItemPointMarkerType');
            this.sampleMode = getAttribute('SampleMode');
            this.baseLineVisible = getAttribute('BaseLineVisible');
            this.baseLineFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'BaselineFG');
            this.interactionFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'InteractionHandleFG');
            this._cursor = getAttribute('Cursor');
            this._drawingToolsLevels = getAttribute('DrawingToolsLevels');
            this.labelsMask = getAttribute('LabelsMask');
            this._maxPoints = getAttribute('MaxPoints');
            this.seriesLabel1ColorFollowsSeriesColor = getAttribute('SeriesLabel1ColorFollowsSeriesColor');
            this.seriesLabel2ColorFollowsSeriesColor = getAttribute('SeriesLabel2ColorFollowsSeriesColor');
            this.seriesLabel1XOffset = getAttribute('SeriesLabel1XOffset');
            this.seriesLabel1YOffset = getAttribute('SeriesLabel1YOffset');
            this.seriesLabel2XOffset = getAttribute('SeriesLabel2XOffset');
            this.seriesLabel2YOffset = getAttribute('SeriesLabel2YOffset');
            this.seriesLabel1HPosition = getAttribute('SeriesLabel1HPosition');
            this.seriesLabel2HPosition = getAttribute('SeriesLabel2HPosition');
            this.seriesLabel1VPosition = getAttribute('SeriesLabel1VPosition');
            this.seriesLabel2VPosition = getAttribute('SeriesLabel2VPosition');
            this.seriesLabel1Format = getAttribute('SeriesLabel1Format');
            this.seriesLabel2Format = getAttribute('SeriesLabel2Format');
            this.seriesLabel1Text = getAttribute('SeriesLabel1Text');
            this.positiveColor = getAttribute('PositiveColor');
            this.negativeColor = getAttribute('NegativeColor');
            this.seriesLabel1LevelsMask = getAttribute('SeriesLabel1LevelsMask');
            this.seriesLabel2LevelsMask = getAttribute('SeriesLabel2LevelsMask');
            this.interactionHandleSize = getAttribute('InteractionHandleSize');
            this._seriesSetHitVector = getAttribute('SeriesSetHitVector');
            this.startDatapoint = getAttribute('StartDatapoint');
            this.endDatapoint = getAttribute('EndDatapoint');
            this.adjustAxes = getAttribute('AdjustAxes');
            this.sysPickable = getAttribute('SysPickable');
            this.drawBelow = getAttribute('DrawBelow');
            this.areaDrawTopLineOnly = getAttribute('AreaDrawTopLineOnly');
            this.drawThinColumnBrackets = getAttribute('DrawThinColumnBrackets');
            this._allowDraggableMarkerInterpolation = getAttribute('AllowDragableMarkerInterpolation');
            this.barColumn3dDepthFactor = getAttribute('BarColumn3dDepthFactor');
            this.barColumn3dDepthFactorDefault = this.attributeSet.isDefault('BarColumn3dDepthFactor');
            this.seriesMarker = getAttribute('SeriesMarker');
            this.markerSize = getAttribute('SeriesMarkerSize');
            this.markerMaxSize = getAttribute('SeriesMarkerMaxSize');
            this.markerStyle = this.attributeSet.getWithFallback('SeriesMarkerStyle', function () {
                var defaultMarkerStyle = _this.attributeSet.getAt('SeriesMarkerStyle', 'def');
                var markerStyleList = _this.attributeSet.getWithFallback('SeriesMarkerStyleList', [defaultMarkerStyle]);
                return _this.root.getSeriesMarkerStyle(_this._seriesNumber, markerStyleList);
            });
            this.markerXOffset = getAttribute('SeriesMarkerXOffset');
            this.markerYOffset = getAttribute('SeriesMarkerYOffset');
            this.markerText = getAttribute('SeriesMarkerText');
            this.markerTextCFS = this.properties.compilePropertyString(this.markerText);
            this.markerFontColorFollowsSeriesColor = getAttribute('SeriesMarkerFontColorFollowsSeriesColor');
            this.seriesValue = getAttribute('SeriesValue');
            if (this.seriesValue) {
                this.seriesValueXOffset = getAttribute('SeriesValueXOffset');
                this.seriesValueYOffset = getAttribute('SeriesValueYOffset');
                this.seriesValueStyle = getAttribute('SeriesValueStyle');
                this.seriesValueAutoPosition = getAttribute('SeriesValueAutoPosition');
                this.seriesValueAutoPositionMethod = getAttribute('SeriesValueAutoPositionMethod');
                this.seriesValueBoundMode = getAttribute('SeriesValueBoundMode');
                this.seriesValueSizingMode = getAttribute('SeriesValueSizingMode');
                if (this.seriesValueSizingMode !== 0 /* DEFAULT */) {
                    this._sizingModeBeforeInteraction = this.seriesValueSizingMode;
                }
                this.seriesValueWidthHint = getAttribute('SeriesValueWidthHint');
                this.seriesValueHeightHint = getAttribute('SeriesValueHeightHint');
                this.seriesValueDisplayMargins = getAttribute('SeriesValueDisplayMargins');
                this.seriesValueText = getAttribute('SeriesValueText');
                this.compiledSeriesValueText = this.properties.compilePropertyString(this.seriesValueText);
                this.seriesValueTextClipping = getAttribute('SeriesValueTextClipping');
                this.seriesValueUsePlotCoordX = getAttribute('SeriesValueUsePlotCoordX');
                this.seriesValueUsePlotCoordY = getAttribute('SeriesValueUsePlotCoordY');
                this.seriesValuePlotCoordX = getAttribute('SeriesValuePlotCoordX');
                this.seriesValuePlotCoordY = getAttribute('SeriesValuePlotCoordY');
                this.seriesValuePlacement = getAttribute('SeriesValuePlacement');
                this.seriesValueArrow = getAttribute('SeriesValueArrow');
                this.seriesValueArrowSize = getAttribute('SeriesValueArrowSize');
                this.seriesValueArrowRatio = getAttribute('SeriesValueArrowRatio');
                this.seriesValueArrowStyle = getAttribute('SeriesValueArrowStyle');
                this.seriesValueArrowPosition = getAttribute('SeriesValueArrowPosition');
                this.seriesValueDisplayStyle = getAttribute('SeriesValueDisplayStyle');
                this.seriesValueBorderRadius = getAttribute('SeriesValueBorderRadius');
                this.seriesValueOutsideDrawnOnEdge = getAttribute('SeriesValueOutsideDrawnOnEdge');
                this.seriesValueAutoPositionMaxDistance = getAttribute('SeriesValueAutoPositionMaxDistance');
                this.seriesValueAutoPositionSteps = getAttribute('SeriesValueAutoPositionSteps');
                this.seriesValueTextFollowsSeriesColor = getAttribute('SeriesValueTextFollowsSeriesColor');
            }
            // these attributes are necessary for FDSDataLabel even if seriesValue is off
            this._seriesValueDataMask = getAttribute('SeriesValueDataMask');
            this._seriesValueLabelMask = getAttribute('SeriesValueLabelMask');
            this._seriesValueSublabelMask = getAttribute('SeriesValueSublabelMask');
            this._seriesValueShowLabel = getAttribute('SeriesValueShowLabel');
            // Outlier attributes
            this.seriesOutlierIndicator = getAttribute('SeriesOutlierIndicator');
            if (this.seriesOutlierIndicator) {
                this.seriesOutlierIndicatorStyle = getAttribute('SeriesOutlierIndicatorStyle');
                this.seriesOutlierIndicatorSize = getAttribute('SeriesOutlierIndicatorSize');
                this.seriesOutlierIndicatorMarkerStyle = getAttribute('SeriesOutlierIndicatorMarkerStyle');
                this.seriesOutlierIndicatorBreakSize = getAttribute('SeriesOutlierIndicatorBreakSize');
                this.seriesOutlierIndicatorHatchAngle = getAttribute('SeriesOutlierIndicatorHatchAngle');
                this.seriesOutlierIndicatorHatchSize = getAttribute('SeriesOutlierIndicatorHatchSize');
            }
            this.isAnnotation = getAttribute('IsAnnotation') || getAttribute('IsAppAnnotation');
            if (this.isAnnotation) {
                this.attributeSet.setAt('InteractivityMode', 'app', -1 /* ALL */);
                this.highAnnotation = getAttribute('HighAnnotation');
                this.lowAnnotation = getAttribute('LowAnnotation');
                this._annotationMode = getAttribute('AnnotationMode');
                this.annotationInLegend = getAttribute('AnnotationInLegend');
                this.annotationAllowAnnotInLegend = getAttribute('AnnotationAllowAnnotInLegend');
                this._syncAnnotDefaults();
                this.annotationFollowsParentValue = getAttribute('AnnotationFollowsParentValue');
                this._annotationDisappearOnNoValidXData = getAttribute('AnnotationDisappearOnNoValidXData');
                this._annotationDisappearOnNoValidYData = getAttribute('AnnotationDisappearOnNoValidYData');
            }
            // depends on isAnnotation
            this._adjustChildrenToSeries();
            this.setInteractivityMode(getAttribute('InteractivityMode'));
            this._interactivityClamping = getAttribute('InteractivityClampToPlot');
            this._setupPens();
            if (this.seriesLabel1ColorFollowsSeriesColor) {
                this.seriesLabel1Font = this.seriesLabel1Font.with({ color: this.calculatedSeriesColor });
            }
            if (this.seriesLabel2ColorFollowsSeriesColor) {
                this.seriesLabel2Font = this.seriesLabel2Font.with({ color: this.calculatedSeriesColor });
            }
            this.seriesValueBGColorDef = this.attributeSet.isInheritedDefault('SeriesValueBGColor');
            if (this.hasValidData) {
                this._setupColorMapModes();
            }
            this.quickLabel = getAttribute('SeriesQuickLabel');
            this.quickLabelText = getAttribute('SeriesQuickLabelText');
            this.quickLabelArrowMultiplier = getAttribute('SeriesQuickLabelArrowMultiplier');
            this._quickLabelAutoPositionFactor = getAttribute('SeriesQuickLabelAutoPositionFactor');
            this.quickLabelConsolidatedTextBoxes = getAttribute('SeriesQuickLabelConsolidatedTextBoxes');
            this.quickLabelFontAlignmentLeft = getAttribute('SeriesQuickLabelFontAlignmentLeft');
            this.quickLabelFontAlignmentRight = getAttribute('SeriesQuickLabelFontAlignmentRight');
            this.quickLabelShowText = getAttribute('SeriesQuickLabelShowText');
            this._quickLabelTextBoxDisplayMargins = getAttribute('SeriesQuickLabelTextBoxDisplayMargins');
            this.quickLabelPosition = getAttribute('SeriesQuickLabelPosition');
            this.quickLabelVerticalPosition = getAttribute('SeriesQuickLabelVerticalPosition');
            this.quickLabelLeftPositionModifier = getAttribute('SeriesQuickLabelLeftPositionModifier');
            this.quickLabelRightPositionModifier = getAttribute('SeriesQuickLabelRightPositionModifier');
            this.quickLabelGap = getAttribute('SeriesQuickLabelGap');
            this.quickLabelColorFollowsSeriesColor = getAttribute('SeriesQuickLabelColorFollowsSeriesColor');
            this._quickLabelColorMaximumContrast = getAttribute('SeriesQuickLabelColorMaximumContrast');
            this.quickLabelBox = getAttribute('SeriesQuickLabelTextBox');
            this.quickLabelBoxDisplayStyle = getAttribute('SeriesQuickLabelTextBoxDisplayStyle');
            this.quickLabelBoxHeightHint = getAttribute('SeriesQuickLabelTextBoxHeightHint');
            this.quickLabelBoxSizingMode = getAttribute('SeriesQuickLabelTextBoxSizingMode');
            this.quickLabelBoxWidthHint = getAttribute('SeriesQuickLabelTextBoxWidthHint');
            this.quickLabelBoxTextClipping = getAttribute('SeriesQuickLabelTextBoxTextClipping');
            this._quickLabelBGColorFollowsSeriesColor = getAttribute('SeriesQuickLabelTextBoxBGColorFollowsSeriesColor');
            this.quickLabelPlacement = getAttribute('SeriesQuickLabelTextBoxPlacement');
            this.updateQLAttrs();
            this.seriesMarkerAutoPosition = getAttribute('SeriesMarkerAutoPosition');
            this.seriesMarkerAutoPositionXFactor = getAttribute('SeriesMarkerAutoPositionXFactor');
            this.seriesMarkerAutoPositionYFactor = getAttribute('SeriesMarkerAutoPositionYFactor');
            this.seriesMarkerAutoPositionMode = getAttribute('SeriesMarkerAutoPositionMode');
            this.seriesMarkerAutoPositionDirection = getAttribute('SeriesMarkerAutoPositionDirection');
            switch (this.getEffectiveDrawStyle()) {
                case 43 /* FIBARC */:
                case 44 /* FIBFAN */:
                case 42 /* FIBRETRACEMENTS */:
                case 57 /* FIBPROJECTION */:
                case 46 /* GANNFAN */:
                case 47 /* QUADRANTLINES */:
                case 49 /* TIRONELEVELS */:
                case 50 /* SPEED_RESISTANCE_LEVELS */:
                    this.fibonacciLevels = getAttribute('FibonacciLevels');
                    break;
                case 21 /* REGRESSION */:
                case 48 /* RAFFREGRESSION */:
                case 58 /* RELATIVE_AREA */:
                    this._setRegressionAttributes();
                    this.curvedRegressionOnLogScale = getAttribute('CurvedRegressionOnLogScale');
                    break;
                case 4 /* RANGEBAR */:
                    this.rangeBarSameDataToLine = getAttribute('RangeBarSameDataToLine');
                    break;
                case 6 /* COLUMNS */:
                case 5 /* COLUMNS3D */:
                case 7 /* THIN */:
                case 12 /* BARS */:
                case 11 /* BARS3D */:
                case 13 /* THINBARS */:
                    this.isStacked = getAttribute('IsStacked');
                    break;
                case 9 /* AREA */:
                    this.isStacked = getAttribute('IsStacked');
                    this.enableAreaTopBottomConditionalColor = getAttribute('EnableAreaTopBottomConditionalColor');
                    break;
                case 51 /* ZIGZAG */:
                    this.zigZagThreshold = getAttribute('ZigZagPriceMovementThreshold');
                    this.zigZagDimensionsMask = getAttribute('ZigZagDimensionsMask');
                    break;
                case 19 /* PIE */:
                case 36 /* PIE3D */:
                    this.pieDesc.donutRadius = getAttribute('PieDonutRadius');
                    this.pieDesc.startAngle = getAttribute('PieStartAngle');
                    this.pieDesc.totalAngle = getAttribute('PieTotalAngle');
                    this.pieDesc.labelFactor = getAttribute('PieLabelFactor');
                    this.pieDesc.minSlice = getAttribute('PieMinimumSlice');
                    this.pieDesc.piePercent = getAttribute('PieLabelPercent');
                    this.pieDesc.radius = getAttribute('PieRadius');
                    this.pieDesc.radiusIsFactor = getAttribute('PieRadiusIsFactor');
                    this.pieDesc.centerOffsetX = getAttribute('PieCenterXOffset');
                    this.pieDesc.centerOffsetY = getAttribute('PieCenterYOffset');
                    this.pieDesc.centerIsFactor = getAttribute('PieCenterIsFactor');
                    this.pieDesc.percentFormat = getAttribute('PiePercentFormat');
                    this.pieDesc.exploded = getAttribute('PieExploded');
                    this.pieDesc.explodeMode = getAttribute('PieClickExplosionMode');
                    this.pieDesc.grouped = getAttribute('PieGroupExplodedSlices');
                    this.pieDesc.explodedIndices = getAttribute('PieExplodedSliceIndices').slice();
                    this.pieDesc.explosionAmt = getAttribute('PieExplodedSliceAmount');
                    this.pieDesc.explodeAnimation = getAttribute('PieExplodeOnClickAnimation');
                    // these are only used during an animation. safe to reset them now
                    this.pieDesc.explodingData = [];
                    // Some 3D pie stuff, adding attributes anyway
                    this.pieDesc.tiltAngle = getAttribute('PieTiltAngle');
                    this.pieDesc.depth = getAttribute('PieDepthSize');
                    this.pieDesc.explodeRadius = getAttribute('PieExplosionIncreasesRadius');
                    this.pieDesc.animationTime = getAttribute('PieAnimationTime');
                    break;
                case 38 /* TREEMAP */:
                    this.treemapCategoryLabelPen = FDSPen.constructFromAttributes(this.attributeSet, 'TreemapCategoryLabelFG');
                    this.treemapCategoryLabelBrush.constructFromAttributes(this.attributeSet, 'TreemapCategoryLabelBG');
                    this.treemapCategoryLabelFont = FDSFont.constructFromAttributes(this.attributeSet, 'TreemapCategoryLabelFont');
                    this.seriesHighlightColor = getAttribute('SeriesHighlightColor');
                    this.treemapHighlightMode = getAttribute('HighlightModeTreemap');
                    this.treemapHighlightLevel = getAttribute('HighlightLevelTreemap');
                    this.hierarchyDesc.seriesWidthMax = getAttribute('SeriesFGWidthMax');
                    this.hierarchyDesc.DataClipStdDeviation = getAttribute('DataClipStdDeviation');
                    this.hierarchyDesc.TreemapRestrictColorRange = getAttribute('TreemapRestrictColorRange');
                    this.hierarchyDesc.TreemapAutoSizeLabels = getAttribute('TreemapAutoSizeLabels');
                    this.hierarchyDesc.TreemapForceAllLabels = getAttribute('TreemapForceAllLabels');
                    this.hierarchyDesc.TreemapLabelMaximumContrast = getAttribute('TreemapLabelMaximumContrast');
                    this.hierarchyDesc.TreemapLabelFontHeightMin = getAttribute('TreemapLabelFontHeightMin');
                    this.hierarchyDesc.TreemapFadeColorWithHierarchy = getAttribute('TreemapFadeColorWithHierarchy');
                    this.hierarchyDesc.TreemapShowHighlightRect = getAttribute('TreemapShowHighlightRect');
                    this.hierarchyDesc.TreemapDrawLabelsRecursively = getAttribute('TreemapDrawLabelsRecursively');
                    this.hierarchyDesc.TreemapCategoryLabelPosition = getAttribute('TreemapCategoryLabelPosition');
                    this.hierarchyDesc.TreemapCategoryLabelHeight = getAttribute('TreemapCategoryLabelHeight');
                    this.hierarchyDesc.TreemapCategoryLabelMaximumContrast
                        = getAttribute('TreemapCategoryLabelMaximumContrast');
                    this.hierarchyDesc.TreemapCategoryLabelBGColorList = getAttribute('TreemapCategoryLabelBGColorList');
                    this.hierarchyDesc.TreemapCategoryLabelBGGradientColorList = getAttribute('TreemapCategoryLabelBGGradientColorList');
                    this.hierarchyDesc.TreemapCategoryLabelFontColorList = getAttribute('TreemapCategoryLabelFontColorList');
                    this.hierarchyDesc.TreemapCategoryLabelFontHeightList = getAttribute('TreemapCategoryLabelFontHeightList');
                    this.hierarchyDesc.TreemapCategoryLabelFontHeightMin = getAttribute('TreemapCategoryLabelFontHeightMin');
                    this.treemapAllowDrilldown = getAttribute('TreemapAllowDrilldown');
                    break;
                case 23 /* CANDLE */:
                    this.candleLineColorFollowsFillColor = getAttribute('CandleLineColorFollowsFillColor');
                    this.candlePositiveFillStyle = getAttribute('CandlePositiveFillStyle');
                    this.candleDrawRectOutline = getAttribute('CandleDrawRectOutline');
                    break;
                case 56 /* ARROW */:
                    this.arrowSize = getAttribute('ArrowSize');
                    this.arrowWidthScale = getAttribute('ArrowWidthScale');
                    this.arrowLengthScale = getAttribute('ArrowLengthScale');
                    this.arrowScalesWithLength = getAttribute('ArrowScalesWithLength');
                    this.seriesArrowLinePen = this.seriesArrowLinePen.inheritFromOtherPen(this.seriesArrowPen, this.attributeSet, 'SeriesValueLineFG');
                    break;
                case 62 /* HISTOGRAM */:
                    this.histogramBinsCreator.updateAttributesAndCalcHistogramBinsIfNeeded(this);
                    break;
                case 64 /* HISTOGRAM_AS_COLUMNS */:
                    this.histogramAsColumnsBinsCreator.updateAttributesAndCalcHistogramBinsIfNeeded(this);
                    break;
            }
            this._updateOnAxes();
            this.attributeSet.setDirty(false);
        };
        FDSSeries.prototype.triggerCalcHistogramBins = function () {
            var drawStyle = this.getEffectiveDrawStyle();
            if (drawStyle === 62 /* HISTOGRAM */) {
                this.histogramBinsCreator.getAttributesAndCalcSeriesHistogramBins(this);
            }
            else if (drawStyle === 64 /* HISTOGRAM_AS_COLUMNS */) {
                this.histogramAsColumnsBinsCreator.getAttributesAndCalcSeriesHistogramBins(this);
            }
        };
        // helper function to get an axis based on its id, whether it be a
        // selector or its actual id
        FDSSeries.prototype._getAxisByID = function (id) {
            var axis = this.root.getTypedObject(id, isAxis);
            if (this.parent && axis == null) {
                // maybe it's a builtin axis
                axis = this.root.getTypedObject("FC_" + this.parent.id + "_" + id + "_AXIS", isAxis);
            }
            return axis;
        };
        // helper function to adjust the old and new axis' associated series,
        // and delete the axis from the plot if it has no series on it
        FDSSeries.prototype._adjustAssociatedSeries = function (oldAxis, newAxis, dim) {
            var plot = this.getPlotParent();
            oldAxis.removeSeries(this);
            // don't remove built-in axes!
            if (oldAxis.associatedSeries.length < 1 && !oldAxis.isBuiltInAxis) {
                // no children left
                plot.onNotify(oldAxis);
            }
            else {
                oldAxis.adjustToCurrentSeries();
            }
            // this can happen if an axis has no series on it
            if (newAxis.dimension === -1 /* NONE */) {
                newAxis.dimension = dim;
            }
            if (!plot.getChild(newAxis.id)) {
                // axis had been removed from the plot. re-add it
                plot.addChild(newAxis);
            }
            newAxis.addSeries(this);
        };
        FDSSeries.prototype._updateOnAxes = function () {
            var newOnX = this.attributeSet.get('OnXAxis');
            if (newOnX !== this._onXAxis) {
                var oldAxis = this._getAxisByID(this._onXAxis);
                var newAxis = this._getAxisByID(newOnX);
                if (newAxis != null) {
                    this._onXAxis = newOnX;
                    if (oldAxis != null) {
                        this._adjustAssociatedSeries(oldAxis, newAxis, 1 /* X */);
                    }
                }
            }
            // repeat for Y
            // this is a compat shim for older charts which set OnY2 prior to the axis refactor in FDSChart circa 2006
            var newOnY = (this.attributeSet.isInheritedDefault('OnYAxis') && this.attributeSet.get('OnY2')) ?
                'Y2' :
                this.attributeSet.get('OnYAxis');
            if (newOnY !== this._onYAxis) {
                var oldAxis = this._getAxisByID(this._onYAxis);
                var newAxis = this._getAxisByID(newOnY);
                if (newAxis != null) {
                    this._onYAxis = newOnY;
                    if (oldAxis != null) {
                        this._adjustAssociatedSeries(oldAxis, newAxis, 2 /* Y */);
                    }
                }
            }
        };
        FDSSeries.prototype._syncAnnotDefaults = function () {
            if (!this.isAnnotation || this._annotationMode === 0 /* DEFAULT */) {
                return;
            }
            var getWithFallback = this.attributeSet.getWithFallback.bind(this.attributeSet);
            this.inTips = getWithFallback('AnnotationInTips', false);
            this.seriesValueArrow = getWithFallback('AnnotationSeriesValueArrow', this.seriesValueStyle !== 0 /* DEFAULT */ ? false : true);
            this._seriesValueSublabelMask = getWithFallback('AnnotationSeriesValueSublabelMask', 0);
            this.drawStyle = getWithFallback('AnnotationDrawStyle', this.drawStyle); // don't change the value if default.
        };
        FDSSeries.prototype._adjustChildrenToSeries = function () {
            if (this.isAnnotation && this.annotationFollowsParentValue) {
                this._adjustYDataToParent();
                return;
            }
            for (var id in this.children) {
                var object = this.children[id];
                if (!isSeries(object)) {
                    continue;
                }
                if (object && object.annotationFollowsParentValue) {
                    object._adjustYDataToParent();
                }
            }
        };
        FDSSeries.prototype.updateQLAttrs = function () {
            this._initializeQLBrushes();
            this._inheritQLAttrs();
            this._finalizeQLBrushes();
            if (this.quickLabel) {
                this._calculateQuickLabelBounds();
            }
        };
        // Function to set up the quicklabel dimensions (For axis calculation)
        FDSSeries.prototype._calculateQuickLabelBounds = function () {
            var plot = this.getPlotParent();
            if (!plot) {
                return;
            }
            var ctx = plot.root.getContext();
            var quickLabelText = this.properties.compilePropertyString(this.quickLabelText).fromValueRT();
            var box = new QuickLabelInfoBox(ctx, this, quickLabelText);
            this._quickLabelCalculatedWidth = box.width;
        };
        FDSSeries.prototype.getCalculatedQuickLabelWidth = function () {
            return this._quickLabelCalculatedWidth;
        };
        // Function to set up the quicklabel brush/pen/font defaults
        FDSSeries.prototype._initializeQLBrushes = function () {
            this.quickLabelFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesQuickLabelTextBoxFG');
            this.quickLabelBGBrush.constructFromAttributes(this.attributeSet, 'SeriesQuickLabelTextBoxBG');
            this.quickLabelFont = FDSFont.constructFromAttributes(this.attributeSet, 'SeriesQuickLabelFont');
        };
        // do some logic based on the values we've gotten
        FDSSeries.prototype._finalizeQLBrushes = function () {
            if (this.quickLabelBox) {
                if (this._quickLabelBGColorFollowsSeriesColor) {
                    this.quickLabelBGBrush.color = this.calculatedSeriesColor;
                }
            }
            else {
                // no box, hide these brushes (no matter what their colors etc are set to)
                this.quickLabelBGBrush.style = 1 /* NULL */;
                this.quickLabelFGPen = this.quickLabelFGPen.with({ style: 5 /* NULL */ });
            }
            if (this.quickLabelColorFollowsSeriesColor &&
                !(this.quickLabelBox && this._quickLabelBGColorFollowsSeriesColor)) {
                // don't make the text the same color as the bg
                this.quickLabelFont = this.quickLabelFont.with({ color: this.calculatedSeriesColor });
            }
            else if (this._quickLabelColorMaximumContrast) {
                var color = new FDSColor(this.quickLabelBGBrush.color);
                this.quickLabelFont = this.quickLabelFont.with({ color: color.getContrastYIQ() });
            }
        };
        // fetch attrs from parent if needed
        FDSSeries.prototype._inheritQLAttrs = function () {
            var plot = this.getPlotParent();
            if (!plot) {
                // this can happen if things are set up weirdly
                return;
            }
            this.quickLabelFGPen = this.quickLabelFGPen.inheritFromOtherPen(plot.quickLabelFGPen, this.attributeSet, 'SeriesQuickLabelTextBoxFG');
            this.quickLabelBGBrush.inheritFromOtherBrush(plot.quickLabelBGBrush, this.attributeSet, 'SeriesQuickLabelTextBoxBG');
            this.quickLabelFont = this.quickLabelFont.inheritFromOtherFont(plot.quickLabelFont, this.attributeSet, 'SeriesQuickLabelFont');
            var isDefault = this.attributeSet.isDefault.bind(this.attributeSet);
            if (isDefault('SeriesQuickLabel')) {
                this.quickLabel = plot.quickLabel;
            }
            if (isDefault('SeriesQuickLabelPosition')) {
                this.quickLabelPosition = plot.quickLabelPosition;
            }
            if (isDefault('SeriesQuickLabelVerticalPosition')) {
                this.quickLabelVerticalPosition = plot.quickLabelVerticalPosition;
            }
            if (isDefault('SeriesQuickLabelLeftPositionModifier')) {
                this.quickLabelLeftPositionModifier = plot.quickLabelLeftPositionModifier;
            }
            if (isDefault('SeriesQuickLabelRightPositionModifier')) {
                this.quickLabelRightPositionModifier = plot.quickLabelRightPositionModifier;
            }
            if (isDefault('SeriesQuickLabelTextBox')) {
                this.quickLabelBox = plot.quickLabelBox;
            }
            if (isDefault('SeriesQuickLabelTextBoxDisplayStyle')) {
                this.quickLabelBoxDisplayStyle = plot.quickLabelBoxDisplayStyle;
            }
            if (isDefault('SeriesQuickLabelColorFollowsSeriesColor')) {
                this.quickLabelColorFollowsSeriesColor = plot.quickLabelColorFollowsSeriesColor;
            }
            if (isDefault('SeriesQuickLabelColorMaximumContrast')) {
                this._quickLabelColorMaximumContrast = plot.quickLabelColorMaximumContrast;
            }
        };
        FDSSeries.prototype._setRegressionAttributes = function () {
            var getAttribute = this.attributeSet.get.bind(this.attributeSet);
            var reset = (this.regressionOrder !== getAttribute('RegressionOrder')) ||
                (this.regressionType !== getAttribute('RegressionType')) ||
                (this.regressionStdDevBands !== getAttribute('RegressionStdDevBands')) ||
                (this.regressionStdDevOffset !== getAttribute('RegressionStdDevOffset')) ||
                (this.regressionStdDevMirror !== getAttribute('RegressionStdDevMirror')) ||
                (this._regressionZeroOrderIsMedian !== getAttribute('RegressionZeroOrderIsMedian')) ||
                (this._regressionZeroOrderIsHarmonicMean !== getAttribute('RegressionZeroOrderIsHarmonicMean')) ||
                (this._regressionFormulaInterceptIsMin !== getAttribute('RegressionFormulaInterceptIsMin')) ||
                (this._regressionFormulaExpandPolynomial !== getAttribute('RegressionFormulaExpandPolynomial')) ||
                (this._regressionFormulaY !== getAttribute('RegressionFormulaY')) ||
                (this._regressionFormulaX !== getAttribute('RegressionFormulaX')) ||
                (this._regressionFormulaFormat !== getAttribute('RegressionFormulaFormat')) ||
                (this._regressionFormulaCollapseInts !== getAttribute('RegressionFormulaCollapseInts')) ||
                (this._regressionFormulaSpaces !== getAttribute('RegressionFormulaSpaces')) ||
                (this._regressionFormulaParens !== getAttribute('RegressionFormulaParens')) ||
                (this.regressionScaleInfluenceMode !== getAttribute('RegressionScaleInfluenceMode')) ||
                (this.getStdDevFromRegression !== getAttribute('RegressionStdDevFromTrend'));
            this.regressionType = getAttribute('RegressionType');
            if (this.regressionType === 0 /* POLYNOMIAL */) {
                this.regressionOrder = getAttribute('RegressionOrder');
            }
            else {
                this.regressionOrder = 1;
            }
            this.regressionStdDevBands = getAttribute('RegressionStdDevBands');
            // who needs more than 50 bands
            if (this.regressionStdDevBands > 50) {
                this.regressionStdDevBands = 50;
            }
            this.regressionStdDevOffset = getAttribute('RegressionStdDevOffset');
            this.regressionStdDevMirror = getAttribute('RegressionStdDevMirror');
            this._regressionZeroOrderIsMedian = getAttribute('RegressionZeroOrderIsMedian');
            this._regressionZeroOrderIsHarmonicMean = getAttribute('RegressionZeroOrderIsHarmonicMean');
            this._regressionFormulaInterceptIsMin = getAttribute('RegressionFormulaInterceptIsMin');
            this._regressionFormulaExpandPolynomial = getAttribute('RegressionFormulaExpandPolynomial');
            this._regressionFormulaY = getAttribute('RegressionFormulaY');
            this._regressionFormulaX = getAttribute('RegressionFormulaX');
            this._regressionFormulaFormat = getAttribute('RegressionFormulaFormat');
            this._regressionFormulaCollapseInts = getAttribute('RegressionFormulaCollapseInts');
            this._regressionFormulaSpaces = getAttribute('RegressionFormulaSpaces');
            this._regressionFormulaParens = getAttribute('RegressionFormulaParens');
            this.regressionScaleInfluenceMode = getAttribute('RegressionScaleInfluenceMode');
            this.getStdDevFromRegression = getAttribute('RegressionStdDevFromTrend');
            if (reset) {
                this._regressionData = [];
                this._regressionFormula = '';
                if (this.drawStyle === 21 /* REGRESSION */ || this.drawStyle === 58 /* RELATIVE_AREA */) {
                    this.getRegressionData();
                }
            }
        };
        FDSSeries.prototype._onSetAttribute = function (key, level, value) {
            if (key === 'RegressionScaleInfluenceMode' || key === 'RegressionOrder' || key === 'RegressionType') {
                this.notifyParents(1 /* CHANGE */);
            }
        };
        // called from PlotRenderManager before every draw call
        FDSSeries.prototype.preDraw = function () {
            if (this._useCondColor) {
                this._setupCondColorData();
            }
        };
        FDSSeries.prototype._setupCondColorData = function () {
            var inputs = this.getData(this._seriesCondColorDim).data;
            var F = new FormatParser();
            var outputs = F.parseConditionalFormatAndApply(this._seriesCondColorProp, inputs);
            var outputNums = [];
            for (var i = 0; i < outputs.length; i++) {
                var output = outputs[i];
                if (this._seriesCondColorAdvanced) {
                    output = (this.properties.compilePropertyString(output)).fromValue({ seriesIndex: i });
                }
                var parsedOutput = parseFloat(output);
                if (isNaN(parsedOutput)) {
                    outputNums[i] = inputs[i];
                }
                else {
                    outputNums[i] = parsedOutput;
                }
            }
            if (!this.isDefined(4 /* COLOR */)) {
                this._createColorData();
            }
            if (this._oldColorData == null) {
                // this means we currently are using the user-defined color (and not another cond color set)
                // save this for later use
                this._oldColorData = this.dimensionalChildren[4 /* COLOR */].data;
            }
            // We pass false here because passing true will notify the parents of the dataset.
            // When that occurs, the plot parent will refresh the axes if AxisResetOnDataChange is set to true.
            // When this occurs, the scales are set to be uninitialized, but they fail to re-initialize before rendering happens
            // causing the axes to fail to render. RPD:31513881
            this.dimensionalChildren[4 /* COLOR */].replace(0, outputNums, false);
        };
        FDSSeries.prototype.tryGetMarker3dLightPosition = function () {
            return this._seriesMarker3D ? this._seriesMarker3DLightPosition : null;
        };
        FDSSeries.prototype.setColorMap = function (map$$1) {
            if (!(map$$1 instanceof ColorMap)) {
                return false;
            }
            this.colorMap = map$$1;
            return this.useColorMap = true;
        };
        FDSSeries.prototype._setupColorMapModes = function () {
            this.useColor = this.cycleColorIndex = this.useColorIndex = this._useCondColor = this.useColorMap = false;
            this.useColorMap = this.attributeSet.get('ColorMapActive');
            // if conditional color property is set, use that and nothing else
            if (this._seriesCondColorProp !== '') {
                this._useCondColor = true;
                if (this._seriesCondColorIsIndex) {
                    this.useColorIndex = true;
                }
                this.useColor = true;
                return;
            }
            else if (this._oldColorData != null) {
                // this means in the past we set up a color dataset for a cond color,
                // which we're not using anymore. Reset!
                this.dimensionalChildren[4 /* COLOR */].data = this._oldColorData;
                // this will be picked up by the later color data check, make sure we
                // really want it to be
                if (this._oldColorData.length === 0) {
                    this.defined[4 /* COLOR */] = false;
                }
                this._oldColorData = undefined;
            }
            if (this.useColorMap) {
                this.useColor = true;
                var colorMapStyle = this.attributeSet.get('ColorMap');
                this.colorMap = new ColorMap(colorMapStyle);
                if (colorMapStyle === 8 /* CUSTOM */) {
                    // this hasn't been implemented yet
                    var colorDataSetName = this.attributeSet.get('ColorMapCustomDataName');
                    var colorMapDataSet = this.root.getTypedObject(colorDataSetName, isDataSet);
                    this.colorMap.setCustomMap(colorMapDataSet);
                }
                else if (colorMapStyle === 9 /* UP_NEUTRAL_DOWN */) {
                    this.colorMap.setMap(colorMapStyle, new FDSColor(this.seriesColorDown), new FDSColor(this.seriesColorNeutral), new FDSColor(this.seriesColorUp));
                }
                else {
                    var lightenFactor = this.attributeSet.get('ColorMapLightenFactor');
                    var seriesColor = new FDSColor(this.seriesFGPen.color);
                    var bgGradientColor = new FDSColor(this.BGGradientColor);
                    this.colorMap.setMap(colorMapStyle, seriesColor, bgGradientColor, null, lightenFactor);
                }
            }
            // if there exists some color data, use it for the series!
            if (this.isDefined(4 /* COLOR */)) {
                this.useColor = true;
                if (this.attributeSet.get('ColorIsIndex')) {
                    this.useColorIndex = true;
                }
            }
            if (this.attributeSet.get('CycleColorIndex')) {
                this.useColor = true;
                this.cycleColorIndex = true;
            }
        };
        FDSSeries.prototype._setupPens = function () {
            // Cache some functions to reduce property access and file size.
            var attributes = this.attributeSet;
            var getWithFallback = attributes.getWithFallback.bind(attributes);
            var isInheritedDefault = attributes.isInheritedDefault.bind(attributes);
            var getAttribute = attributes.get.bind(attributes);
            this.seriesColorList = getWithFallback('SeriesColorList', undefined);
            this.seriesOutlineColorList = getWithFallback('SeriesOutlineColorList', undefined);
            this.seriesLineStyleList = getWithFallback('SeriesLineStyleList', undefined);
            this.seriesLineWidthList = getWithFallback('SeriesLineWidthList', undefined);
            this.calculatedSeriesColor = this.root.getSeriesColor(this._seriesNumber, this.seriesColorList);
            this._calculatedOutlineColor = this.root.getSeriesOutlineColor(this._seriesNumber, this.seriesOutlineColorList);
            this._calculatedLineWidth = this.root.getSeriesLineWidth(this._seriesNumber, this.seriesLineWidthList);
            this._calculatedLineStyle = this.root.getSeriesLineStyle(this._seriesNumber, this.seriesLineStyleList);
            // this attribute stores the logic SeriesColor## -> SeriesColor
            if (!isInheritedDefault('SeriesColor')) {
                this.calculatedSeriesColor = getAttribute('SeriesColor');
            }
            // Set up the foreground pen with actual color used for drawing the series
            //   logic: SeriesColor## -> SeriesColor -> SeriesFGColor
            this.seriesFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesFG');
            var calculatedOptions = {};
            if (isInheritedDefault('SeriesFGColor')) {
                calculatedOptions.color = this.calculatedSeriesColor;
            }
            if (isInheritedDefault('SeriesFGStyle')) {
                calculatedOptions.style = this._calculatedLineStyle;
            }
            if (isInheritedDefault('SeriesFGWidth')) {
                calculatedOptions.width = this._calculatedLineWidth;
            }
            this.seriesFGPen = this.seriesFGPen.with(calculatedOptions);
            // Set up the background brush
            //   logic: SeriesColor## -> SeriesColor -> SeriesBGColor
            this.seriesBGBrush.constructFromAttributes(this.attributeSet, 'SeriesBG');
            if (isInheritedDefault('SeriesBGColor')) {
                this.seriesBGBrush.color = this.calculatedSeriesColor;
            }
            if (this.enableSeriesAlternateBGBrush) {
                this.seriesAlternateBGBrush.constructFromAttributes(this.attributeSet, 'SeriesAlternateBG');
                if (isInheritedDefault('SeriesAlternateBGColor')) {
                    this.seriesAlternateBGBrush.color = FDSColor.invert(this.seriesBGBrush.color);
                }
            }
            else {
                this.seriesAlternateBGBrush = this.seriesBGBrush.copy();
            }
            // Set up the outline pen
            // logic: outlinePen = SeriesOutlineColor## (from root) -> SeriesOutlineColor -> SeriesFGColor
            //    unless SeriesOutlineMatchColor is true, then:
            //       SeriesColor## -> SeriesColor -> SeriesOutlineColor -> SeriesFGColor
            // copy all other traits from seriesFGPen
            var outlineColor = this._calculatedOutlineColor;
            this.isSeriesOutlineColorDefault = true;
            if (getAttribute('SeriesOutlineMatchColor')) {
                outlineColor = this.calculatedSeriesColor;
                this.isSeriesOutlineColorDefault = false;
            }
            if (!isInheritedDefault('SeriesOutlineColor')) {
                outlineColor = getAttribute('SeriesOutlineColor');
                this.isSeriesOutlineColorDefault = false;
            }
            if (!isInheritedDefault('SeriesFGColor')) {
                outlineColor = getAttribute('SeriesFGColor');
                this.isSeriesOutlineColorDefault = false;
            }
            this.seriesOutlinePen = this.seriesFGPen.with({ color: outlineColor });
            this.seriesMarkerFont = FDSFont.constructFromAttributes(this.attributeSet, 'SeriesMarkerFont');
            if (this.seriesMarker) {
                // Set up marker FG pen
                //   logic: SeriesColor## -> SeriesColor -> SeriesMarkerColor -> SeriesMarkerFGColor
                this.seriesMarkerFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesMarkerFG');
                if (isInheritedDefault('SeriesMarkerFGColor')) {
                    var markerColor = void 0;
                    if (!isInheritedDefault('SeriesMarkerColor')) {
                        markerColor = getAttribute('SeriesMarkerColor');
                    }
                    else {
                        markerColor = this.calculatedSeriesColor;
                    }
                    this.seriesMarkerFGPen = this.seriesMarkerFGPen.with({ color: markerColor });
                }
                // Set up marker outline pen
                //   logic: Black -> seriesOutlineColor -> seriesMarkerOutlineColor -> SeriesMarkerFGColor
                //    unless SeriesOutlineMatchColor is true, then:
                //        SeriesColor## -> SeriesColor -> seriesOutlineColor -> seriesMarkerOutlineColor -> SeriesMarkerFGColor
                // copy all other traits from MarkerFGPen
                this.seriesMarkerOutlinePen = this.seriesMarkerFGPen;
                var markerOutlineColor = getAttribute('SeriesMarkerOutlineColor');
                if (!isInheritedDefault('SeriesMarkerFGColor')) {
                    markerOutlineColor = getAttribute('SeriesMarkerFGColor');
                }
                else if (isInheritedDefault('SeriesMarkerOutlineColor')) {
                    if (!isInheritedDefault('SeriesOutlineColor')) {
                        markerOutlineColor = getAttribute('SeriesOutlineColor');
                    }
                    else {
                        if (getAttribute('SeriesOutlineMatchColor')) {
                            markerOutlineColor = this.calculatedSeriesColor;
                        }
                        else {
                            markerOutlineColor = 0 /* BLACK */;
                        }
                    }
                }
                this.seriesMarkerOutlinePen = this.seriesMarkerFGPen.with({ color: markerOutlineColor });
                // Set up marker BG brush
                //   logic: SeriesColor## -> SeriesColor -> SeriesMarkerColor -> SeriesMarkerBGColor
                this.seriesMarkerBGBrush.constructFromAttributes(this.attributeSet, 'SeriesMarkerBG');
                if (isInheritedDefault('SeriesMarkerBGColor')) {
                    if (!isInheritedDefault('SeriesMarkerColor')) {
                        this.seriesMarkerBGBrush.color = getAttribute('SeriesMarkerColor');
                    }
                    else {
                        this.seriesMarkerBGBrush.color = this.calculatedSeriesColor;
                    }
                }
            }
            // set up the label pens and brushes
            this.seriesLabelPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesValueFG');
            this.seriesLabelBrush.constructFromAttributes(this.attributeSet, 'SeriesValueBG');
            if (this.seriesValue) {
                this.seriesArrowBrush.constructFromAttributes(this.attributeSet, 'SeriesValueArrowBG');
                this.seriesArrowPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesValueArrowFG');
                this.seriesArrowLinePen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesValueLineFG');
            }
            if (this.seriesOutlierIndicator) {
                this.seriesOutlierIndicatorBGBrush.constructFromAttributes(this.attributeSet, 'SeriesOutlierIndicatorBG');
                this.seriesOutlierIndicatorFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesOutlierIndicatorFG');
            }
            // seriesArrowLinePen inherits its attributes from seriesArrowPen when not set specifically
            this.seriesArrowLinePen = this.seriesArrowLinePen.inheritFromOtherPen(this.seriesArrowPen, this.attributeSet, 'SeriesValueLineFG');
            var seriesOutlineOptions = {
                style: getWithFallback('SeriesOutlineStyle', this.seriesFGPen.style),
                width: getWithFallback('SeriesOutlineWidth', this.seriesFGPen.width),
            };
            this.seriesOutlinePen = this.seriesOutlinePen.with(seriesOutlineOptions);
            if (this.enableSeriesAlternateFGPen) {
                this.seriesAlternateFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesAlternateFG');
                this.seriesAlternateOutlinePen = FDSPen.constructFromAttributes(this.attributeSet, 'SeriesAlternateOutline');
            }
            else {
                this.seriesAlternateFGPen = this.seriesFGPen;
                this.seriesAlternateOutlinePen = this.seriesOutlinePen;
            }
            this.seriesColorUp = getAttribute('SeriesColorUp');
            this.seriesColorDown = getAttribute('SeriesColorDown');
            this.seriesColorNeutral = getAttribute('SeriesColorNeutral');
        };
        FDSSeries.prototype.getSeriesColor = function (index) {
            if (index == null) {
                return this.calculatedSeriesColor;
            }
            return this.root.getSeriesColor(index, this.seriesColorList, this.cycleColorIndex);
        };
        FDSSeries.prototype.getSeriesOutlineColor = function (index) {
            if (index == null) {
                return this._calculatedOutlineColor;
            }
            return this.root.getSeriesOutlineColor(index, this.seriesOutlineColorList, this.cycleColorIndex);
        };
        FDSSeries.prototype._setAttributes = function () {
            if (!this.attributeSet.defaultMap.startInitialization()) {
                return;
            }
            _super.prototype._setAttributes.call(this);
            this.attributeSet.addMultiple([
                [
                    'SeriesNumber',
                    Number,
                    0
                ],
                [
                    'SeriesColor',
                    Number,
                    0
                ],
                [
                    'SeriesColorUp',
                    Number,
                    39219 /* GREEN3 */,
                    'SeriesColorUp'
                ],
                [
                    'SeriesColorDown',
                    Number,
                    255 /* RED */,
                    'SeriesColorDown'
                ],
                [
                    'SeriesColorNeutral',
                    Number,
                    15707648 /* BLUE1 */,
                    'SeriesColorNeutral'
                ],
                [
                    'SeriesBin',
                    Number,
                    0
                ],
                [
                    'DrawStyle',
                    Number,
                    0
                ],
                [
                    'DrawingToolType',
                    Number,
                    0 /* NONE */
                ],
                [
                    'Visible',
                    Boolean,
                    this.visible
                ],
                [
                    'SeriesColorList',
                    Number,
                    [],
                    'SeriesColorList'
                ],
                [
                    'SeriesOutlineColorList',
                    Number,
                    [],
                    'SeriesOutlineColorList'
                ],
                [
                    'SeriesLineStyleList',
                    Number,
                    [],
                    'SeriesLineStyleList'
                ],
                [
                    'SeriesLineWidthList',
                    Number,
                    [],
                    'SeriesLineWidthList'
                ],
                [
                    'SeriesMarkerStyleList',
                    Number,
                    [],
                    'SeriesMarkerStyleList'
                ],
                [
                    'OnY2',
                    Boolean,
                    false
                ],
                [
                    'OnYAxis',
                    String,
                    'Y'
                ],
                [
                    'OnXAxis',
                    String,
                    'X'
                ],
                [
                    'LegendTextFollowsSeriesColor',
                    Boolean,
                    false
                ],
                [
                    'InLegend',
                    Boolean,
                    true
                ],
                [
                    'LegendOrderIndex',
                    Number,
                    0
                ],
                [
                    'MaxElementWidth',
                    Number,
                    0.05
                ],
                // Series Marker attributes
                [
                    'SeriesMarker',
                    Boolean,
                    false
                ],
                [
                    'SeriesMarkerSize',
                    Number,
                    5
                ],
                [
                    'SeriesMarkerMaxSize',
                    Number,
                    50
                ],
                [
                    'SeriesMarkerStyle',
                    Number,
                    1 /* CIRCLE */
                ],
                [
                    'SeriesMarkerText',
                    String,
                    ''
                ],
                [
                    'SeriesMarkerXOffset',
                    Number,
                    0
                ],
                [
                    'SeriesMarkerYOffset',
                    Number,
                    0
                ],
                [
                    'SeriesMarkerColor',
                    Number,
                    0
                ],
                [
                    'SeriesMarker3D',
                    Boolean,
                    false
                ],
                [
                    'SeriesMarker3DLightPosition',
                    Number,
                    4 /* TOP_LEFT */
                ],
                [
                    'SeriesOutlineMatchColor',
                    Boolean,
                    false
                ],
                // Quick label attributes
                [
                    'SeriesQuickLabel',
                    Boolean,
                    false
                ],
                [
                    'SeriesQuickLabelText',
                    String,
                    '<FDSLabel>',
                    'SeriesQuickLabelText'
                ],
                [
                    'SeriesQuickLabelPosition',
                    Number,
                    2 /* RIGHT */
                ],
                [
                    'SeriesQuickLabelVerticalPosition',
                    Number,
                    2 /* DEFAULT */
                ],
                [
                    'SeriesQuickLabelLeftPositionModifier',
                    Number,
                    0 /* INSIDE */
                ],
                [
                    'SeriesQuickLabelRightPositionModifier',
                    Number,
                    0 /* INSIDE */
                ],
                [
                    'SeriesQuickLabelGap',
                    Number,
                    0,
                    'SeriesQuickLabelGap'
                ],
                [
                    'SeriesQuickLabelColorFollowsSeriesColor',
                    Boolean,
                    true
                ],
                [
                    'SeriesQuickLabelColorMaximumContrast',
                    Boolean,
                    false,
                    'SeriesQuickLabelColorMaximumContrast'
                ],
                [
                    'SeriesQuickLabelTextBox',
                    Boolean,
                    false
                ],
                [
                    'SeriesQuickLabelTextBoxDisplayStyle',
                    Number,
                    0 /* RECT */
                ],
                [
                    'SeriesQuickLabelTextBoxHeightHint',
                    Number,
                    0,
                    'SeriesQuickLabelTextBoxHeightHint'
                ],
                [
                    'SeriesQuickLabelTextBoxSizingMode',
                    Number,
                    0 /* DEFAULT */,
                    'SeriesQuickLabelTextBoxSizingMode'
                ],
                [
                    'SeriesQuickLabelTextBoxWidthHint',
                    Number,
                    0,
                    'SeriesQuickLabelTextBoxWidthHint'
                ],
                [
                    'SeriesQuickLabelTextBoxTextClipping',
                    Boolean,
                    false,
                    'SeriesQuickLabelTextBoxTextClipping'
                ],
                [
                    'SeriesQuickLabelArrowMultiplier',
                    Number,
                    1,
                    'SeriesQuickLabelArrowMultiplier'
                ],
                [
                    'SeriesQuickLabelAutoPositionFactor',
                    Number,
                    1,
                    'SeriesQuickLabelAutoPositionFactor'
                ],
                [
                    'SeriesQuickLabelConsolidatedTextBoxes',
                    Boolean,
                    true,
                    'SeriesQuickLabelConsolidatedTextBoxes'
                ],
                [
                    'SeriesQuickLabelFontAlignmentLeft',
                    Number,
                    1 /* RIGHT */,
                    'SeriesQuickLabelFontAlignmentLeft'
                ],
                [
                    'SeriesQuickLabelFontAlignmentRight',
                    Number,
                    0 /* LEFT */,
                    'SeriesQuickLabelFontAlignmentRight'
                ],
                [
                    'SeriesQuickLabelShowText',
                    Boolean,
                    true,
                    'SeriesQuickLabelShowText'
                ],
                [
                    'SeriesQuickLabelTextBoxDisplayMargins',
                    Number,
                    0,
                    'SeriesQuickLabelTextBoxDisplayMargins'
                ],
                [
                    'SeriesQuickLabelTextBoxBGColorFollowsSeriesColor',
                    Boolean,
                    false,
                    'SeriesQuickLabelTextBoxBGColorFollowsSeriesColor'
                ],
                [
                    'SeriesQuickLabelTextBoxPlacement',
                    Number,
                    1 /* INSIDE */,
                    'SeriesQuickLabelTextBoxPlacement'
                ],
                [
                    'SeriesValueAutoPositionMaxDistance',
                    Number,
                    5
                ],
                [
                    'SeriesValueAutoPositionSteps',
                    Number,
                    250
                ],
                [
                    'KMLMapUseZeroBasedColors',
                    Boolean,
                    true
                ],
                [
                    'CandleDrawRectOutline',
                    Boolean,
                    true
                ],
                [
                    'CandlePositiveFillStyle',
                    Number,
                    0
                ],
                [
                    'CandlePositiveFillColor',
                    Number,
                    0
                ],
                [
                    'CandleLineColorFollowsFillColor',
                    Boolean,
                    false
                ],
                [
                    'SteppedSkipFirst',
                    Boolean,
                    false
                ],
                [
                    'WickStyle',
                    Number,
                    0
                ],
                [
                    'SeriesXReference',
                    Number,
                    0
                ],
                [
                    'SeriesYReference',
                    Number,
                    0
                ],
                [
                    'ReferenceSeriesName',
                    String,
                    ''
                ],
                [
                    'ReferenceSeriesIsRegression',
                    Boolean,
                    false
                ],
                [
                    'BreakOnNA',
                    Boolean,
                    false
                ],
                [
                    'BreakOnGap',
                    Boolean,
                    false
                ],
                [
                    'AreaDrawTopLineOnly',
                    Boolean,
                    false
                ],
                // for the Step and AreaStep draw styles
                [
                    'StepDirection',
                    Number,
                    0
                ],
                // attributes for individual colors for data points
                [
                    'CycleColorIndex',
                    Boolean,
                    false
                ],
                [
                    'ColorIsIndex',
                    Boolean,
                    false
                ],
                [
                    'SeriesConditionalColorProperty',
                    String,
                    ''
                ],
                [
                    'SeriesConditionalColorDimension',
                    Number,
                    2 /* Y */
                ],
                [
                    'SeriesConditionalColorAdvanced',
                    Boolean,
                    false
                ],
                [
                    'SeriesConditionalColorIsIndex',
                    Boolean,
                    false
                ],
                // Color map attributes
                [
                    'ColorMap',
                    Number,
                    0 /* BW */
                ],
                [
                    'ColorMapActive',
                    Boolean,
                    false
                ],
                [
                    'ColorMapCustomDataName',
                    String,
                    'ColorMap'
                ],
                [
                    'ColorMapLightenFactor',
                    Number,
                    50
                ],
                [
                    'SeriesEnableAlternateBGBrush',
                    Boolean,
                    false
                ],
                [
                    'SeriesEnableAlternateFGPen',
                    Boolean,
                    false
                ],
                [
                    'AnnotationDraggingStepSizeLarge',
                    Number,
                    5
                ],
                [
                    'AnnotationDraggingStepSizeSmall',
                    Number,
                    1
                ],
                // Pie Attributes
                [
                    'PieDonutRadius',
                    Number,
                    this.pieDesc.donutRadius
                ],
                [
                    'PieStartAngle',
                    Number,
                    this.pieDesc.startAngle
                ],
                [
                    'PieTotalAngle',
                    Number,
                    this.pieDesc.totalAngle
                ],
                [
                    'PieLabelFactor',
                    Number,
                    this.pieDesc.labelFactor
                ],
                [
                    'PieMinimumSlice',
                    Number,
                    this.pieDesc.minSlice
                ],
                [
                    'PieLabelPercent',
                    Boolean,
                    this.pieDesc.piePercent
                ],
                [
                    'PiePercentFormat',
                    String,
                    this.pieDesc.percentFormat
                ],
                [
                    'PieTiltAngle',
                    Number,
                    this.pieDesc.tiltAngle
                ],
                [
                    'PieDepthSize',
                    Number,
                    this.pieDesc.depth
                ],
                [
                    'PieRadius',
                    Number,
                    this.pieDesc.radius
                ],
                [
                    'PieRadiusIsFactor',
                    Boolean,
                    this.pieDesc.radiusIsFactor
                ],
                [
                    'PieCenterXOffset',
                    Number,
                    this.pieDesc.centerOffsetX
                ],
                [
                    'PieCenterYOffset',
                    Number,
                    this.pieDesc.centerOffsetY
                ],
                [
                    'PieCenterIsFactor',
                    Boolean,
                    this.pieDesc.centerIsFactor
                ],
                [
                    'PieExploded',
                    Boolean,
                    this.pieDesc.exploded
                ],
                [
                    'PieExplodedSliceIndices',
                    Number,
                    []
                ],
                [
                    'PieExplodedSliceAmount',
                    Number,
                    this.pieDesc.explosionAmt
                ],
                [
                    'PieExplodeOnClickAnimation',
                    Boolean,
                    this.pieDesc.explodeAnimation
                ],
                [
                    'PieClickExplosionMode',
                    Number,
                    this.pieDesc.explodeMode
                ],
                [
                    'PieExplosionIncreasesRadius',
                    Boolean,
                    this.pieDesc.explodeRadius
                ],
                [
                    'PieGroupExplodedSlices',
                    Boolean,
                    this.pieDesc.grouped
                ],
                [
                    'PieAnimationTime',
                    Number,
                    this.pieDesc.animationTime
                ],
                [
                    'IsAnnotation',
                    Boolean,
                    false
                ],
                [
                    'IsAppAnnotation',
                    Boolean,
                    false
                ],
                [
                    'AnnotationMode',
                    Number,
                    0 /* DEFAULT */
                ],
                [
                    'AnnotationInLegend',
                    Boolean,
                    true
                ],
                [
                    'AnnotationInTips',
                    Boolean,
                    true
                ],
                [
                    'AnnotationAllowAnnotInLegend',
                    Boolean,
                    false
                ],
                [
                    'AnnotationDrawStyle',
                    Number,
                    0 /* LINE */
                ],
                [
                    'AnnotationSeriesBGStyle',
                    Number,
                    0 /* SOLID */
                ],
                [
                    'AnnotationSeriesColor',
                    Number,
                    0 /* BLACK */
                ],
                [
                    'AnnotationSeriesOulineColor',
                    Number,
                    0 /* BLACK */
                ],
                [
                    'AnnotationSeriesValue',
                    Boolean,
                    false
                ],
                [
                    'AnnotationSeriesValueArrow',
                    Boolean,
                    false
                ],
                [
                    'AnnotationSeriesValueSublabelMask',
                    Number,
                    -1 /* ALL */
                ],
                [
                    'AnnotationArrowFraction',
                    Number,
                    0.25
                ],
                [
                    'HighAnnotation',
                    Boolean,
                    this.highAnnotation
                ],
                [
                    'LowAnnotation',
                    Boolean,
                    this.lowAnnotation
                ],
                [
                    'SeriesValue',
                    Boolean,
                    false,
                    'SeriesValue'
                ],
                [
                    'SeriesValueXOffset',
                    Number,
                    0
                ],
                [
                    'SeriesValueYOffset',
                    Number,
                    0
                ],
                [
                    'SeriesValueStyle',
                    Number,
                    0 /* DEFAULT */
                ],
                [
                    'SeriesValueAutoPosition',
                    Boolean,
                    false
                ],
                [
                    'SeriesValueAutoPositionMethod',
                    Number,
                    -1 /* PROGRESSIVE */
                ],
                [
                    'SeriesValueBoundMode',
                    Number,
                    0 /* PLOT_LEVEL */
                ],
                [
                    'SeriesValueSizingMode',
                    Number,
                    0 /* DEFAULT */
                ],
                [
                    'SeriesValueWidthHint',
                    Number,
                    -1
                ],
                [
                    'SeriesValueHeightHint',
                    Number,
                    -1
                ],
                [
                    'SeriesValueDisplayMargins',
                    Number,
                    0.0
                ],
                [
                    'SeriesValueText',
                    String,
                    '<FDSDataLabel>'
                ],
                [
                    'SeriesValueTextClipping',
                    Boolean,
                    false
                ],
                [
                    'SeriesValueDataMask',
                    Number,
                    1 /* VALUE */
                ],
                [
                    'SeriesValueLabelMask',
                    Number,
                    0 /* NONE */
                ],
                [
                    'SeriesValueSublabelMask',
                    Number,
                    -1 /* ALL */
                ],
                [
                    'SeriesValueShowLabel',
                    Boolean,
                    false
                ],
                [
                    'SeriesValueUsePlotCoordX',
                    Boolean,
                    false
                ],
                [
                    'SeriesValueUsePlotCoordY',
                    Boolean,
                    false
                ],
                [
                    'SeriesValuePlotCoordX',
                    Number,
                    0
                ],
                [
                    'SeriesValuePlotCoordY',
                    Number,
                    0
                ],
                [
                    'SeriesValuePlacement',
                    Number,
                    0 /* POINT */
                ],
                [
                    'SeriesValueDisplayStyle',
                    Number,
                    0 /* RECT */
                ],
                [
                    'SeriesValueBorderRadius',
                    Number,
                    0
                ],
                [
                    'SeriesValueOutsideDrawnOnEdge',
                    Boolean,
                    false
                ],
                [
                    'SeriesValueArrow',
                    Boolean,
                    false
                ],
                [
                    'SeriesValueArrowSize',
                    Number,
                    8
                ],
                [
                    'SeriesValueArrowRatio',
                    Number,
                    0.4
                ],
                [
                    'SeriesValueArrowStyle',
                    Number,
                    1 /* CLOSED */
                ],
                [
                    'SeriesValueArrowPosition',
                    Number,
                    1 /* TO */
                ],
                [
                    'SeriesValueTextFollowsSeriesColor',
                    Boolean,
                    false
                ],
                [
                    'AnnotationFollowsParentValue',
                    Boolean,
                    true,
                    'AnnotationFollowsParentValue'
                ],
                [
                    'AnnotationDisappearOnNoValidXData',
                    Boolean,
                    false,
                    'AnnotationDisappearOnNoValidXData'
                ],
                [
                    'AnnotationDisappearOnNoValidYData',
                    Boolean,
                    false,
                    'AnnotationDisappearOnNoValidYData'
                ],
                [
                    'SeriesFGWidthMax',
                    Number,
                    this.hierarchyDesc.seriesWidthMax
                ],
                [
                    'DataClipStdDeviation',
                    Number,
                    this.hierarchyDesc.DataClipStdDeviation
                ],
                [
                    'TreemapRestrictColorRange',
                    Number,
                    this.hierarchyDesc.TreemapRestrictColorRange
                ],
                [
                    'SeriesHighlightColor',
                    Number,
                    this.seriesHighlightColor
                ],
                [
                    'TreemapShowHighlightRect',
                    Boolean,
                    this.hierarchyDesc.TreemapShowHighlightRect
                ],
                [
                    'TreemapFadeColorWithHierarchy',
                    Boolean,
                    this.hierarchyDesc.TreemapFadeColorWithHierarchy
                ],
                [
                    'TreemapAutoSizeLabels',
                    Boolean,
                    this.hierarchyDesc.TreemapAutoSizeLabels
                ],
                [
                    'TreemapLabelMaximumContrast',
                    Boolean,
                    this.hierarchyDesc.TreemapLabelMaximumContrast
                ],
                [
                    'TreemapLabelFontHeightMin',
                    Number,
                    this.hierarchyDesc.TreemapLabelFontHeightMin
                ],
                [
                    'TreemapForceAllLabels',
                    Boolean,
                    this.hierarchyDesc.TreemapForceAllLabels
                ],
                [
                    'TreemapDrawLabelsRecursively',
                    Boolean,
                    this.hierarchyDesc.TreemapDrawLabelsRecursively
                ],
                [
                    'TreemapCategoryLabelMaximumContrast',
                    Boolean,
                    this.hierarchyDesc.TreemapCategoryLabelMaximumContrast
                ],
                [
                    'TreemapCategoryLabelPosition',
                    Number,
                    this.hierarchyDesc.TreemapCategoryLabelPosition
                ],
                [
                    'TreemapCategoryLabelHeight',
                    Number,
                    this.hierarchyDesc.TreemapCategoryLabelHeight
                ],
                [
                    'TreemapCategoryLabelBGColorList',
                    String,
                    this.hierarchyDesc.TreemapCategoryLabelBGColorList
                ],
                [
                    'TreemapCategoryLabelBGGradientColorList',
                    String,
                    this.hierarchyDesc.TreemapCategoryLabelBGGradientColorList
                ],
                [
                    'TreemapCategoryLabelFontColorList',
                    String,
                    this.hierarchyDesc.TreemapCategoryLabelFontColorList
                ],
                [
                    'TreemapCategoryLabelFontHeightList',
                    String,
                    this.hierarchyDesc.TreemapCategoryLabelFontHeightList
                ],
                [
                    'TreemapCategoryLabelFontHeightMin',
                    Number,
                    this.hierarchyDesc.TreemapCategoryLabelFontHeightMin
                ],
                [
                    'TreemapAllowDrilldown',
                    Boolean,
                    true
                ],
                [
                    'HighlightModeTreemap',
                    Number,
                    2 /* DEFINED_LEVEL */
                ],
                [
                    'HighlightLevelTreemap',
                    Number,
                    0
                ],
                [
                    'DatapointHitShapeSize',
                    Number,
                    8
                ],
                [
                    'TooltipDataMask',
                    Number,
                    -1 /* ALL */
                ],
                [
                    'TooltipLabelMask',
                    Number,
                    -1 /* ALL */
                ],
                [
                    'TooltipSublabelMask',
                    Number,
                    -1 /* ALL */
                ],
                [
                    'TooltipShowLabel',
                    Boolean,
                    true
                ],
                [
                    'InTips',
                    Boolean,
                    true
                ],
                [
                    'ExtendLine',
                    Boolean,
                    this.extendLine
                ],
                [
                    'ExtendLineRightOrUp',
                    Boolean,
                    this.extendLineRightOrUp
                ],
                [
                    'ExtendLineLeftOrDown',
                    Boolean,
                    this.extendLineLeftOrDown
                ],
                // Outlier attributes
                [
                    'SeriesOutlierIndicator',
                    Boolean,
                    true
                ],
                [
                    'SeriesOutlierIndicatorStyle',
                    Number,
                    0
                ],
                [
                    'SeriesOutlierIndicatorSize',
                    Number,
                    12
                ],
                [
                    'SeriesOutlierIndicatorMarkerStyle',
                    Number,
                    22
                ],
                [
                    'SeriesOutlierIndicatorBreakSize',
                    Number,
                    5.0
                ],
                [
                    'SeriesOutlierIndicatorHatchAngle',
                    Number,
                    45
                ],
                [
                    'SeriesOutlierIndicatorHatchSize',
                    Number,
                    5.0
                ],
                [
                    'IsStacked',
                    Boolean,
                    false
                ],
                // Sampling
                [
                    'SampleMode',
                    Number,
                    3 /* MINMAX */
                ],
                [
                    'MaxPoints',
                    Number,
                    500
                ],
                [
                    'MaxLabels',
                    Number,
                    100
                ],
                [
                    'SelectableItemSamplingEnabled',
                    Boolean,
                    true,
                    'SelectableItemSamplingEnabled'
                ],
                [
                    'SelectableItemSamplingMinPixelsPerMarker',
                    Number,
                    20
                ],
                [
                    'SelectableItemPointMarkerSize',
                    Number,
                    6,
                    'SelectableItemPointMarkerSize'
                ],
                [
                    'SelectableItemPointMarkerType',
                    Number,
                    2 /* SQUARE */,
                    'SelectableItemPointMarkerType'
                ],
                [
                    'FibonacciLevels',
                    Number,
                    -1
                ],
                [
                    'BaseLineVisible',
                    Boolean,
                    true
                ],
                [
                    'DrawingToolsLevels',
                    String,
                    ''
                ],
                [
                    'LabelsMask',
                    Number,
                    -1
                ],
                [
                    'DrawThinColumnBrackets',
                    Boolean,
                    false
                ],
                [
                    'SeriesLabel1ColorFollowsSeriesColor',
                    Boolean,
                    true
                ],
                [
                    'SeriesLabel2ColorFollowsSeriesColor',
                    Boolean,
                    true
                ],
                [
                    'SeriesLabel1XOffset',
                    Number,
                    0
                ],
                [
                    'SeriesLabel1YOffset',
                    Number,
                    0
                ],
                [
                    'SeriesLabel2XOffset',
                    Number,
                    0
                ],
                [
                    'SeriesLabel2YOffset',
                    Number,
                    0
                ],
                [
                    'SeriesLabel1HPosition',
                    Number,
                    0 /* LEFT */
                ],
                [
                    'SeriesLabel2HPosition',
                    Number,
                    1 /* RIGHT */
                ],
                [
                    'SeriesLabel1VPosition',
                    Number,
                    1 /* V_TOP */
                ],
                [
                    'SeriesLabel2VPosition',
                    Number,
                    1 /* V_TOP */
                ],
                [
                    'SeriesLabel1Format',
                    String,
                    '#.1F'
                ],
                [
                    'SeriesLabel2Format',
                    String,
                    '#.1F'
                ],
                [
                    'SeriesLabel1Text',
                    String,
                    ''
                ],
                [
                    'SeriesSetHitVector',
                    Boolean,
                    true
                ],
                [
                    'SeriesInteractivityStatus',
                    Number,
                    0 /* DISABLED */
                ],
                [
                    'PositiveColor',
                    Number,
                    RGBtoCOLORREF(0, 255, 0)
                ],
                [
                    'NegativeColor',
                    Number,
                    255
                ],
                [
                    'SeriesLabel1LevelsMask',
                    Number,
                    -1
                ],
                [
                    'SeriesLabel2LevelsMask',
                    Number,
                    -1
                ],
                [
                    'InteractionHandleSize',
                    Number,
                    5
                ],
                [
                    'ArrowSize',
                    Number,
                    10
                ],
                [
                    'ArrowWidthScale',
                    Number,
                    2
                ],
                [
                    'ArrowLengthScale',
                    Number,
                    2
                ],
                [
                    'ArrowScalesWithLength',
                    Boolean,
                    false
                ],
                [
                    'ZigZagPriceMovementThreshold',
                    Number,
                    this.zigZagThreshold
                ],
                [
                    'ZigZagDimensionsMask',
                    Number,
                    this.zigZagDimensionsMask
                ],
                [
                    'CurvedRegressionOnLogScale',
                    Boolean,
                    this.curvedRegressionOnLogScale
                ],
                [
                    'RegressionOrder',
                    Number,
                    1
                ],
                [
                    'RegressionType',
                    Number,
                    0 /* POLYNOMIAL */
                ],
                [
                    'RegressionStdDevBands',
                    Number,
                    0
                ],
                [
                    'RegressionStdDevOffset',
                    Number,
                    0
                ],
                [
                    'RegressionStdDevMirror',
                    Boolean,
                    true
                ],
                [
                    'RegressionStdDevFromTrend',
                    Boolean,
                    false
                ],
                [
                    'RegressionZeroOrderIsMedian',
                    Boolean,
                    false
                ],
                [
                    'RegressionZeroOrderIsHarmonicMean',
                    Boolean,
                    false
                ],
                [
                    'RegressionFormulaInterceptIsMin',
                    Boolean,
                    false
                ],
                [
                    'RegressionFormulaExpandPolynomial',
                    Boolean,
                    true
                ],
                [
                    'RegressionFormulaY',
                    String,
                    'y = '
                ],
                [
                    'RegressionFormulaX',
                    String,
                    'x'
                ],
                [
                    'RegressionFormulaFormat',
                    String,
                    '#.2F'
                ],
                [
                    'RegressionFormulaCollapseInts',
                    Boolean,
                    true
                ],
                [
                    'RegressionFormulaSpaces',
                    Boolean,
                    true
                ],
                [
                    'RegressionFormulaParens',
                    Boolean,
                    false
                ],
                [
                    'RegressionScaleInfluenceMode',
                    Number,
                    1 /* DATA_RANGE */
                ],
                [
                    'StartDatapoint',
                    Number,
                    NAN
                ],
                [
                    'EndDatapoint',
                    Number,
                    NAN
                ],
                [
                    'AdjustAxes',
                    Boolean,
                    this.adjustAxes
                ],
                [
                    'SysPickable',
                    Boolean,
                    this.sysPickable
                ],
                [
                    'RangeBarSameDataToLine',
                    Boolean,
                    false
                ],
                [
                    'EnableAreaTopBottomConditionalColor',
                    Boolean,
                    false
                ],
                [
                    'InteractivityMode',
                    Number,
                    1 /* SELECTABLE */
                ],
                [
                    'InteractivityClampToPlot',
                    Boolean,
                    true,
                    'InteractivityClampToPlot'
                ],
                [
                    'OnLeftButtonClick',
                    String,
                    '',
                    'OnLeftButtonClick'
                ],
                [
                    'OnLeftButtonDoubleClick',
                    String,
                    '',
                    'OnLeftButtonDoubleClick'
                ],
                [
                    'OnRightButtonClick',
                    String,
                    '',
                    'OnRightButtonClick'
                ],
                [
                    'OnRightButtonDoubleClick',
                    String,
                    '',
                    'OnRightButtonDoubleClick'
                ],
                [
                    'OnMiddleButtonClick',
                    String,
                    '',
                    'OnMiddleButtonClick'
                ],
                [
                    'OnMiddleButtonDoubleClick',
                    String,
                    '',
                    'OnMiddleButtonDoubleClick'
                ],
                [
                    'DrawBelow',
                    Boolean,
                    this.drawBelow
                ],
                [
                    'SeriesMarkerFontColorFollowsSeriesColor',
                    Boolean,
                    false
                ],
                [
                    'CrosshairsSwapIndexedAxis',
                    Boolean,
                    false,
                    'CrosshairsSwapIndexedAxis'
                ],
                [
                    'CrosshairsFallbackOnLinear',
                    Boolean,
                    false,
                    'CrosshairsFallbackOnLinear'
                ],
                [
                    'CrosshairsDrawMarker',
                    Boolean,
                    false,
                    'CrosshairsDrawMarker'
                ],
                [
                    'CrosshairsMarkerColor',
                    Number,
                    0 /* BLACK */,
                    'CrosshairsMarkerColor'
                ],
                [
                    'CrosshairsMarkerSize',
                    Number,
                    10,
                    'CrosshairsMarkerSize'
                ],
                [
                    'CrosshairsMarkerStyle',
                    Number,
                    1 /* CIRCLE */,
                    'CrosshairsMarkerStyle'
                ],
                [
                    'Cursor',
                    String,
                    'default',
                    'Cursor'
                ],
                [
                    'AllowDragableMarkerInterpolation',
                    Boolean,
                    false
                ],
                [
                    'BarColumn3dDepthFactor',
                    Number,
                    0.5
                ],
                [
                    'SeriesMarkerAutoPosition',
                    Boolean,
                    true,
                    'SeriesMarkerAutoPosition'
                ],
                [
                    'SeriesMarkerAutoPositionXFactor',
                    Number,
                    0.75,
                    'SeriesMarkerAutoPositionXFactor'
                ],
                [
                    'SeriesMarkerAutoPositionYFactor',
                    Number,
                    0.75,
                    'SeriesMarkerAutoPositionYFactor'
                ],
                [
                    'SeriesMarkerAutoPositionMode',
                    Number,
                    0 /* ANNOTATION */,
                    'SeriesMarkerAutoPositionMode'
                ],
                [
                    'SeriesMarkerAutoPositionDirection',
                    Number,
                    0 /* POSITIVE */,
                    'SeriesMarkerAutoPositionDirection'
                ],
                [
                    'HistogramBinCount',
                    Number,
                    0
                ],
                [
                    'HistogramBinSize',
                    Number,
                    0
                ],
                [
                    'HistogramBinMin',
                    Number,
                    NaN
                ],
                [
                    'HistogramBinMax',
                    Number,
                    NaN
                ],
                [
                    'HistogramAggregateDataOutOfRange',
                    Boolean,
                    false
                ],
                [
                    'HistogramAdjustForNiceBins',
                    Boolean,
                    false
                ],
                [
                    'HistogramCountAsPercents',
                    Boolean,
                    false
                ],
                [
                    'HistogramAsColumnsNumDecimals',
                    Number,
                    0
                ]
            ]);
            // Apply theme, if necessary
            this._applyTheme();
            this.seriesLabelPen.writeToAttrSet(this.attributeSet, 'SeriesValueFG', 'SeriesValueFG');
            this.seriesLabelBrush.writeToAttrSet(this.attributeSet, 'SeriesValueBG', 'SeriesValueBG');
            this.seriesLabelFont.writeToAttrSet(this.attributeSet, 'SeriesValueFont', 'SeriesValueFont');
            this.seriesLabel1Font.writeToAttrSet(this.attributeSet, 'SeriesLabel1Font');
            this.seriesLabel2Font.writeToAttrSet(this.attributeSet, 'SeriesLabel2Font');
            this.seriesArrowPen.writeToAttrSet(this.attributeSet, 'SeriesValueArrowFG');
            this.seriesArrowLinePen.writeToAttrSet(this.attributeSet, 'SeriesValueLineFG');
            this.seriesArrowBrush.writeToAttrSet(this.attributeSet, 'SeriesValueArrowBG');
            this.seriesBGBrush.writeToAttrSet(this.attributeSet, 'SeriesBG');
            this.seriesFGPen.writeToAttrSet(this.attributeSet, 'SeriesFG');
            this.seriesOutlinePen.writeToAttrSet(this.attributeSet, 'SeriesOutline');
            this.seriesMarkerBGBrush.writeToAttrSet(this.attributeSet, 'SeriesMarkerBG');
            this.seriesMarkerFGPen.writeToAttrSet(this.attributeSet, 'SeriesMarkerFG');
            this.seriesMarkerOutlinePen.writeToAttrSet(this.attributeSet, 'SeriesMarkerOutline');
            this.seriesMarkerFont.writeToAttrSet(this.attributeSet, 'SeriesMarkerFont');
            this.seriesAlternateBGBrush.writeToAttrSet(this.attributeSet, 'SeriesAlternateBG');
            this.seriesAlternateFGPen.writeToAttrSet(this.attributeSet, 'SeriesAlternateFG');
            this.seriesAlternateOutlinePen.writeToAttrSet(this.attributeSet, 'SeriesAlternateOutline');
            this.quickLabelFont.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelFont');
            this.quickLabelFGPen.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelTextBoxFG');
            this.quickLabelBGBrush.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelTextBoxBG');
            this.treemapCategoryLabelPen.writeToAttrSet(this.attributeSet, 'TreemapCategoryLabelFG');
            this.treemapCategoryLabelBrush.writeToAttrSet(this.attributeSet, 'TreemapCategoryLabelBG');
            this.treemapCategoryLabelFont.writeToAttrSet(this.attributeSet, 'TreemapCategoryLabelFont');
            this.seriesOutlierIndicatorBGBrush.writeToAttrSet(this.attributeSet, 'SeriesOutlierIndicatorBG');
            this.seriesOutlierIndicatorFGPen.writeToAttrSet(this.attributeSet, 'SeriesOutlierIndicatorFG');
            this.baseLineFGPen.writeToAttrSet(this.attributeSet, 'BaselineFG');
            this.interactionFGPen.writeToAttrSet(this.attributeSet, 'InteractionHandleFG');
            this.attributeSet.defaultMap.finalizeInitialization();
        };
        FDSSeries.prototype.addAxis = function (axis, dimension) {
            return this._dimensionalAxes[dimension] = axis;
        };
        FDSSeries.prototype.getAxis = function (dimension) {
            var ret = this._dimensionalAxes[dimension];
            var parent = this.parent;
            // if we don't have the axis, check if our parents are series and they do
            while (ret == null && isSeries(parent)) {
                ret = parent._dimensionalAxes[dimension];
                parent = parent.parent;
            }
            return ret;
        };
        FDSSeries.prototype.getScale = function (dimension) {
            var axis = this.getAxis(dimension);
            if (axis != null) {
                var scale = axis.getScale();
                if (scale == null) {
                    scale = new FDSBinScale(this.root, axis.getPrefix(), axis);
                    axis.scale = scale;
                    axis.temporaryScale = true;
                }
                return scale;
            }
            return null;
        };
        FDSSeries.prototype.getData = function (dimension) {
            if (dimension === 4 /* COLOR */ && !this.dimensionalChildren[dimension].hasData()) {
                // if there's no color data, return the Y dimension
                dimension = 2 /* Y */;
            }
            return this.dimensionalChildren[dimension];
        };
        FDSSeries.prototype.getPlotParent = function () {
            var parent = this.parent;
            if (isPlot(parent)) {
                return parent;
            }
            else if (isRootChart(parent)) {
                return null;
            }
            return parent.getPlotParent();
        };
        FDSSeries.prototype.getSeriesParent = function () {
            return isSeries(this.parent) ? this.parent : null;
        };
        FDSSeries.prototype.initFromElement = function (element) {
            var fdschildrenList = element.getElementsByTagName('FDSChildren');
            var childObjects = (fdschildrenList.length > 0) ? fdschildrenList[0] : null;
            var children = childObjects ? childObjects['children'] || childObjects.childNodes : null;
            this._childrenNames = [];
            if (children) {
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < children.length; i++) {
                    // a child with no tag name is probably a text element - ignore
                    var child = children[i];
                    if (child.tagName === undefined) {
                        continue;
                    }
                    var childId = '';
                    if (child.tagName === 'FDSData') {
                        var tempId = child.getAttribute('ID');
                        // don't add a dataset for id-less children (which will be something like <FDSData />)
                        if (tempId != null) {
                            childId = tempId;
                            var dataset = new FDSDataSet(this.root, childId);
                            dataset.initFromElement(child);
                            this.root._addObject(childId, dataset);
                        }
                    }
                    else if (child.tagName === 'ChildId') {
                        childId = child.textContent;
                    }
                    // for now just save the names, will be replaced with actual children in addChildren
                    this._childrenNames.push(childId);
                }
            }
            // now find any random series appended inside this series
            var seriesChildren = element.getElementsByTagName('FDSSeries');
            // tslint:disable-next-line:prefer-for-of
            for (var j = 0; j < seriesChildren.length; j++) {
                var sc = seriesChildren[j];
                var id = sc.getAttribute('ID');
                if (id != null) {
                    this._childrenNames.push(id);
                }
            }
            // Call super::initFromElement, returning this
            _super.prototype.initFromElement.call(this, element);
        };
        FDSSeries.prototype.addChild = function (obj) {
            // So we don't actually want FDSDataSets in our this.children list, so
            // if the object that we are adding is an FDSDataSet, we will just
            // add ourselves to the boundSeries list it has and return true. It
            // is the responsiblity of the consumer to ensure that the FDSDataSet
            // gets added in the appropriate place in this.dimensionalChildren
            if (isDataSet(obj)) {
                obj.addSeries(this);
                return true;
            }
            return _super.prototype.addChild.call(this, obj);
        };
        FDSSeries.prototype.removeChildren = function () {
            for (var id in this.children) {
                var child = this.children[id];
                if ((child.parent != null) && child.parent === this) {
                    child.parent = null;
                }
            }
            this.children = {};
            for (var dim in this.dimensionalChildren) {
                var dataset = this.dimensionalChildren[dim];
                if ((dataset != null) && isDataSet(dataset)) {
                    dataset.removeSeries(this);
                }
            }
        };
        FDSSeries.prototype.addChildren = function () {
            return this.setChildren(this._childrenNames);
        };
        FDSSeries.prototype._createColorData = function () {
            var colordata = new FDSDataSet(this.root, "Color(" + this.id + ")");
            colordata.dataType = 'INT';
            colordata.attributeSet.setAt('InTips', 'app', false);
            colordata.syncMembers();
            this.root.addChartObject(colordata);
            this.addChild(colordata);
            this.dimensionalChildren[4 /* COLOR */] = colordata;
            this.defined[4 /* COLOR */] = true;
        };
        FDSSeries.prototype._destroySelectively = function (data) {
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                if (this.dimensionalChildren[i] !== undefined && this.dimensionalChildren[i] !== data[i]) {
                    this.dimensionalChildren[i] = undefined;
                    this.defined[i] = false;
                }
            }
        };
        // Sets the data on this series.
        //
        // @param data [Object] Object containing a new set of data (object with keys 0 through 6). If it is null it will
        // clear the data
        FDSSeries.prototype._setData = function (data) {
            if (data === void 0) { data = null; }
            if (data === null) {
                data = {};
                for (var i = 0; i < 7 /* MEMBERS */; i++) {
                    data[i] = undefined;
                }
            }
            this._destroySelectively(data);
            // Assign data to @dimensionalChildren
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                if (this.dimensionalChildren[i] !== data[i]) {
                    this.dimensionalChildren[i] = data[i];
                    if (data[i] !== undefined) {
                        this.defined[i] = true;
                    }
                }
            }
            if (this.dimensionalChildren[0 /* VALUE */] === undefined) {
                if (this.dimensionalChildren[2 /* Y */] !== undefined) {
                    this.dimensionalChildren[0 /* VALUE */] = this.dimensionalChildren[2 /* Y */];
                }
                else if (this.dimensionalChildren[1 /* X */] !== undefined) {
                    this.dimensionalChildren[0 /* VALUE */] = this.dimensionalChildren[1 /* X */];
                }
                else if (this.dimensionalChildren[3 /* Z */] !== undefined) {
                    this.dimensionalChildren[0 /* VALUE */] = this.dimensionalChildren[3 /* Z */];
                }
                else if (this.dimensionalChildren[4 /* COLOR */] !== undefined) {
                    this.dimensionalChildren[0 /* VALUE */] = this.dimensionalChildren[4 /* COLOR */];
                }
                else {
                    this.dimensionalChildren[0 /* VALUE */] = new FDSDataSet(this.root, '');
                }
            }
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                if (this.dimensionalChildren[i] === undefined) {
                    switch (i) {
                        case 2 /* Y */:
                        case 4 /* COLOR */:
                            this.dimensionalChildren[i] = this.dimensionalChildren[0 /* VALUE */];
                            break;
                        default:
                            this.dimensionalChildren[i] = new FDSDataSet(this.root, '');
                            this.dimensionalChildren[i].setIsIndex(true);
                    }
                }
            }
            this.adjust();
        };
        FDSSeries.prototype.getChildList = function () {
            var childList = {};
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                if (this.isDefined(i)) {
                    childList[this.dimensionalChildren[i].id] = this.dimensionalChildren[i];
                }
            }
            return childList;
        };
        FDSSeries.prototype.getDimensionOfDataChild = function (dataSet) {
            for (var dim = 0; dim < 7 /* MEMBERS */; dim++) {
                if (this.getData(dim) === dataSet) {
                    return dim;
                }
            }
            return -1 /* NONE */;
        };
        // Clears the Series
        FDSSeries.prototype.clear = function () {
            _super.prototype.clear.call(this);
            this._setData();
        };
        // Adjusts the Series to its data. Will update things such as hasValidData and size field
        FDSSeries.prototype.adjust = function () {
            this.updateCount += 1;
            if (this.renderCache) {
                this.renderCache.setInvalidated();
            }
            this.size = 0;
            this.hasValidData = true;
            this.hasValidPrimaryData = true;
            var init = true;
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                if (this._getDataType(i) !== 0 /* NO_FLAGS */) {
                    if (init) {
                        this.size = this.dimensionalChildren[i].getSize();
                        init = false;
                    }
                    else {
                        if (this.dimensionalChildren[i].getSize() < this.size) {
                            this.size = this.dimensionalChildren[i].getSize();
                        }
                    }
                    if (!this.dimensionalChildren[i].valid) {
                        this.hasValidData = false;
                        if (i === 1 /* X */ || i === 2 /* Y */) {
                            this.hasValidPrimaryData = false;
                        }
                    }
                }
            }
            if (this.size === 0) {
                this.hasValidData = false;
                this.hasValidPrimaryData = false;
            }
            this._parentDataPointIndex = ArrayUtils.makeArrayOf(-1, this.size);
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                // put in fake size for bin data sets
                if (this._getDataType(i) === 0 /* NO_FLAGS */) {
                    this.dimensionalChildren[i].setSize(this.size);
                }
            }
            return true;
        };
        FDSSeries.prototype._valueExistsInSeries = function (series, pt) {
            if (series != null) {
                var targetData = series.getData(1 /* X */);
                if (targetData) {
                    var size = targetData.getSize();
                    for (var i = 0; i < size; i++) {
                        if (targetData.getAt(i) === pt) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        // This is used to move annotations after a data update
        FDSSeries.prototype._adjustYDataToParent = function () {
            // Only will be used when the series in an annotation
            if (!this.isAnnotation) {
                return;
            }
            if (this.root) {
                if (isSeries(this.parent)) {
                    var yData = this.getData(2 /* Y */);
                    var xData = this.getData(1 /* X */);
                    if ((xData && yData) && (xData.getSize() > 0 && yData.getSize() > 0) && (yData.dataType !== 'STRING')) {
                        if (this._parentDataPointIndex.length !== this.size) {
                            this._parentDataPointIndex = ArrayUtils.makeArrayOf(-1, this.size);
                        }
                        var yValue = 0.0;
                        for (var i = 0; i < this.size; i++) {
                            if (this._annotationDisappearOnNoValidXData) {
                                if (!this._valueExistsInSeries(this.parent, xData.getAt(i))) {
                                    if (IsSomeNAN(yData.getAt(i))) {
                                        continue;
                                    }
                                    yData.replacePoint(i, NAN);
                                    continue;
                                }
                            }
                            var ret = this.parent._getValueAt(1 /* X */, xData.getAt(i), 2 /* Y */, yData.getAt(i), this._parentDataPointIndex[i], this._annotationDisappearOnNoValidYData, this._annotationDisappearOnNoValidXData);
                            if (ret) {
                                var index = ret.index, value = ret.value;
                                yValue = value;
                                this._parentDataPointIndex[i] = index;
                                // if the values are the same, we dont need to replace the point
                                // need to check specially if they're NAN because they could each be different NANs
                                var pt = yData.getAt(i);
                                var equal = (pt === yValue) || (IsSomeNAN(pt) && IsSomeNAN(yValue));
                                if (!equal) {
                                    yData.replacePoint(i, value, false);
                                }
                            }
                        }
                    }
                }
            }
            this._updateHighLowAnnotations();
        };
        FDSSeries.prototype._replaceDataPoint = function (dim, index, value, isValueInNDCSpace) {
            if (isValueInNDCSpace === void 0) { isValueInNDCSpace = false; }
            if (!this.root) {
                return false;
            }
            var data = this.getData(dim);
            if (!data) {
                return false;
            }
            if (index < 0 || index >= data.getSize()) {
                return false;
            }
            if (isValueInNDCSpace && typeof value === 'number') {
                var axis = this.getAxis(dim);
                if (axis) {
                    var scale = axis.getScale();
                    if (scale) {
                        value = clamp(scale.computeValue(value), scale.threshMin, scale.threshMax);
                    }
                }
            }
            var valArr = value instanceof Array ? value : [value];
            // we only have the dataset notify its parents if
            // @adjustAxes is true. This way our drawing tools will cause the
            // scale to reset since we (usually) set adjustAxes to false on those.
            data.replacePoint(index, valArr, this.adjustAxes);
            return true;
        };
        FDSSeries.prototype._updateHighLowAnnotations = function () {
            this._updateHighLowAnnotationsInternal(1 /* X */);
            this._updateHighLowAnnotationsInternal(2 /* Y */);
        };
        FDSSeries.prototype._updateHighLowAnnotationsInternal = function (dim) {
            if (!this.isAnnotation || !(this.highAnnotation || this.lowAnnotation)) {
                return;
            }
            if (isSeries(this.parent)) {
                var data = this.getData(dim);
                var parentData = this.parent.getData(dim);
                if ((data == null) || (parentData == null)) {
                    return;
                }
                if (data.getDataType() !== parentData.getDataType()) {
                    var id = this.dimensionalChildren[dim].id;
                    data.removeSeries(this);
                    this.root._deleteObjectInternal(id, 0 /* NONE */, false);
                    this.root.addObject(id, 1 /* FC_DATA */, (parentData.getDataType() ? parentData.getDataType() : 1 /* INT_DATA */), null, null);
                    this.dimensionalChildren[dim] = this._getImageDS(id);
                    if (this.dimensionalChildren[dim] == null) {
                        return;
                    }
                }
                data = this.getData(dim);
                var pdim = parentData.getDimension();
                for (var i = 0; i < pdim; i++) {
                    if (data.getDimension() < pdim) {
                        data.add(i.toString(), []);
                    }
                    // TODO(port): is this supposed to be dataID or label
                    data.getDimensionalDataset(i)['label'] = parentData.getDimensionalDataset(i)['label'];
                }
                pdim = parentData.getDimension();
                var pos = 0;
                if (this.highAnnotation) {
                    pos = 1;
                    var _a = this.parent.getData(2 /* Y */).Max(), index = _a[1];
                    if (index < this.parent.getData(dim).getSize()) {
                        var dataPts = [];
                        for (var i = 0; i < pdim; i++) {
                            dataPts.push(parentData.getAt(index, i));
                        }
                        data.replacePointGrow(0, dataPts, false);
                    }
                }
                if (this.lowAnnotation) {
                    var _b = this.parent.getData(2 /* Y */).Min(), index = _b[1];
                    if (index < this.parent.getData(dim).getSize()) {
                        var dataPts = [];
                        for (var i = 0; i < pdim; i++) {
                            dataPts.push(parentData.getAt(index, i));
                        }
                        data.replacePointGrow(pos, dataPts, false);
                    }
                }
                if (data.getSize() < this.size) {
                    data.growWithNA(this.size - 1, false);
                }
            }
        };
        FDSSeries.prototype._getImageDS = function (name) {
            if (this.root != null) {
                return this.root.getImageDS(name);
            }
            return null;
        };
        FDSSeries.prototype._getValueAt = function (targetDim, target, valueDim, matchToThisValue, dataPointIndex, annotationDisappearOnNoValidYData, annotationDisappearOnNoValidXData) {
            var targetData = this.getData(targetDim);
            var valueData = this.getData(valueDim);
            var value = 0.0;
            if (targetData && valueData) {
                // the datapoints is already known, There's no need to look for a target datapoint...
                if (dataPointIndex >= 0) {
                    // unless the parent's dataset size has changed
                    if (dataPointIndex < valueData.getSize()) {
                        // x data is nan?
                        if (IsSomeNAN(targetData.getAt(dataPointIndex)) && annotationDisappearOnNoValidXData) {
                            return { index: dataPointIndex, value: value = NAN };
                        }
                        value = valueData.getAt(dataPointIndex);
                        // y data is nan?
                        if (IsSomeNAN(value)) {
                            if (annotationDisappearOnNoValidYData) {
                                return { index: dataPointIndex, value: value };
                            }
                        }
                        else {
                            return { index: dataPointIndex, value: value };
                        }
                    }
                    else {
                        dataPointIndex = -1;
                    }
                }
                // if the target dimension is an index, we can just use ceiling to get the next closest index. Much faster.
                if (targetData.isIndex) {
                    var index = Math.ceil(target);
                    if (0 <= index && index < valueData.getSize()) {
                        value = valueData.getAt(index);
                        dataPointIndex = index;
                    }
                    else {
                        value = NAN;
                    }
                    return { index: dataPointIndex, value: value };
                }
                var sorted = targetData.sorted;
                var ascending = targetData.ascending;
                if (this.size < 1) {
                    return null;
                }
                // You might be asking yourself, why do we care about NA values? Don't we want to return what is at the point?
                // The short answer is IPO annotations.
                //                       ___
                // 4  |          ___    /   |
                // 3  |  IPO    /   \__/    |   /
                // 2  |   |    /            \__/
                // 1  |   v   /
                // 0  --------------------------------------
                //      1  2  3  4  5  6  7  8  9
                //
                // -- Sometimes it is necessary that we annotate off the series. In the case of IPO annotations, we do this
                //    to mark when the IPO is. Perhaps it's prior to the first trading day. In any case, it has a date, and
                // its
                //    associated value is actually the next non-NA value (since there is no value for the date that the IPO
                // was, just the date, no value) Its value should be the value on the first valid day (3), in which the value
                // would be 1.  -- Another interesting note: In this case, the IPO Annotation isn't annotating an NA value,
                // but rather the first value in the dataseries. So it will follow the first data point around. Same for
                // values after the dataset.
                if (sorted) {
                    var left = 0;
                    var right = targetData.getSize() - 1;
                    var mid = 0;
                    var current = 0;
                    while (left < right) {
                        mid = ~~((left + right) / 2);
                        current = targetData.getAt(mid);
                        var nan = IsSomeNAN(current);
                        if (IsSomeNAN(current)) {
                            var offset = 0;
                            while (IsSomeNAN(current) && (mid + offset <= right)) {
                                offset++;
                                current = targetData.getAt(mid + offset);
                            }
                            // if we hit an end point without finding a non-NA value, the desired point must have been in the
                            // unsearched half.
                            if (mid + offset > right) {
                                right = mid;
                                continue;
                            }
                        }
                        if (fuzzyEQ(target, current)) {
                            value = valueData.getAt(mid);
                            // If we explicitly allow for NAs to be detected, lets return after finding what we were after
                            // Implicitly at this point, IsNA(value) == true
                            // we will deal with NA as part of the value parameter in calling functions
                            if (!IsSomeNAN(value) || (IsSomeNAN(value) && annotationDisappearOnNoValidYData)) {
                                dataPointIndex = mid;
                                return { value: value, index: dataPointIndex };
                            }
                            else {
                                left = right = mid;
                                break;
                            }
                        }
                        else if ((ascending && target <= current) || // ascending
                            (!ascending && target >= current)) {
                            right = mid;
                        }
                        else {
                            left = mid + 1;
                        }
                    }
                    // left now contains the closest match (or an NA)
                    current = targetData.getAt(left);
                    if (IsSomeNAN(current) && annotationDisappearOnNoValidXData) {
                        value = NAN;
                        return { index: dataPointIndex, value: value };
                    }
                    value = valueData.getAt(left);
                    // if we settled on an NA somewhere in the series, walk back down the series until we hit a valid number
                    // or the start of the series
                    if (IsSomeNAN(value) && !annotationDisappearOnNoValidYData) {
                        while (left < valueData.getSize() && IsSomeNAN(value = valueData.getAt(++left))) {
                            continue;
                        }
                        if (left >= valueData.getSize()) {
                            value = NAN;
                        }
                        return { index: dataPointIndex, value: value };
                    }
                }
                else {
                    // If the data is unsorted (ie. scatterplot), fall back on a linear search looking for an exact match.
                    // if none is found, return the last datapoint or NA if we are "disapearing on no valid y data"
                    // When adding a new annotation to an unordered dataset, before we are able to do anything, this piece of
                    // code is executed (when no datasets exists or when they exist but the datapoints are all NAs) Since the
                    // target is NAN, it will be clamped to TargetData->Min() and a match will ALWAYS be found (namely the
                    // datapoint with the smallest x-value) bogusMatch will assign the found datapoint index (i) ONLY if target
                    // is a valid number. bogusMatch is used so that we do not change the behavior of the algorithm (which is
                    // currently very confusing)
                    var bogusMatch = IsSomeNAN(target) || IsSomeNAN(matchToThisValue);
                    var indexOfSemiMatch = -1;
                    // force the Y value we're looking for to lie within the min/max range of XData
                    target = Math.max(target, targetData.Min()[0]);
                    target = Math.min(target, targetData.Max()[0]);
                    // linear search through data
                    for (var i = 0; i < this.size; i++) {
                        var current = targetData.getAt(i);
                        // check to see if we're at the nearest value to the one we're looking for:
                        // for unsorted graphs, we are only concerned with exact matches
                        if (fuzzyEQ(current, target)) {
                            if (fuzzyEQ(valueData.getAt(i), matchToThisValue)) {
                                value = valueData.getAt(i);
                                // if we explicitly allow for NAs to be detected, let's return after finding what we were after
                                // Implicitly at this point ISNA(value) === true
                                if ((!IsSomeNAN(value)) || annotationDisappearOnNoValidYData) {
                                    if (!bogusMatch) {
                                        dataPointIndex = i;
                                    }
                                    return { index: dataPointIndex, value: value }; // we will deal with the NA as part of the value
                                    // parameter in calling functions
                                }
                            }
                            else {
                                indexOfSemiMatch = IsSomeNAN(valueData.getAt(i)) ? indexOfSemiMatch : i;
                            }
                        }
                    }
                    // return whatever we found. Might not be exactly what we want, but it's close
                    if (indexOfSemiMatch >= 0) {
                        value = valueData.getAt(indexOfSemiMatch);
                        if (!bogusMatch) {
                            dataPointIndex = indexOfSemiMatch;
                        }
                        return { index: dataPointIndex, value: value };
                    }
                    // an exact match wasnt found... so we return NA or the last data poiint
                    if (annotationDisappearOnNoValidXData || annotationDisappearOnNoValidYData) {
                        value = NAN;
                    }
                    else {
                        value = valueData.getAt(this.size - 1);
                    }
                    return { index: dataPointIndex, value: value };
                }
            }
            return null;
        };
        // Gets the dataType of the given dimension
        //
        // @param dim [DIM] dimension
        FDSSeries.prototype._getDataType = function (dim) {
            var ds = this.getData(dim);
            return ds ? ds.getDataType() : undefined;
        };
        FDSSeries.prototype.addSeriesChild = function (series) {
            // sync this object before performing adjust
            series.syncMembers();
            this.addChild(series);
            // don't bother calling this if the parent data doesn't exist yet or something
            if (isSeries(series.parent) && series.parent.getData(2 /* Y */).hasData()) {
                series._adjustYDataToParent();
            }
            this.wrapper.setSeriesListDirty();
        };
        // Sets objects in `children` to be parented to this series
        //
        // @param children [Array] array containing string IDs of objects to be parented to this series
        FDSSeries.prototype.setChildren = function (children) {
            var ret = true;
            var errString = '';
            if (!this.root) {
                errString = 'Invalid root when parenting';
                return [false, errString];
            }
            var newData = {};
            var numberOfDataPoints = [];
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                newData[i] = undefined;
            }
            var count = 0;
            var updateData = false;
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                var object = this.root.getChild(child);
                if (isSeries(object)) {
                    if (object === this || object.hasChild(this)) {
                        ret = false;
                    }
                    else {
                        this.addSeriesChild(object);
                        ret = true;
                    }
                    this.wrapper.setSeriesListDirty();
                }
                else if (count < 7 /* MEMBERS */) {
                    if (isDataSet(object)) {
                        this.addChild(object);
                        newData[count] = object;
                        numberOfDataPoints.push(object.data.length);
                        this.hasValidData = this.hasValidData || object.valid;
                        if (count === 1 /* X */ || count === 2 /* Y */) {
                            this.hasValidPrimaryData = this.hasValidPrimaryData && object.valid;
                        }
                        updateData = ret = true;
                        this.wrapper.setDataMapDirty();
                    }
                    count++;
                }
                else {
                    ret = false;
                    errString = "Unable to parent " + child + " on series " + this.id;
                }
            }
            if (ENABLE_DEBUG && this.root.commonDebug && numberOfDataPoints.length > 0) {
                var hasMismatchingDataLengths = _$1.some(numberOfDataPoints, function (currentPoint) {
                    return currentPoint !== numberOfDataPoints[0];
                });
                if (hasMismatchingDataLengths) {
                    console.warn("Mismatching number of datapoints for " + this.id + ": " + numberOfDataPoints.join(','));
                }
            }
            if (updateData) {
                this._setData(newData);
            }
            this.adjust();
            this.notifyParents(1 /* CHANGE */);
            return [ret, errString];
        };
        FDSSeries.prototype.processChildren = function () {
            // we need to re-run through our children after the datasets are parented
            // to update the annotations
            for (var id in this.children) {
                var child = this.children[id];
                child._adjustYDataToParent();
            }
        };
        FDSSeries.prototype._getZoomedPoint = function (zoomPtType, dim, propInfo) {
            var dimension = 0;
            if (propInfo.seriesDim >= 0) {
                dimension = propInfo.seriesDim;
            }
            var check = this._filterZoomedPoints(dim, dimension);
            if (!check) {
                return null;
            }
            var startIndex = check.startIndex, endIndex = check.endIndex, points = check.points;
            if (points.length <= 0) {
                return null;
            }
            switch (zoomPtType) {
                case 0 /* MAX */:
                    return ArrayUtils.max(points, DataPtGreater);
                case 1 /* MIN */:
                    return ArrayUtils.min(points, DataPtLess);
                case 2 /* FIRST */:
                    return points[0];
                case 3 /* LAST */:
                    return points[points.length - 1];
            }
            return null;
        };
        FDSSeries.prototype._propFDSRegressionFormula = function (propInfo) {
            this;
            if (this.getRegressionData()) {
                return this._regressionFormula;
            }
            else {
                return '';
            }
        };
        FDSSeries.prototype._propFDSPlotName = function (propInfo) {
            var obj = this.getPlotParent();
            return obj ? obj.id : '@NA';
        };
        FDSSeries.prototype._propFDSAxisNameX = function (propInfo) {
            var obj = this.getAxis(1 /* X */);
            return obj ? obj.id : '@NA';
        };
        FDSSeries.prototype._propFDSAxisNameY = function (propInfo) {
            var obj = this.getAxis(2 /* Y */);
            return obj ? obj.id : '@NA';
        };
        FDSSeries.prototype._propFDSAxisFormatX = function (propInfo) {
            var obj = this.getAxis(1 /* X */);
            return obj ? obj._propFDSAxisFormat(propInfo) : '@NA';
        };
        FDSSeries.prototype._propFDSAxisFormatY = function (propInfo) {
            var obj = this.getAxis(2 /* Y */);
            return obj ? obj._propFDSAxisFormat(propInfo) : '@NA';
        };
        FDSSeries.prototype._propFDSAxisTypeX = function (propInfo) {
            var obj = this.getAxis(1 /* X */);
            return obj ? obj._propFDSAxisType(propInfo) : '@NA';
        };
        FDSSeries.prototype._propFDSAxisTypeY = function (propInfo) {
            var obj = this.getAxis(2 /* Y */);
            return obj ? obj._propFDSAxisType(propInfo) : '@NA';
        };
        FDSSeries.prototype._propFDSZoomedFirstX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getZoomedPoint.bind(this, 2 /* FIRST */, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedFirstY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getZoomedPoint.bind(this, 2 /* FIRST */, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedLastX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getZoomedPoint.bind(this, 3 /* LAST */, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedLastY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getZoomedPoint.bind(this, 3 /* LAST */, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedMaxX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getZoomedPoint.bind(this, 0 /* MAX */, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedMinX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getZoomedPoint.bind(this, 1 /* MIN */, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedMaxY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getZoomedPoint.bind(this, 0 /* MAX */, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSZoomedMinY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getZoomedPoint.bind(this, 1 /* MIN */, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSFirstX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this.getFirstValidPoint.bind(this, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSFirstY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this.getFirstValidPoint.bind(this, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSLastX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this.getLastValidPoint.bind(this, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSLastY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this.getLastValidPoint.bind(this, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMinX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getMinValidPoint.bind(this, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMinY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getMinValidPoint.bind(this, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMaxX = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getMaxValidPoint.bind(this, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMaxY = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getMaxValidPoint.bind(this, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMinXAll = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getMinPtAllDim.bind(this, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMaxXAll = function (propInfo, kwArgs) {
            return this._statPropertyHelper(1 /* X */, this._getMaxPtAllDim.bind(this, 1 /* X */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMinYAll = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getMinPtAllDim.bind(this, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSMaxYAll = function (propInfo, kwArgs) {
            return this._statPropertyHelper(2 /* Y */, this._getMaxPtAllDim.bind(this, 2 /* Y */), propInfo, kwArgs);
        };
        FDSSeries.prototype._propFDSTooltipText = function (propInfo, kwArgs) {
            var index = propInfo.seriesIndex != null ? propInfo.seriesIndex : -1;
            return this.getTooltipLabel(index);
        };
        FDSSeries.prototype._statPropertyHelper = function (plotDim, fn, propInfo, kwArgs) {
            var value, index, dim;
            var result = fn(propInfo);
            if (!result) {
                return '@NA';
            }
            (value = result.value, index = result.index, dim = result.dim);
            if (dim == null) {
                dim = propInfo.seriesDim != null ? propInfo.seriesDim : 0;
            }
            var ds = this.getData(plotDim);
            var type = ds.dataType;
            if (kwArgs && kwArgs.hasArg('TYPE')) {
                var left = kwArgs.getArg('TYPE', propInfo).toUpperCase();
                type = left != null ? left : ds.dataType;
            }
            var format = ds.compiledFormat.fromValue();
            if (kwArgs && kwArgs.hasArg('FORMAT')) {
                format = kwArgs.getArg('FORMAT', propInfo);
            }
            return this._printValueFormat(propInfo, type, format, ds, dim, index);
        };
        FDSSeries.prototype._propFDSZoomedIndexFirst = function (propInfo) {
            return this._zoomedIndexAtHelper(1 /* X */, 2 /* FIRST */, propInfo);
        };
        FDSSeries.prototype._propFDSZoomedIndexLast = function (propInfo) {
            return this._zoomedIndexAtHelper(1 /* X */, 3 /* LAST */, propInfo);
        };
        FDSSeries.prototype._propFDSZoomedIndexAtMaxX = function (propInfo) {
            return this._zoomedIndexAtHelper(1 /* X */, 0 /* MAX */, propInfo);
        };
        FDSSeries.prototype._propFDSZoomedIndexAtMinX = function (propInfo) {
            return this._zoomedIndexAtHelper(1 /* X */, 1 /* MIN */, propInfo);
        };
        FDSSeries.prototype._propFDSZoomedIndexAtMaxY = function (propInfo) {
            return this._zoomedIndexAtHelper(2 /* Y */, 0 /* MAX */, propInfo);
        };
        FDSSeries.prototype._propFDSZoomedIndexAtMinY = function (propInfo) {
            return this._zoomedIndexAtHelper(2 /* Y */, 1 /* MIN */, propInfo);
        };
        FDSSeries.prototype._zoomedIndexAtHelper = function (dim, zoomIndexType, propInfo) {
            var dimension = 0;
            if (propInfo.seriesDim >= 0) {
                dimension = propInfo.seriesDim;
            }
            var check = this._filterZoomedPoints(dim, dimension);
            if (!check) {
                return -1;
            }
            var startIndex = check.startIndex, endIndex = check.endIndex, points = check.points;
            if (points.length <= 0) {
                return -1;
            }
            switch (zoomIndexType) {
                case 0 /* MAX */:
                    return ArrayUtils.max(points, DataPtLess).index;
                case 1 /* MIN */:
                    return ArrayUtils.min(points, DataPtLess).index;
                case 2 /* FIRST */:
                    return startIndex;
                case 3 /* LAST */:
                    return endIndex;
            }
            return -1;
        };
        // mimics logic used in _constructLabel but uses attributes on the legend
        FDSSeries.prototype._propFDSLegendLabel = function (propertyValueContext) {
            // use the first piece of data in the series...
            var index = 0;
            var pie = false;
            // ...unless it's provided to us...
            if ((propertyValueContext.seriesIndex != null) && propertyValueContext.seriesIndex > -1) {
                pie = true; // ...in which case it must be a pie drawstyle
                index = propertyValueContext.seriesIndex;
            }
            // go through the three things the mask controls and append them if necessary
            var ret = [];
            var parentLegend = this.getPlotParent().legend;
            var legendActive = parentLegend && !this.getPlotParent().isActiveLegendHeatmap();
            var lp = legendActive ? parentLegend.legendProperties : null;
            if (!lp) {
                return this.compiledLabelText.fromValueRT({ propertySet: this.properties });
            }
            if (pie && lp.dataMask === 0) {
                // show X data in pie legends when nothing is set to be shown
                lp.dataMask = 2;
            }
            for (var dim = 0; dim < 3; dim++) {
                var flag = 1 << dim; // 1, 2, 4
                if (lp.dataMask & flag) {
                    ret = this._appendLegendDataLabel(dim, index, ret);
                    // if we want only the value and there is no value data, put the Y data
                    if (lp.dataMask === 1 && ret.length === 0) {
                        ret = this._appendLegendDataLabel(2 /* Y */, index, ret);
                    }
                }
            }
            // do at the end so you can still do the blank check inside the loop
            if (lp.showLabel && !pie) {
                var label = this.compiledLabelText.fromValueRT({ propertySet: this.properties });
                ret = label.data.concat(' ').concat(ret);
            }
            // remove trailing whitespace
            while (ret[ret.length - 1] === ' ') {
                ret.pop();
            }
            return new RichTextString(ret);
        };
        // mimics _appendDataLabel but uses legend attributes
        FDSSeries.prototype._appendLegendDataLabel = function (dimension, index, array) {
            var ds = this.getData(dimension);
            if (ds === undefined || !this.isDefined(dimension)) {
                return array;
            }
            var added = false;
            var flag = 1 << dimension;
            var parentLegend = this.getPlotParent().legend;
            var legendActive = parentLegend && !this.getPlotParent().isActiveLegendHeatmap();
            var lp = legendActive ? parentLegend.legendProperties : null;
            if (!lp) {
                return array;
            }
            if ((lp.labelMask & flag) && (ds.labelText !== '')) {
                array = this._append(array, ds.labelText);
                added = true;
            }
            if ((lp.sublabelMask & flag) && (ds.dataId !== '')) {
                array = this._append(array, ds.dataId);
                added = true;
            }
            if (ds.data !== undefined) {
                // get the type and format and format the data
                var formattedData = this._printValueFormat(null, ds.dataType, ds.compiledFormat.fromValue(), ds, 0, index, true);
                array = this._append(array, formattedData);
                added = true;
            }
            if (added) {
                array.push(' ');
            }
            return array;
        };
        FDSSeries.prototype._propFDSCrosshairIndex = function (propertyValueContext) {
            return this.crosshairIndex;
        };
        FDSSeries.prototype._propFDSDataValue = function (seriesPropInfo, kwArgs) {
            var dataSet = this.getData(0 /* VALUE */);
            var _a = this._getPropertyArgs(kwArgs, seriesPropInfo, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printValueFormat(seriesPropInfo, type, format, dataSet, dim, index);
        };
        FDSSeries.prototype._propFDSDataY = function (propertyValueContext, kwArgs) {
            var dataSet;
            if (this.isDefined(2 /* Y */)) {
                dataSet = this.getData(2 /* Y */);
            }
            else {
                return '';
            }
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printValueFormat(propertyValueContext, type, format, dataSet, dim, index);
        };
        FDSSeries.prototype._propFDSDataX = function (propertyValueContext, kwArgs) {
            var dataSet;
            if (this.isDefined(1 /* X */)) {
                dataSet = this.getData(1 /* X */);
            }
            else {
                return '';
            }
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printValueFormat(propertyValueContext, type, format, dataSet, dim, index);
        };
        FDSSeries.prototype._propFDSDataZ = function (propertyValueContext, kwArgs) {
            var dataSet;
            if (this.isDefined(3 /* Z */)) {
                dataSet = this.getData(3 /* Z */);
            }
            else {
                return '';
            }
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printValueFormat(propertyValueContext, type, format, dataSet, dim, index);
        };
        FDSSeries.prototype._propFDSDataColor = function (propertyValueContext, kwArgs) {
            var dataSet;
            if (this.isDefined(4 /* COLOR */)) {
                dataSet = this.getData(4 /* COLOR */);
            }
            else {
                return '';
            }
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printValueFormat(propertyValueContext, type, format, dataSet, dim, index);
        };
        FDSSeries.prototype._propFDSDataDSize = function (propertyValueContext, kwArgs) {
            var dataSet;
            if (this.isDefined(5 /* DSIZE */)) {
                dataSet = this.getData(5 /* DSIZE */);
            }
            else {
                return '';
            }
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printValueFormat(propertyValueContext, type, format, dataSet, dim, index);
        };
        FDSSeries.prototype._propFDSDataLabel = function (propertyValueContext, kwArgs) {
            var index = propertyValueContext.seriesIndex != null ? propertyValueContext.seriesIndex : 0;
            return this._constructLabel(index, 'seriesValue', false);
        };
        FDSSeries.prototype._propFDSDataTooltip = function (propertyValueContext, kwArgs) {
            var index = propertyValueContext.seriesIndex != null ? propertyValueContext.seriesIndex : 0;
            if (index < 0) {
                return RichTextString.Empty;
            }
            return this._constructLabel(index, 'tooltip', true);
        };
        FDSSeries.prototype._propFDSAverageX = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(1 /* X */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'mean');
        };
        FDSSeries.prototype._propFDSAverageY = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(2 /* Y */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'mean');
        };
        FDSSeries.prototype._propFDSStdDevX = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(1 /* X */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'stddev');
        };
        FDSSeries.prototype._propFDSStdDevY = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(2 /* Y */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'stddev');
        };
        FDSSeries.prototype._propFDSVarianceX = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(1 /* X */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'variance');
        };
        FDSSeries.prototype._propFDSVarianceY = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(2 /* Y */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, dataSet), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'variance');
        };
        FDSSeries.prototype._propFDSCountValidX = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(1 /* X */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, { dataType: 'INT' }), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'countValid');
        };
        FDSSeries.prototype._propFDSCountValidY = function (propertyValueContext, kwArgs) {
            var dataSet = this.getData(2 /* Y */);
            var _a = this._getPropertyArgs(kwArgs, propertyValueContext, { dataType: 'INT' }), index = _a[0], dim = _a[1], type = _a[2], format = _a[3];
            return this._printStatFormat(propertyValueContext, type, format, dataSet, dim, 'countValid');
        };
        FDSSeries.prototype._propFDSIndex = function (propertyValueContext, kwArgs) {
            return propertyValueContext.seriesIndex != null ? propertyValueContext.seriesIndex : -1;
        };
        FDSSeries.prototype._propFDSDataTypeX = function (propertyValueContext, kwArgs) {
            var dataSet;
            return ((dataSet = this.getData(1 /* X */)) ? dataSet.dataType : 'NONE');
        };
        FDSSeries.prototype._propFDSDataTypeY = function (propertyValueContext, kwArgs) {
            var dataSet;
            return ((dataSet = this.getData(2 /* Y */)) ? dataSet.dataType : 'NONE');
        };
        // function to construct a label from attributes with a certain prefix
        // @return [Array<String>] an array to be handed into richtext renderer
        FDSSeries.prototype._constructLabel = function (index, prefix, checkInTips) {
            // go through the three things the mask controls and append them if necessary
            var ret = [];
            var dataMask = prefix === 'seriesValue' ? this._seriesValueDataMask : this._tooltipDataMask;
            for (var dim = 0; dim < 7 /* MEMBERS */; dim++) {
                var flag = 1 << dim; // 1, 2, 4
                if (dataMask & flag) {
                    ret = this._appendDataLabel(dim, index, ret, prefix, checkInTips);
                    // if we want only the value and there is no value data, put the Y data
                    if (dataMask === 1 && ret.length === 0) {
                        ret = this._appendDataLabel(2 /* Y */, index, ret, prefix, checkInTips);
                    }
                }
            }
            // do at the end so you can still do the blank check inside the loop
            var showLabel = prefix === 'seriesValue' ? this._seriesValueShowLabel : this._tooltipShowLabel;
            if (showLabel) {
                var label = this.compiledLabelText.fromValueRT({ propertySet: this.properties });
                ret = label.data.concat('\n').concat(ret);
            }
            // chop off trailing newlines, if any
            var len = ret.length - 1;
            if (ret[len] === '\n') {
                ret[len] = '';
            }
            return new RichTextString(ret);
        };
        // generates a label for a specific dimension based on masks
        FDSSeries.prototype._appendDataLabel = function (dimension, index, array, prefix, checkInTips) {
            var _this = this;
            var ds = this.getData(dimension);
            if (ds === undefined || !this.isDefined(dimension) || (checkInTips && !ds.inTips)) {
                return array;
            }
            var added = false;
            var flag = 1 << dimension;
            var labelMask = prefix === 'seriesValue' ? this._seriesValueLabelMask : this._tooltipLabelMask;
            var subLabelMask = prefix === 'seriesValue' ? this._seriesValueSublabelMask : this._tooltipSublabelMask;
            // we'll use this function to append the labels for the dataset
            // given as well as all of its children
            var appendFormattedDataSetLabel = function (ds2) {
                if (checkInTips && !ds2.inTips) {
                    return;
                }
                if ((labelMask & flag) && (ds2.labelText !== '')) {
                    array = _this._append(array, ds2.labelText);
                    added = true;
                }
                if ((subLabelMask & flag) && (ds2.dataId !== '')) {
                    array = _this._append(array, ds2.dataId);
                    added = true;
                }
                if (ds2.data !== undefined) {
                    // get the type and format and format the data
                    var parser = new FormatParser();
                    var preFormattedData = parser.parseConditionalFormatAndApply(ds2.compiledFormat.fromValue(), ds2.getAtDirect(index));
                    var formattedData = _this._printValueFormat(null, ds2.dataType, preFormattedData, ds2, 0, index, true);
                    array = _this._append(array, formattedData);
                    added = true;
                }
                if (added) {
                    array.push('\n');
                }
            };
            appendFormattedDataSetLabel(ds);
            for (var key in ds.children) {
                var _ds = ds.children[key];
                appendFormattedDataSetLabel(_ds);
            }
            return array;
        };
        // helper to append a string or an array onto an array, padded with a space if necessary
        // @param one [Array] the array to append to
        // @param two [String/Array] either a string or an array to append
        FDSSeries.prototype._append = function (one, two) {
            if (one.length !== 0) {
                var str = one[one.length - 1];
                if (typeof str === 'string' && str[str.length - 1] !== '\n' && str[str.length - 1] !== ' ') {
                    one.push(' ');
                }
            }
            if (two instanceof RichTextString) {
                one = one.concat(two.data);
            }
            else {
                one.push(two);
            }
            return one;
        };
        FDSSeries.prototype._propFDSSelectionIndex = function (propertyValueContext, kwArgs) {
            var side = kwArgs.getArg('side', propertyValueContext);
            if (this.root.isSelectionEnabled()) {
                if (side === 'l') {
                    return this.leftSelectIndex;
                }
                else if (side === 'r') {
                    return this.rightSelectIndex;
                }
                else {
                    return -1;
                }
            }
            else {
                return -1;
            }
        };
        FDSSeries.prototype._getPropertyArgs = function (kwArgs, propertyValueContext, dataSet) {
            var index = propertyValueContext.seriesIndex != null ? propertyValueContext.seriesIndex : 0;
            var dim = propertyValueContext.seriesDim;
            var type = dataSet.dataType;
            if (kwArgs && kwArgs.hasArg('TYPE')) {
                type = kwArgs.getArg('TYPE', propertyValueContext).toUpperCase();
                if (type == null) {
                    type = dataSet.dataType;
                }
            }
            var format = '';
            if (dataSet && dataSet.compiledFormat) {
                format = dataSet.compiledFormat.fromValue();
            }
            if (kwArgs && kwArgs.hasArg('FORMAT')) {
                format = kwArgs.getArg('FORMAT', propertyValueContext);
            }
            else if (type === 'FLOAT' && !format) {
                format = '#.2F';
            }
            return [index, dim, type, format];
        };
        FDSSeries.prototype._printStatFormat = function (propInfo, type, format, ds, dim, stat, richtext) {
            if (richtext === void 0) { richtext = false; }
            var res = '';
            if ((ds == null) || dim < 0 || !ds.hasData()) {
                return res;
            }
            // this is to say that we already formatted the number here. it will be formatted after we return.
            // this prevents double formatting inside resolvePropertyHandle() in FDSProperty
            if (propInfo != null) {
                propInfo.formattingApplied = true;
            }
            var startDim;
            var totalDim;
            if (dim == null) {
                startDim = 0;
                totalDim = ds.getDimension();
            }
            else {
                if (dim >= ds.getDimension()) {
                    dim = 0;
                }
                startDim = dim;
                totalDim = dim + 1;
            }
            for (var i = startDim; i < totalDim; i++) {
                var value = ds.getDimensionalDataset(i).statistics[stat];
                var formatString = this._valueFormatter.setNumberFormat(format);
                res += this._valueFormatter.formatAsNumber(value);
                if (i + 1 < totalDim) {
                    res += '\n';
                }
            }
            return res;
        };
        FDSSeries.prototype._printValueFormat = function (propInfo, type, format, ds, dim, index, richtext) {
            if (richtext === void 0) { richtext = false; }
            var res = '';
            if ((ds == null) || dim < 0 || index < 0 || index > ds.getSize() || !ds.hasData()) {
                return res;
            }
            // this is to say that we already formatted the number here. it will be formatted after we return.
            // this prevents double formatting inside resolvePropertyHandle() in FDSProperty
            if (propInfo != null) {
                propInfo.formattingApplied = true;
            }
            var startDim;
            var totalDim;
            if (dim == null) {
                startDim = 0;
                totalDim = ds.getDimension();
            }
            else {
                // clamp dim to the upper bound.
                if (dim >= ds.getDimension()) {
                    dim = 0;
                }
                startDim = dim;
                totalDim = dim + 1;
            }
            for (var i = startDim; i < totalDim; i++) {
                var value = ds.getAtDirect(index, i);
                switch (type) {
                    case 'DATE':
                        this._valueFormatter.setDateFormat(format);
                        res += this._valueFormatter.formatAsDate(value);
                        break;
                    case 'TIME':
                        this._valueFormatter.setTimeFormat(format);
                        res += this._valueFormatter.formatAsTime(value);
                        break;
                    case 'DATETIME':
                        this._valueFormatter.setDateTimeFormat(format);
                        res += this._valueFormatter.formatAsDateTime(value);
                        break;
                    case 'STRING':
                        var valueStr = ds.getStringAt(index, i);
                        // this seems almost wedged in here at this ponit, probably needs to be moved out
                        if (richtext) {
                            var compiledFormatString = this.properties.compilePropertyString(valueStr);
                            return compiledFormatString.fromValueRT({ seriesIndex: index });
                        }
                        else {
                            res += valueStr;
                        }
                        break;
                    default:
                        this._valueFormatter.setNumberFormat(format);
                        res += this._valueFormatter.formatAsNumber(value);
                }
                if (i + 1 < totalDim) {
                    res += '\n';
                }
            }
            return res;
        };
        // Returns an array of three elements:
        //
        //  * An array of the currently viewable points on `dimension`
        //  * The starting index of the array
        //  * The ending index of the array
        FDSSeries.prototype._filterZoomedPoints = function (dimension, dataDim) {
            var endIndex;
            var zoomedPoints = [];
            var p1 = this.getData(dimension);
            var p2 = this.getData(dimension === 1 /* X */ ? 2 /* Y */ : 1 /* X */);
            var pX = dimension === 1 /* X */ ? p1 : p2;
            var scale = this.getScale(1 /* X */);
            if (!p1 || !p2 || !scale) {
                return null;
            }
            if (dataDim >= p1.getDimension()) {
                dataDim = 0;
            }
            var acceptMin = scale.threshMin;
            var acceptMax = scale.threshMax;
            var startIndex = endIndex = -1;
            var size = Math.min(p1.getSize(), p2.getSize());
            for (var i = 0; i < size; i++) {
                var val = pX.getAt(i);
                if (fuzzyGTE(val, acceptMin) && fuzzyLT(val, acceptMax)) {
                    if (startIndex === -1) {
                        startIndex = i;
                    }
                    endIndex = i;
                    if (!IsNA(p1.getAt(i, dataDim))) {
                        zoomedPoints.push({ value: p1.getAt(i, dataDim), index: i });
                    }
                }
            }
            return { startIndex: startIndex, endIndex: endIndex, points: zoomedPoints };
        };
        // Determine what the actual draw style should be by looking at both the plot
        // and the series' DrawStyle attribute and determining which is set at the higher
        // level
        FDSSeries.prototype.getEffectiveDrawStyle = function () {
            var plotParent = this.getPlotParent();
            if (!this.isAnnotation && plotParent &&
                (plotParent.attributeSet.getLevel('DrawStyle') > this.attributeSet.getLevel('DrawStyle'))) {
                return plotParent.attributeSet.get('DrawStyle');
            }
            else {
                return this.attributeSet.get('DrawStyle');
            }
        };
        FDSSeries.prototype.getDrawStylePrototype = function () {
            var hint = this.getEffectiveDrawStyle();
            var dsenum = getDrawStyleFromEnum(hint, this.isStacked);
            var DS = new dsenum(this);
            while (!DS.verify()) {
                hint = DS.hint();
                dsenum = getDrawStyleFromEnum(hint, this.isStacked);
                DS = new dsenum(this);
            }
            return { drawStyle: DS, drawStyleEnum: hint };
        };
        FDSSeries.prototype.getFirstValidPoint = function (dim, propInfo) {
            if (propInfo === void 0) { propInfo = null; }
            return this._getMinValidPoint(dim, propInfo, 0 /* IGNORE */);
        };
        FDSSeries.prototype.getLastValidPoint = function (dim, propInfo) {
            if (propInfo === void 0) { propInfo = null; }
            return this._getMaxValidPoint(dim, propInfo, 0 /* IGNORE */);
        };
        FDSSeries.prototype._getMinValidPoint = function (dim, propInfo, sortMode) {
            if (sortMode === void 0) { sortMode = 1 /* FORCE */; }
            if (dim !== 1 /* X */ && dim !== 2 /* Y */) {
                return { value: NAN, index: -1 };
            }
            var dimension = 0;
            if (propInfo && propInfo.seriesDim >= 0) {
                dimension = propInfo.seriesDim;
            }
            var data = this.getData(dim);
            var dataCmp = this.getData((dim === 1 /* X */ ? 2 /* Y */ : 1 /* X */));
            if ((data == null) || (dataCmp == null) || data === dataCmp) {
                return { value: NAN, index: -1 };
            }
            if (dimension >= data.getDimension()) {
                dimension = 0;
            }
            // clever way to deal with a descending sorted dataset
            if (sortMode !== 0 /* IGNORE */ && data.sorted && !data.ascending) {
                return this._getMaxValidPoint(dim, propInfo, 0 /* IGNORE */);
            }
            var isSorted = sortMode === 0 /* IGNORE */ ? true : data.sorted;
            if (isSorted) {
                var size = Math.min(data.getSize(), dataCmp.getSize());
                for (var index = 0; index < size; index++) {
                    var pt = data.getAt(index, dimension);
                    if (!IsSomeInternalNAN(pt) && !IsSomeInternalNAN(dataCmp.getAt(index))) {
                        return { value: pt, index: index };
                    }
                }
            }
            else {
                return this._dataCache.getIndexAndValueOfMin(dim);
            }
            return { value: NAN, index: -1 };
        };
        FDSSeries.prototype._getMaxValidPoint = function (dim, propInfo, sortMode) {
            if (sortMode === void 0) { sortMode = 1 /* FORCE */; }
            if (dim !== 1 /* X */ && dim !== 2 /* Y */) {
                return { value: NAN, index: -1 };
            }
            var dimension = 0;
            if (propInfo && propInfo.seriesDim >= 0) {
                dimension = propInfo.seriesDim;
            }
            var data = this.getData(dim);
            var dataCmp = this.getData((dim === 1 /* X */ ? 2 /* Y */ : 1 /* X */));
            if ((data == null) || (dataCmp == null) || data === dataCmp) {
                return { value: NAN, index: -1 };
            }
            if (dimension >= data.getDimension()) {
                dimension = 0;
            }
            if (sortMode !== 0 /* IGNORE */ && data.sorted && !data.ascending) {
                return this._getMinValidPoint(dim, propInfo, 0 /* IGNORE */);
            }
            var isSorted = sortMode === 0 /* IGNORE */ ? true : data.sorted;
            if (isSorted) {
                var size = Math.min(data.getSize(), dataCmp.getSize());
                for (var index = size - 1; index >= 0; index--) {
                    var pt = data.getAt(index, dimension);
                    if (!IsSomeInternalNAN(pt) && !IsSomeInternalNAN(dataCmp.getAt(index))) {
                        return { value: pt, index: index };
                    }
                }
            }
            else {
                return this._dataCache.getIndexAndValueOfMax(dim);
            }
            return { value: NAN, index: -1 };
        };
        FDSSeries.prototype._getMaxPtAllDim = function (dim, propInfo) {
            var index, min$$1;
            var ds = this.getData(dim);
            if (ds == null) {
                return { value: NAN, index: -1, dim: -1 };
            }
            _a = ds.Max(), min$$1 = _a[0], index = _a[1], dim = _a[2];
            return { value: min$$1, index: index, dim: dim };
            var _a;
        };
        FDSSeries.prototype._getMinPtAllDim = function (dim, propInfo) {
            var index, min$$1;
            var ds = this.getData(dim);
            if (ds == null) {
                return { value: NAN, dim: -1, index: -1 };
            }
            _a = ds.Min(), min$$1 = _a[0], index = _a[1], dim = _a[2];
            return { value: min$$1, index: index, dim: dim };
            var _a;
        };
        FDSSeries.prototype.getSeriesColors = function () {
            return [this.seriesFGPen.color, this.seriesBGBrush.color, this.seriesOutlinePen.color];
        };
        FDSSeries.prototype.updateDynamicStyleObject = function () {
            if (this.root.containsDrawStyleSpecificStyleObjects() && !this.isStyleObject &&
                this.attributeSet.isDefault('Style')) {
                var drawStyleEnum = this.getDrawStylePrototype().drawStyleEnum;
                var newOverride = this.root.getStyleObjectNameForDrawStyle(drawStyleEnum);
                if (newOverride !== this._styleNameOverride) {
                    this._styleNameOverride = newOverride;
                    this.attributeSet.setDirty(true);
                }
            }
            else {
                this._styleNameOverride = null;
            }
        };
        FDSSeries.prototype.getStyleObjectName = function () {
            if (this.isStyleObject) {
                return 'FDSChart';
            }
            else {
                if (this._styleNameOverride != null && this.root.getTypedObject(this._styleNameOverride, isSeries)) {
                    return this._styleNameOverride;
                }
                else {
                    return 'FC_SERIES';
                }
            }
        };
        FDSSeries.prototype.getObjectTypeName = function () {
            return 'FDSSeries';
        };
        FDSSeries.prototype.clearPointLookup = function () {
            this._pointLookup = {
                sorted: true,
                min: Number.MAX_VALUE,
                max: Number.MIN_VALUE,
                points: []
            };
        };
        FDSSeries.prototype.addLookupPoint = function (x, y, index) {
            if (x > this._pointLookup.max) {
                this._pointLookup.max = x;
            }
            if (x < this._pointLookup.min) {
                this._pointLookup.min = x;
            }
            if (this._pointLookup.sorted && x < this._pointLookup.max) {
                this._pointLookup.sorted = false;
            }
            return this._pointLookup.points.push({
                x: x,
                y: y,
                index: index
            });
        };
        FDSSeries.prototype.getPointLookupRange = function () {
            if (this._pointLookup.points.length > 0) {
                return {
                    min: this._pointLookup.min,
                    max: this._pointLookup.max,
                };
            }
            else {
                return null;
            }
        };
        FDSSeries.prototype._sortPointLookup = function () {
            this._pointLookup.points = this._pointLookup.points.sort(function (a, b) {
                if (a.x < b.x) {
                    return -1;
                }
                else if (a.x > b.x) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
            this._pointLookup.sorted = true;
        };
        FDSSeries.prototype.searchPointLookup = function (x, y, isCrosshairsLookup) {
            if (isCrosshairsLookup === void 0) { isCrosshairsLookup = false; }
            if ((this._pointLookup == null) || !this._pointLookup.points.length) {
                return [-1, -1, -1];
            }
            if (!this._pointLookup.sorted) {
                this._sortPointLookup();
            }
            var points = this._pointLookup.points;
            var min$$1 = 0;
            var max$$1 = points.length - 1;
            var pt = 0;
            while (min$$1 <= max$$1) {
                var mid = ~~((min$$1 + max$$1) / 2);
                pt = mid;
                if (x > points[mid].x) {
                    if (mid + 1 < points.length && points[mid + 1].x > x) {
                        var right = points[mid + 1].x - x;
                        var left = x - points[mid].x;
                        if (right < left) {
                            pt = mid + 1;
                        }
                        break;
                    }
                    min$$1 = mid + 1;
                }
                else if (x < points[mid].x) {
                    if (mid - 1 >= 0 && points[mid - 1].x < x) {
                        var left = x - points[mid - 1].x;
                        var right = points[mid].x - x;
                        if (left < right) {
                            pt = mid - 1;
                        }
                        break;
                    }
                    max$$1 = mid - 1;
                }
                else {
                    break;
                }
            }
            var ptFound = points[pt];
            if (isCrosshairsLookup) {
                return [ptFound.x, ptFound.y[0], ptFound.index];
            }
            var iMin = 0;
            var yMin = Math.abs(ptFound.y[0] - y);
            for (var i = 1; i < ptFound.y.length; i++) {
                var yDist = Math.abs(y - ptFound.y[i]);
                if (yDist < yMin) {
                    iMin = i;
                    yMin = yDist;
                }
            }
            return [ptFound.x, ptFound.y[iMin], ptFound.index];
        };
        FDSSeries.prototype.getTooltipLabel = function (index, rich) {
            if (rich === void 0) { rich = true; }
            if (index < 0 || !this._tooltipText) {
                return rich ? RichTextString.Empty : '';
            }
            var valuePropertyObj = this._tooltipText.main;
            var context = { seriesIndex: index };
            if (rich) {
                return valuePropertyObj.fromValueRT(context);
            }
            else {
                return valuePropertyObj.fromValue(context);
            }
        };
        FDSSeries.prototype.displayToolTip = function (x, y, index) {
            if (this.root.suppressAllInteraction) {
                return;
            }
            var drawStyle = this.getDrawStylePrototype().drawStyle;
            var arrowLocation = drawStyle.getClickTooltipArrowPoint(x, y, index);
            this.root.clickTooltip.displayTooltipForSeries(this, index, arrowLocation.point, arrowLocation.position);
        };
        // @return [false||object] either false if a hit was not found, or an object containing hit info
        FDSSeries.prototype.hitTest = function (x, y, hitShape) {
            if (hitShape === void 0) { hitShape = 0 /* POINT */; }
            if (this.root && this.root.pickObjectType === 2 /* FC_SERIES */ &&
                this.root.dragMode === 1 /* PICK */ && !this.sysPickable) {
                return null;
            }
            var plot = this.getPlotParent();
            if (plot) {
                var testPoint = new Point(x, y);
                if ((plot.clipSubPlotX && !plot.isPointInSubPlotX(testPoint)) ||
                    (plot.clipSubPlot && !plot.isPointInSubPlot(testPoint))) {
                    return null;
                }
            }
            var cursor = '';
            var hit = -1;
            var tip = '';
            var objectPart = '';
            for (var i = this.hitVector.length - 1; i >= 0; i--) {
                var shape = this.hitVector[i];
                if (shape.onHitTest(x, y, hitShape)) {
                    this._hitShapeName = shape.name;
                    this._offsetMouseCoordinatesBy = shape.distancesFromCentroid(x, y);
                    if (this._hitShapeName === this.hittableShapeIdentifier) {
                        if (this.getInteractivityStatus() & (-1 /* ALL */ ^ 1 /* SELECTION */)) {
                            cursor = Cursor.SIZEALL;
                        }
                    }
                    else if (this._hitShapeName === 14 /* DATAPOINTNW */ || this._hitShapeName === 15 /* DATAPOINTSE */) {
                        cursor = Cursor.SIZENWSE;
                    }
                    else if (this._hitShapeName === 13 /* DATAPOINTNE */ || this._hitShapeName === 16 /* DATAPOINTSW */) {
                        cursor = Cursor.SIZENESW;
                    }
                    else if (this._hitShapeName === 9 /* DATAPOINTN */ || this._hitShapeName === 10 /* DATAPOINTS */) {
                        cursor = Cursor.SIZENS;
                    }
                    else if (this._hitShapeName === 11 /* DATAPOINTE */ || this._hitShapeName === 12 /* DATAPOINTW */) {
                        cursor = Cursor.SIZEWE;
                    }
                    else if (this._hitShapeName === 18 /* VERTICAL */) {
                        if (this.getInteractivityStatus() !== 0 /* DISABLED */ ||
                            this.attributeSet.get('AlwaysDisplayCursorForReferenceLine')) {
                            cursor = Cursor.SIZEWE;
                        }
                    }
                    else if (this._hitShapeName === 17 /* HORIZONTAL */) {
                        if (this.getInteractivityStatus() !== 0 /* DISABLED */ ||
                            this.attributeSet.get('AlwaysDisplayCursorForReferenceLine')) {
                            cursor = Cursor.SIZENS;
                        }
                    }
                    else if (this._hitShapeName === 5 /* SERIESHIT */) {
                        if (this._shouldSeriesShowCursor()) {
                            cursor = Cursor.SIZEALL;
                        }
                        this._currentSelectedDataPoint = shape.index;
                    }
                    else if (this._hitShapeName === 1 /* DATAPOINTNS */) {
                        if (this._shouldSeriesShowCursor()) {
                            cursor = Cursor.SIZENS;
                        }
                        this._currentSelectedDataPoint = shape.index;
                    }
                    else if (this._hitShapeName === 2 /* DATAPOINTWE */) {
                        if (this._shouldSeriesShowCursor()) {
                            cursor = Cursor.SIZEWE;
                        }
                        this._currentSelectedDataPoint = shape.index;
                    }
                    else if (this._hitShapeName === 3 /* DATAPOINT */ || this._hitShapeName === 4 /* DATAPOINTALTX */) {
                        if (this._shouldSeriesShowCursor()) {
                            cursor = Cursor.HAND;
                        }
                        this._currentSelectedDataPoint = shape.index;
                        if (this._hitShapeName === 4 /* DATAPOINTALTX */) {
                            this._currentAlternateDataPoint = shape.altIndex;
                        }
                    }
                    else if (this._hitShapeName === 8 /* SERIESHITLEFTRIGHT */) {
                        if (this._shouldSeriesShowCursor()) {
                            cursor = Cursor.SIZEALL;
                        }
                    }
                    else if (this._hitShapeName === 6 /* DATAPOINTLEFT */ || this._hitShapeName === 7 /* DATAPOINTRIGHT */) {
                        if (this._shouldSeriesShowCursor()) {
                            cursor = Cursor.SIZEWE;
                        }
                    }
                    hit = shape.index;
                    if (this.root != null) {
                        if (this.root.pick.accessMessage() === 'Tooltip') {
                            if (this.crosshairIndex !== -1) {
                                hit = this.crosshairIndex;
                            }
                        }
                        else if (this.root.pick.accessMessage() === 'OnMouseMove') {
                            // If a custom cursor is set and nothing else has already assigned a cursor, set it
                            if ((this._cursor !== Cursor.DEFAULT) && (cursor === '')) {
                                cursor = this._cursor;
                            }
                        }
                    }
                    if (shape.objectPart != null) {
                        objectPart = shape.objectPart;
                    }
                    if (shape.hoverText != null) {
                        tip = shape.hoverText;
                    }
                    return { hit: hit, tip: tip, objectPart: objectPart, cursor: cursor };
                }
            }
            return null;
        };
        FDSSeries.prototype._shouldSeriesShowCursor = function () {
            return this.getInteractivityStatus() !== 0 /* DISABLED */ ||
                this.attributeSet.get('AlwaysDisplayCursorForSeries');
        };
        // Sets SeriesNumber attribute
        //
        // @param n [Number] the number to set as this series' SeriesNumber
        FDSSeries.prototype.setSeriesNumber = function (n) {
            if (this.attributeSet.isInheritedDefault('SeriesNumber')) {
                this.attributeSet.setAt('SeriesNumber', 'app', n);
            }
        };
        // Removes the objects in `children` from being parented to this series
        FDSSeries.prototype.clearChildren = function (children) {
            if (!this.root) {
                return [false, 'Invalid root during clearing'];
            }
            var ret = true;
            var newData = {};
            for (var i = 0; i < 7 /* MEMBERS */; i++) {
                newData[i] = this.dimensionalChildren[i];
            }
            var updateData = false;
            for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                var child = children_2[_i];
                var childObj = this.root.getChild(child);
                if (isDataSet(childObj)) {
                    for (var i = 0; i < 7 /* MEMBERS */; i++) {
                        if (this.dimensionalChildren[i] === childObj) {
                            this.dimensionalChildren[i].removeSeries(this);
                            newData[i] = undefined;
                            updateData = true;
                        }
                    }
                }
                else {
                    this.removeChild(childObj);
                }
            }
            if (updateData) {
                this._setData(newData);
            }
            this.adjust();
            this.notifyParents(1 /* CHANGE */);
            // returning '' as the errString because the only place we can get
            // an error message is the second line if root is invalid
            return [ret, ''];
        };
        // Removes this series from the axes that it is attached to
        FDSSeries.prototype.removeSelfFromAxes = function () {
            for (var id in this._dimensionalAxes) {
                var axis = this._dimensionalAxes[id];
                axis.removeSeries(this);
            }
        };
        // Actions we perform when notified by our children of an update
        //
        // @param child [FDSChartObject] Child object that notified us
        // @param flags [UpdateMessage] Message that the child told us
        FDSSeries.prototype.onNotify = function (child, flags) {
            if (flags === 0 /* REMOVE */) {
                // maybe a series child
                if (this.removeChild(child)) {
                    this.notifyParents(1 /* CHANGE */);
                    this.wrapper.setSeriesListDirty();
                }
                else {
                    if (isDataSet(child)) {
                        this.wrapper.setDataMapDirty();
                        var removeData = false;
                        for (var i = 0; i < 7 /* MEMBERS */; i++) {
                            if (this.dimensionalChildren[i] === child) {
                                removeData = true;
                                this.dimensionalChildren[i].removeSeries(this);
                            }
                        }
                        if (removeData) {
                            this.clear();
                        }
                        else {
                            this.notifyParents(1 /* CHANGE */);
                        }
                    }
                }
            }
            else if (flags === 3 /* APPEND */) {
                this.setNeedUpdate(true);
                this.notifyParents(flags);
            }
            else if (flags === 2 /* DATA */) {
                this.updateCount += 1;
                // do some complicated stuff
                if (this.renderCache != null) {
                    this.renderCache.setInvalidated();
                }
                this._adjustChildrenToSeries();
                this.setNeedUpdate(true);
                this.notifyParents(flags);
                this._regressionData = [];
            }
            else {
                this.setNeedUpdate(true);
                this.notifyParents(flags);
            }
            this.updateCount += 1;
            if (this.renderCache) {
                this.renderCache.setInvalidated();
            }
            this._dataCache.setDirty();
        };
        FDSSeries.prototype.serialize = function (level) {
            return this._serializeObject('Series', level, this._styleNameOverride);
        };
        FDSSeries.prototype._serializeChildren = function () {
            var str = '<FDSChildren>';
            // add dataset children
            var maxDim = 0;
            for (var _i = 0, _a = Object.keys(this.dimensionalChildren).map(Number); _i < _a.length; _i++) {
                var num = _a[_i];
                maxDim = Math.max(maxDim, num);
            }
            for (var dimNum = 0; dimNum <= maxDim; dimNum++) {
                var child = this.dimensionalChildren[dimNum];
                var childId = void 0;
                // skip empty datasets
                if (!child || (child.hasData && !child.hasData()) || !this.isDefined(dimNum)) {
                    childId = '';
                }
                else {
                    childId = child.id === undefined ? '' : child.id;
                }
                str += "<ChildId>" + cleanString(childId) + "</ChildId>";
            }
            // add series (and any other) children
            for (var child in this.children) {
                str += "<ChildId>" + cleanString(child) + "</ChildId>";
            }
            str += '</FDSChildren>';
            return str;
        };
        FDSSeries.prototype.isDefined = function (dim) {
            return this.defined[dim] === true;
        };
        FDSSeries.prototype.computeLabelSampling = function (size) {
            return this._computeSampleSizeHelper(size, this._maxLabels, this._maxLabels);
        };
        FDSSeries.prototype._computeSampleSizeHelper = function (count, window, iMax) {
            var step = 1;
            if (this.sampleMode !== 0 /* NONE */) {
                step = Math.max(1, ~~(count / Math.max(iMax, window)));
                if (this.sampleMode === 2 /* POWER2 */ || this.sampleMode === 3 /* MINMAX */) {
                    var power = 1;
                    while (((power * 2) <= step) && (power <= 4096)) {
                        power *= 2;
                    }
                    step = power;
                }
            }
            return step;
        };
        FDSSeries.prototype._computeSampleSize = function (window, max$$1, start, end) {
            // Ensure sure only Minmax series that are zoomed in have isMinmaxAndZoomed set to true
            var effectiveNumber = end - start;
            var step = this._computeSampleSizeHelper(effectiveNumber, window, max$$1);
            var size = ~~(effectiveNumber / step);
            if (this.sampleMode === 3 /* MINMAX */) {
                if ((step !== this.stepSize) || ((size * 2) !== this._indices.length)) {
                    this.stepSize = step;
                    if (this.stepSize > 1) {
                        var yData = this.getData(2 /* Y */);
                        var min$$1 = max$$1 = 0;
                        var minIndex = 0;
                        var maxIndex = 0;
                        this._indices = new Array(size * 2);
                        for (var i = 0; i < size; i++) {
                            var index = ~~((i * this.stepSize) + start);
                            var init = true;
                            minIndex = maxIndex = index;
                            for (var j = 0; j < this.stepSize; j++) {
                                var value = yData.getAt((index + j));
                                if (NOTNAN(value)) {
                                    if (init) {
                                        min$$1 = max$$1 = value;
                                        minIndex = maxIndex = (index + j);
                                        init = false;
                                    }
                                    else {
                                        if (value < min$$1) {
                                            minIndex = index + j;
                                            min$$1 = value;
                                        }
                                        if (value > max$$1) {
                                            maxIndex = index + j;
                                            max$$1 = value;
                                        }
                                    }
                                    this.lastValidIndex = Math.max(minIndex, maxIndex);
                                }
                            }
                            if (minIndex > maxIndex) {
                                _a = [maxIndex, minIndex], minIndex = _a[0], maxIndex = _a[1];
                            }
                            this._indices[i * 2] = minIndex;
                            this._indices[(i * 2) + 1] = maxIndex;
                        }
                    }
                    else {
                        this.lastValidIndex = Math.max(size - 1, 0);
                    }
                }
                this.isMinmaxAndZoomed = ((start !== 0) || (end !== this.size));
                if (this.stepSize > 1) {
                    start = 0;
                    end = size * 2;
                    step = 1;
                }
            }
            else {
                this.stepSize = 1;
            }
            return [step, start, end];
            var _a;
        };
        FDSSeries.prototype._computeYTrimLinear = function (start, end) {
            var pData = this.getData(2 /* Y */);
            var pScale = (this.getAxis(2 /* Y */)).getScale();
            var xScaleMin = pScale.threshMin;
            var xScaleMax = pScale.threshMax;
            if (!pData || !pScale) {
                return [start, end];
            }
            var count = pData.getSize();
            start = 0;
            end = count;
            var v = 0.0;
            // Loop through the  data from the left, to find the first data point that is within the scale,
            // and store the previous index (we keep one number outside the "visible" range to match the
            // behavior of the binary scaling algorithm.
            for (var i = 0; i <= count; i++) {
                v = pData.getAt(i);
                if (NOTNAN(v)) {
                    start = Math.max(i, 0);
                    break;
                }
            }
            // Loop through the data from the right, to find the last data point that is withing the scale,
            // and keep an index outside that
            for (var i = (count - 1); i >= start; i--) {
                v = pData.getAt(i);
                if (NOTNAN(v)) {
                    end = Math.min(i, count);
                    break;
                }
            }
            return [start, end];
        };
        FDSSeries.prototype._computeXTrimLinear = function (start, end) {
            var pData = this.getData(1 /* X */);
            var axis = this.getAxis(1 /* X */);
            if (!axis) {
                return [start, end];
            }
            var pScale = axis.getScale();
            if (!pData || !pScale) {
                return [start, end];
            }
            var xScaleMin = pScale.threshMin;
            var xScaleMax = pScale.threshMax;
            if (!pData.sorted) {
                return [start, end];
            }
            if (xScaleMin > xScaleMax) {
                return [start, end];
            }
            var count = Math.min(this.size, pData.getSize());
            start = 0;
            end = count;
            var v = 0.0;
            var ascending = pData.ascending;
            // Loop through the  data from the left, to find the first data point that is within the scale,
            // and store the previous index (we keep one number outside the "visible" range to match the
            // behavior of the binary scaling algorithm.
            for (var i = 0; i <= count; i++) {
                v = pData.getAt(i);
                if (NOTNAN(v)) {
                    if ((ascending && (v > xScaleMin)) || ((!ascending) && (v < xScaleMax))) {
                        // Store the index of the first element past the left side of the
                        // range.
                        start = Math.max(i - 1, 0);
                        break;
                    }
                }
            }
            // Loop through the data from the right, to find the last data point that is withing the scale,
            // and keep an index outside that
            for (var i = (count - 1); i > start; i--) {
                v = pData.getAt(i);
                if (NOTNAN(v)) {
                    if ((ascending && (v < xScaleMax)) || ((!ascending) && (v > xScaleMin))) {
                        // Because rendering loops loop with regard to < end, and we
                        // need one point out-of-range to complete the line draw, we
                        // actually need to store the index of the first location *past*
                        // the first element outside the range on the right side of the array.
                        end = Math.min(i + 2, count);
                        break;
                    }
                }
            }
            return [start, end];
        };
        FDSSeries.prototype._computeXTrimBinary = function (start, end) {
            var pData = this.getData(1 /* X */);
            var axis = this.getAxis(1 /* X */);
            if (!axis) {
                return [start, end];
            }
            var pScale = axis.getScale();
            if (!pData || !pScale) {
                return [start, end];
            }
            var xScaleMin = pScale.threshMin;
            var xScaleMax = pScale.threshMax;
            if (!pData.sorted) {
                return [start, end];
            }
            if (xScaleMin > xScaleMax) {
                return [start, end];
            }
            var size = Math.min(this.size, pData.getSize());
            var eStart = 0;
            var eEnd = size;
            var count = 0;
            // Note the checks for NA which will (safely)
            // push the bounds out past the X check. A slower
            // more accurate scheme could be produced that
            // felt around the NA, but the code would be very
            // error prone
            // Update: A slower, more accurate solution has been
            // provided, in order to fix some nasty corner cases.
            // It is now used by default for any series that has
            // any NA values in it at all.
            var eTest;
            var v;
            if (pData.ascending) {
                if (pData.getAt(eStart) !== xScaleMin) {
                    while ((eStart < eEnd) && (count < 500)) {
                        eTest = ~~((eStart + eEnd) / 2);
                        v = pData.getAt(eTest);
                        if (v <= xScaleMin && NOTNAN(v)) {
                            eStart = eTest + 1;
                        }
                        else {
                            eEnd = eTest;
                        }
                        count += 1;
                    }
                }
                start = Math.max(eStart - 1, 0);
                eStart = start;
                eEnd = size;
                count = 0;
                if (pData.getAt(Math.max(eEnd - 1, 0)) !== xScaleMax) {
                    while ((eStart < eEnd) && (count < 500)) {
                        eTest = ~~((eStart + eEnd) / 2);
                        v = pData.getAt(eTest);
                        if ((v <= xScaleMax) && NOTNAN(v)) {
                            eStart = eTest + 1;
                        }
                        else {
                            eEnd = eTest;
                        }
                        count += 1;
                    }
                }
                end = Math.min(eEnd + 1, size);
            }
            else {
                if (pData.getAt(eStart) !== xScaleMax) {
                    while ((eStart < eEnd) && count < 500) {
                        eTest = ~~((eStart + eEnd) / 2);
                        v = pData.getAt(eTest);
                        if ((v >= xScaleMax) && NOTNAN(v)) {
                            eStart = eTest + 1;
                        }
                        else {
                            eEnd = eTest;
                        }
                        count += 1;
                    }
                }
                start = Math.max(eStart - 1, 0);
                eStart = start;
                eEnd = size;
                count = 0;
                if (pData.getAt(Math.max(eEnd - 1, 0)) !== xScaleMin) {
                    while ((eStart < eEnd) && count < 500) {
                        eTest = Math.round((eStart + eEnd) / 2);
                        v = pData.getAt(eTest);
                        if ((v >= xScaleMin) && NOTNAN(v)) {
                            eStart = eTest + 1;
                        }
                        else {
                            eEnd = eTest;
                        }
                        count += 1;
                    }
                }
                end = Math.min(eEnd + 1, size);
            }
            return [start, end];
        };
        FDSSeries.prototype.computeXTrim = function (widthHint, start, end, step) {
            var xData = this.getData(1 /* X */);
            var size = Math.min(this.size, xData.getSize());
            if (size > 0) {
                // This section of code checks for data visible withing the bounds
                // of the current X axis. Makes zooming effectively resample.
                // Note that zooming will not resample unsorted data.
                // We could add checks for X and Y to further focus data.
                if (xData.sorted) {
                    if (xData.hasNA) {
                        _a = this._computeXTrimLinear(start, end), start = _a[0], end = _a[1];
                    }
                    else {
                        _b = this._computeXTrimBinary(start, end), start = _b[0], end = _b[1];
                    }
                }
            }
            _c = this._computeSampleSize(widthHint, this._maxPoints, start, end), step = _c[0], start = _c[1], end = _c[2];
            return [start, end, step];
            var _a, _b, _c;
        };
        FDSSeries.prototype.computeYTrim = function (start, end) {
            if (this.size > 0) {
                var yData = this.getData(2 /* Y */);
                if (yData.hasNA) {
                    this._computeYTrimLinear(start, end);
                }
            }
            return [start, end];
        };
        FDSSeries.prototype.getSampleSize = function () {
            if (this.stepSize > 1) {
                return this._indices.length;
            }
            else {
                return this.size;
            }
        };
        FDSSeries.prototype.getSampleIndex = function (index) {
            if (this.stepSize > 1) {
                return this._indices[index];
            }
            else {
                return index;
            }
        };
        // This takes in the amount of available space and determines the number of selection markers based on it.
        FDSSeries.prototype._getSelectionMarkerCountFromSize = function (renderSize) {
            if (this.selectableItemSamplingMinPixelsPerMarker > 0) {
                return Math.abs(Math.round(renderSize / this.selectableItemSamplingMinPixelsPerMarker));
            }
            else {
                return 0;
            }
        };
        FDSSeries.prototype.getLogRegressionFlags = function () {
            if (this.regressionType === 1 /* LOGARITHMIC */) {
                return [true, false];
            }
            else if (this.regressionType === 2 /* EXPONENTIAL */) {
                return [false, true];
            }
            else {
                return [false, false];
            }
        };
        // Calculates the available space and determines the number of selection markers based on it.
        FDSSeries.prototype.getSelectionMarkerCount = function (dimension) {
            if (dimension !== 1 /* X */ && dimension !== 2 /* Y */) {
                throw new Error('Dimenision must be X or Y');
            }
            // If selection is disabled on this series, just forget the whole thing.
            if (!this.isSelected() || !this.visible) {
                return 0;
            }
            // Width in pixels of the length of the series
            var seriesSize = 0;
            var pPlot = this.getPlotParent();
            if (!pPlot) {
                return this._getSelectionMarkerCountFromSize(seriesSize);
            }
            // Start with the base plot width
            if (dimension === 1 /* X */) {
                seriesSize = pPlot.plotRect.getWidth();
            }
            else {
                seriesSize = pPlot.plotRect.getHeight();
            }
            // Then fetch the datapoints on the data associated with the series
            var pDataPt = this.getData(dimension);
            // If the data is bogus, we must abort.
            if (pDataPt === undefined) {
                return 0;
            }
            // Find the starting and ending datapoints that were calculated earlier in BaseDrawStyle.
            var pt1 = pDataPt.getAt(Math.min(this.getSampleIndex(this.xEnd - 1), this.yEnd - 1));
            var pt2 = pDataPt.getAt(Math.max(this.getSampleIndex(this.xStart), this.yStart));
            // And as long as they aren't NAN, we can now calculate the actual width to determine the # of selection markers.
            if (!IsSomeNAN(pt1) && !IsSomeNAN(pt2)) {
                var scale = (this.getAxis(dimension)).getScale();
                if (scale !== undefined) {
                    seriesSize = Math.abs(pPlot.subPlotFromNDC(scale.lookup(pt1), dimension) -
                        pPlot.subPlotFromNDC(scale.lookup(pt2), dimension));
                }
            }
            return this._getSelectionMarkerCountFromSize(seriesSize);
        };
        // data is an array of Point objects.
        FDSSeries.prototype.getRegressionData = function (startIndex, endIndex, data, order) {
            if (startIndex === void 0) { startIndex = -1; }
            if (endIndex === void 0) { endIndex = -1; }
            if (order === void 0) { order = this.regressionOrder; }
            if (this._regressionData && this._regressionData.length > 0) {
                return this._regressionData;
            }
            var pScaleX = this.getAxis(1 /* X */).getScale();
            var pScaleY = this.getAxis(2 /* Y */).getScale();
            var value1 = 0;
            var xvalue1 = 0;
            var cvalue1 = 0;
            var xData = this.getData(1 /* X */);
            var yData = this.getData(2 /* Y */);
            var cData = this.getData(4 /* COLOR */);
            if ((pScaleX === undefined)
                || (pScaleY === undefined)
                || (xData === undefined)
                || (yData === undefined)
                || (cData === undefined)) {
                return this._regressionData;
            }
            var _a = this.getLogRegressionFlags(), logRegressionX = _a[0], logRegressionY = _a[1];
            var size = data != null ? data.length : this.size;
            // Storage array of size number
            // will be passed to @polynomial later
            var arr = [];
            var snumber = 0;
            // getting min and max values (and indices) for x and y data
            var _b = yData.Min(), minValue = _b[0], minValueIndex = _b[1];
            var _c = xData.Min(), minXValue = _c[0], minXValueIndex = _c[1];
            var _d = yData.Max(), maxValue = _d[0], maxValueIndex = _d[1];
            var _e = xData.Max(), maxXValue = _e[0], maxXValueIndex = _e[1];
            var xCompressedMin = pScaleX.compressValue(minXValue, logRegressionX);
            var xCompressedMax = pScaleX.compressValue(maxXValue, logRegressionX);
            var yCompressedMin = pScaleY.compressValue(minValue, logRegressionY);
            var yCompressedMax = pScaleY.compressValue(maxValue, logRegressionY);
            var xScale = xCompressedMax - xCompressedMin;
            var yScale = yCompressedMax - yCompressedMin;
            if (xScale === 0) {
                xScale = 1;
            }
            if (yScale === 0) {
                yScale = 1;
            }
            if (data == null) {
                startIndex = startIndex < 0 ? 0 : startIndex;
                endIndex = endIndex < 0 ? size : endIndex;
                for (var i = startIndex; i < endIndex; i++) {
                    value1 = yData.getValueOrIndexAt(pScaleY, i);
                    xvalue1 = xData.getValueOrIndexAt(pScaleX, i);
                    var cvalue = cData.getAt(i);
                    if (!IsSomeNAN(value1) && !IsSomeNAN(xvalue1) && !IsSomeNAN(cvalue)) {
                        var xValueComp = pScaleX.compressValue(xvalue1, logRegressionX);
                        var yValueComp = pScaleY.compressValue(value1, logRegressionY);
                        // populate arr
                        arr[snumber] = new Point((xValueComp - xCompressedMin) / xScale, (yValueComp - yCompressedMin) / yScale);
                        snumber += 1;
                    }
                }
            }
            else {
                for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                    var dataItem = data_1[_i];
                    if (!IsSomeNAN(dataItem.x) && !IsSomeNAN(dataItem.y)) {
                        var xValueComp = pScaleX.compressValue(dataItem.x, logRegressionX);
                        var yValueComp = pScaleY.compressValue(dataItem.y, logRegressionY);
                        // populate arr
                        arr[snumber] = new Point((xValueComp - xCompressedMin) / xScale, (yValueComp - yCompressedMin) / yScale);
                        snumber += 1;
                    }
                }
            }
            if (order < 0) {
                order = 1;
            }
            // reset regressionData
            this._regressionData = [];
            if ((snumber > 1) && this._polynomial(arr, snumber, order, this._regressionData)) {
                var regressionIsMedian = (order === 0 && this._regressionZeroOrderIsMedian);
                var regressionIsHarmonicMean = (order === 0 && this._regressionZeroOrderIsHarmonicMean);
                var zeroOrderOverride = void 0;
                if (regressionIsMedian) {
                    zeroOrderOverride = yData.median(0);
                }
                else if (regressionIsHarmonicMean) {
                    zeroOrderOverride = yData.harmonicMean(0);
                }
                if (zeroOrderOverride != null) {
                    this._regressionData[0] = (pScaleY.compressValue(zeroOrderOverride, logRegressionY) - yCompressedMin) /
                        yScale;
                }
                this._setRegressionFormula(this._regressionData, order, xScale, yScale, xCompressedMin, yCompressedMin);
                var stdDev = 0;
                var count = 0;
                for (var i = 0; i < this.size; i++) {
                    value1 = yData.getValueOrIndexAt(pScaleY, i);
                    xvalue1 = xData.getValueOrIndexAt(pScaleX, i);
                    var cvalue = cData.getAt(i);
                    if (!IsSomeNAN(value1) && !IsSomeNAN(xvalue1) && !IsSomeNAN(cvalue)) {
                        var xVal = (pScaleX.compressValue(xvalue1, logRegressionX) - xCompressedMin) / xScale;
                        var y = polyinterp(this._regressionData, order + 1, xVal);
                        y = pScaleY.decompressValue((y * yScale) + yCompressedMin, logRegressionY);
                        var diff = y - value1;
                        stdDev += diff * diff;
                        count++;
                    }
                }
                this.stdDevFromRegression = Math.sqrt(stdDev / (count - 1));
            }
            else {
                this._regressionData = [];
                this.stdDevFromRegression = 0;
            }
            return this._regressionData;
        };
        FDSSeries.prototype._setRegressionFormula = function (arr, order, xScale, yScale, xOffset, yOffset) {
            if (this._regressionFormulaInterceptIsMin) {
                xOffset = 0;
            }
            var coeffOrig = [];
            var coeff = [];
            for (var i = 0; i <= order; i++) {
                coeff[i] = coeffOrig[i] = (arr[i] * yScale) / Math.pow(xScale, i);
            }
            if (this._regressionFormulaExpandPolynomial) {
                for (var i = order; i >= 0; i--) {
                    for (var n = i - 1; n >= 0; n--) {
                        coeff[n] += this._pascalTriangle(n, i) * Math.pow(-xOffset, (i - n)) * coeffOrig[i];
                    }
                }
            }
            coeff[0] += yOffset;
            var regressionFormula = this._regressionFormulaY;
            this._valueFormatter = new FDSFormat();
            this._valueFormatter.setNumberFormat(this._regressionFormulaFormat);
            if (this.regressionType === 2 /* EXPONENTIAL */) {
                /*
                Exponential regression is defined as:
                  ln(y) = m*x + b
       
                Solve for y:
                  exp(ln(y)) = exp(m*x + b)
                  y = exp(m*x + b)
                  y = exp(b)*exp(m*x)
       
                substitute where
                  m = coeff[1]
                  b = coeff[0]
       
                  y = exp(coeff[0])*e^(coeff[1]*x)
                */
                regressionFormula += this._valueFormatter.formatAsNumber(Math.exp(coeff[0]));
                regressionFormula += 'e';
                regressionFormula += this._superScript(this._valueFormatter.formatAsNumber(coeff[1]) +
                    this._regressionFormulaX);
            }
            else {
                var xLabel = (this.regressionType === 1 /* LOGARITHMIC */) ?
                    // y = m*ln(x) + b
                    "ln(" + this._regressionFormulaX + ")"
                    :
                        // y = m*x + b
                        this._regressionFormulaX;
                var xOffsetStr = this._valueFormatter.formatAsNumber(Math.abs(xOffset));
                var bFirst = true;
                for (var i = order; i >= 0; i--) {
                    if (fuzzyEQ(coeff[i], 0.0) && this._regressionFormulaCollapseInts) {
                        continue;
                    }
                    if (!bFirst) {
                        if (this._regressionFormulaSpaces) {
                            regressionFormula += coeff[i] >= 0 ? ' + ' : ' - ';
                        }
                        else {
                            regressionFormula += coeff[i] >= 0 ? '+' : '-';
                        }
                    }
                    if (this._regressionFormulaCollapseInts && fuzzyEQ(coeff[i], Math.round(coeff[i]))) {
                        this._valueFormatter.setNumberFormat('#I');
                    }
                    else {
                        this._valueFormatter.setNumberFormat(this._regressionFormulaFormat);
                    }
                    var formattedCoeff = '';
                    if (bFirst) {
                        formattedCoeff = this._valueFormatter.formatAsNumber(coeff[i]);
                    }
                    else {
                        formattedCoeff = this._valueFormatter.formatAsNumber(Math.abs(coeff[i]));
                    }
                    if (!fuzzyEQ(coeff[i], 1)) {
                        if (fuzzyEQ(coeff[i], -1)) {
                            if (bFirst) {
                                regressionFormula += '-';
                            }
                        }
                        else if (this._regressionFormulaParens && i > 0) {
                            regressionFormula += "(" + formattedCoeff + ")";
                        }
                        else {
                            regressionFormula += formattedCoeff;
                        }
                    }
                    if (i > 0) {
                        if (this._regressionFormulaExpandPolynomial) {
                            regressionFormula += xLabel;
                        }
                        else {
                            if (this._regressionFormulaSpaces) {
                                regressionFormula += "(" + xLabel + " " + (xOffset >= 0 ? '-' : '+') + " " + xOffsetStr;
                            }
                            else {
                                regressionFormula += "(" + xLabel + (xOffset >= 0 ? '-' : '+') + xOffsetStr;
                            }
                        }
                        if (i > 1) {
                            regressionFormula += this._superScript(i);
                        }
                    }
                    bFirst = false;
                }
            }
            this._regressionFormula = this.properties.compilePropertyString(regressionFormula);
        };
        FDSSeries.prototype._pascalTriangle = function (c, r) {
            if ((c <= 0) || (r <= 0) || (c >= r)) {
                return 1;
            }
            return (this._pascalTriangle(c - 1, r) * ((r + 1) - c)) / c;
        };
        FDSSeries.prototype._superScript = function (i) {
            return "<FDSSpan superscript=\"true\">" + i + "</FDSSpan>";
        };
        // from getRegressionData:
        //  parr is arr
        //  pSize is snumber
        //  order is order
        //  regressDataArr is @regressionData (should be empty, was reset right
        //  before the call to polynomial
        FDSSeries.prototype._polynomial = function (parr, pSize, order, regressDataArr) {
            order += 1; // bump the order by 1 to account for 0 based matrix
            var sum$$1 = [];
            // TODO I think m is the problem at some point
            // eventually regressDataArr gets built from it,
            // which gets returned to Regression as ans
            var m = [];
            for (var i = 0; i < 2 * order; i++) {
                sum$$1[i] = 0.0;
                for (var j = 0; j < pSize; j++) {
                    // raise to correct power
                    sum$$1[i] += Math.pow(parr[j].x, i);
                }
            }
            for (var i = 0; i < order; i++) {
                for (var j = 0; j < order; j++) {
                    m[(i * (order + 1)) + j] = sum$$1[i + j];
                }
                m[(i * (order + 1)) + order] = 0.0;
                // Handle agumented section of matrix
                for (var j = 0; j < pSize; j++) {
                    m[(i * (order + 1)) + order] += Math.pow(parr[j].x, i) * parr[j].y;
                }
            }
            // Solve the lnear system of equations
            // a returns the solution coeficiants
            return this._gauss(m, order, regressDataArr);
        };
        // a is regressDataArr
        // n is order
        FDSSeries.prototype._gauss = function (m, order, regressDataArr) {
            var row = order + 1;
            var last$$1 = order - 1;
            var p = 0;
            for (var i = 0; i < last$$1; i++) {
                p = -1;
                for (var j = i; j < order; j++) {
                    if (m[(j * row) + i] !== 0) {
                        p = j;
                        break;
                    }
                }
                if (p === -1) {
                    return false;
                }
                if (p !== i) {
                    this._swapRow(m, order, p, i);
                }
                for (var j = i + 1; j < order; j++) {
                    var c = m[(j * row) + i] / m[(i * row) + i];
                    this._replaceRow(m, order, j, c, i);
                }
            }
            var denom = m[(last$$1 * row) + last$$1];
            // TODO right now, denom is becoming 0, so we aren't getting
            // past this, so ans in Regression.coffee is an empty array
            if (denom === 0) {
                return false;
            }
            // backward substitution process
            regressDataArr[order - 1] = m[(last$$1 * row) + order] / denom;
            var sum$$1 = 0;
            for (var i = last$$1 - 1; i >= 0; i--) {
                sum$$1 = 0;
                for (var j = i + 1; j < order; j++) {
                    sum$$1 += m[(i * row) + j] * regressDataArr[j];
                }
                regressDataArr[i] = (m[(i * row) + order] - sum$$1) / m[(i * row) + i];
            }
            return true;
        };
        FDSSeries.prototype._swapRow = function (m, order, to_row, from_row) {
            var row = order + 1;
            for (var i = 0; i < row; i++) {
                var temp = m[(from_row * row) + i];
                m[(from_row * row) + i] = m[(to_row * row) + i];
                m[(to_row * row) + i] = temp;
            }
        };
        FDSSeries.prototype._replaceRow = function (m, order, to_row, c, from_row) {
            var row = order + 1;
            for (var i = 0; i < row; i++) {
                m[(to_row * row) + i] -= c * m[(from_row * row) + i];
            }
        };
        FDSSeries.prototype._cancelSeriesTranslation = function (dim, delta) {
            var ds = this.getData(dim);
            if (ds.getDataType() !== 4 /* STRING_DATA */) {
                var data = [];
                switch (dim) {
                    case 1 /* X */:
                        if (this._dataPointsBeforeInteractionX.length > 0) {
                            data = this._dataPointsBeforeInteractionX;
                            this._dataPointsBeforeInteractionX = [];
                        }
                        break;
                    case 2 /* Y */:
                        if (this._dataPointsBeforeInteractionY.length > 0) {
                            data = this._dataPointsBeforeInteractionY;
                            this._dataPointsBeforeInteractionY = [];
                        }
                        break;
                }
                ds.replace(0, data);
            }
        };
        FDSSeries.prototype.findExtremaInRange = function (startDatapoint, endDatapoint, startIndex, endIndex, value1, xvalue1, value2, xvalue2, forceSearch) {
            var xData = this.getData(1 /* X */);
            var yData = this.getData(2 /* Y */);
            if (xData.getSize() < 1 || yData.getSize() < 1) {
                return [false, startIndex, endIndex, value1, xvalue1, value2, xvalue2];
            }
            // If the startdatapoint and enddatapoint haven't changed, and if forceSearch is false, return the cached values
            if (startDatapoint === this._startPointCached && endDatapoint === this._endPointCached && (!forceSearch)) {
                startIndex = this._startIndexCached;
                endIndex = this._endIndexCached;
                value1 = this._startPointYValueCached;
                xvalue1 = this._startPointXValueCached;
                value2 = this._endPointYValueCached;
                xvalue2 = this._endPointXValueCached;
                return [true, startIndex, endIndex, value1, xvalue1, value2, xvalue2];
            }
            var xScale = this.getScale(1 /* X */);
            var yScale = this.getScale(2 /* Y */);
            // Cache both indices before they're adjusted by the code below
            this._startPointCached = startDatapoint;
            this._endPointCached = endDatapoint;
            if (ISNAN(startDatapoint)) {
                startDatapoint = xData.Min()[0];
            }
            if (ISNAN(endDatapoint)) {
                endDatapoint = xData.Max()[0];
            }
            if (startDatapoint > xData.getValueOrIndexAt(xScale, xData.getSize() - 1)) {
                return [false, startIndex, endIndex, value1, xvalue1, value2, xvalue2];
            }
            if (endDatapoint < xData.getValueOrIndexAt(xScale, 0)) {
                return [false, startIndex, endIndex, value1, xvalue1, value2, xvalue2];
            }
            if (startDatapoint > endDatapoint) {
                return [false, startIndex, endIndex, value1, xvalue1, value2, xvalue2];
            }
            var minIndex = -1;
            var maxIndex = -1;
            var minDim = 0;
            var maxDim = 0;
            var min$$1 = NAN * -1;
            var max$$1 = NAN;
            // Adjust startindex and/or endindex if the data isn't sorted
            var startx = startDatapoint;
            var endx = endDatapoint;
            var tmpStartIndex = -1;
            var tmpEndIndex = -1;
            // loop through all datapoints
            var minx = NAN * -1;
            var maxx = NAN;
            var minDataLength = xData.getSize() < yData.getSize() ? xData.getSize() : yData.getSize();
            for (var index = 0; index < minDataLength; index++) {
                var xdp = xData.getValueOrIndexAt(xScale, index);
                if (xdp < startx) {
                    continue;
                }
                if (tmpStartIndex < 0) {
                    minx = xdp;
                    tmpStartIndex = index;
                }
                else {
                    if (xdp < minx) {
                        minx = xdp;
                        tmpStartIndex = index;
                    }
                }
                if (xdp > endx) {
                    continue;
                }
                if (xdp > maxx) {
                    maxx = xdp;
                    tmpEndIndex = index;
                }
                for (var dim = 0; dim < yData.getDimension(); dim++) {
                    var ydp = yData.getValueOrIndexAt(yScale, index, dim);
                    if (NOTNAN(ydp)) {
                        if (ydp < min$$1) {
                            min$$1 = ydp;
                            minIndex = index;
                            minDim = dim;
                        }
                        if (ydp > max$$1) {
                            max$$1 = ydp;
                            maxIndex = index;
                            maxDim = dim;
                        }
                    }
                }
            }
            this._startPointYValueCached = value1 = minIndex >= 0 ? yData.getValueOrIndexAt(yScale, minIndex, minDim) : 0;
            this._startPointXValueCached = xvalue1 = minIndex >= 0 ? xData.getValueOrIndexAt(xScale, minIndex) : 0;
            this._endPointYValueCached = value2 = maxIndex >= 0 ? yData.getValueOrIndexAt(yScale, maxIndex, maxDim) : 0.0;
            this._endPointXValueCached = xvalue2 = maxIndex >= 0 ? xData.getValueOrIndexAt(xScale, maxIndex) : 0;
            this._startIndexCached = startIndex = tmpStartIndex;
            this._endIndexCached = endIndex = tmpEndIndex;
            return [true, startIndex, endIndex, value1, xvalue1, value2, xvalue2];
        };
        FDSSeries.prototype.getDataPtNDC = function (dim, dataPt) {
            if (!(dim === 1 /* X */ || dim === 2 /* Y */)) {
                return NAN;
            }
            var ndc = 0;
            var plot = this.getPlotParent();
            var scale = this.getAxis(dim).getScale();
            if (plot && scale) {
                var style = this.drawStyle;
                var bin = dim === 1 /* X */ ?
                    isVerticalBinnedDrawStyle(style) :
                    isHorizontalBinnedDrawStyle(style);
                if (bin) {
                    var _a = plot.getXYBins(), nXBins = _a[0], nYBins = _a[1], useDelta = _a[2];
                    var val = void 0, x1 = void 0, x2 = void 0, offset = void 0;
                    _b = scale.lookupRange(dataPt), val = _b[0], x1 = _b[1], x2 = _b[2], offset = _b[3];
                    if (offset < 0.001) {
                        offset = 0.0;
                    }
                    var delta = ((x2 - offset) - ((x1 + offset) / Math.max(1, dim === 1 /* X */ ? nXBins : nYBins)));
                    x1 += offset + (delta * this.barNumber * Number(useDelta));
                    x2 = x1 + delta;
                    ndc = (x1 + x2) / 2;
                }
                else {
                    ndc = scale.lookup(dataPt);
                }
            }
            return ndc;
            var _b;
        };
        FDSSeries.prototype.getClosestValueTo = function (targetDim, target, isFixedToEndpoints, allowLinearSearch, snapToFrequency) {
            if (isFixedToEndpoints === void 0) { isFixedToEndpoints = false; }
            if (allowLinearSearch === void 0) { allowLinearSearch = false; }
            if (snapToFrequency === void 0) { snapToFrequency = false; }
            var targetData = this.getData(targetDim);
            var retVal = NAN;
            var errorRet = [NAN, 0];
            if (targetData) {
                var sorted = targetData.sorted, ascending = targetData.ascending;
                if (this.size < 1) {
                    return errorRet;
                }
                var axis = this.getAxis(targetDim);
                var scale = axis.getScale();
                if (sorted) {
                    // since its sorted, we can do a (psuedo)binary search through the data
                    var left = 0;
                    var right = targetData.getSize() - 1;
                    var mid = 0;
                    if (!isFixedToEndpoints) {
                        var plot = this.getPlotParent();
                        if (plot) {
                            if (scale) {
                                var offset = void 0;
                                var lowVal = targetData.getAt(left);
                                var highVal = targetData.getAt(right);
                                if (scale.bin || targetData.isFrequencyDefault()) {
                                    if ((ascending && !scale.reverse) || (!ascending && scale.reverse)) {
                                        _a = scale.lookupRange(targetData.getAt(left)), lowVal = _a[1], offset = _a[3];
                                        _b = scale.lookupRange(targetData.getAt(right)), highVal = _b[2], offset = _b[3];
                                    }
                                    else {
                                        _c = scale.lookupRange(targetData.getAt(left)), lowVal = _c[2], offset = _c[3];
                                        _d = scale.lookupRange(targetData.getAt(right)), highVal = _d[1], offset = _d[3];
                                    }
                                    lowVal = scale.computeValue(scale.applyRevPlotFactorNDC(lowVal));
                                    highVal = scale.computeValue(scale.applyRevPlotFactorNDC(highVal));
                                }
                                if ((ascending && (lowVal > target || (highVal < target))) ||
                                    (!ascending && (lowVal < target || (highVal > target)))) {
                                    return errorRet;
                                }
                            }
                        }
                    }
                    var current = 0;
                    while (left < right) {
                        mid = ~~((left + right) / 2);
                        current = targetData.getAt(mid);
                        if (scale && snapToFrequency) {
                            current = scale.snapToFrequency(current);
                        }
                        // Q. What if we hit an @NA in the middle of targetData?
                        // A. Shift right until we hit a non-na value
                        if (IsNA(current)) {
                            var offset = 0;
                            while (IsNA(current) && mid + offset <= right) {
                                offset++;
                                current = targetData.getAt(mid + offset);
                                if ((scale != null) && snapToFrequency) {
                                    current = scale.snapToFrequency(current);
                                }
                            }
                            if (mid + offset > right) {
                                right = mid;
                                continue;
                            }
                        }
                        if (target === current) {
                            retVal = targetData.getAt(mid);
                            var retValIndex_1 = mid;
                            if ((scale != null) && snapToFrequency) {
                                retVal = scale.snapToFrequency(retVal);
                            }
                            if (!IsNA(retVal)) {
                                return [retVal, retValIndex_1];
                            }
                            else {
                                left = right = mid;
                                break;
                            }
                        }
                        else if ((ascending && (target <= current)) || (!ascending && (target >= current))) {
                            right = mid;
                        }
                        else {
                            left = mid + 1;
                        }
                    }
                    // left now contains the closest match (or an NA)
                    current = targetData.getAt(left);
                    if ((scale != null) && snapToFrequency) {
                        current = scale.snapToFrequency(current);
                    }
                    retVal = current;
                    var retValIndex = left;
                    // compare the values at left and left-1 to see how close they are
                    if (left > 0) {
                        var ret = this._getClosestValueToIndex(targetDim, targetData, target, left, ascending);
                        if (!ret) {
                            return errorRet;
                        }
                        retVal = ret[0], retValIndex = ret[1];
                    }
                    return [retVal, retValIndex];
                }
                else {
                    if (allowLinearSearch) {
                        if (!isFixedToEndpoints && (target < targetData.Min()[0] || target > targetData.Max()[0])) {
                            return errorRet;
                        }
                        if (scale != null) {
                            var minDist = 2;
                            var minIndex = -1;
                            var targetPt = scale.snapToFrequency(target);
                            var targetNDC = this.getDataPtNDC(targetDim, targetPt);
                            for (var i = 0; i < this.size; i++) {
                                var currentNDC = this.getDataPtNDC(targetDim, scale.snapToFrequency(targetData.getAt(i)));
                                var dist = Math.abs(currentNDC - targetNDC);
                                if (dist < minDist) {
                                    minIndex = i;
                                    minDist = dist;
                                }
                            }
                            retVal = targetData.getAt(minIndex);
                            return [retVal, minIndex];
                        }
                    }
                    else {
                        return errorRet;
                    }
                }
            }
            return errorRet;
            var _a, _b, _c, _d;
        };
        FDSSeries.prototype._getClosestValueToIndex = function (targetDim, data, target, index, ascending) {
            var value = NAN;
            var dataSize = data.getSize();
            if (dataSize > 0) {
                var rightIndex = clamp(index, 0, dataSize);
                var leftIndex = rightIndex - 1;
                var leftValue = NAN;
                var rightValue = NAN;
                var targetValue = target;
                while (leftIndex >= 0 && leftValue === NAN) {
                    leftValue = data.getAt(leftIndex);
                    if (IsNA(leftValue)) {
                        leftIndex--;
                    }
                }
                while (rightIndex < dataSize && rightValue === NAN) {
                    rightValue = data.getAt(rightIndex);
                    if (IsNA(rightValue)) {
                        rightIndex++;
                    }
                }
                if (leftIndex < 0 && rightIndex < dataSize) {
                    return [rightValue, rightIndex];
                }
                else if (rightIndex >= dataSize && leftIndex >= 0) {
                    return [leftValue, leftIndex];
                }
                else if (leftIndex < 0 && rightIndex >= dataSize) {
                    return [NAN, 0];
                }
                index = 0;
                var plot = this.getPlotParent();
                if (plot) {
                    var scale = this.getAxis(targetDim).getScale();
                    if (scale) {
                        if (scale.reverse) {
                            ascending = !ascending;
                        }
                        var leftVal = this.getDataPtNDC(targetDim, leftValue);
                        var rightVal = this.getDataPtNDC(targetDim, rightValue);
                        var targetVal = this.getDataPtNDC(targetDim, targetValue);
                        if ((ascending && (targetVal - leftVal) < (rightVal - targetVal)) ||
                            (!ascending && (targetVal - leftVal) >= (rightVal - targetVal))) {
                            value = leftValue;
                            index = leftIndex;
                        }
                        else {
                            value = rightValue;
                            index = rightIndex;
                        }
                    }
                }
            }
            return [value, index];
        };
        FDSSeries.prototype._getIndexFromPosHelper = function (percent, dim, isFixedToEndpoints, clampToThresholds) {
            if (isFixedToEndpoints === void 0) { isFixedToEndpoints = false; }
            if (clampToThresholds === void 0) { clampToThresholds = true; }
            var plot = this.getPlotParent();
            var scale = this.getScale(dim);
            var data = this.getData(dim);
            if (plot && scale && data) {
                if (!data.isIndex && data.getDataType() !== 4 /* STRING_DATA */) {
                    // compute the data value based on the ndc and align the result to the dataset's frequency if applicable
                    var target = scale.computeValueUnbinned(percent);
                    // here we attempt to retrieve the X value of the series that immediately follows our target
                    var _a = this.getClosestValueTo(dim, target, isFixedToEndpoints, this._crosshairsFallbackOnLinear, true), retPoint = _a[0], retPointIndex = _a[1];
                    if (!IsNA(retPoint)) {
                        var i = retPointIndex;
                        if (clampToThresholds && 0 <= i && i < data.getSize()) {
                            // walk backwards till the index is in the subplot rect
                            var threshMax = scale.snapToFrequency(scale.threshMax);
                            var threshMin = scale.snapToFrequency(scale.threshMin);
                            while (i > 0 && data.getAt(i) > threshMax) {
                                i--;
                            }
                            if (i > 0 && dim === 1 /* X */) {
                                var point1 = new Point(plot.subPlotFromNDC(scale.lookup(data.getAt(i)), 1 /* X */) +
                                    plot.plotRect.x1, 0);
                                if (!plot.isPointInSubPlotX(point1)) {
                                    i--;
                                }
                            }
                            // walk forward till the index is in the subplot rect
                            while (i < data.getSize() - 1 && data.getAt(i) < threshMin) {
                                i++;
                            }
                        }
                        return i;
                    }
                }
                else {
                    var index = Math.round(scale.computeValue(percent));
                    // can't assume the data is in order
                    // first get the string from the scale from this index
                    var str = scale.getStringFromIndex(index);
                    if (str == null) {
                        return -1;
                    }
                    // now find the corresponding index of this string for this series
                    var dataItems = this.getData(dim).data;
                    index = -1;
                    for (var i = 0; i < dataItems.length; i++) {
                        var d = dataItems[i];
                        if (d === str) {
                            index = i;
                            break;
                        }
                    }
                    // bail out if we didn't find it. otherwise, we're golden, continue
                    if (index === -1) {
                        return index;
                    }
                    if (isFixedToEndpoints) {
                        if (index < 0) {
                            index = 0;
                        }
                        if (index >= dataItems.length) {
                            index = dataItems.length - 1;
                        }
                        if (clampToThresholds) {
                            if (index < scale.threshMin) {
                                index = ~~(scale.threshMin);
                            }
                            else if (index >= scale.threshMax) {
                                index = ~~(scale.threshMax);
                            }
                        }
                    }
                    return index;
                }
            }
            return -1;
        };
        FDSSeries.prototype.getIndexFromPos = function (point, isFixedToEndpoints) {
            if (isFixedToEndpoints === void 0) { isFixedToEndpoints = false; }
            if (this.root) {
                var style = this.getEffectiveDrawStyle();
                if (!isFullPlotDrawStyle(style)) {
                    if (!isHorizonalBarType(style) && !this._crosshairsSwapIndexedAxis) {
                        return this._getIndexFromXPos(point, isFixedToEndpoints);
                    }
                    else {
                        return this._getIndexFromYPos(point, isFixedToEndpoints);
                    }
                }
            }
            return -1;
        };
        FDSSeries.prototype._getIndexFromXPos = function (point, isFixedToEndpoints) {
            if (isFixedToEndpoints === void 0) { isFixedToEndpoints = false; }
            var plot = this.getPlotParent();
            if (plot) {
                var ndcPt = this._mousePointerToNDC(point, false);
                return this._getIndexFromPosHelper(ndcPt.x, 1 /* X */, isFixedToEndpoints);
            }
            else {
                return -1;
            }
        };
        FDSSeries.prototype._getIndexFromYPos = function (point, isFixedToEndpoints) {
            if (isFixedToEndpoints === void 0) { isFixedToEndpoints = false; }
            var plot = this.getPlotParent();
            if (plot) {
                var ndcPt = this._mousePointerToNDC(point, false);
                return this._getIndexFromPosHelper(ndcPt.y, 2 /* Y */, isFixedToEndpoints);
            }
            else {
                return -1;
            }
        };
        FDSSeries.prototype.getPointAtIndex = function (index, plot) {
            // get everything
            var xData = this.getData(1 /* X */);
            var yData = this.getData(2 /* Y */);
            var xScale = this.getScale(1 /* X */);
            var yScale = this.getScale(2 /* Y */);
            var xPt = xData.getAt(index);
            var yPt = yData.getAt(index);
            if ((xPt == null) || (yPt == null) || IsSomeNAN(xPt) || IsSomeNAN(yPt)) {
                return undefined;
            }
            if (plot.renderManager.nHorizontalBars > 1) {
                var _a = xScale.lookupRange(xPt), low = _a[1], high = _a[2], offset = _a[3];
                var delta = ((high - offset) - (low + offset)) / plot.renderManager.nHorizontalBars;
                xPt = low + offset + (delta * this.barNumber) + (delta / 2);
            }
            else {
                xPt = xScale.lookup(xPt);
            }
            yPt = yScale.lookup(yPt);
            xPt = plot.subPlotFromNDC(xPt, 1 /* X */);
            yPt = plot.subPlotFromNDC(yPt, 2 /* Y */);
            return new Point(xPt, yPt);
        };
        FDSSeries.prototype.objectAction = function (action, flags, args) {
            return _super.prototype.objectAction.call(this, action, flags, args);
        };
        FDSSeries.prototype._mousePointerToNDC = function (point, updateDataPoints) {
            if (updateDataPoints === void 0) { updateDataPoints = true; }
            var ndc = new Point(0, 0);
            var plot = this.getPlotParent();
            var rect = plot.plotRect;
            var subrect = rect.copy();
            var subrectXMaxFactor = plot.getPlotFactor(1 /* X */, 'max');
            var subrectXMinFactor = plot.getPlotFactor(1 /* X */, 'min');
            var subrectYMaxFactor = plot.getPlotFactor(2 /* Y */, 'max');
            var subrectYMinFactor = plot.getPlotFactor(2 /* Y */, 'min');
            subrect.x1 += subrectXMinFactor * rect.getWidth();
            subrect.x1 += plot.leftQuickLabelOffsets.inside;
            subrect.x2 -= (1 - subrectXMaxFactor) * rect.getWidth();
            subrect.x2 -= plot.rightQuickLabelOffsets.inside;
            // y is backwards
            subrect.y2 -= subrectYMinFactor * rect.getHeight();
            subrect.y1 += (1 - subrectYMaxFactor) * rect.getHeight();
            ndc.x = subrect.globalPixelsToRectNdc(point.x, 1 /* X */);
            ndc.y = 1 - subrect.globalPixelsToRectNdc(point.y, 2 /* Y */);
            if (updateDataPoints) {
                _a = this._updateDataPoint(1 /* X */, ndc.x, 0, false), ndc.x = _a[1];
                _b = this._updateDataPoint(2 /* Y */, ndc.y, 0, false), ndc.y = _b[1];
            }
            return ndc;
            var _a, _b;
        };
        FDSSeries.prototype._isPlotLevelAnnotation = function () {
            var isReferenceLine = _$1.includes([16 /* VERTICAL */, 17 /* HORIZONTAL */], this.getEffectiveDrawStyle());
            return !isSeries(this.parent) && !isReferenceLine && this.isAnnotation;
        };
        // helper function to return the min and max valid points on this series
        // @return [Array<Point>] returns two points, [min, max]
        FDSSeries.prototype.getMinMaxValidPoints = function () {
            var dataX = this.getData(1 /* X */);
            var dataY = this.getData(2 /* Y */);
            var scaleX = this.getAxis(1 /* X */).getScale();
            var scaleY = this.getAxis(2 /* Y */).getScale();
            var firstX, firstY, lastX, lastY;
            firstX = firstY = lastX = lastY = undefined;
            // find first and last valid points
            for (var i = 0; i < dataX.getSize(); i++) {
                firstX = dataX.getAt(i);
                firstY = dataY.getAt(i);
                if (firstX && firstY && (!isNaN(firstX)) && (!isNaN(firstY))) {
                    // we've found a valid item, end the loop
                    break;
                }
            }
            for (var i = dataX.getSize() - 1; i >= 0; i--) {
                lastX = dataX.getAt(i);
                lastY = dataY.getAt(i);
                if (lastX && lastY && (!isNaN(lastX)) && (!isNaN(lastY))) {
                    // we've found a valid item, end the loop
                    break;
                }
            }
            if (firstX == null || firstY == null || lastX == null || lastY == null) {
                return null;
            }
            var increasing = firstX < lastX;
            var min$$1, max$$1;
            if ((increasing && !scaleX.reverse) || (!increasing && scaleX.reverse)) {
                min$$1 = new Point(firstX, firstY);
                max$$1 = new Point(lastX, lastY);
            }
            else if ((increasing && scaleX.reverse) || (!increasing && !scaleX.reverse)) {
                min$$1 = new Point(lastX, lastY);
                max$$1 = new Point(firstX, firstY);
            }
            return [min$$1, max$$1];
        };
        // similar fn to return indices that work on a certain dimension
        // mostly for quicklabels
        FDSSeries.prototype.getMinMaxValidIndices = function (dim) {
            if (dim === void 0) { dim = 1 /* X */; }
            var data = this.getData(dim);
            var scale = this.getAxis(dim).getScale();
            var min$$1 = 0;
            var max$$1 = 0;
            // find first and last valid points
            var size = data.getSize();
            for (min$$1 = 0; min$$1 < size; min$$1++) {
                var first$$1 = data.getAt(min$$1);
                if (first$$1 && (!IsSomeNAN(first$$1))) {
                    // we've found a valid item, end the loop
                    break;
                }
            }
            for (max$$1 = size - 1; max$$1 >= 0; max$$1--) {
                var last$$1 = data.getAt(max$$1);
                if (last$$1 && (!IsSomeNAN(last$$1))) {
                    // we've found a valid item, end the loop
                    break;
                }
            }
            return [min$$1, max$$1];
        };
        FDSSeries.prototype.getSortedData = function () {
            var startDatapoint = this.attributeSet.get('StartDatapoint');
            var endDatapoint = this.attributeSet.get('EndDatapoint');
            return this._getSortedDataHelper(startDatapoint, endDatapoint);
        };
        FDSSeries.prototype._getSortedDataHelper = function (startDatapoint, endDatapoint) {
            var needUpdate = startDatapoint !== this._startPointCached || endDatapoint !== this._endPointCached;
            var startIndex = 0;
            var endIndex = 0;
            if (!this._sortedData || needUpdate) {
                this._sortedData = [];
                this._startPointCached = startDatapoint;
                this._endPointCached = endDatapoint;
                var xData = this.getData(1 /* X */);
                var yData = this.getData(2 /* Y */);
                var _a = xData.Min(), dsMin = _a[0], dsMinIndex = _a[1];
                var _b = xData.Max(), dsMax = _b[0], dsMaxIndex = _b[1];
                startDatapoint = ISNAN(startDatapoint) ? dsMin : startDatapoint;
                endDatapoint = ISNAN(endDatapoint) ? dsMax : endDatapoint;
                var xScale = this.getScale(1 /* X */);
                var yScale = this.getScale(2 /* Y */);
                for (var i = 0; i < xData.getSize(); i++) {
                    var x = xData.getValueOrIndexAt(xScale, i);
                    var y = yData.getValueOrIndexAt(yScale, i);
                    if (!ISNAN(x) && !ISNAN(y) && (startDatapoint <= x && x <= endDatapoint)) {
                        this._sortedData.push({ index: i, point: new Point(x, y) });
                    }
                }
                if (!xData.sorted) {
                    this._sortedData.sort(function (a, b) { return a.point.x - b.point.x; });
                }
            }
            if (this._sortedData.length > 0) {
                this._startIndexCached = startIndex = this._sortedData[0].index;
                this._endIndexCached = endIndex = this._sortedData[this._sortedData.length - 1].index;
            }
            return {
                'data': this._sortedData,
                'startIndex': startIndex,
                'endIndex': endIndex
            };
        };
        FDSSeries.prototype._getCompleteSortedData = function () {
            return this._getSortedDataHelper(NAN, NAN);
        };
        FDSSeries.prototype.interpolateBetweenPoints = function (datapoint) {
            var data = this._getCompleteSortedData().data;
            if (data.length <= 0) {
                return { index: 0, point: Point.zero() };
            }
            if (datapoint < data[0].point.x) {
                return data[0];
            }
            for (var i = 0; i < data.length; i++) {
                var datum = data[i];
                if (i === data.length - 1) {
                    return datum;
                }
                var nextDatum = data[i + 1];
                if (datum.point.x === datapoint) {
                    return datum;
                }
                if (!(datum.point.x < datapoint && datapoint < nextDatum.point.x)) {
                    continue;
                }
                if (!this._allowDraggableMarkerInterpolation) {
                    return datum;
                }
                else {
                    var xScale = this.getScale(1 /* X */);
                    var yScale = this.getScale(2 /* Y */);
                    var xLog = xScale.log;
                    var yLog = yScale.log;
                    var xDiff = xScale.compressValue(nextDatum.point.x, xLog) - xScale.compressValue(datum.point.x, xLog);
                    var yDiff = yScale.compressValue(nextDatum.point.y, yLog) - yScale.compressValue(datum.point.y, yLog);
                    if (xDiff === 0) {
                        return { index: 0, point: Point.zero() };
                    }
                    var x = xScale.compressValue(datapoint, xLog);
                    var yDelta = (((x - xScale.compressValue(datum.point.x, xLog)) / xDiff) * yDiff);
                    var y = yScale.compressValue(datum.point.y, yLog) + yDelta;
                    if (xDiff === 0) {
                        return { index: 0, point: Point.zero() };
                    }
                    var xVal = xScale.decompressValue(x, xLog);
                    var yVal = yScale.decompressValue(y, yLog);
                    return { index: -1, point: new Point(xVal, yVal) };
                }
            }
            return null;
        };
        FDSSeries.prototype.getInteractivityObjectType = function () {
            return 1 /* SERIES */;
        };
        FDSSeries.prototype._maybeBound = function (value, min$$1, max$$1) {
            return this._interactivityClamping ? clamp(value, min$$1, max$$1) : value;
        };
        // interactivity stuff
        FDSSeries.prototype.interact = function (point, event, message) {
            var ret = false;
            switch (message) {
                case 10 /* STARTINTERACTION_LMBUTTON_DBLCLICK */:
                    if (this.size > 1) {
                        this._cancelInteraction(false, false);
                        return false;
                    }
                    ret = this._startInteraction(point, event, message);
                    break;
                case 11 /* STARTINTERACTION_RESIZE */:
                case 12 /* STARTINTERACTION_DRAG_SERIES */:
                case 13 /* STARTINTERACTION_DRAG_RL */:
                case 14 /* STARTINTERACTION_DRAG_ANNOTATION */:
                case 6 /* STARTINTERACTION */:
                    ret = this._startInteraction(point, event, message);
                    break;
                case 1 /* MOUSEMOVE */:
                    ret = this._continueInteraction(point, event, message);
                    break;
                case 2 /* LMBUTTONUP */:
                    ret = this._continueInteraction(point, event, message);
                    break;
                case 4 /* KEYDOWN */:
                    ret = this._continueInteraction(point, event, message);
                    break;
                case 5 /* KEYUP */:
                    if (event.which === 27 /* ESCAPE */ || event.which === 17 /* CONTROL */) {
                        ret = this._continueInteraction(point, event, message);
                    }
                    break;
                case 7 /* ENDINTERACTION */:
                    ret = this._endInteraction(point);
                    break;
                case 15 /* CANCELINTERACTION */:
                    ret = this._cancelInteraction((this.interactivityStatus & 2 /* DRAGGING */) !== 0, (this.interactivityStatus & 2 /* DRAGGING */) !== 0);
                    break;
                case 16 /* SINGLEINTERACTION */:
                    var hit = this.hitTest(point.x, point.y).hit;
                    if (this.pieDesc.explodeMode !== 0 /* NONE */) {
                        var pieAnimator = this.root.animationManager.tryGetAnimator(this.id, 'PieExplosion');
                        pieAnimator.explodePiePiece(hit);
                    }
                    break;
            }
            return ret;
        };
        FDSSeries.prototype._startInteraction = function (point, event, message) {
            if (this.interactivityMode & (2 /* DRAGGABLE */ | 4 /* RESIZABLE */ |
                8 /* TEXTEDITABLE */)) {
                if (message === 10 /* STARTINTERACTION_LMBUTTON_DBLCLICK */ &&
                    (this.interactivityMode & 8 /* TEXTEDITABLE */)) {
                    if (!this.root) {
                        return false;
                    }
                    // save the state of the current tooltip status
                    this._previousToolTipStatus = this.root.tooltipsEnabled;
                    this.root.tooltipsEnabled = false;
                    var ds = this.getData(0 /* VALUE */);
                    if (!ds || ds.getSize() < 1) {
                        return false;
                    }
                    this._initialAnnotationText = ds.getStringAt(0);
                    this.root.setTextEditingContent(this._initialAnnotationText);
                    this.root.setTextEditingStyle(this._getAnnotationStyleInCSS());
                    this.root.displayTextEditingRectAt(this._getCurrentAnnotationRect());
                    this.root.selectTextEditingContent();
                    this.interactivityStatus = 8 /* TEXTEDITING */;
                    return true;
                }
                else if (message === 11 /* STARTINTERACTION_RESIZE */ ||
                    this._hitShapeName === 14 /* DATAPOINTNW */ || this._hitShapeName === 13 /* DATAPOINTNE */ ||
                    this._hitShapeName === 15 /* DATAPOINTSE */ || this._hitShapeName === 16 /* DATAPOINTSW */ ||
                    this._hitShapeName === 9 /* DATAPOINTN */ || this._hitShapeName === 10 /* DATAPOINTS */ ||
                    this._hitShapeName === 11 /* DATAPOINTE */ || this._hitShapeName === 12 /* DATAPOINTW */) {
                    return this._resize(point, event);
                }
                else if (message === 13 /* STARTINTERACTION_DRAG_RL */ ||
                    this._hitShapeName === 18 /* VERTICAL */ || this._hitShapeName === 17 /* HORIZONTAL */) {
                    return this._dragRL(point, event);
                }
                else if (message === 12 /* STARTINTERACTION_DRAG_SERIES */ ||
                    this._hitShapeName === 5 /* SERIESHIT */ || this._hitShapeName === 3 /* DATAPOINT */ ||
                    this._hitShapeName === 4 /* DATAPOINTALTX */ || this._hitShapeName === 1 /* DATAPOINTNS */ ||
                    this._hitShapeName === 2 /* DATAPOINTWE */ || this._hitShapeName === 8 /* SERIESHITLEFTRIGHT */ ||
                    this._hitShapeName === 6 /* DATAPOINTLEFT */ || this._hitShapeName === 7 /* DATAPOINTRIGHT */) {
                    return this._dragSeries(point, event);
                }
                else {
                    return this._drag(point, event);
                }
            }
            return false;
        };
        FDSSeries.prototype._dragRL = function (point, event) {
            if (this._hitShapeName !== 17 /* HORIZONTAL */ && this._hitShapeName !== 18 /* VERTICAL */) {
                return false;
            }
            switch (this.getEffectiveDrawStyle()) {
                case 16 /* VERTICAL */:
                    var ds = this.getData(1 /* X */);
                    if (ds != null) {
                        this._initialInteractionDataPoint = ds.getAt(0);
                        if (this.root != null) {
                            this.root.setInteractionCursor(Cursor.SIZEWE);
                        }
                    }
                    break;
                case 17 /* HORIZONTAL */:
                    ds = this.getData(2 /* Y */);
                    if (ds != null) {
                        this._initialInteractionDataPoint = ds.getAt(0);
                        if (this.root != null) {
                            this.root.setInteractionCursor(Cursor.SIZENS);
                        }
                    }
                    break;
            }
            if (this.getPlotParent().referenceLineEventMask & 1 /* PICK */) {
                var vec = this._prepareReferenceLineEventVector(this._initialInteractionDataPoint);
                this.root.fireChartEvent('ReferenceLinePick', point, vec);
            }
            this._lastInteractionPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            this._initialInteractionPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            this._initialHitShapeType = hitShapeNameToType(this._hitShapeName);
            this.interactivityStatus = 2 /* DRAGGING */;
            return true;
        };
        FDSSeries.prototype._resize = function (point, event) {
            this.initialHitShapeId = convertResizingMarkerNametoId(this._hitShapeName);
            if (this.seriesValueAutoPosition) {
                this.attributeSet.setAt('SeriesValueAutoPosition', 'user', false);
            }
            this._initialSize.x = this._currentAnnotationTextBoxSize.x;
            this._initialSize.y = this._currentAnnotationTextBoxSize.y;
            // compute real size of the annotation if margins (cell padding) are being applied
            if (!(this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */ && this._initialSize.x !== 0)) {
                this._initialSize.x -= Math.round(2 * this.seriesValueDisplayMargins);
            }
            if (!(this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */ && this._initialSize.y !== 0)) {
                this._initialSize.y -= Math.round(2 * this.seriesValueDisplayMargins);
            }
            var width = this.attributeSet.get('SeriesValueWidthHint');
            var height = this.attributeSet.get('SeriesValueHeightHint');
            this._initialSize.x = makeEven(this._initialSize.x);
            this._initialSize.x = Math.max(this._initialSize.x, 2);
            this._initialSize.y = makeEven(this._initialSize.y);
            this._initialSize.y = Math.max(this._initialSize.y, 2);
            this._initialOffsets.x = Math.round(this.attributeSet.get('SeriesValueXOffset'));
            this._initialOffsets.y = Math.round(this.attributeSet.get('SeriesValueYOffset'));
            if (this.seriesValueSizingMode === 0 /* DEFAULT */) {
                if (this._sizingModeBeforeInteraction === 2 /* CUSTOM_FORCE */) {
                    this._initialSize.x += Math.round(2 * this.seriesValueDisplayMargins);
                    this._initialSize.y += Math.round(2 * this.seriesValueDisplayMargins);
                }
                this.attributeSet.setAt('SeriesValueSizingMode', 'user', this._sizingModeBeforeInteraction);
                this.attributeSet.setAt('SeriesValueWidthHint', 'user', this._initialSize.x);
                this.attributeSet.setAt('SeriesValueHeightHint', 'user', this._initialSize.y);
                this.seriesValueHeightHint = this._initialSize.y;
                this.seriesValueWidthHint = this._initialSize.x;
                this._sizingModeStartedAsAutomatic = true;
            }
            else {
                if (width === 0 && this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */) {
                    width = this._currentAnnotationTextBoxSize.x;
                }
                if (height === 0 && this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */) {
                    height = this._currentAnnotationTextBoxSize.y;
                }
                if (width !== this._initialSize.x) {
                    this._initialOffsets.x -= this.offsetSigns.x * Math.round((width - this._initialSize.x) / 2);
                }
                if (height !== this._initialSize.y) {
                    this._initialOffsets.y += this.offsetSigns.y * Math.round((this._initialSize.y - height) / 2);
                }
                this._sizingModeStartedAsAutomatic = false;
            }
            this._initialOffsetMouseCoordinatesBy = this._offsetMouseCoordinatesBy;
            this._lastInteractionPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            this._initialInteractionPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            this.interactivityStatus = 4 /* SIZING */;
            var ds = this.getData(1 /* X */);
            if ((ds != null) && ds.getSize() > 0) {
                this._initialInteractionDataPoint = ds.getAt(0);
            }
            ds = this.getData(2 /* Y */);
            if ((ds != null) && ds.getSize() > 0) {
                this._initialInteractionDataPointAlternate = ds.getAt(0);
            }
            this.minimumWidth = this.minimumHeight = 0.0;
            return true;
        };
        FDSSeries.prototype._dragSeries = function (point, event) {
            if (!(this.interactivityMode & (2 /* DRAGGABLE */ | 4 /* RESIZABLE */))) {
                return false;
            }
            this._initialHitShapeType = hitShapeNameToType(this._hitShapeName);
            if (!this.root) {
                return false;
            }
            if (!_$1.includes([
                0 /* SERIES */,
                13 /* DATAPOINT */,
                17 /* DATAPOINT_ALTX */,
                11 /* DATAPOINT_NS */,
                12 /* DATAPOINT_WE */,
                16 /* SERIES_LEFT_RIGHT */,
                14 /* DATAPOINT_LEFT */,
                15 /* DATAPOINT_RIGHT */
            ], this._initialHitShapeType)) {
                this.root.removeFromInteractionList(this);
                return true;
            }
            switch (this._initialHitShapeType) {
                case 11 /* DATAPOINT_NS */:
                case 12 /* DATAPOINT_WE */:
                case 14 /* DATAPOINT_LEFT */:
                case 15 /* DATAPOINT_RIGHT */:
                case 13 /* DATAPOINT */:
                case 17 /* DATAPOINT_ALTX */:
                    if (!this.isInteractive(4 /* RESIZABLE */)) {
                        this.root.removeFromInteractionList(this);
                        return false;
                    }
                    this.interactivityStatus = 4 /* SIZING */;
                    break;
                default:
                    if (!this.isInteractive(2 /* DRAGGABLE */)) {
                        if (this.isInteractive(4 /* RESIZABLE */)) {
                            this.interactivityStatus = 4 /* SIZING */;
                        }
                        else {
                            this.root.removeFromInteractionList(this);
                            return false;
                        }
                    }
                    else {
                        this.interactivityStatus = 2 /* DRAGGING */;
                    }
            }
            // set cursor
            switch (this._initialHitShapeType) {
                case 11 /* DATAPOINT_NS */:
                    this.root.setInteractionCursor(Cursor.SIZENS);
                    break;
                case 12 /* DATAPOINT_WE */:
                case 14 /* DATAPOINT_LEFT */:
                case 15 /* DATAPOINT_RIGHT */:
                    this.root.setInteractionCursor(Cursor.SIZEWE);
                    break;
                case 13 /* DATAPOINT */:
                case 17 /* DATAPOINT_ALTX */:
                    this.root.setInteractionCursor(Cursor.SIZEALL);
                    break;
                default:
                    if (this.isInteractive(2 /* DRAGGABLE */)) {
                        this.root.setInteractionCursor(Cursor.SIZEALL);
                    }
            }
            this._initialOffsetMouseCoordinatesBy = this._offsetMouseCoordinatesBy;
            this._initialInteractionPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            this._lastInteractionPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            this._initialInteractionNDC = this._mousePointerToNDC(point.subtract(this._initialOffsetMouseCoordinatesBy));
            this._lastInteractionNDC = this._mousePointerToNDC(point.subtract(this._initialOffsetMouseCoordinatesBy));
            this._initialSelectedDataPoint = this._currentSelectedDataPoint;
            this._initialAlternateDataPoint = this._currentAlternateDataPoint;
            this._initialSlope = this.attributeSet.get('LineSlope');
            this._shiftPressedInitially = (typeof MouseEvent !== 'undefined' && MouseEvent != null) &&
                event instanceof MouseEvent ? event.shiftKey : false;
            this._initialStartDatapoint = this.attributeSet.get('StartDatapoint');
            this._initialEndDatapoint = this.attributeSet.get('EndDatapoint');
            this._dataPointsBeforeInteractionX = [];
            this._dataPointsBeforeInteractionY = [];
            switch (this._initialHitShapeType) {
                case 0 /* SERIES */:
                    var ds = this.getData(1 /* X */);
                    if (ds && ds.getDataType() !== 4 /* STRING_DATA */) {
                        for (var i = 0; i < ds.getSize(); i++) {
                            this._dataPointsBeforeInteractionX.push(ds.getAt(i));
                        }
                    }
                    ds = this.getData(2 /* Y */);
                    if (ds && ds.getDataType() !== 4 /* STRING_DATA */) {
                        for (var i = 0; i < ds.getSize(); i++) {
                            this._dataPointsBeforeInteractionY.push(ds.getAt(i));
                        }
                    }
                    break;
                default:
                    ds = this.getData(1 /* X */);
                    if (this._initialHitShapeType === 17 /* DATAPOINT_ALTX */) {
                        if ((ds != null) && ds.getDataType() !== 4 /* STRING_DATA */ && this._initialAlternateDataPoint >= 0 &&
                            ds.getSize() > this._initialAlternateDataPoint) {
                            this._dataPointsBeforeInteractionX = [ds.getAt(this._initialAlternateDataPoint)];
                        }
                    }
                    else {
                        if ((ds != null) && ds.getDataType() !== 4 /* STRING_DATA */ && this._initialSelectedDataPoint >= 0 &&
                            ds.getSize() > this._initialSelectedDataPoint) {
                            this._dataPointsBeforeInteractionX = [ds.getAt(this._initialSelectedDataPoint)];
                        }
                    }
                    ds = this.getData(2 /* Y */);
                    if ((ds != null) && ds.getDataType() !== 4 /* STRING_DATA */ && this._initialSelectedDataPoint >= 0 &&
                        ds.getSize() > this._initialSelectedDataPoint) {
                        this._dataPointsBeforeInteractionY = [ds.getAt(this._initialSelectedDataPoint)];
                    }
            }
            if (this.getPlotParent().seriesEventMask & 1 /* PICK */) {
                var dataValues = void 0;
                if (this._initialHitShapeType !== 0 /* SERIES */ &&
                    this._dataPointsBeforeInteractionX.length > 0 && this._dataPointsBeforeInteractionY.length > 0) {
                    dataValues = new Point(this._dataPointsBeforeInteractionX[0], this._dataPointsBeforeInteractionY[0]);
                }
                else {
                    dataValues = this._computeValue(this._initialInteractionNDC);
                }
                var dataVec = this._prepareSeriesEventVector(dataValues);
                this.root.fireChartEvent('SeriesPick', point, dataVec);
            }
            return true;
        };
        FDSSeries.prototype._computeValue = function (ndc) {
            var data = new Point(0, 0);
            var xds = this.getData(1 /* X */);
            var xaxis = this.getAxis(1 /* X */);
            var xscale = xaxis.getScale();
            if (xds && xaxis && xscale) {
                data.x = xscale.computeValue(ndc.x);
            }
            var yds = this.getData(2 /* Y */);
            var yaxis = this.getAxis(2 /* Y */);
            var yscale = yaxis.getScale();
            if (yds && yaxis && yscale) {
                data.y = yscale.computeValue(ndc.y);
            }
            return data;
        };
        FDSSeries.prototype._drag = function (point, event) {
            if (!(this.interactivityMode & 2 /* DRAGGABLE */) ||
                (this._hitShapeName !== this.hittableShapeIdentifier)) {
                this.interactivityStatus = 1 /* SELECTION */;
                return false;
            }
            this._initialSize.x = this.attributeSet.get('SeriesValueWidthHint');
            this._initialSize.y = this.attributeSet.get('SeriesValueHeightHint');
            // flickering will occur if AutoPosition is on
            if (this.seriesValueAutoPosition) {
                this.attributeSet.setAt('SeriesValueAutoPosition', 'user', false);
            }
            this._lastInteractionPoint = this._initialInteractionPoint = point;
            var ds = this.getData(1 /* X */);
            if ((ds != null) && ds.getSize() > 0) {
                this._initialInteractionDataPoint = ds.getAt(0);
            }
            ds = this.getData(2 /* Y */);
            if ((ds != null) && ds.getSize() > 0) {
                this._initialInteractionDataPointAlternate = ds.getAt(0);
            }
            if (this._offsetDifference.x !== 0) {
                this.attributeSet.setAt('SeriesValueXOffset', 'user', this._offsetDifference.x);
                this._initialOffsets.x = this._offsetDifference.x;
                this._offsetDifference.x = 0;
            }
            else {
                this._initialOffsets.x = Math.round(this.attributeSet.get('SeriesValueXOffset'));
            }
            if (this._offsetDifference.y !== 0) {
                this.attributeSet.setAt('SeriesValueYOffset', 'user', this._offsetDifference.y);
                this._initialOffsets.y = this._offsetDifference.y;
                this._offsetDifference.y = 0;
            }
            else {
                // this.autoPositionYOffset will prevent the annotation from jumping around when being selected && it was
                // autopositioned && storeYOffset was disabled this.autoPositionYOffsetLinkedAnnotation will prevent the
                // annotation from jumping around when being selected && it was autopositioned && storeYOffset was disabled &&
                // it has linked annotations
                this._initialOffsets.y = Math.round(this.attributeSet.get('SeriesValueYOffset')) +
                    this._autoPositionYOffsetLinkedAnnotation + this._autoPositionYOffset;
                this.attributeSet.setAt('SeriesValueYOffset', 'user', this._initialOffsets.y);
                this._autoPositionYOffset = this._autoPositionYOffsetLinkedAnnotation = 0;
            }
            if (this.root != null) {
                this.root.setInteractionCursor(Cursor.SIZEALL);
            }
            if (this._isPlotLevelAnnotation() && (this.getPlotParent().annotationEventMask & 1 /* PICK */)) {
                var eventData = this._preparePlotLevelAnnotationDropEventVector(this._initialInteractionDataPoint, this._initialInteractionDataPointAlternate);
                this.root.fireChartEvent('AnnotationPick', point, eventData);
            }
            this.interactivityStatus = 2 /* DRAGGING */;
            return true;
        };
        FDSSeries.prototype._continueInteraction = function (point, event, message) {
            if (!this.root) {
                return false;
            }
            if ((typeof KeyboardEvent !== 'undefined' && KeyboardEvent != null) && event instanceof KeyboardEvent) {
                if (event.which === 27 /* ESCAPE */) {
                    return this._cancelInteraction((this.interactivityStatus & 2 /* DRAGGING */) !== 0, (this.interactivityStatus & 4 /* SIZING */) !== 0);
                }
                if (event.which === 13 /* RETURN */) {
                    return this._endInteraction(point);
                }
            }
            if (this.interactivityStatus & 2 /* DRAGGING */) {
                switch (this._initialHitShapeType) {
                    case 1 /* VERTICAL */:
                    case 2 /* HORIZONTAL */:
                        return this._continueToDragRL(point, event, message);
                    case 0 /* SERIES */:
                    case 13 /* DATAPOINT */:
                    case 17 /* DATAPOINT_ALTX */:
                    case 11 /* DATAPOINT_NS */:
                    case 12 /* DATAPOINT_WE */:
                    case 16 /* SERIES_LEFT_RIGHT */:
                        return this._continueToDragSeries(point, event, message);
                    default:
                        return this._continueToDrag(point, event, message);
                }
            }
            else if (this.interactivityStatus & 4 /* SIZING */) {
                switch (this._initialHitShapeType) {
                    case 13 /* DATAPOINT */:
                    case 17 /* DATAPOINT_ALTX */:
                    case 12 /* DATAPOINT_WE */:
                    case 11 /* DATAPOINT_NS */:
                    case 14 /* DATAPOINT_LEFT */:
                    case 15 /* DATAPOINT_RIGHT */:
                        var npoint = new Point(0, 0);
                        if (!this.root.snapMouseToSeries(point, npoint, [this], event)) {
                            npoint = point;
                        }
                        return this._continueToDragSeries(npoint, event, message, this.root.drawBandsMarkers);
                    default:
                        return this._continueToResize(point, event, message);
                }
            }
            return false;
        };
        FDSSeries.prototype._translateSeries = function (dim, ndc, enablePtSlopeRotation, deltaIsAnActualDelta) {
            var _this = this;
            if (deltaIsAnActualDelta === void 0) { deltaIsAnActualDelta = false; }
            var delta = 0.0;
            switch (dim) {
                case 1 /* X */:
                    delta = ndc.x;
                    break;
                case 2 /* Y */:
                    if (this._initialHitShapeType === 16 /* SERIES_LEFT_RIGHT */) {
                        return false;
                    }
                    delta = ndc.y;
                    break;
            }
            if (!fuzzyEQ(delta, 0.0)) {
                var data_2 = this.getData(dim);
                var axis = this.getAxis(dim);
                if (data_2 && axis) {
                    // String axes can easily support the DATAPOINT_LEFT and DATAPOINT_RIGHT methods, but
                    // We can't easily update the data when dragging around arbitrary data points if the values are string or
                    // index.
                    var supportsDataChange = !data_2.isIndex && data_2.getDataType() !== 4;
                    var scale_1 = axis.getScale();
                    if (scale_1) {
                        var minx_1;
                        var dataPts = [];
                        var dataPtsSize = 0;
                        var value_1 = scale_1.computeValue(this._maybeBound(delta, 0.0, 1.0));
                        switch (this._initialHitShapeType) {
                            case 16 /* SERIES_LEFT_RIGHT */:
                                dataPtsSize = 2;
                                break;
                            case 14 /* DATAPOINT_LEFT */:
                            case 15 /* DATAPOINT_RIGHT */:
                                if (deltaIsAnActualDelta) {
                                    if (this._initialHitShapeType === 14 /* DATAPOINT_LEFT */) {
                                        value_1 = this.attributeSet.get('StartDatapoint');
                                    }
                                    else {
                                        value_1 = this.attributeSet.get('EndDatapoint');
                                    }
                                    value_1 = scale_1.computeValue(this._maybeBound(scale_1.applyRevPlotFactorNDC(scale_1.lookup(value_1)) +
                                        delta, 0, 1));
                                }
                                this._updateStartOrEndIndexAttributes(dim, value_1);
                                return true;
                            case 17 /* DATAPOINT_ALTX */:
                                if (!supportsDataChange) {
                                    return false;
                                }
                                if (deltaIsAnActualDelta) {
                                    var dp = data_2.getAt(dim === 1 /* X */ ?
                                        this._initialAlternateDataPoint :
                                        this._initialSelectedDataPoint);
                                    value_1 = scale_1.computeValue(this._maybeBound(scale_1.applyRevPlotFactorNDC(scale_1.lookup(dp)) +
                                        delta, 0, 1));
                                }
                                this._replaceDataPoint(dim, (dim === 1 /* X */ ? this._initialAlternateDataPoint : this._initialSelectedDataPoint), value_1);
                                return true;
                            case 12 /* DATAPOINT_WE */:
                            case 11 /* DATAPOINT_NS */:
                            case 13 /* DATAPOINT */:
                                if (!supportsDataChange) {
                                    return false;
                                }
                                if (deltaIsAnActualDelta) {
                                    var dp = data_2.getAt(this._initialSelectedDataPoint);
                                    value_1 = scale_1.computeValue(this._maybeBound(scale_1.applyRevPlotFactorNDC(scale_1.lookup(dp)) +
                                        delta, 0, 1));
                                }
                                this._replaceDataPoint(dim, this._initialSelectedDataPoint, value_1);
                                return true;
                            default:
                                dataPtsSize = data_2.getSize();
                        }
                        var maxx_1 = minx_1 = 0;
                        if (!deltaIsAnActualDelta) {
                            delta -= dim === 1 /* X */ ? this._initialInteractionNDC.x : this._initialInteractionNDC.y;
                        }
                        for (var i = 0; i < dataPtsSize; i++) {
                            var finalDp = { value: 0, index: 0 };
                            // special case for quadrant/tirone class of draw styles
                            if (this._initialHitShapeType === 16 /* SERIES_LEFT_RIGHT */) {
                                var quadrantTironeClassUpdater = function (index, initialValue, attribute) {
                                    value_1 = deltaIsAnActualDelta ? _this.attributeSet.get(attribute) : initialValue;
                                    if (ISNAN(value_1)) {
                                        value_1 = data_2.getValueOrIndexAt(scale_1, index);
                                    }
                                    return value_1;
                                };
                                if (i === 0) {
                                    finalDp.value = quadrantTironeClassUpdater(0, this._initialStartDatapoint, 'StartDatapoint');
                                }
                                else {
                                    finalDp.value = quadrantTironeClassUpdater(data_2.getSize() - 1, this._initialEndDatapoint, 'EndDatapoint');
                                }
                            }
                            else {
                                finalDp.value = dim === 1 /* X */ ?
                                    this._dataPointsBeforeInteractionX[i] :
                                    this._dataPointsBeforeInteractionY[i];
                                if (deltaIsAnActualDelta) {
                                    finalDp.value = value_1 = data_2.getValueOrIndexAt(scale_1, i);
                                    finalDp.index = i;
                                }
                                if (data_2.useValueAsIndex) {
                                    finalDp.index = Math.round(finalDp.value);
                                    if (deltaIsAnActualDelta) {
                                        finalDp.index += delta > 0 ? 1 : -1;
                                        delta = 0.0;
                                    }
                                }
                            }
                            dataPts.push(scale_1.applyRevPlotFactorNDC(scale_1.lookup(finalDp.value)) + delta);
                            // scales that useValueAsIndex() offset the datapoints by half the bin to the right, in other words,
                            // every datapoint = datapoints + half bin we add m here so that we limit the NDC by (0.0 + m) to the
                            // right and (1.0 + m) to the left
                            var m = data_2.useValueAsIndex ? (1.0 / scale_1.number) / 2.0 : 0;
                            if (data_2.useValueAsIndex || this._interactivityClamping) {
                                maxx_1 = Math.max(maxx_1, dataPts[i] - (1.0 + m));
                                minx_1 = Math.min(minx_1, -(m - dataPts[i]));
                            }
                        }
                        // convert points to data space
                        dataPts = dataPts.map(function (pt) {
                            return scale_1.computeValue(pt - maxx_1 - minx_1);
                        });
                        if (this._initialHitShapeType === 16 /* SERIES_LEFT_RIGHT */) {
                            dataPts = dataPts.sort(function (a, b) { return a - b; });
                            this.attributeSet.setAt('StartDatapoint', 'user', dataPts[0]);
                            this.attributeSet.setAt('EndDatapoint', 'user', dataPts[1]);
                        }
                        else {
                            data_2.replace(0, dataPts, this.adjustAxes);
                        }
                    }
                }
            }
            return true;
        };
        FDSSeries.prototype._updateStartOrEndIndexAttributes = function (dim, value) {
            if (dim === 1 /* X */) {
                if (this._initialHitShapeType === 14 /* DATAPOINT_LEFT */) {
                    this.attributeSet.setAt('StartDatapoint', 'user', value);
                }
                else if (this._initialHitShapeType === 15 /* DATAPOINT_RIGHT */) {
                    this.attributeSet.setAt('EndDatapoint', 'user', value);
                }
            }
        };
        FDSSeries.prototype._continueToDragSeries = function (point, event, message, snapping) {
            if (snapping === void 0) { snapping = false; }
            var deltaPx = new Point(0, 0);
            var returnValue = false;
            if (message === 2 /* LMBUTTONUP */) {
                if (this.getPlotParent().getSeriesEventMask() & 4 /* DROP */) {
                    var ndc = this._computeValue(this._mousePointerToNDC(point));
                    var dataVec = snapping ?
                        this._prepareSeriesEventVectorSnapped(ndc, this.root.getSnappedSeries())
                        :
                            this._prepareSeriesEventVector(ndc);
                    this.root.fireChartEvent('SeriesDrop', point, dataVec);
                }
            }
            var which = event['which'];
            if ((typeof KeyboardEvent !== 'undefined' && KeyboardEvent != null) && event instanceof KeyboardEvent) {
                deltaPx = Point.zero();
                if (!this._initializeDeltaAccordingToKeys(deltaPx, event)) {
                    return false;
                }
                if (this._initialHitShapeType === 11 /* DATAPOINT_NS */) {
                    deltaPx.x = 0;
                }
                else if (this._initialHitShapeType === 12 /* DATAPOINT_WE */) {
                    deltaPx.y = 0;
                }
                var delta = this._computeNDCFromKeyPress(deltaPx);
                returnValue = this._translateSeries(1 /* X */, delta, false, true) || returnValue;
                returnValue = this._translateSeries(2 /* Y */, delta, false, true) || returnValue;
                if (this.getPlotParent().getSeriesEventMask() & 2 /* DRAG */) {
                    if (this.drawStyle === 59 /* DRAGGABLE_MARKER */) {
                        (point = this.interpolateBetweenPoints(this.attributeSet.get('StartDatapoint')).point);
                        this.root.fireChartEvent('MarkerDatapointDrag', point, [point.x, point.y]);
                    }
                    else {
                        var dataVec = this._prepareSeriesEventVector(delta);
                        this.root.fireChartEvent('SeriesDrag', point, dataVec);
                    }
                }
            }
            else if (which === 1 /* LEFT */ ||
                ((typeof TouchEvent !== 'undefined' && TouchEvent != null) && event instanceof TouchEvent)) {
                var temp = new Point(point.x, point.y);
                if (!snapping) {
                    temp.x -= this._initialOffsetMouseCoordinatesBy.x;
                    temp.y += this._initialOffsetMouseCoordinatesBy.y;
                }
                var ndc = this._mousePointerToNDC(temp);
                if (this._initialHitShapeType === 11 /* DATAPOINT_NS */) {
                    ndc.x = 0;
                }
                else if (this._initialHitShapeType === 12 /* DATAPOINT_WE */) {
                    ndc.y = 0;
                }
                returnValue = this._translateSeries(1 /* X */, ndc, (this.getEffectiveDrawStyle() === 33 /* PTSLOPE */)) ||
                    returnValue;
                if (!event.shiftKey) {
                    returnValue = this._translateSeries(2 /* Y */, ndc, false) || returnValue;
                    if (this.getPlotParent().getSeriesEventMask() & 2 /* DRAG */) {
                        if (this.drawStyle === 59 /* DRAGGABLE_MARKER */) {
                            (point = this.interpolateBetweenPoints(this.attributeSet.get('StartDatapoint')).point);
                            this.root.fireChartEvent('MarkerDatapointDrag', point, [point.x, point.y]);
                        }
                        else {
                            var dataVec = this._prepareSeriesEventVector(this._lastInteractionNDC.subtract(this._initialInteractionNDC));
                            this.root.fireChartEvent('SeriesDrag', point, dataVec);
                        }
                    }
                }
                if (this._initialHitShapeType === 11 /* DATAPOINT_NS */) {
                    this.root.setInteractionCursor(Cursor.SIZENS);
                }
                else if (this._initialHitShapeType === 12 /* DATAPOINT_WE */) {
                    this.root.setInteractionCursor(Cursor.SIZEWE);
                }
            }
            else {
                this.root.setInteractionCursor(Cursor.DEFAULT);
            }
            if (returnValue && (this._regressionData != null)) {
                this._regressionData = null;
            }
            return returnValue;
        };
        FDSSeries.prototype._computeNDCFromKeyPress = function (delta) {
            var ndc = Point.zero();
            ndc.x = this._computeNDCFromKeyPressOnOneDimension(1 /* X */, delta.x);
            ndc.y = this._computeNDCFromKeyPressOnOneDimension(2 /* Y */, delta.y);
            return ndc;
        };
        FDSSeries.prototype._computeNDCFromKeyPressOnOneDimension = function (dim, delta) {
            var data = this.getData(dim);
            if (data) {
                var tmp = 0;
                if (data.getSize() > 0) {
                    tmp = data.getAt(0);
                    var plot = this.getPlotParent();
                    var rect = plot.plotRect;
                    var subrect = rect.copy();
                    var subrectXMaxFactor = plot.getPlotFactor(1 /* X */, 'max');
                    var subrectXMinFactor = plot.getPlotFactor(1 /* X */, 'min');
                    var subrectYMaxFactor = plot.getPlotFactor(2 /* Y */, 'max');
                    var subrectYMinFactor = plot.getPlotFactor(2 /* Y */, 'min');
                    subrect.x1 += subrectXMinFactor * rect.getWidth();
                    subrect.x2 -= (1 - subrectXMaxFactor) * rect.getWidth();
                    subrect.y1 += subrectYMinFactor * rect.getHeight();
                    subrect.y2 -= (1 - subrectYMaxFactor) * rect.getHeight();
                    switch (dim) {
                        case 1 /* X */:
                            if (!fuzzyEQ(subrect.getWidth(), 0)) {
                                return delta / subrect.getWidth();
                            }
                            break;
                        case 2 /* Y */:
                            if (!fuzzyEQ(subrect.getHeight(), 0)) {
                                return delta / subrect.getHeight();
                            }
                            break;
                    }
                }
            }
            return 0;
        };
        FDSSeries.prototype._continueToResize = function (point, event, message) {
            var actualPoint = new Point(0, 0);
            if (message === 1 /* MOUSEMOVE */) {
                actualPoint = point.subtract(this._initialOffsetMouseCoordinatesBy);
            }
            else {
                actualPoint = this._lastInteractionPoint.subtract(this._initialOffsetMouseCoordinatesBy);
            }
            if (!this._processResizeMessages(message, event, actualPoint)) {
                return false;
            }
            this._updateKeysState(message, event);
            if (this._leftMouseButtonDownWhileInteracting || message === 4 /* KEYDOWN */ ||
                message === 5 /* KEYUP */) {
                return this._processLeftMouseButtonDown(point, event, message, actualPoint);
            }
            if (message === 2 /* LMBUTTONUP */) {
                return this._processLeftMouseButtonUp(point, event, message, actualPoint);
            }
            return true;
        };
        FDSSeries.prototype._primaryButton = function (event) {
            if ((typeof MouseEvent !== 'undefined' && MouseEvent != null) && event instanceof MouseEvent) {
                if (event.which === 1 /* LEFT */) {
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        };
        FDSSeries.prototype._continueToDragRL = function (point, event, message) {
            var delta = new Point(0, 0);
            var ndc = new Point(0, 0);
            var effectiveDrawStyle = this.getEffectiveDrawStyle();
            if (message === 2 /* LMBUTTONUP */) {
                if (this.getPlotParent().referenceLineEventMask & 4 /* DROP */) {
                    ndc = this._mousePointerToNDC(point, false);
                    var dataVec = [];
                    var value = void 0;
                    if (effectiveDrawStyle === 16 /* VERTICAL */) {
                        _a = this._updateDataPoint(1 /* X */, ndc.x), value = _a[0], ndc.x = _a[1];
                        dataVec = this._prepareReferenceLineEventVector(value);
                    }
                    else if (effectiveDrawStyle === 17 /* HORIZONTAL */) {
                        _b = this._updateDataPoint(2 /* Y */, ndc.y), value = _b[0], ndc.y = _b[1];
                        dataVec = this._prepareReferenceLineEventVector(value);
                    }
                    this.root.fireChartEvent('ReferenceLineDrop', point, dataVec);
                }
            }
            if ((typeof KeyboardEvent !== 'undefined' && KeyboardEvent != null) && event instanceof KeyboardEvent) {
                if (!this._initializeDeltaAccordingToKeys(delta, event)) {
                    return false;
                }
                var dim = 1;
                switch (effectiveDrawStyle) {
                    case 16 /* VERTICAL */:
                        dim = 1 /* X */;
                        ndc = this._computeNDCFromKeyPress(delta);
                        break;
                    case 17 /* HORIZONTAL */:
                        dim = 2 /* Y */;
                        ndc = this._computeNDCFromKeyPress(delta);
                        break;
                }
                var data = this.getData(dim);
                if (data) {
                    var tmp = 0;
                    if (data.getSize() > 0) {
                        tmp = data.getAt(0);
                    }
                    var value = 0;
                    var scale = this.getAxis(dim).getScale();
                    if (scale) {
                        value = scale.lookup(tmp);
                    }
                    ndc.x += value;
                    ndc.y += value;
                }
                this.root.setInteractionCursor(Cursor.DEFAULT);
            }
            else if (this._primaryButton(event)) {
                ndc = this._mousePointerToNDC(point, false);
                switch (effectiveDrawStyle) {
                    case 16 /* VERTICAL */:
                        this.root.setInteractionCursor(Cursor.SIZEWE);
                        break;
                    case 17 /* HORIZONTAL */:
                        this.root.setInteractionCursor(Cursor.SIZENS);
                        break;
                }
            }
            else {
                this.root.setInteractionCursor(Cursor.DEFAULT);
            }
            if (!ndc.isEqual(new Point(0, 0))) {
                var value = 0;
                switch (effectiveDrawStyle) {
                    case 16 /* VERTICAL */:
                        _c = this._updateDataPoint(1 /* X */, ndc.x), value = _c[0], ndc.x = _c[1];
                        break;
                    case 17 /* HORIZONTAL */:
                        _d = this._updateDataPoint(2 /* Y */, ndc.y), value = _d[0], ndc.x = _d[1];
                        break;
                }
                if (this.getPlotParent().referenceLineEventMask & 2 /* DRAG */) {
                    var dataVec = this._prepareReferenceLineEventVector(value);
                    this.root.fireChartEvent('ReferenceLineDrag', point, dataVec);
                }
                this._lastInteractionPoint = point;
                return true;
            }
            return false;
            var _a, _b, _c, _d;
        };
        FDSSeries.prototype._prepareReferenceLineEventVector = function (value) {
            return [this.id, value.toString()];
        };
        FDSSeries.prototype._prepareSeriesEventVector = function (value) {
            var dataPoint = '-1';
            if (this._initialHitShapeType === 13 /* DATAPOINT */) {
                dataPoint = this._initialSelectedDataPoint.toString();
            }
            var tmpFormat = value.x + "," + value.y;
            return [this.id, tmpFormat, dataPoint];
        };
        FDSSeries.prototype._prepareSeriesEventVectorSnapped = function (value, seriesName) {
            var dataPoint = '-1';
            if (this._initialHitShapeType === 13 /* DATAPOINT */) {
                dataPoint = this._initialSelectedDataPoint.toString();
            }
            var tmpFormat = value.x + "," + value.y;
            return [this.id, tmpFormat, dataPoint, seriesName];
        };
        FDSSeries.prototype._preparePlotLevelAnnotationDropEventVector = function (x, y) {
            return [this.id, x.toString(), y.toString()];
        };
        FDSSeries.prototype._preparePlotLevelAnnotationTextChangeEventVector = function () {
            var vec = [this.id];
            var dataSet = this.getData(0 /* VALUE */);
            if (dataSet) {
                if (dataSet.getSize() > 0) {
                    var str = dataSet.getStringAt(0, 0);
                    vec.push(str);
                }
                else {
                    vec.push('');
                }
            }
            else {
                vec.push('');
            }
            vec.push(this._initialAnnotationText);
            return vec;
        };
        FDSSeries.prototype._initializeDeltaAccordingToKeys = function (delta, event) {
            var numPixels = this.attributeSet.get('AnnotationDraggingStepSizeLarge');
            if (event.ctrlKey) {
                numPixels = this.attributeSet.get('AnnotationDraggingStepSizeSmall');
            }
            switch (event.which) {
                case 37 /* LEFT */:
                    delta.x -= numPixels;
                    break;
                case 39 /* RIGHT */:
                    delta.x += numPixels;
                    break;
                case 38 /* UP */:
                    delta.y += numPixels;
                    break;
                case 40 /* DOWN */:
                    delta.y -= numPixels;
                    break;
                default:
                    return false;
            }
            return true;
        };
        FDSSeries.prototype._updateDataPoint = function (dim, ndc, dataPointIndex, updateDataPoint) {
            if (dataPointIndex === void 0) { dataPointIndex = 0; }
            if (updateDataPoint === void 0) { updateDataPoint = true; }
            var ds = this.getData(dim);
            var axis = this.getAxis(dim);
            var scale = axis.getScale();
            if ((ds != null) && (axis != null) && (scale != null)) {
                // scale ndc according to (min,max)PlotFactor
                var factor = 1;
                var maxPlotFactor = axis.attributeSet.get('maxPlotFactor');
                var minPlotFactor = axis.attributeSet.get('minPlotFactor');
                if (maxPlotFactor !== minPlotFactor) {
                    factor = 1 / (maxPlotFactor - minPlotFactor);
                }
                ndc = (ndc - minPlotFactor) * factor;
                var tmp = this._maybeBound(scale.computeValue(ndc), scale.threshMin, scale.threshMax);
                if (updateDataPoint) {
                    this._replaceDataPoint(dim, dataPointIndex, tmp);
                }
                return [tmp, ndc];
            }
            return [0.0, ndc];
        };
        FDSSeries.prototype._boundDataPoint = function (dim, value) {
            var plot = this.getPlotParent();
            if (!plot) {
                return null;
            }
            var dataSet = this.getData(dim);
            if (!dataSet || dataSet.getSize() === 0) {
                return null;
            }
            var dp = dataSet.getAt(0);
            var axis = this.getAxis(dim);
            if (!axis) {
                return null;
            }
            var scale = axis.getScale();
            if (!scale) {
                return null;
            }
            value = this._maybeBound(dp, scale.threshMin, scale.threshMax);
            if (value !== dp) {
                this._replaceDataPoint(dim, 0, [value]);
            }
            return value;
        };
        FDSSeries.prototype._continueToDrag = function (point, event, message) {
            var delta = new Point(0, 0);
            if ((typeof KeyboardEvent !== 'undefined' && KeyboardEvent != null) && event instanceof KeyboardEvent) {
                if (this._isPlotLevelAnnotation()) {
                    if (message === 2 /* LMBUTTONUP */ || message === 4 /* KEYDOWN */) {
                        var xValue = this._boundDataPoint(1 /* X */, 0);
                        var yValue = this._boundDataPoint(2 /* Y */, 0);
                        if (this.getPlotParent().annotationEventMask & 2 /* DROP */) {
                            var vec = this._preparePlotLevelAnnotationDropEventVector(xValue, yValue);
                            this.root.fireChartEvent('AnnotationDrop', point, vec);
                        }
                        return true;
                    }
                    var p2 = this._dataSpaceToScreenSpace(Point.zero());
                    var p3 = this._dataSpaceToScreenSpace(Point.zero(), true);
                    delta = p2.subtract(p3);
                }
                else {
                    var currentPosition = new Point(this.attributeSet.get('SeriesValueXOffset'), this.attributeSet.get('SeriesValueYOffset'));
                    delta = currentPosition.subtract(this._initialOffsets);
                }
                this._initializeDeltaAccordingToKeys(delta, event);
                delta.y = -delta.y;
            }
            else if (this._primaryButton(event)) {
                delta = point.subtract(this._initialInteractionPoint);
                delta.x = ~~delta.x;
                delta.y = ~~delta.y;
                this.root.setInteractionCursor(Cursor.SIZEALL);
            }
            else {
                this.root.setInteractionCursor(Cursor.DEFAULT);
            }
            if (!delta.isEqual(new Point(0, 0))) {
                if (this._isPlotLevelAnnotation()) {
                    return this._applyOffsetAsDataChange(delta);
                }
                else {
                    this.attributeSet.setAt('SeriesValueXOffset', 'user', this._initialOffsets.x + delta.x);
                    this.attributeSet.setAt('SeriesValueYOffset', 'user', this._initialOffsets.y - delta.y);
                }
                return true;
            }
            return false;
        };
        FDSSeries.prototype._dataSpaceToScreenSpace = function (delta, applyToInitialDataPoint) {
            if (applyToInitialDataPoint === void 0) { applyToInitialDataPoint = false; }
            var subPlotX = function (plot, value) {
                return plot.subPlotFromNDC(value, 1 /* X */);
            };
            var subPlotY = function (plot, value) {
                return plot.subPlotFromNDC(value, 2 /* Y */);
            };
            var plot = this.getPlotParent();
            var pt = delta.copy();
            if (plot == null) {
                return null;
            }
            // find the actual datapoint in screen space
            if (!this._findPointInScreenSpace(1 /* X */, delta, applyToInitialDataPoint, this._initialInteractionDataPoint, subPlotX)) {
                return null;
            }
            if (!this._findPointInScreenSpace(2 /* Y */, delta, applyToInitialDataPoint, this._initialInteractionDataPointAlternate, subPlotY)) {
                return null;
            }
            var rect = plot.plotRect;
            var subrect = rect.copy();
            var subrectXMaxFactor = plot.getPlotFactor(1 /* X */, 'max');
            var subrectXMinFactor = plot.getPlotFactor(1 /* X */, 'min');
            var subrectYMaxFactor = plot.getPlotFactor(2 /* Y */, 'max');
            var subrectYMinFactor = plot.getPlotFactor(2 /* Y */, 'min');
            subrect.x1 += subrectXMinFactor * rect.getWidth();
            subrect.x2 -= (1 - subrectXMaxFactor) * rect.getWidth();
            subrect.y1 += subrectYMinFactor * rect.getHeight();
            subrect.y2 -= (1 - subrectYMaxFactor) * rect.getHeight();
            pt.x += Math.round(subrect.x1);
            pt.y += Math.round(subrect.y1);
            return pt;
        };
        FDSSeries.prototype._findPointInScreenSpace = function (dim, point, applyToInitialDataPoint, initialInteractionDP, subPlot) {
            if (subPlot == null) {
                return false;
            }
            var plot = this.getPlotParent();
            var dataPt = this._getDataPointAt(dim, 0);
            var scale = this.getScale(dim);
            if (!scale) {
                return false;
            }
            var temp = (applyToInitialDataPoint) ?
                Math.round(subPlot(plot, scale.lookup(initialInteractionDP)))
                :
                    Math.round(subPlot(plot, scale.lookup(dataPt.value)));
            if (dim === 1 /* X */) {
                point.x = temp;
            }
            else if (dim === 2 /* Y */) {
                point.y = temp;
            }
            else {
                return false;
            }
            return true;
        };
        FDSSeries.prototype._getDataPointAt = function (dim, index) {
            if (index < 0) {
                return { value: 0, index: 0 };
            }
            var data = this.getData(dim);
            if (!data || data.getSize() < (index - 1)) {
                return { value: 0, index: 0 };
            }
            return { value: data.getAt(index), index: index };
        };
        // Converts the delta (in screen space coordinates) to a data space delta and apply it to the datapoints
        // in data(DIM.X).getAt(0) and data(DIM.Y).getAt(0) or, if applyToInitialDataPoint is true, to
        // the datapoints in @initialInteractionDataPoint and @initialInteractionDataPointAlternate
        FDSSeries.prototype._applyOffsetAsDataChange = function (delta, applyToInitialDataPoint) {
            if (applyToInitialDataPoint === void 0) { applyToInitialDataPoint = true; }
            delta = delta.add(this._initialOffsets);
            if (delta.isEqual(Point.zero())) {
                return false;
            }
            var pointInScreenSpace = Point.zero();
            var subPlotX = function (plot, value) {
                return plot.subPlotFromNDC(value, 1 /* X */);
            };
            var subPlotY = function (plot, value) {
                return plot.subPlotFromNDC(value, 2 /* Y */);
            };
            // 1. find the actual datapoint in screen space
            if (!this._findPointInScreenSpace(1 /* X */, pointInScreenSpace, applyToInitialDataPoint, this._initialInteractionDataPoint, subPlotX)) {
                return false;
            }
            if (!this._findPointInScreenSpace(2 /* Y */, pointInScreenSpace, applyToInitialDataPoint, this._initialInteractionDataPointAlternate, subPlotY)) {
                return false;
            }
            // 2. Add the deltas
            var plot = this.getPlotParent();
            pointInScreenSpace.x += Math.round(plot.plotRect.x1) + delta.x;
            pointInScreenSpace.y += Math.round(plot.plotRect.y1) + delta.y;
            // 3. compute the final point in data space
            var pointInNDCSpace = this._mousePointerToNDC(pointInScreenSpace, false);
            var pointInDataSpaceX;
            var pointInDataSpaceY;
            var xScale = this.getScale(1 /* X */);
            if (xScale) {
                _a = this._updateDataPoint(1 /* X */, pointInNDCSpace.x, 0, false), pointInNDCSpace.x = _a[1];
                pointInDataSpaceX = xScale.computeValueUnbinned(pointInNDCSpace.x);
            }
            var yScale = this.getScale(2 /* Y */);
            if (yScale != null) {
                _b = this._updateDataPoint(2 /* Y */, pointInNDCSpace.y, 0, false), pointInNDCSpace.y = _b[1];
                pointInDataSpaceY = yScale.computeValueUnbinned(pointInNDCSpace.y);
            }
            // 4. replace the datapoint with the result
            if (delta.x !== 0) {
                this._replaceDataPoint(1 /* X */, 0, pointInDataSpaceX);
            }
            if (delta.y !== 0) {
                this._replaceDataPoint(2 /* Y */, 0, pointInDataSpaceY);
            }
            return true;
            var _a, _b;
        };
        FDSSeries.prototype._processLeftMouseButtonDown = function (point, event, message, actualPoint) {
            if (message === 1 /* MOUSEMOVE */) {
                this._lastInteractionPoint = actualPoint.copy();
            }
            this.offsetSigns = new Point(1, 1);
            // limit actualPoint to plot bounds
            if (!this._keepPointInsidePlotBounds(actualPoint)) {
                return false;
            }
            // compute delta and offsetSigns based on which corner has been selected for resizing
            var delta = this._computeInitialDelta(actualPoint);
            // the diameter of the circle is given by the height of the text box only
            // changing the width of the annotation will bring nothing but pain
            if (this.seriesValueDisplayStyle === 1 /* CIRCLE */) {
                delta.x = 0;
            }
            var multiplier = 1;
            if (this.controlKeyDownWhileInteracting) {
                multiplier = 2;
            }
            // adjust delta according to zoom level
            delta.x = Math.round(delta.x * multiplier);
            delta.y = Math.round(delta.y * multiplier);
            if (this.altKeyDownWhileInteracting) {
                delta = this._maintainAspectRatio(delta);
            }
            if (delta.x % 2 !== 0) {
                delta.x -= this.offsetSigns.x;
            }
            if (delta.y % 2 !== 0) {
                delta.y -= this.offsetSigns.y;
            }
            var finalSize = this._initialSize.add(delta);
            var bounds = new Rectangle(0, 0, 0, 0);
            if (!this._getAnnotationBounds(bounds)) {
                return false;
            }
            // this loop will compute the minimum available space in all directions for all the annotations of the series
            // given the textpoint of each one
            this._availableSurroundingSpace = new Rectangle(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
            for (var _i = 0, _a = this.annotationTextpoints; _i < _a.length; _i++) {
                var pt = _a[_i];
                this._computeAvailableSpace(pt, bounds);
            }
            // prevents the annotation from growing outside the plot bounds
            _b = this._stopResizingAnnotationWhenPlotBoundsAreHit(finalSize, delta), finalSize = _b[0], delta = _b[1];
            this._applyFinalSize(finalSize, delta);
            return true;
            var _b;
        };
        FDSSeries.prototype._getAnnotationBounds = function (bounds) {
            var ep = this.getPlotParent();
            if (!ep) {
                return false;
            }
            var leftAdd = ep.getPlotFactor(1 /* X */, 'min') * this.root.getWidth();
            var topAdd = Math.round(this.root.getHeight() - (ep.getPlotFactor(2 /* Y */, 'max') * this.root.getHeight()));
            switch (this.seriesValueBoundMode) {
                case 0 /* PLOT_LEVEL */:
                    bounds.x1 = Math.round(ep.plotRect.x1 + leftAdd);
                    bounds.x2 = Math.round(ep.plotRect.x2 + leftAdd);
                    bounds.y1 = Math.round(ep.plotRect.y1 + topAdd);
                    bounds.y2 = Math.round(ep.plotRect.y2 + topAdd);
                    break;
                case 1 /* CHART_LEVEL */:
                    bounds.x1 = Math.round(leftAdd);
                    bounds.x2 = Math.round(leftAdd + ep.plotRect.getWidth());
                    bounds.y1 = Math.round(this.root.getHeight() - topAdd);
                    bounds.y2 = Math.round(ep.getPlotFactor(1 /* X */, 'min') * this.root.getHeight());
                    break;
            }
            return true;
        };
        FDSSeries.prototype._computeAvailableSpace = function (pt, bounds) {
            var marginv = 0;
            var marginh = 0;
            if (!(this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */ && this._initialSize.x !== 0)) {
                marginh = Math.round(this.seriesValueDisplayMargins);
            }
            if (!(this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */ && this._initialSize.y !== 0)) {
                marginv = Math.round(this.seriesValueDisplayMargins);
            }
            this._availableSurroundingSpace.x1 = Math.min(this._availableSurroundingSpace.x1, Math.max(0, ((pt.x + this._initialOffsets.x) - marginh) - bounds.x1));
            this._availableSurroundingSpace.x2 = Math.min(this._availableSurroundingSpace.x2, Math.max(0, (bounds.x2 - (pt.x + this._initialOffsets.x)) + marginh));
            this._availableSurroundingSpace.y1 = Math.min(this._availableSurroundingSpace.y1, Math.max(0, ((pt.y + this._initialOffsets.y) + marginv) - bounds.y1));
            this._availableSurroundingSpace.y2 = Math.min(this._availableSurroundingSpace.y2, Math.max(0, bounds.y2 - ((pt.y + this._initialOffsets.y) - marginv)));
        };
        FDSSeries.prototype._processLeftMouseButtonUp = function (point, event, message, actualPoint) {
            var usersWidth = this.attributeSet.get('SeriesValueWidthHint');
            if (this.minimumWidth > usersWidth && this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */ &&
                this.controlKeyDownWhileInteracting) {
                this.offsetSigns.x = 0;
            }
            this.root.setInteractionCursor(Cursor.DEFAULT);
            if (this.interactivityMode & 2 /* DRAGGABLE */) {
                this.interactivityStatus = 2 /* DRAGGING */;
            }
            else {
                this.interactivityStatus = 1 /* SELECTION */;
            }
            return true;
        };
        FDSSeries.prototype._finalizeInteraction = function () {
            if ((this.interactivityStatus & 8 /* TEXTEDITING */) && this._previousToolTipStatus != null) {
                this.root.tooltipsEnabled = this._previousToolTipStatus;
                this._previousToolTipStatus = null;
                this.root.hideTextEditingRect();
            }
            this.root.removeFromInteractionList(this);
            this.root.interactionSignal = function (point, eventt, message) {
            };
            this.root.setInteractionCursor(Cursor.DEFAULT);
            this._offsetDifference = new Point(0, 0);
            this.interactivityStatus = 0 /* DISABLED */;
            this.setSelected(false);
            this._lastInteractionPoint = new Point(0, 0);
            this._initialOffsetMouseCoordinatesBy = new Point(0, 0);
            this._initialSize = new Point(0, 0);
            this._sizingModeStartedAsAutomatic = false;
            this._dataPointsBeforeInteractionX = [];
            this._dataPointsBeforeInteractionY = [];
            // reference lines
            this._initialInteractionDataPoint = 0;
            this._initialHitShapeType = -1 /* NONE */;
            // series
            this._shiftPressedInitially = false;
            this._initialInteractionNDC = this._lastInteractionNDC = new Point(0, 0);
            this._initialSlope = 0;
            this._initialInteractionDataPoint = 0;
        };
        FDSSeries.prototype._cancelInteraction = function (resetOffsets, resetSize) {
            if (resetOffsets === void 0) { resetOffsets = true; }
            if (resetSize === void 0) { resetSize = true; }
            if (this.root == null) {
                return false;
            }
            var eventName = '';
            var parameters = [];
            var seriesEventMask = this.getPlotParent().seriesEventMask;
            if (resetOffsets) {
                if (this._isPlotLevelAnnotation()) {
                    this._replaceDataPoint(1 /* X */, 0, this._initialInteractionDataPoint);
                    this._replaceDataPoint(2 /* Y */, 0, this._initialInteractionDataPointAlternate);
                    this.attributeSet.setAt('SeriesValueWidthHint', 'user', this._initialSize.x);
                    this.attributeSet.setAt('SeriesValueHeightHint', 'user', this._initialSize.y);
                    this.seriesValueWidthHint = this._initialSize.x;
                    this.seriesValueHeightHint = this._initialSize.y;
                    if (this.getPlotParent().annotationEventMask & 2 /* DROP */) {
                        eventName = 'AnnotationDrop';
                        parameters = this._preparePlotLevelAnnotationDropEventVector(this._initialInteractionDataPoint, this._initialInteractionDataPointAlternate);
                    }
                }
                else {
                    this.attributeSet.setAt('SeriesValueXOffset', 'user', this._initialOffsets.x);
                    this.attributeSet.setAt('SeriesValueYOffset', 'user', this._initialOffsets.y);
                    if (this.getPlotParent().annotationEventMask & 2 /* DROP */) {
                        eventName = 'AnnotationDrop';
                        parameters = this._preparePlotLevelAnnotationDropEventVector(this._initialOffsets.x, this._initialOffsets.y);
                    }
                }
                switch (this._initialHitShapeType) {
                    case 0 /* SERIES */:
                        var delta = this._initialInteractionNDC.subtract(this._lastInteractionNDC);
                        if (!this._shiftPressedInitially) {
                            this._cancelSeriesTranslation(1 /* X */, delta.x);
                            this._cancelSeriesTranslation(2 /* Y */, delta.y);
                        }
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            var dataValues = this._computeValue(this._initialInteractionNDC);
                            parameters = this._prepareSeriesEventVector(dataValues);
                        }
                        break;
                    case 16 /* SERIES_LEFT_RIGHT */:
                        this.attributeSet.setAt('StartDatapoint', 'user', this._initialStartDatapoint);
                        this.attributeSet.setAt('EndDatapoint', 'user', this._initialEndDatapoint);
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            var dataValues = this._computeValue(this._initialInteractionNDC);
                            parameters = this._prepareSeriesEventVector(dataValues);
                        }
                        break;
                    case 1 /* VERTICAL */:
                        this._replaceDataPoint(1 /* X */, 0, this._initialInteractionDataPoint);
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'ReferenceLineDrop';
                            parameters = this._prepareReferenceLineEventVector(this._initialInteractionDataPoint);
                        }
                        break;
                }
            }
            if (resetSize) {
                this.attributeSet.setAt('SeriesValueWidthHint', 'user', this._initialSize.x);
                this.attributeSet.setAt('SeriesValueHeightHint', 'user', this._initialSize.y);
                this.seriesValueWidthHint = this._initialSize.x;
                this.seriesValueHeightHint = this._initialSize.y;
                var initialSelectedDataPoint = this._initialAlternateDataPoint;
                switch (this._initialHitShapeType) {
                    case 13 /* DATAPOINT */:
                    case 17 /* DATAPOINT_ALTX */:
                        if (this._initialHitShapeType === 13 /* DATAPOINT */) {
                            initialSelectedDataPoint = this._initialSelectedDataPoint;
                        }
                        var eventLocation = new Point(0, 0);
                        if (this._dataPointsBeforeInteractionX.length > 0) {
                            eventLocation.x = this._dataPointsBeforeInteractionX[0];
                            this._replaceDataPoint(1 /* X */, initialSelectedDataPoint, this._dataPointsBeforeInteractionX[0]);
                        }
                        if (this._dataPointsBeforeInteractionY.length > 0) {
                            eventLocation.y = this._dataPointsBeforeInteractionY[0];
                            // We use @initialSelectedDataPoint here on both situations
                            this._replaceDataPoint(2 /* Y */, this._initialSelectedDataPoint, this._dataPointsBeforeInteractionY[0]);
                        }
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            parameters = this._prepareSeriesEventVector(eventLocation);
                        }
                        break;
                    case 11 /* DATAPOINT_NS */:
                        if (this._dataPointsBeforeInteractionY.length > 0) {
                            this._replaceDataPoint(2 /* Y */, this._initialSelectedDataPoint, this._dataPointsBeforeInteractionY[0]);
                        }
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            parameters = this._prepareSeriesEventVector(new Point(this._dataPointsBeforeInteractionX[0], this._dataPointsBeforeInteractionY[0]));
                        }
                        break;
                    case 12 /* DATAPOINT_WE */:
                        if (this._dataPointsBeforeInteractionX.length > 0) {
                            this._replaceDataPoint(1 /* X */, this._initialSelectedDataPoint, this._dataPointsBeforeInteractionX[0]);
                        }
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            parameters = this._prepareSeriesEventVector(new Point(this._dataPointsBeforeInteractionX[0], this._dataPointsBeforeInteractionY[0]));
                        }
                        break;
                    case 14 /* DATAPOINT_LEFT */:
                        this.attributeSet.setAt('StartDatapoint', 'user', this._initialStartDatapoint);
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            parameters = this._prepareSeriesEventVector(new Point(this._dataPointsBeforeInteractionX[0], this._dataPointsBeforeInteractionY[0]));
                        }
                        break;
                    case 15 /* DATAPOINT_RIGHT */:
                        this.attributeSet.setAt('EndDatapoint', 'user', this._initialEndDatapoint);
                        if (seriesEventMask & 4 /* DROP */) {
                            eventName = 'SeriesDrop';
                            parameters = this._prepareSeriesEventVector(new Point(this._dataPointsBeforeInteractionX[0], this._dataPointsBeforeInteractionY[0]));
                        }
                        break;
                }
            }
            // go back to FC_SIZE_DEFAULT if this was the sizing mode used before resizing started
            if (this._sizingModeStartedAsAutomatic) {
                this.attributeSet.setAt('SeriesValueSizingMode', 'user', 0 /* DEFAULT */);
            }
            if (this.interactivityStatus & 8 /* TEXTEDITING */) {
                this.root.setTextEditingContent(this._initialAnnotationText);
                this._replaceDataPoint(0 /* VALUE */, 0, this._initialAnnotationText);
            }
            if (eventName.length !== 0) {
                this.root.fireChartEvent(eventName, new Point(0, 0), parameters);
            }
            this._regressionData = [];
            this._initialInteractionDataPoint = undefined;
            this._initialOffsets = new Point(0, 0);
            this._initialSize = new Point(0, 0);
            this._finalizeInteraction();
            return true;
        };
        FDSSeries.prototype._endInteraction = function (point) {
            if (this.root == null) {
                return false;
            }
            if ((this.interactivityStatus & 8 /* TEXTEDITING */) &&
                (this.getPlotParent().annotationEventMask & 4 /* TEXTCHANGED */)) {
                var params = this._preparePlotLevelAnnotationTextChangeEventVector();
                this.root.fireChartEvent('AnnotationTextChanged', point, params);
            }
            if (this.interactivityMode & (2 /* DRAGGABLE */ | 4 /* RESIZABLE */)) {
                this._initialInteractionDataPoint = undefined;
                this._initialOffsets = new Point(0, 0);
                this._initialSize = new Point(0, 0);
            }
            this._finalizeInteraction();
            return true;
        };
        FDSSeries.prototype._stopResizingAnnotationWhenPlotBoundsAreHit = function (finalSize, delta) {
            // increasing height
            if (delta.y > 0) {
                // Going up
                _a = this._updateSizeAndDelta(-this.offsetSigns.y, finalSize.y, this._initialSize.y, delta.y, this._availableSurroundingSpace.y1, 5 /* HORIZONTAL */), finalSize.y = _a[0], delta.y = _a[1];
                // Going down
                _b = this._updateSizeAndDelta(this.offsetSigns.y, finalSize.y, this._initialSize.y, delta.y, this._availableSurroundingSpace.y2, 5 /* HORIZONTAL */), finalSize.y = _b[0], delta.y = _b[1];
            }
            // increasing width
            if (delta.x > 0) {
                // Going left
                _c = this._updateSizeAndDelta(-this.offsetSigns.x, finalSize.x, this._initialSize.x, delta.x, this._availableSurroundingSpace.x1, 19 /* VERTICAL */), finalSize.x = _c[0], delta.x = _c[1];
                // Going right
                _d = this._updateSizeAndDelta(this.offsetSigns.x, finalSize.x, this._initialSize.x, delta.x, this._availableSurroundingSpace.x2, 19 /* VERTICAL */), finalSize.x = _d[0], delta.x = _d[1];
            }
            return [finalSize, delta];
            var _a, _b, _c, _d;
        };
        FDSSeries.prototype._updateSizeAndDelta = function (offsetSignal, finalSize, initialSize, delta, surroundingSpace, group) {
            if (offsetSignal > 0 || this.controlKeyDownWhileInteracting ||
                (this.altKeyDownWhileInteracting && RMIBelongsToSMG(this.initialHitShapeId, group))) {
                if (finalSize / 2 > surroundingSpace) {
                    finalSize = 2 * surroundingSpace;
                    delta = finalSize - initialSize;
                }
            }
            return [finalSize, delta];
        };
        FDSSeries.prototype._processResizeMessages = function (message, event, point) {
            switch (message) {
                case 5 /* KEYUP */:
                    if (event['which'] === 17 /* CONTROL */ && this.controlKeyDownWhileInteracting) {
                        point.x = this._lastInteractionPoint.x;
                        point.y = this._lastInteractionPoint.y;
                        this.controlKeyDownWhileInteracting = false;
                    }
                    else if (event['which'] === 18 /* ALT */ && this.altKeyDownWhileInteracting) {
                        point.x = this._lastInteractionPoint.x;
                        point.y = this._lastInteractionPoint.y;
                        this.altKeyDownWhileInteracting = false;
                    }
                    else {
                        return false;
                    }
                    break;
                case 2 /* LMBUTTONUP */:
                    this._leftMouseButtonDownWhileInteracting = false;
                    break;
                case 4 /* KEYDOWN */:
                    if (event['which'] === 17 /* CONTROL */) {
                        if (this.controlKeyDownWhileInteracting) {
                            return false;
                        }
                        else {
                            this.controlKeyDownWhileInteracting = true;
                        }
                        point.x = this._lastInteractionPoint.x;
                        point.y = this._lastInteractionPoint.y;
                        if (this._isPlotLevelAnnotation()) {
                            this._replaceDataPoint(1 /* X */, 0, this._initialInteractionDataPoint);
                            this._replaceDataPoint(2 /* Y */, 0, this._initialInteractionDataPointAlternate);
                        }
                    }
                    else if (event['which'] === 18 /* ALT */) {
                        if (this.altKeyDownWhileInteracting) {
                            return false;
                        }
                        else {
                            this.altKeyDownWhileInteracting = true;
                        }
                        point.x = this._lastInteractionPoint.x;
                        point.y = this._lastInteractionPoint.y;
                    }
                    else {
                        return false;
                    }
                    break;
            }
            return true;
        };
        FDSSeries.prototype._keepPointInsidePlotBounds = function (point) {
            var plot = this.getPlotParent();
            if (plot == null) {
                return false;
            }
            var minXFactor = clamp(plot.attributeSet.get('minXFactor'), 0, 1);
            var maxYFactor = clamp(plot.attributeSet.get('maxYFactor'), 0, 1);
            var leftAdd = minXFactor * this.root.getWidth();
            var topAdd = Math.round(this.root.getHeight() - (maxYFactor * this.root.getHeight()));
            var pointInChartSpace = point.copy();
            var plotRect = plot.plotRect;
            if (this.attributeSet.get('SeriesValueBoundMode') === 0 /* PLOT_LEVEL */) {
                if (pointInChartSpace.x < plotRect.x1 + leftAdd) {
                    point.x = Math.round(plotRect.x1 + leftAdd);
                }
                if (pointInChartSpace.x > plotRect.x1 + plotRect.getWidth() + leftAdd) {
                    point.x = Math.round(plotRect.x1 + plotRect.getWidth() + leftAdd);
                }
                if (pointInChartSpace.y < plotRect.y1 + topAdd) {
                    point.y = Math.round(plotRect.y1 + topAdd);
                }
                if (pointInChartSpace.y > plotRect.y1 + plotRect.getHeight() + topAdd) {
                    point.y = Math.round(plotRect.y1 + plotRect.getHeight() + topAdd);
                }
            }
            else {
                if (pointInChartSpace.x < leftAdd) {
                    point.x = Math.round(leftAdd);
                }
                if (pointInChartSpace.x > plotRect.getWidth() + leftAdd) {
                    point.x = Math.round(plotRect.getWidth() + leftAdd);
                }
                if (pointInChartSpace.y < topAdd) {
                    point.y = Math.round(this.root.getHeight() - topAdd);
                }
                if (pointInChartSpace.y > Math.round(plotRect.getHeight() + topAdd)) {
                    point.y = Math.round(this.root.getHeight() - (plotRect.getHeight() + topAdd));
                }
            }
            return true;
        };
        FDSSeries.prototype._updateKeysState = function (message, event) {
            if (!event.ctrlKey && this.controlKeyDownWhileInteracting) {
                this.controlKeyDownWhileInteracting = false;
            }
            if (!event.altKey && this.altKeyDownWhileInteracting) {
                this.altKeyDownWhileInteracting = false;
            }
            var isTouchEvent = typeof TouchEvent !== 'undefined' && TouchEvent != null && event instanceof TouchEvent;
            this._leftMouseButtonDownWhileInteracting = (message === 1 /* MOUSEMOVE */) &&
                (event.which === 1 /* LEFT */ || isTouchEvent);
        };
        FDSSeries.prototype._computeInitialDelta = function (point) {
            var delta = new Point(0, 0);
            if (RMIBelongsToSMG(this.initialHitShapeId, 7 /* NORTH */)) {
                delta.y = ~~(this._initialInteractionPoint.y - point.y);
                this.offsetSigns.y = -1;
            }
            else if (RMIBelongsToSMG(this.initialHitShapeId, 11 /* SOUTH */)) {
                delta.y = ~~(point.y - this._initialInteractionPoint.y);
            }
            else {
                delta.y = this.offsetSigns.y = 0;
            }
            if (RMIBelongsToSMG(this.initialHitShapeId, 13 /* EAST */)) {
                delta.x = ~~(point.x - this._initialInteractionPoint.x);
            }
            else if (RMIBelongsToSMG(this.initialHitShapeId, 3 /* WEST */)) {
                delta.x = ~~(this._initialInteractionPoint.x - point.x);
                this.offsetSigns.x = -1;
            }
            else {
                delta.x = this.offsetSigns.x = 0;
            }
            return delta;
        };
        FDSSeries.prototype.setCurrentAnnotationTextBoxSize = function (width, height) {
            this._currentAnnotationTextBoxSize = new Point(width, height);
        };
        FDSSeries.prototype._getCurrentAnnotationRect = function () {
            if (this.annotationTextpoints.length < 1) {
                return new Rectangle(-1, -1, -1, -1);
            }
            var x1 = this.annotationTextpoints[0].x - (this._currentAnnotationTextBoxSize.x / 2);
            var x2 = this.annotationTextpoints[0].x + (this._currentAnnotationTextBoxSize.x / 2);
            var y1 = this.annotationTextpoints[0].y - (this._currentAnnotationTextBoxSize.y / 2);
            var y2 = this.annotationTextpoints[0].y + (this._currentAnnotationTextBoxSize.y / 2);
            return new Rectangle(x1, y1, x2, y2);
        };
        FDSSeries.prototype._getAnnotationStyleInCSS = function () {
            var style = this.seriesLabelFont.toCSSStyle();
            var rect = this._getCurrentAnnotationRect();
            var clientRect = {
                left: 0,
                top: 0,
                right: rect.getWidth(),
                width: rect.getWidth(),
                bottom: rect.getHeight(),
                height: rect.getHeight()
            };
            if (this.seriesLabelBrush.style === 1 /* NULL */ || this.seriesLabelBrush.alpha !== 255) {
                var brush = new FDSBrush();
                brush.style = 0 /* SOLID */;
                brush.color = 16777215 /* WHITE */;
                style.background = brush.toCSSStyle(clientRect);
            }
            else {
                style.background = this.seriesLabelBrush.toCSSStyle(clientRect);
            }
            style.textAlign = 'center';
            style.verticalAlign = 'middle';
            return style;
        };
        FDSSeries.prototype._recomputeAvailableSpace = function (surroundingSpace, xoff, finalSize, sign) {
            var tmp = Math.round(surroundingSpace - (sign * xoff));
            if (Math.round(finalSize / 2) !== tmp) {
                var ox = (finalSize / 2) - tmp;
                finalSize -= Math.round(ox);
                xoff -= sign * (ox / 2);
            }
            return [xoff, finalSize];
        };
        FDSSeries.prototype._applyFinalSize = function (finalSize, delta) {
            finalSize.x = Math.max(Math.abs(this._seriesValueMinimumTextBoxSize), finalSize.x);
            finalSize.y = Math.max(Math.abs(this._seriesValueMinimumTextBoxSize), finalSize.y);
            // if text box is equal to minimumTextBoxSize, make its sizing mode be hint
            if ((finalSize.isEqual(new Point(this._seriesValueMinimumTextBoxSize, this._seriesValueMinimumTextBoxSize)) ||
                (finalSize.y === this._seriesValueMinimumTextBoxSize &&
                    this.seriesValueDisplayStyle === 1 /* CIRCLE */)) &&
                this.seriesValueSizingMode === 2 /* CUSTOM_FORCE */ &&
                this.attributeSet.get('SeriesValueAutomaticSizingModeWhenCollapsed')) {
                this.attributeSet.setAt('SeriesValueSizingMode', 'user', 0 /* DEFAULT */);
                this.attributeSet.setAt('SeriesValueWidthHint', 'user', finalSize.x);
                this.attributeSet.setAt('SeriesValueHeightHint', 'user', finalSize.y);
                this.seriesValueWidthHint = this._initialSize.x;
                this.seriesValueHeightHint = this._initialSize.y;
                this.seriesValueWidthHint = this._finalSize.x;
                this.seriesValueHeightHint = this._finalSize.y;
                this._currentAnnotationTextBoxSize = new Point(0, 0);
                this._initialSize = new Point(0, 0);
                this.offsetSigns = new Point(0, 0);
                // do not reset SeriesValue{Width|Height}Hint because we want them to be equal to finalSize
                this._cancelInteraction(true, false);
            }
            else {
                if (!this.controlKeyDownWhileInteracting) {
                    var xoff = 0.0;
                    var yoff = 0.0;
                    // x axis
                    _a = this._computeFinalOffset(xoff, finalSize.x, this.offsetSigns.x, delta.x, this._initialSize.x, this._availableSurroundingSpace.x2, this._availableSurroundingSpace.x1), xoff = _a[0], finalSize.x = _a[1];
                    // y axis
                    _b = this._computeFinalOffset(yoff, finalSize.y, this.offsetSigns.y, delta.y, this._initialSize.y, this._availableSurroundingSpace.y2, this._availableSurroundingSpace.y1), yoff = _b[0], finalSize.y = _b[1];
                    if (this._isPlotLevelAnnotation()) {
                        this._applyOffsetAsDataChange(new Point(xoff, yoff), true);
                    }
                    else {
                        this.attributeSet.setAt('SeriesValueXOffset', 'user', this._initialOffsets.x + xoff);
                        this.attributeSet.setAt('SeriesValueYOffset', 'user', this._initialOffsets.y - yoff);
                    }
                }
                else {
                    this.attributeSet.setAt('SeriesValueXOffset', 'user', this._initialOffsets.x);
                    this.attributeSet.setAt('SeriesValueYOffset', 'user', this._initialOffsets.y);
                }
                this.attributeSet.setAt('SeriesValueWidthHint', 'user', finalSize.x);
                this.attributeSet.setAt('SeriesValueHeightHint', 'user', finalSize.y);
                this.seriesValueWidthHint = this._initialSize.x;
                this.seriesValueHeightHint = this._initialSize.y;
                // set interaction cursor
                if (this.initialHitShapeId === 91 /* NE */ || this.initialHitShapeId === 33 /* SW */) {
                    this.root.setInteractionCursor(Cursor.SIZENESW);
                }
                else if (this.initialHitShapeId === 63 /* NW */ || this.initialHitShapeId === 143 /* SE */) {
                    this.root.setInteractionCursor(Cursor.SIZENWSE);
                }
                else if (RMIBelongsToSMG(this.initialHitShapeId, 19 /* VERTICAL */)) {
                    this.root.setInteractionCursor(Cursor.SIZENS);
                }
                else if (RMIBelongsToSMG(this.initialHitShapeId, 5 /* HORIZONTAL */)) {
                    this.root.setInteractionCursor(Cursor.SIZEWE);
                }
            }
            return [finalSize, delta];
            var _a, _b;
        };
        FDSSeries.prototype._computeFinalOffset = function (offset, finalSize, offsetSignal, delta, initialSize, side1, side2) {
            if (finalSize > this._seriesValueMinimumTextBoxSize) {
                offset = (offsetSignal * (delta * 0.5));
            }
            else {
                offset = -(offsetSignal * ((initialSize - this._seriesValueMinimumTextBoxSize) * 0.5));
            }
            // since the offset change, we need to recompute the available space around the annotation
            if (offsetSignal > 0 && delta > 0 && ((finalSize / 2.0) >= (side1 + offset))) {
                _a = this._recomputeAvailableSpace(side1, offset, finalSize, 1), offset = _a[0], finalSize = _a[1];
            }
            if (offsetSignal < 0 && delta > 0 && ((finalSize / 2.0) >= (side2 - offset))) {
                _b = this._recomputeAvailableSpace(side2, offset, finalSize, -1), offset = _b[0], finalSize = _b[1];
            }
            return [offset, finalSize];
            var _a, _b;
        };
        // Keeps the aspect ratio for the delta. Does not modify delta.
        //
        // @param delta [Point] Delta to use
        // @return [Point] new delta with modified aspect ratio
        FDSSeries.prototype._maintainAspectRatio = function (delta) {
            var ratio = this._initialSize.x / this._initialSize.y;
            var p = delta.copy();
            if (RMIBelongsToSMG(this.initialHitShapeId, 19 /* VERTICAL */) ||
                this._initialSize.x < this._initialSize.y) {
                p.x = Math.round(p.y * ratio);
            }
            else if (RMIBelongsToSMG(this.initialHitShapeId, 5 /* HORIZONTAL */) ||
                this._initialSize.x > this._initialSize.y) {
                p.y = Math.round((1 / ratio) * p.x);
            }
            return p;
        };
        FDSSeries.prototype.shadeHitshapes = function () {
            var ctx = this.root.getUIContext();
            for (var _i = 0, _a = this.hitVector; _i < _a.length; _i++) {
                var shape = _a[_i];
                shape.shadeShape(ctx);
            }
        };
        FDSSeries.prototype.onUpdateText = function () {
            var str = this.root.getTextEditingContent();
            this._replaceDataPoint(0 /* VALUE */, 0, str);
            this.root.setTextEditRect(this._getCurrentAnnotationRect());
            this.root.renderManager.draw(false);
        };
        FDSSeries.prototype.cancelTextEdit = function () {
            this._cancelInteraction(false, false);
            this.root.hideTextEditingRect();
            this.root.emptyInteractionList();
            this.root.draw();
        };
        FDSSeries.prototype.processEventHandling = function (event, pick$$1, point) {
            // args is the point of the event, and the index we clicked on of the series
            var args = [point, pick$$1.accessSubObject()];
            this.wrapper.handleEvent(event, args);
        };
        FDSSeries.prototype.getPropertyUsage = function (usedPropertiesMap) {
            if (this.root.propertyUsageManager.isTrackingProperties()) {
                // This technically works if it's after super.getPropertyUsage since this is called multiple times per series,
                // but being consistent with FDSChart.getPropertiesUsage.
                this._getPropertyUsageForUnrenderedAttributes();
            }
            _super.prototype.getPropertyUsage.call(this, usedPropertiesMap);
        };
        FDSSeries.prototype._getPropertyUsageForUnrenderedAttributes = function () {
            this._tooltipText.main.fromValue();
            this._tooltipText.alt.fromValue();
            this._tooltipText.center.fromValue();
        };
        FDSSeries.prototype._getDefaultTooltipText = function () {
            return '<FDSDataTooltip>';
        };
        FDSSeries.prototype.getHeatmapColorScaleMinMax = function () {
            var _a = this.getDrawStylePrototype(), drawStyle = _a.drawStyle, drawStyleEnum = _a.drawStyleEnum;
            return drawStyle.getColorScaleRange();
        };
        FDSSeries.selector = 'FDSSeries';
        return FDSSeries;
    }(FDSChartObject));
    var FDSSeriesStyle = /** @class */ (function (_super) {
        __extends(FDSSeriesStyle, _super);
        function FDSSeriesStyle(root, id) {
            return _super.call(this, root, id) || this;
        }
        FDSSeriesStyle.prototype._init = function () {
            this.isStyleObject = true;
            this.type = 11 /* FC_SERIES_STYLE */;
            _super.prototype._init.call(this);
        };
        return FDSSeriesStyle;
    }(FDSSeries));
    // Be careful when using this, we only verify the left data point because
    // the right starts with negative or positive infinity. Checking that for NA
    // will break things. Also, as a result of how this is consumed right cannot
    // be NA since we always check left and that's what sets right.
    function DataPtLess(left, right) {
        if (IsNA(left.value)) {
            return false;
        }
        return left.value < right.value;
    }
    function DataPtGreater(left, right) {
        if (IsNA(left.value)) {
            return false;
        }
        return left.value > right.value;
    }
    function convertResizingMarkerNametoId(resizingMarkerName) {
        if (resizingMarkerName === 14 /* DATAPOINTNW */) {
            return 63 /* NW */;
        }
        if (resizingMarkerName === 9 /* DATAPOINTN */) {
            return 133 /* N */;
        }
        if (resizingMarkerName === 13 /* DATAPOINTNE */) {
            return 91 /* NE */;
        }
        if (resizingMarkerName === 11 /* DATAPOINTE */) {
            return 65 /* E */;
        }
        if (resizingMarkerName === 12 /* DATAPOINTW */) {
            return 45 /* W */;
        }
        if (resizingMarkerName === 15 /* DATAPOINTSE */) {
            return 143 /* SE */;
        }
        if (resizingMarkerName === 16 /* DATAPOINTSW */) {
            return 33 /* SW */;
        }
        if (resizingMarkerName === 10 /* DATAPOINTS */) {
            return 209 /* S */;
        }
        return 0 /* NONE */;
    }
    
    /**
     * Class for logging changes to attributes
     *
     * @class FDSStateLog
     */
    var FDSStateLog = /** @class */ (function () {
        /**
         * Creates an instance of FDSStateLog.
         */
        function FDSStateLog() {
            this._log = {};
        }
        /**
         * Update the existing state log entry or create a new one with information about an attribute change.
         *
         * @param object - the FDSChartObject that changed.
         * @param id - the name of the attribute that changed.
         * @param level - the level the attribute changed at (user or app)
         * @param value - the new attribute value, undefined if being reset
         * @param oldValue - the previous attribute value, undefined if unset
         */
        FDSStateLog.prototype.updateAttr = function (object, id, level, value, oldValue) {
            var obj = this._log[object.id] = this._log[object.id] || {};
            var attr = obj[id] = obj[id] || {};
            var reset = value === undefined;
            if (!attr[level]) {
                // initialize the attr object to be not reset,
                // and save the old value
                attr[level] = {
                    reset: reset,
                    current: value,
                    old: oldValue
                };
            }
            else {
                // Don't set the old value if we already have a log entry.
                attr[level].reset = reset;
                attr[level].current = value;
            }
        };
        /**
         * Converts the state log information to the serialized state log format.
         *
         * @returns a json object
         */
        FDSStateLog.prototype.toJson = function () {
            var json = [];
            for (var objID in this._log) {
                var obj = this._log[objID];
                var objJSON = {
                    name: objID,
                    SET_RESET_FLAGS: [],
                    SET_RESET_ROOT_FLAGS: [],
                    SET_NO_FLAGS: [],
                    SET_APP_FLAGS: []
                };
                for (var attrName in obj) {
                    var attrObj = obj[attrName];
                    for (var level in attrObj) {
                        var attr = attrObj[level];
                        if (attr === undefined) {
                            continue;
                        }
                        if (attr.old === attr.current) {
                            continue;
                        }
                        var entry = { name: attrName, oldValue: attr.old };
                        if (attr.reset) {
                            if (level === 'app') {
                                objJSON.SET_RESET_ROOT_FLAGS.push(entry);
                            }
                            else {
                                objJSON.SET_RESET_FLAGS.push(entry);
                            }
                        }
                        else {
                            entry.newValue = attr.current;
                            if (level === 'app') {
                                objJSON.SET_APP_FLAGS.push(entry);
                            }
                            else {
                                objJSON.SET_NO_FLAGS.push(entry);
                            }
                        }
                    }
                }
                json.push(objJSON);
            }
            return json;
        };
        return FDSStateLog;
    }());
    
    var LoggingWhitelist = {
        FDSChartObject: {
            'Label': false,
            'Menu': false,
            'MenuXML': false,
            'Style': false,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipText': false
        },
        FDSAxis: {
            'Alias': true,
            'AlternatingBackground': true,
            'AlternatingBackgroundFactor': false,
            'AutomaticHolidayDetection': true,
            'AutomaticStartEndDayDetection': true,
            'Axis': true,
            'AxisFGColor': false,
            'AxisFGDashFactor': false,
            'AxisFGLineCap': true,
            'AxisFGStyle': true,
            'AxisFGWidth': false,
            'AxisOffset': false,
            'AxisPosition': true,
            'AxisSeries': false,
            'BaseRangesOnIntervals': true,
            'Bin': true,
            'BinFactor': false,
            'BinLabelMode': true,
            'BinMinorLabelMode': true,
            'CrosshairsLabel': true,
            'CrosshairsLabelDrawnWithoutAxisLabels': true,
            'CrosshairsLabelFontAlignment': false,
            'CrosshairsLabelFontColor': false,
            'CrosshairsLabelFontEscapement': false,
            'CrosshairsLabelFontFamily': true,
            'CrosshairsLabelFontHeight': false,
            'CrosshairsLabelFontItalic': true,
            'CrosshairsLabelFontTruncate': true,
            'CrosshairsLabelFontTruncateString': false,
            'CrosshairsLabelFontUnderline': true,
            'CrosshairsLabelFontWeight': false,
            'CrosshairsLabelFontWidthHint': false,
            'CrosshairsLabelShowText': true,
            'CrosshairsLabelText': false,
            'CrosshairsLabelTextBox': true,
            'CrosshairsLabelTextBoxArrowMultiplier': false,
            'CrosshairsLabelTextBoxBGAlpha': false,
            'CrosshairsLabelTextBoxBGColor': false,
            'CrosshairsLabelTextBoxBGGradientAlpha': false,
            'CrosshairsLabelTextBoxBGGradientAngle': false,
            'CrosshairsLabelTextBoxBGGradientColor': false,
            'CrosshairsLabelTextBoxBGGradientFactor': false,
            'CrosshairsLabelTextBoxBGGradientStyle': true,
            'CrosshairsLabelTextBoxBGImageName': false,
            'CrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'CrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'CrosshairsLabelTextBoxBGStyle': true,
            'CrosshairsLabelTextBoxClipText': true,
            'CrosshairsLabelTextBoxDisplayMargins': false,
            'CrosshairsLabelTextBoxDisplayStyle': true,
            'CrosshairsLabelTextBoxFGColor': false,
            'CrosshairsLabelTextBoxFGDashFactor': false,
            'CrosshairsLabelTextBoxFGLineCap': true,
            'CrosshairsLabelTextBoxFGStyle': true,
            'CrosshairsLabelTextBoxFGWidth': false,
            'CrosshairsLabelTextBoxHeightHint': false,
            'CrosshairsLabelTextBoxPlacement': false,
            'CrosshairsLabelTextBoxSizingMode': true,
            'CrosshairsLabelTextBoxWidthHint': false,
            'DateLabelShift': false,
            'DateMinorLabelShift': false,
            'DisplayHolidays': true,
            'EndLabelLeftFormat': false,
            'EndLabelLeftPosition': true,
            'EndLabelMinorLeftFormat': false,
            'EndLabelMinorLeftPosition': true,
            'EndLabelMinorRightFormat': false,
            'EndLabelMinorRightPosition': true,
            'EndLabelRightFormat': false,
            'EndLabelRightPosition': true,
            'EndLabelSnapToDatapoint': true,
            'EndMinorLabelSnapToDatapoint': true,
            'ExtendMajorTicks': true,
            'ExtendMinorTicks': true,
            'FadeNonZoomedRegion': true,
            'Font2Alignment': false,
            'Font2Color': false,
            'Font2Escapement': false,
            'Font2Family': true,
            'Font2Height': false,
            'Font2Italic': true,
            'Font2Truncate': true,
            'Font2TruncateString': false,
            'Font2Underline': true,
            'Font2Weight': false,
            'Font2WidthHint': false,
            'FontAlignment': false,
            'FontColor': false,
            'FontEscapement': false,
            'FontFamily': true,
            'FontHeight': false,
            'FontItalic': true,
            'FontTruncate': true,
            'FontTruncateString': false,
            'FontUnderline': true,
            'FontWeight': false,
            'FontWidthHint': false,
            'ForceEndLabels': true,
            'ForceMinorEndLabels': true,
            'Grid': true,
            'GridFGColor': false,
            'GridFGDashFactor': false,
            'GridFGLineCap': true,
            'GridFGStyle': true,
            'GridFGWidth': false,
            'HLBinsHint': false,
            'HolidayDataset': false,
            'IgnoreIntradayScaleLeastVisibleInterval': true,
            'InnerBinPadding': false,
            'IntradayLabeling': true,
            'IntradayLabelingMask': true,
            'IntradayScaleLabelFormatDAY': false,
            'IntradayScaleLabelFormatFIVEMINUTE': false,
            'IntradayScaleLabelFormatFIVESECOND': false,
            'IntradayScaleLabelFormatFIVEY': false,
            'IntradayScaleLabelFormatHALFHOUR': false,
            'IntradayScaleLabelFormatHALFMINUTE': false,
            'IntradayScaleLabelFormatHALFY': false,
            'IntradayScaleLabelFormatHOUR': false,
            'IntradayScaleLabelFormatMINUTE': false,
            'IntradayScaleLabelFormatMONTH': false,
            'IntradayScaleLabelFormatNONE': false,
            'IntradayScaleLabelFormatQUARTER': false,
            'IntradayScaleLabelFormatSECOND': false,
            'IntradayScaleLabelFormatSIXHOUR': false,
            'IntradayScaleLabelFormatTENMINUTE': false,
            'IntradayScaleLabelFormatTENSECOND': false,
            'IntradayScaleLabelFormatTENY': false,
            'IntradayScaleLabelFormatTWOHOUR': false,
            'IntradayScaleLabelFormatTWOMINUTE': false,
            'IntradayScaleLabelFormatTWOSECOND': false,
            'IntradayScaleLabelFormatTWOY': false,
            'IntradayScaleLabelFormatWEEK': false,
            'IntradayScaleLabelFormatYEAR': false,
            'IntradayScaleLengthForPartialDays': true,
            'IntradayScaleMajorUnitBGAlpha': false,
            'IntradayScaleMajorUnitBGColor': false,
            'IntradayScaleMajorUnitBGGradientAlpha': false,
            'IntradayScaleMajorUnitBGGradientAngle': false,
            'IntradayScaleMajorUnitBGGradientColor': false,
            'IntradayScaleMajorUnitBGGradientFactor': false,
            'IntradayScaleMajorUnitBGGradientStyle': true,
            'IntradayScaleMajorUnitBGImageName': false,
            'IntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'IntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'IntradayScaleMajorUnitBGStyle': true,
            'IntradayScaleMinorLabelFormatDAY': false,
            'IntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'IntradayScaleMinorLabelFormatFIVESECOND': false,
            'IntradayScaleMinorLabelFormatFIVEY': false,
            'IntradayScaleMinorLabelFormatHALFHOUR': false,
            'IntradayScaleMinorLabelFormatHALFMINUTE': false,
            'IntradayScaleMinorLabelFormatHALFY': false,
            'IntradayScaleMinorLabelFormatHOUR': false,
            'IntradayScaleMinorLabelFormatMINUTE': false,
            'IntradayScaleMinorLabelFormatMONTH': false,
            'IntradayScaleMinorLabelFormatNONE': false,
            'IntradayScaleMinorLabelFormatQUARTER': false,
            'IntradayScaleMinorLabelFormatSECOND': false,
            'IntradayScaleMinorLabelFormatSIXHOUR': false,
            'IntradayScaleMinorLabelFormatTENMINUTE': false,
            'IntradayScaleMinorLabelFormatTENSECOND': false,
            'IntradayScaleMinorLabelFormatTENY': false,
            'IntradayScaleMinorLabelFormatTWOHOUR': false,
            'IntradayScaleMinorLabelFormatTWOMINUTE': false,
            'IntradayScaleMinorLabelFormatTWOSECOND': false,
            'IntradayScaleMinorLabelFormatTWOY': false,
            'IntradayScaleMinorLabelFormatWEEK': false,
            'IntradayScaleMinorLabelFormatYEAR': false,
            'IntradayScaleMinorRangeDAY': false,
            'IntradayScaleMinorRangeFIVEMINUTE': false,
            'IntradayScaleMinorRangeFIVESECOND': false,
            'IntradayScaleMinorRangeFIVEY': false,
            'IntradayScaleMinorRangeHALFHOUR': false,
            'IntradayScaleMinorRangeHALFMINUTE': false,
            'IntradayScaleMinorRangeHALFY': false,
            'IntradayScaleMinorRangeHOUR': false,
            'IntradayScaleMinorRangeMINUTE': false,
            'IntradayScaleMinorRangeMONTH': false,
            'IntradayScaleMinorRangeNONE': false,
            'IntradayScaleMinorRangeQUARTER': false,
            'IntradayScaleMinorRangeSECOND': false,
            'IntradayScaleMinorRangeSIXHOUR': false,
            'IntradayScaleMinorRangeTENMINUTE': false,
            'IntradayScaleMinorRangeTENSECOND': false,
            'IntradayScaleMinorRangeTENY': false,
            'IntradayScaleMinorRangeTWOHOUR': false,
            'IntradayScaleMinorRangeTWOMINUTE': false,
            'IntradayScaleMinorRangeTWOSECOND': false,
            'IntradayScaleMinorRangeTWOY': false,
            'IntradayScaleMinorRangeWEEK': false,
            'IntradayScaleMinorRangeYEAR': false,
            'IntradayScaleRangeDAY': false,
            'IntradayScaleRangeFIVEMINUTE': false,
            'IntradayScaleRangeFIVESECOND': false,
            'IntradayScaleRangeFIVEY': false,
            'IntradayScaleRangeHALFHOUR': false,
            'IntradayScaleRangeHALFMINUTE': false,
            'IntradayScaleRangeHALFY': false,
            'IntradayScaleRangeHOUR': false,
            'IntradayScaleRangeMINUTE': false,
            'IntradayScaleRangeMONTH': false,
            'IntradayScaleRangeNONE': false,
            'IntradayScaleRangeQUARTER': false,
            'IntradayScaleRangeSECOND': false,
            'IntradayScaleRangeSIXHOUR': false,
            'IntradayScaleRangeTENMINUTE': false,
            'IntradayScaleRangeTENSECOND': false,
            'IntradayScaleRangeTENY': false,
            'IntradayScaleRangeTWOHOUR': false,
            'IntradayScaleRangeTWOMINUTE': false,
            'IntradayScaleRangeTWOSECOND': false,
            'IntradayScaleRangeTWOY': false,
            'IntradayScaleRangeWEEK': false,
            'IntradayScaleRangeYEAR': false,
            'Label': true,
            'LabelAnchor': false,
            'LabelCentered': true,
            'LabelCentered2': true,
            'LabelFormat': false,
            'LabelFormat2': false,
            'LabelMinorPadding': false,
            'LabelOffset': false,
            'LabelOverride': false,
            'LabelPadded': true,
            'LabelPosition': true,
            'LabelPostfix': false,
            'LabelPostfix2': false,
            'LabelPrefix': false,
            'LabelPrefix2': false,
            'LabelTooltipEnabled': true,
            'LabelTooltipText': false,
            'LabelsLevelsMask': true,
            'Log': true,
            'MajorTickMultiplier': false,
            'MajorTickSnapToDate': true,
            'MajorUnitStart': false,
            'Menu': false,
            'MenuXML': false,
            'MinorGrid': true,
            'MinorGridFGColor': false,
            'MinorGridFGDashFactor': false,
            'MinorGridFGLineCap': true,
            'MinorGridFGStyle': true,
            'MinorGridFGWidth': false,
            'MinorGridInheritsColor': true,
            'MinorTickDateBin': true,
            'MinorTickMultiplier': false,
            'MinorTickOffset': false,
            'MinorTickSnapToDate': true,
            'MinorTicks': true,
            'MinorTicksLengthFactor': false,
            'MinorUnitEnd': false,
            'MinorUnitStart': false,
            'OutlierAxis': true,
            'OutlierAxisDynamic': true,
            'OutlierAxisDynamicThreshold': false,
            'OutlierAxisMarginMax': false,
            'OutlierAxisMarginMin': false,
            'OutlierAxisThreshMax': false,
            'OutlierAxisThreshMin': false,
            'OutlierIndicator': true,
            'OutlierIndicatorBGAlpha': false,
            'OutlierIndicatorBGColor': false,
            'OutlierIndicatorBGGradientAlpha': false,
            'OutlierIndicatorBGGradientAngle': false,
            'OutlierIndicatorBGGradientColor': false,
            'OutlierIndicatorBGGradientFactor': false,
            'OutlierIndicatorBGGradientStyle': true,
            'OutlierIndicatorBGImageName': false,
            'OutlierIndicatorBGRadialGradientOffsetX': false,
            'OutlierIndicatorBGRadialGradientOffsetY': false,
            'OutlierIndicatorBGStyle': true,
            'OutlierIndicatorFGColor': false,
            'OutlierIndicatorFGDashFactor': false,
            'OutlierIndicatorFGLineCap': true,
            'OutlierIndicatorFGStyle': true,
            'OutlierIndicatorFGWidth': false,
            'OutlierIndicatorFactor': false,
            'OutlierIndicatorMarkerSize': false,
            'OutlierIndicatorMarkerStyle': true,
            'Reference': false,
            'ReferenceLine': true,
            'ReferenceLineFGColor': false,
            'ReferenceLineFGDashFactor': false,
            'ReferenceLineFGLineCap': true,
            'ReferenceLineFGStyle': true,
            'ReferenceLineFGWidth': false,
            'RefreshAxis': true,
            'RemoveGapsFromMajorIntervals': true,
            'RemoveGapsFromMinorIntervals': true,
            'Reverse': true,
            'RoundMinMax': true,
            'SecondaryFrequency': true,
            'ShowMajorUnitWhenNoTicks': true,
            'Style': false,
            'SubBinLabels': false,
            'SubBinLabelsDefault': false,
            'ThreshConsider': true,
            'ThreshConsiderFactor': false,
            'ThreshConsiderValue': false,
            'ThreshMax': false,
            'ThreshMaxMargin': false,
            'ThreshMin': false,
            'ThreshMinMargin': false,
            'TickBin': true,
            'TickDateBin': true,
            'TickMode': true,
            'TickOffset': false,
            'TickSafety': false,
            'Ticks': true,
            'TicksFGColor': false,
            'TicksFGDashFactor': false,
            'TicksFGLineCap': true,
            'TicksFGStyle': true,
            'TicksFGWidth': false,
            'TicksLength': false,
            'TicksOffset': false,
            'TicksPosition': true,
            'TicksResize': true,
            'Title': true,
            'TitleAtEnd': true,
            'TitleFontAlignment': false,
            'TitleFontColor': false,
            'TitleFontEscapement': false,
            'TitleFontFamily': true,
            'TitleFontHeight': false,
            'TitleFontItalic': true,
            'TitleFontTruncate': true,
            'TitleFontTruncateString': false,
            'TitleFontUnderline': true,
            'TitleFontWeight': false,
            'TitleFontWidthHint': false,
            'TitleOffset': false,
            'TitlePosition': true,
            'TitleRotationMode': true,
            'TitleText': false,
            'TitleTieWithEndLabel': true,
            'TitleValuePosition': true,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipText': false,
            'TreatWeekendsAsHolidays': true,
            'WeekType': true,
            'ZoomDefaultMax': false,
            'ZoomDefaultMin': false,
            'ZoomEnabled': true,
            'ZoomGroup': false,
            'ZoomSliderHandleWidth': false,
            'ZoomSliderRegion': true,
            'ZoomSliderStickyMode': true,
            'maxPlotFactor': true,
            'minPlotFactor': true
        },
        FDSChart: {
            'AnnotationDisappearOnNoValidXData': true,
            'AnnotationDisappearOnNoValidYData': true,
            'AnnotationFollowsParentValue': true,
            'AxisFGColor': false,
            'AxisFGDashFactor': false,
            'AxisFGLineCap': true,
            'AxisFGStyle': true,
            'AxisFGWidth': false,
            'Base': true,
            'BaseAltText': false,
            'BaseBasePosition': true,
            'BaseCenterText': false,
            'BaseFont2Alignment': false,
            'BaseFont2Color': false,
            'BaseFont2Escapement': false,
            'BaseFont2Family': true,
            'BaseFont2Height': false,
            'BaseFont2Italic': true,
            'BaseFont2Truncate': true,
            'BaseFont2TruncateString': false,
            'BaseFont2Underline': true,
            'BaseFont2Weight': false,
            'BaseFont2WidthHint': false,
            'BaseFontAlignment': false,
            'BaseFontColor': false,
            'BaseFontEscapement': false,
            'BaseFontFamily': true,
            'BaseFontHeight': false,
            'BaseFontItalic': true,
            'BaseFontTruncate': true,
            'BaseFontTruncateString': false,
            'BaseFontUnderline': true,
            'BaseFontWeight': false,
            'BaseFontWidthHint': false,
            'BasePosition': true,
            'BaseText': false,
            'CanvasBGAlpha': false,
            'CanvasBGColor': false,
            'CanvasBGGradientAlpha': false,
            'CanvasBGGradientAngle': false,
            'CanvasBGGradientColor': false,
            'CanvasBGGradientFactor': false,
            'CanvasBGGradientStyle': true,
            'CanvasBGImageName': false,
            'CanvasBGRadialGradientOffsetX': false,
            'CanvasBGRadialGradientOffsetY': false,
            'CanvasBGStyle': true,
            'CanvasFGColor': false,
            'CanvasFGDashFactor': false,
            'CanvasFGLineCap': true,
            'CanvasFGStyle': true,
            'CanvasFGWidth': false,
            'ChartBGAlpha': false,
            'ChartBGColor': false,
            'ChartBGGradientAlpha': false,
            'ChartBGGradientAngle': false,
            'ChartBGGradientColor': false,
            'ChartBGGradientFactor': false,
            'ChartBGGradientStyle': true,
            'ChartBGImageName': false,
            'ChartBGRadialGradientOffsetX': false,
            'ChartBGRadialGradientOffsetY': false,
            'ChartBGStyle': true,
            'ChartFGColor': false,
            'ChartFGDashFactor': false,
            'ChartFGLineCap': true,
            'ChartFGStyle': true,
            'ChartFGWidth': false,
            'ChartFooter': true,
            'ChartFooterAltText': false,
            'ChartFooterBasePosition': true,
            'ChartFooterCenterText': false,
            'ChartFooterFontAlignment': false,
            'ChartFooterFontColor': false,
            'ChartFooterFontEscapement': false,
            'ChartFooterFontFamily': true,
            'ChartFooterFontHeight': false,
            'ChartFooterFontItalic': true,
            'ChartFooterFontTruncate': true,
            'ChartFooterFontTruncateString': false,
            'ChartFooterFontUnderline': true,
            'ChartFooterFontWeight': false,
            'ChartFooterFontWidthHint': false,
            'ChartFooterPosition': true,
            'ChartFooterText': false,
            'ChartHeader': true,
            'ChartHeaderAltText': false,
            'ChartHeaderBasePosition': true,
            'ChartHeaderCenterText': false,
            'ChartHeaderFontAlignment': false,
            'ChartHeaderFontColor': false,
            'ChartHeaderFontEscapement': false,
            'ChartHeaderFontFamily': true,
            'ChartHeaderFontHeight': false,
            'ChartHeaderFontItalic': true,
            'ChartHeaderFontTruncate': true,
            'ChartHeaderFontTruncateString': false,
            'ChartHeaderFontUnderline': true,
            'ChartHeaderFontWeight': false,
            'ChartHeaderFontWidthHint': false,
            'ChartHeaderPosition': true,
            'ChartHeaderText': false,
            'ChartHeadersBotOffset': false,
            'ChartHeadersTopOffset': false,
            'ChartHeadersUsePlotOffsets': true,
            'ChartHeading1': true,
            'ChartHeading1AltText': false,
            'ChartHeading1BasePosition': true,
            'ChartHeading1CenterText': false,
            'ChartHeading1FontAlignment': false,
            'ChartHeading1FontColor': false,
            'ChartHeading1FontEscapement': false,
            'ChartHeading1FontFamily': true,
            'ChartHeading1FontHeight': false,
            'ChartHeading1FontItalic': true,
            'ChartHeading1FontTruncate': true,
            'ChartHeading1FontTruncateString': false,
            'ChartHeading1FontUnderline': true,
            'ChartHeading1FontWeight': false,
            'ChartHeading1FontWidthHint': false,
            'ChartHeading1Position': true,
            'ChartHeading1Text': false,
            'ChartHeading2': true,
            'ChartHeading2AltText': false,
            'ChartHeading2BasePosition': true,
            'ChartHeading2CenterText': false,
            'ChartHeading2FontAlignment': false,
            'ChartHeading2FontColor': false,
            'ChartHeading2FontEscapement': false,
            'ChartHeading2FontFamily': true,
            'ChartHeading2FontHeight': false,
            'ChartHeading2FontItalic': true,
            'ChartHeading2FontTruncate': true,
            'ChartHeading2FontTruncateString': false,
            'ChartHeading2FontUnderline': true,
            'ChartHeading2FontWeight': false,
            'ChartHeading2FontWidthHint': false,
            'ChartHeading2Position': true,
            'ChartHeading2Text': false,
            'ChartHeading3': true,
            'ChartHeading3AltText': false,
            'ChartHeading3BasePosition': true,
            'ChartHeading3CenterText': false,
            'ChartHeading3FontAlignment': false,
            'ChartHeading3FontColor': false,
            'ChartHeading3FontEscapement': false,
            'ChartHeading3FontFamily': true,
            'ChartHeading3FontHeight': false,
            'ChartHeading3FontItalic': true,
            'ChartHeading3FontTruncate': true,
            'ChartHeading3FontTruncateString': false,
            'ChartHeading3FontUnderline': true,
            'ChartHeading3FontWeight': false,
            'ChartHeading3FontWidthHint': false,
            'ChartHeading3Position': true,
            'ChartHeading3Text': false,
            'ChartHeading4': true,
            'ChartHeading4AltText': false,
            'ChartHeading4BasePosition': true,
            'ChartHeading4CenterText': false,
            'ChartHeading4FontAlignment': false,
            'ChartHeading4FontColor': false,
            'ChartHeading4FontEscapement': false,
            'ChartHeading4FontFamily': true,
            'ChartHeading4FontHeight': false,
            'ChartHeading4FontItalic': true,
            'ChartHeading4FontTruncate': true,
            'ChartHeading4FontTruncateString': false,
            'ChartHeading4FontUnderline': true,
            'ChartHeading4FontWeight': false,
            'ChartHeading4FontWidthHint': false,
            'ChartHeading4Position': true,
            'ChartHeading4Text': false,
            'ClickToolTips': true,
            'ClickTooltipBGAlpha': false,
            'ClickTooltipBGColor': false,
            'ClickTooltipBGGradientAlpha': false,
            'ClickTooltipBGGradientAngle': false,
            'ClickTooltipBGGradientColor': false,
            'ClickTooltipBGGradientFactor': false,
            'ClickTooltipBGGradientStyle': true,
            'ClickTooltipBGImageName': false,
            'ClickTooltipBGRadialGradientOffsetX': false,
            'ClickTooltipBGRadialGradientOffsetY': false,
            'ClickTooltipBGStyle': true,
            'ClickTooltipFontAlignment': false,
            'ClickTooltipFontColor': false,
            'ClickTooltipFontEscapement': false,
            'ClickTooltipFontFamily': true,
            'ClickTooltipFontHeight': false,
            'ClickTooltipFontItalic': true,
            'ClickTooltipFontTruncate': true,
            'ClickTooltipFontTruncateString': false,
            'ClickTooltipFontUnderline': true,
            'ClickTooltipFontWeight': false,
            'ClickTooltipFontWidthHint': false,
            'ContextMenuEnabled': true,
            'CopyAsActiveGraphEnabled': true,
            'CopyAsActiveGraphMode': true,
            'CrosshairsBoundToPlot': true,
            'CrosshairsDrawMarker': true,
            'CrosshairsDrawOnPlot': true,
            'CrosshairsEnabled': true,
            'CrosshairsLabel': true,
            'CrosshairsLabelDrawnWithoutAxisLabels': true,
            'CrosshairsLineColor': false,
            'CrosshairsLineSize': false,
            'CrosshairsMarkerColor': false,
            'CrosshairsMarkerSize': false,
            'CrosshairsMarkerStyle': true,
            'CrosshairsShowHorizontal': true,
            'CrosshairsShowVertical': true,
            'CrosshairsSnapToSeries': false,
            'CrosshairsSnapXToSeries': true,
            'CrosshairsSnapYToSeries': true,
            'CrosshairsTooltipEnabled': true,
            'CrosshairsTooltipFontAlignment': false,
            'CrosshairsTooltipFontColor': false,
            'CrosshairsTooltipFontEscapement': false,
            'CrosshairsTooltipFontFamily': true,
            'CrosshairsTooltipFontHeight': false,
            'CrosshairsTooltipFontItalic': true,
            'CrosshairsTooltipFontTruncate': true,
            'CrosshairsTooltipFontTruncateString': false,
            'CrosshairsTooltipFontUnderline': true,
            'CrosshairsTooltipFontWeight': false,
            'CrosshairsTooltipFontWidthHint': false,
            'CrosshairsTooltipMode': true,
            'CrosshairsTooltipSnapPlot': false,
            'CrosshairsTooltipSnapX': true,
            'CrosshairsTooltipSnapY': true,
            'CrosshairsTooltipText': false,
            'CrosshairsTooltipXOffset': false,
            'CrosshairsTooltipYOffset': false,
            'Cursor': true,
            'EquateLRMargins': true,
            'Exceptions': true,
            'FireRightButtonDownBeforeMenu': false,
            'FocusPlot': false,
            'Footer': true,
            'FooterAltText': false,
            'FooterBasePosition': true,
            'FooterCenterText': false,
            'FooterFontAlignment': false,
            'FooterFontColor': false,
            'FooterFontEscapement': false,
            'FooterFontFamily': true,
            'FooterFontHeight': false,
            'FooterFontItalic': true,
            'FooterFontTruncate': true,
            'FooterFontTruncateString': false,
            'FooterFontUnderline': true,
            'FooterFontWeight': false,
            'FooterFontWidthHint': false,
            'FooterPosition': true,
            'FooterText': false,
            'GridFGColor': false,
            'GridFGDashFactor': false,
            'GridFGLineCap': true,
            'GridFGStyle': true,
            'GridFGWidth': false,
            'Header': true,
            'HeaderAltText': false,
            'HeaderBasePosition': true,
            'HeaderCenterText': false,
            'HeaderFontAlignment': false,
            'HeaderFontColor': false,
            'HeaderFontEscapement': false,
            'HeaderFontFamily': true,
            'HeaderFontHeight': false,
            'HeaderFontItalic': true,
            'HeaderFontTruncate': true,
            'HeaderFontTruncateString': false,
            'HeaderFontUnderline': true,
            'HeaderFontWeight': false,
            'HeaderFontWidthHint': false,
            'HeaderPosition': true,
            'HeaderText': false,
            'Heading': true,
            'Heading1': true,
            'Heading1AltText': false,
            'Heading1BasePosition': true,
            'Heading1CenterText': false,
            'Heading1FontAlignment': false,
            'Heading1FontColor': false,
            'Heading1FontEscapement': false,
            'Heading1FontFamily': true,
            'Heading1FontHeight': false,
            'Heading1FontItalic': true,
            'Heading1FontTruncate': true,
            'Heading1FontTruncateString': false,
            'Heading1FontUnderline': true,
            'Heading1FontWeight': false,
            'Heading1FontWidthHint': false,
            'Heading1Position': true,
            'Heading1Text': false,
            'Heading2': true,
            'Heading2AltText': false,
            'Heading2BasePosition': true,
            'Heading2CenterText': false,
            'Heading2FontAlignment': false,
            'Heading2FontColor': false,
            'Heading2FontEscapement': false,
            'Heading2FontFamily': true,
            'Heading2FontHeight': false,
            'Heading2FontItalic': true,
            'Heading2FontTruncate': true,
            'Heading2FontTruncateString': false,
            'Heading2FontUnderline': true,
            'Heading2FontWeight': false,
            'Heading2FontWidthHint': false,
            'Heading2Position': true,
            'Heading2Text': false,
            'Heading3': true,
            'Heading3AltText': false,
            'Heading3BasePosition': true,
            'Heading3CenterText': false,
            'Heading3FontAlignment': false,
            'Heading3FontColor': false,
            'Heading3FontEscapement': false,
            'Heading3FontFamily': true,
            'Heading3FontHeight': false,
            'Heading3FontItalic': true,
            'Heading3FontTruncate': true,
            'Heading3FontTruncateString': false,
            'Heading3FontUnderline': true,
            'Heading3FontWeight': false,
            'Heading3FontWidthHint': false,
            'Heading3Position': true,
            'Heading3Text': false,
            'Heading4': true,
            'Heading4AltText': false,
            'Heading4BasePosition': true,
            'Heading4CenterText': false,
            'Heading4FontAlignment': false,
            'Heading4FontColor': false,
            'Heading4FontEscapement': false,
            'Heading4FontFamily': true,
            'Heading4FontHeight': false,
            'Heading4FontItalic': true,
            'Heading4FontTruncate': true,
            'Heading4FontTruncateString': false,
            'Heading4FontUnderline': true,
            'Heading4FontWeight': false,
            'Heading4FontWidthHint': false,
            'Heading4Position': true,
            'Heading4Text': false,
            'HeadingAltText': false,
            'HeadingBasePosition': true,
            'HeadingCenterText': false,
            'HeadingFontAlignment': false,
            'HeadingFontColor': false,
            'HeadingFontEscapement': false,
            'HeadingFontFamily': true,
            'HeadingFontHeight': false,
            'HeadingFontItalic': true,
            'HeadingFontTruncate': true,
            'HeadingFontTruncateString': false,
            'HeadingFontUnderline': true,
            'HeadingFontWeight': false,
            'HeadingFontWidthHint': false,
            'HeadingPosition': true,
            'HeadingText': false,
            'HorizontalZoom': true,
            'InteractivityClampToPlot': true,
            'InteractivityMode': true,
            'InteractivitySelectableMask': true,
            'InteractivityWithoutToolTips': true,
            'Label': false,
            'Legend': true,
            'LegendAxisPosition': true,
            'LegendBGAlpha': false,
            'LegendBGColor': false,
            'LegendBGGradientAlpha': false,
            'LegendBGGradientAngle': false,
            'LegendBGGradientColor': false,
            'LegendBGGradientFactor': false,
            'LegendBGGradientStyle': true,
            'LegendBGImageName': false,
            'LegendBGRadialGradientOffsetX': false,
            'LegendBGRadialGradientOffsetY': false,
            'LegendBGShadow': true,
            'LegendBGShadowColor': false,
            'LegendBGShadowX': false,
            'LegendBGShadowY': false,
            'LegendBGStyle': true,
            'LegendBasePosition': true,
            'LegendDirection': true,
            'LegendFGColor': false,
            'LegendFGDashFactor': false,
            'LegendFGLineCap': true,
            'LegendFGStyle': true,
            'LegendFGWidth': false,
            'LegendFontAlignment': false,
            'LegendFontColor': false,
            'LegendFontEscapement': false,
            'LegendFontFamily': true,
            'LegendFontHeight': false,
            'LegendFontItalic': true,
            'LegendFontTruncate': true,
            'LegendFontTruncateString': false,
            'LegendFontUnderline': true,
            'LegendFontWeight': false,
            'LegendFontWidthHint': false,
            'LegendPacking': true,
            'LegendPosition': true,
            'LegendText': false,
            'LegendVPosition': true,
            'LegendXOffset': false,
            'LegendYOffset': false,
            'LongPressInteractTimeout': false,
            'LongPressToInteract': true,
            'Menu': false,
            'MenuXML': false,
            'MinorGridFGColor': false,
            'MinorGridFGDashFactor': false,
            'MinorGridFGLineCap': true,
            'MinorGridFGStyle': true,
            'MinorGridFGWidth': false,
            'OnLeftButtonClick': false,
            'OnLeftButtonDoubleClick': false,
            'OnMiddleButtonClick': false,
            'OnMiddleButtonDoubleClick': false,
            'OnRightButtonClick': false,
            'OnRightButtonDoubleClick': false,
            'PersistInteraction': true,
            'PlotBGAlpha': false,
            'PlotBGColor': false,
            'PlotBGGradientAlpha': false,
            'PlotBGGradientAngle': false,
            'PlotBGGradientColor': false,
            'PlotBGGradientFactor': false,
            'PlotBGGradientStyle': true,
            'PlotBGImageName': false,
            'PlotBGRadialGradientOffsetX': false,
            'PlotBGRadialGradientOffsetY': false,
            'PlotBGStyle': true,
            'PlotDragEnabled': true,
            'PlotDragScalePadding': false,
            'PlotFGColor': false,
            'PlotFGDashFactor': false,
            'PlotFGLineCap': true,
            'PlotFGStyle': true,
            'PlotFGWidth': false,
            'RefreshPlotOnResize': true,
            'RefreshPlotOnZoom': true,
            'ResizeAllAxesOnZoom': true,
            'ResizeEnabled': true,
            'ResizeMinFactorX': false,
            'ResizeMinFactorY': false,
            'ResizeSliderBGColor': false,
            'ResizeSliderButtonHoverColor': false,
            'ResizeSliderButtonPressedColor': false,
            'ResizeSliderButtonRestColor': false,
            'ResizeSliderDrawSegmented': true,
            'ResizeSliderMobileRectBGAlpha': false,
            'ResizeSliderMobileRectBGColor': false,
            'ResizeSliderMobileRectBGGradientAlpha': false,
            'ResizeSliderMobileRectBGGradientAngle': false,
            'ResizeSliderMobileRectBGGradientColor': false,
            'ResizeSliderMobileRectBGGradientFactor': false,
            'ResizeSliderMobileRectBGGradientStyle': true,
            'ResizeSliderMobileRectBGImageName': false,
            'ResizeSliderMobileRectBGRadialGradientOffsetX': false,
            'ResizeSliderMobileRectBGRadialGradientOffsetY': false,
            'ResizeSliderMobileRectBGStyle': true,
            'ResizeSliderMobileRectFGColor': false,
            'ResizeSliderMobileRectFGDashFactor': false,
            'ResizeSliderMobileRectFGLineCap': true,
            'ResizeSliderMobileRectFGStyle': true,
            'ResizeSliderMobileRectFGWidth': false,
            'ResizeSliderMobileRectHeight': false,
            'ResizeSliderMobileRectPadding': false,
            'ResizeSliderMobileRectWidth': false,
            'ResizeSliderStyle': true,
            'ResizeSliderUnFocusedBGAlpha': false,
            'ResizeSliderUnFocusedBGColor': false,
            'ResizeSliderUnFocusedBGGradientAlpha': false,
            'ResizeSliderUnFocusedBGGradientAngle': false,
            'ResizeSliderUnFocusedBGGradientColor': false,
            'ResizeSliderUnFocusedBGGradientFactor': false,
            'ResizeSliderUnFocusedBGGradientStyle': true,
            'ResizeSliderUnFocusedBGImageName': false,
            'ResizeSliderUnFocusedBGRadialGradientOffsetX': false,
            'ResizeSliderUnFocusedBGRadialGradientOffsetY': false,
            'ResizeSliderUnFocusedBGStyle': true,
            'ResizeSliderWidth': false,
            'ResizeTouchingOnly': true,
            'SelectableItemPointMarkerSize': false,
            'SelectableItemPointMarkerType': true,
            'SelectableItemRenderMode': true,
            'SelectableItemSamplingEnabled': true,
            'SelectionToolBGAlpha': false,
            'SelectionToolBGColor': false,
            'SelectionToolBGGradientAlpha': false,
            'SelectionToolBGGradientAngle': false,
            'SelectionToolBGGradientColor': false,
            'SelectionToolBGGradientFactor': false,
            'SelectionToolBGGradientStyle': true,
            'SelectionToolBGImageName': false,
            'SelectionToolBGRadialGradientOffsetX': false,
            'SelectionToolBGRadialGradientOffsetY': false,
            'SelectionToolBGStyle': true,
            'SelectionToolEnabled': true,
            'SeriesColor0': false,
            'SeriesColor1': false,
            'SeriesColor10': false,
            'SeriesColor11': false,
            'SeriesColor12': false,
            'SeriesColor13': false,
            'SeriesColor14': false,
            'SeriesColor15': false,
            'SeriesColor2': false,
            'SeriesColor3': false,
            'SeriesColor4': false,
            'SeriesColor5': false,
            'SeriesColor6': false,
            'SeriesColor7': false,
            'SeriesColor8': false,
            'SeriesColor9': false,
            'SeriesColorAutoLighten': true,
            'SeriesColorCycle': false,
            'SeriesColorDown': false,
            'SeriesColorList': false,
            'SeriesColorNeutral': false,
            'SeriesColorUp': false,
            'SeriesLineStyle0': true,
            'SeriesLineStyle1': true,
            'SeriesLineStyle10': true,
            'SeriesLineStyle11': true,
            'SeriesLineStyle12': true,
            'SeriesLineStyle13': true,
            'SeriesLineStyle14': true,
            'SeriesLineStyle15': true,
            'SeriesLineStyle2': true,
            'SeriesLineStyle3': true,
            'SeriesLineStyle4': true,
            'SeriesLineStyle5': true,
            'SeriesLineStyle6': true,
            'SeriesLineStyle7': true,
            'SeriesLineStyle8': true,
            'SeriesLineStyle9': true,
            'SeriesLineStyleList': true,
            'SeriesLineWidth0': false,
            'SeriesLineWidth1': false,
            'SeriesLineWidth10': false,
            'SeriesLineWidth11': false,
            'SeriesLineWidth12': false,
            'SeriesLineWidth13': false,
            'SeriesLineWidth14': false,
            'SeriesLineWidth15': false,
            'SeriesLineWidth2': false,
            'SeriesLineWidth3': false,
            'SeriesLineWidth4': false,
            'SeriesLineWidth5': false,
            'SeriesLineWidth6': false,
            'SeriesLineWidth7': false,
            'SeriesLineWidth8': false,
            'SeriesLineWidth9': false,
            'SeriesLineWidthList': false,
            'SeriesMarkerAutoPosition': true,
            'SeriesMarkerAutoPositionDirection': true,
            'SeriesMarkerAutoPositionMode': true,
            'SeriesMarkerAutoPositionXFactor': false,
            'SeriesMarkerAutoPositionYFactor': false,
            'SeriesMarkerStyleList': true,
            'SeriesOutlineColor0': false,
            'SeriesOutlineColor1': false,
            'SeriesOutlineColor10': false,
            'SeriesOutlineColor11': false,
            'SeriesOutlineColor12': false,
            'SeriesOutlineColor13': false,
            'SeriesOutlineColor14': false,
            'SeriesOutlineColor15': false,
            'SeriesOutlineColor2': false,
            'SeriesOutlineColor3': false,
            'SeriesOutlineColor4': false,
            'SeriesOutlineColor5': false,
            'SeriesOutlineColor6': false,
            'SeriesOutlineColor7': false,
            'SeriesOutlineColor8': false,
            'SeriesOutlineColor9': false,
            'SeriesOutlineColorList': false,
            'SeriesQuickLabel': true,
            'SeriesQuickLabelArrowMultiplier': false,
            'SeriesQuickLabelAutoPosition': true,
            'SeriesQuickLabelAutoPositionFactor': false,
            'SeriesQuickLabelColorFollowsSeriesColor': true,
            'SeriesQuickLabelColorMaximumContrast': true,
            'SeriesQuickLabelConsolidatedTextBoxes': true,
            'SeriesQuickLabelFontAlignment': false,
            'SeriesQuickLabelFontAlignmentLeft': true,
            'SeriesQuickLabelFontAlignmentRight': true,
            'SeriesQuickLabelFontColor': false,
            'SeriesQuickLabelFontEscapement': false,
            'SeriesQuickLabelFontFamily': true,
            'SeriesQuickLabelFontHeight': false,
            'SeriesQuickLabelFontItalic': true,
            'SeriesQuickLabelFontTruncate': true,
            'SeriesQuickLabelFontTruncateString': false,
            'SeriesQuickLabelFontUnderline': true,
            'SeriesQuickLabelFontWeight': false,
            'SeriesQuickLabelFontWidthHint': false,
            'SeriesQuickLabelGap': false,
            'SeriesQuickLabelLeftPositionModifier': true,
            'SeriesQuickLabelPosition': true,
            'SeriesQuickLabelRightPositionModifier': true,
            'SeriesQuickLabelShowText': true,
            'SeriesQuickLabelText': false,
            'SeriesQuickLabelTextBox': true,
            'SeriesQuickLabelTextBoxBGAlpha': false,
            'SeriesQuickLabelTextBoxBGColor': false,
            'SeriesQuickLabelTextBoxBGColorFollowsSeriesColor': true,
            'SeriesQuickLabelTextBoxBGGradientAlpha': false,
            'SeriesQuickLabelTextBoxBGGradientAngle': false,
            'SeriesQuickLabelTextBoxBGGradientColor': false,
            'SeriesQuickLabelTextBoxBGGradientFactor': false,
            'SeriesQuickLabelTextBoxBGGradientStyle': true,
            'SeriesQuickLabelTextBoxBGImageName': false,
            'SeriesQuickLabelTextBoxBGRadialGradientOffsetX': false,
            'SeriesQuickLabelTextBoxBGRadialGradientOffsetY': false,
            'SeriesQuickLabelTextBoxBGStyle': true,
            'SeriesQuickLabelTextBoxDisplayMargins': false,
            'SeriesQuickLabelTextBoxDisplayStyle': true,
            'SeriesQuickLabelTextBoxFGColor': false,
            'SeriesQuickLabelTextBoxFGDashFactor': false,
            'SeriesQuickLabelTextBoxFGLineCap': true,
            'SeriesQuickLabelTextBoxFGStyle': true,
            'SeriesQuickLabelTextBoxFGWidth': false,
            'SeriesQuickLabelTextBoxHeightHint': false,
            'SeriesQuickLabelTextBoxPlacement': true,
            'SeriesQuickLabelTextBoxSizingMode': true,
            'SeriesQuickLabelTextBoxTextClipping': true,
            'SeriesQuickLabelTextBoxWidthHint': false,
            'SeriesQuickLabelVerticalPosition': true,
            'SeriesShadow': true,
            'SeriesShadowAlpha': false,
            'SeriesShadowColor': false,
            'SeriesShadowX': false,
            'SeriesShadowY': false,
            'SeriesValue': true,
            'SeriesValueBGAlpha': false,
            'SeriesValueBGColor': false,
            'SeriesValueBGGradientAlpha': false,
            'SeriesValueBGGradientAngle': false,
            'SeriesValueBGGradientColor': false,
            'SeriesValueBGGradientFactor': false,
            'SeriesValueBGGradientStyle': true,
            'SeriesValueBGImageName': false,
            'SeriesValueBGRadialGradientOffsetX': false,
            'SeriesValueBGRadialGradientOffsetY': false,
            'SeriesValueBGStyle': true,
            'SeriesValueFGColor': false,
            'SeriesValueFGDashFactor': false,
            'SeriesValueFGLineCap': true,
            'SeriesValueFGStyle': true,
            'SeriesValueFGWidth': false,
            'SeriesValueFontAlignment': false,
            'SeriesValueFontColor': false,
            'SeriesValueFontEscapement': false,
            'SeriesValueFontFamily': true,
            'SeriesValueFontHeight': false,
            'SeriesValueFontItalic': true,
            'SeriesValueFontTruncate': true,
            'SeriesValueFontTruncateString': false,
            'SeriesValueFontUnderline': true,
            'SeriesValueFontWeight': false,
            'SeriesValueFontWidthHint': false,
            'SimpleZoom': true,
            'SnapMouseToSeries': true,
            'SnappingThreshhold': false,
            'Style': true,
            'SubHeading': true,
            'SubHeadingAltText': false,
            'SubHeadingBasePosition': true,
            'SubHeadingCenterText': false,
            'SubHeadingFontAlignment': false,
            'SubHeadingFontColor': false,
            'SubHeadingFontEscapement': false,
            'SubHeadingFontFamily': true,
            'SubHeadingFontHeight': false,
            'SubHeadingFontItalic': true,
            'SubHeadingFontTruncate': true,
            'SubHeadingFontTruncateString': false,
            'SubHeadingFontUnderline': true,
            'SubHeadingFontWeight': false,
            'SubHeadingFontWidthHint': false,
            'SubHeadingPosition': true,
            'SubHeadingText': false,
            'ToolTipDelay': false,
            'ToolTips': true,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipText': false,
            'XAxis': true,
            'XAxisFGColor': false,
            'XAxisFGDashFactor': false,
            'XAxisFGLineCap': true,
            'XAxisFGStyle': true,
            'XAxisFGWidth': false,
            'XAxisPosition': true,
            'XFontAlignment': false,
            'XFontColor': false,
            'XFontEscapement': false,
            'XFontFamily': true,
            'XFontHeight': false,
            'XFontItalic': true,
            'XFontTruncate': true,
            'XFontTruncateString': false,
            'XFontUnderline': true,
            'XFontWeight': false,
            'XFontWidthHint': false,
            'XGrid': true,
            'XGridFGColor': false,
            'XGridFGDashFactor': false,
            'XGridFGLineCap': true,
            'XGridFGStyle': true,
            'XGridFGWidth': false,
            'XHLBinsHint': false,
            'XIntradayScaleLabelFormatDAY': false,
            'XIntradayScaleLabelFormatFIVEMINUTE': false,
            'XIntradayScaleLabelFormatFIVESECOND': false,
            'XIntradayScaleLabelFormatFIVEY': false,
            'XIntradayScaleLabelFormatHALFHOUR': false,
            'XIntradayScaleLabelFormatHALFMINUTE': false,
            'XIntradayScaleLabelFormatHALFY': false,
            'XIntradayScaleLabelFormatHOUR': false,
            'XIntradayScaleLabelFormatMINUTE': false,
            'XIntradayScaleLabelFormatMONTH': false,
            'XIntradayScaleLabelFormatQUARTER': false,
            'XIntradayScaleLabelFormatSECOND': false,
            'XIntradayScaleLabelFormatSIXHOUR': false,
            'XIntradayScaleLabelFormatTENMINUTE': false,
            'XIntradayScaleLabelFormatTENSECOND': false,
            'XIntradayScaleLabelFormatTENY': false,
            'XIntradayScaleLabelFormatTWOHOUR': false,
            'XIntradayScaleLabelFormatTWOMINUTE': false,
            'XIntradayScaleLabelFormatTWOSECOND': false,
            'XIntradayScaleLabelFormatTWOY': false,
            'XIntradayScaleLabelFormatWEEK': false,
            'XIntradayScaleLabelFormatYEAR': false,
            'XIntradayScaleMinorLabelFormatDAY': false,
            'XIntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'XIntradayScaleMinorLabelFormatFIVESECOND': false,
            'XIntradayScaleMinorLabelFormatFIVEY': false,
            'XIntradayScaleMinorLabelFormatHALFHOUR': false,
            'XIntradayScaleMinorLabelFormatHALFMINUTE': false,
            'XIntradayScaleMinorLabelFormatHALFY': false,
            'XIntradayScaleMinorLabelFormatHOUR': false,
            'XIntradayScaleMinorLabelFormatMINUTE': false,
            'XIntradayScaleMinorLabelFormatMONTH': false,
            'XIntradayScaleMinorLabelFormatQUARTER': false,
            'XIntradayScaleMinorLabelFormatSECOND': false,
            'XIntradayScaleMinorLabelFormatSIXHOUR': false,
            'XIntradayScaleMinorLabelFormatTENMINUTE': false,
            'XIntradayScaleMinorLabelFormatTENSECOND': false,
            'XIntradayScaleMinorLabelFormatTENY': false,
            'XIntradayScaleMinorLabelFormatTWOHOUR': false,
            'XIntradayScaleMinorLabelFormatTWOMINUTE': false,
            'XIntradayScaleMinorLabelFormatTWOSECOND': false,
            'XIntradayScaleMinorLabelFormatTWOY': false,
            'XIntradayScaleMinorLabelFormatWEEK': false,
            'XIntradayScaleMinorLabelFormatYEAR': false,
            'XIntradayScaleMinorRangeDAY': false,
            'XIntradayScaleMinorRangeFIVEMINUTE': false,
            'XIntradayScaleMinorRangeFIVESECOND': false,
            'XIntradayScaleMinorRangeFIVEY': false,
            'XIntradayScaleMinorRangeHALFHOUR': false,
            'XIntradayScaleMinorRangeHALFMINUTE': false,
            'XIntradayScaleMinorRangeHALFY': false,
            'XIntradayScaleMinorRangeHOUR': false,
            'XIntradayScaleMinorRangeMINUTE': false,
            'XIntradayScaleMinorRangeMONTH': false,
            'XIntradayScaleMinorRangeQUARTER': false,
            'XIntradayScaleMinorRangeSECOND': false,
            'XIntradayScaleMinorRangeSIXHOUR': false,
            'XIntradayScaleMinorRangeTENMINUTE': false,
            'XIntradayScaleMinorRangeTENSECOND': false,
            'XIntradayScaleMinorRangeTENY': false,
            'XIntradayScaleMinorRangeTWOHOUR': false,
            'XIntradayScaleMinorRangeTWOMINUTE': false,
            'XIntradayScaleMinorRangeTWOSECOND': false,
            'XIntradayScaleMinorRangeTWOY': false,
            'XIntradayScaleMinorRangeWEEK': false,
            'XIntradayScaleMinorRangeYEAR': false,
            'XIntradayScaleRangeDAY': false,
            'XIntradayScaleRangeFIVEMINUTE': false,
            'XIntradayScaleRangeFIVESECOND': false,
            'XIntradayScaleRangeFIVEY': false,
            'XIntradayScaleRangeHALFHOUR': false,
            'XIntradayScaleRangeHALFMINUTE': false,
            'XIntradayScaleRangeHALFY': false,
            'XIntradayScaleRangeHOUR': false,
            'XIntradayScaleRangeMINUTE': false,
            'XIntradayScaleRangeMONTH': false,
            'XIntradayScaleRangeQUARTER': false,
            'XIntradayScaleRangeSECOND': false,
            'XIntradayScaleRangeSIXHOUR': false,
            'XIntradayScaleRangeTENMINUTE': false,
            'XIntradayScaleRangeTENSECOND': false,
            'XIntradayScaleRangeTENY': false,
            'XIntradayScaleRangeTWOHOUR': false,
            'XIntradayScaleRangeTWOMINUTE': false,
            'XIntradayScaleRangeTWOSECOND': false,
            'XIntradayScaleRangeTWOY': false,
            'XIntradayScaleRangeWEEK': false,
            'XIntradayScaleRangeYEAR': false,
            'XLabel': true,
            'XLabelFormat': false,
            'XLog': true,
            'XMinorGrid': true,
            'XMinorGridFGColor': false,
            'XMinorGridFGDashFactor': false,
            'XMinorGridFGLineCap': true,
            'XMinorGridFGStyle': true,
            'XMinorGridFGWidth': false,
            'XMinorTickOffset': false,
            'XMinorTicks': true,
            'XOutlierAxis': true,
            'XOutlierAxisDynamic': true,
            'XOutlierAxisDynamicThreshold': false,
            'XOutlierAxisMarginMax': false,
            'XOutlierAxisMarginMin': false,
            'XOutlierAxisThreshMax': false,
            'XOutlierAxisThreshMin': false,
            'XReverse': true,
            'XThreshMax': false,
            'XThreshMin': false,
            'XTickDateBin': true,
            'XTickMode': true,
            'XTickOffset': false,
            'XTicks': true,
            'XTicksFGColor': false,
            'XTicksFGDashFactor': false,
            'XTicksFGLineCap': true,
            'XTicksFGStyle': true,
            'XTicksFGWidth': false,
            'XTitle': true,
            'XTitleFontAlignment': false,
            'XTitleFontColor': false,
            'XTitleFontEscapement': false,
            'XTitleFontFamily': true,
            'XTitleFontHeight': false,
            'XTitleFontItalic': true,
            'XTitleFontTruncate': true,
            'XTitleFontTruncateString': false,
            'XTitleFontUnderline': true,
            'XTitleFontWeight': false,
            'XTitleFontWidthHint': false,
            'XmaxPlotFactor': true,
            'XminPlotFactor': true,
            'YAxis': true,
            'YAxisFGColor': false,
            'YAxisFGDashFactor': false,
            'YAxisFGLineCap': true,
            'YAxisFGStyle': true,
            'YAxisFGWidth': false,
            'YAxisPosition': true,
            'YFontAlignment': false,
            'YFontColor': false,
            'YFontEscapement': false,
            'YFontFamily': true,
            'YFontHeight': false,
            'YFontItalic': true,
            'YFontTruncate': true,
            'YFontTruncateString': false,
            'YFontUnderline': true,
            'YFontWeight': false,
            'YFontWidthHint': false,
            'YGrid': true,
            'YGridFGColor': false,
            'YGridFGDashFactor': false,
            'YGridFGLineCap': true,
            'YGridFGStyle': true,
            'YGridFGWidth': false,
            'YHLBinsHint': false,
            'YIntradayScaleLabelFormatDAY': false,
            'YIntradayScaleLabelFormatFIVEMINUTE': false,
            'YIntradayScaleLabelFormatFIVESECOND': false,
            'YIntradayScaleLabelFormatFIVEY': false,
            'YIntradayScaleLabelFormatHALFHOUR': false,
            'YIntradayScaleLabelFormatHALFMINUTE': false,
            'YIntradayScaleLabelFormatHALFY': false,
            'YIntradayScaleLabelFormatHOUR': false,
            'YIntradayScaleLabelFormatMINUTE': false,
            'YIntradayScaleLabelFormatMONTH': false,
            'YIntradayScaleLabelFormatQUARTER': false,
            'YIntradayScaleLabelFormatSECOND': false,
            'YIntradayScaleLabelFormatSIXHOUR': false,
            'YIntradayScaleLabelFormatTENMINUTE': false,
            'YIntradayScaleLabelFormatTENSECOND': false,
            'YIntradayScaleLabelFormatTENY': false,
            'YIntradayScaleLabelFormatTWOHOUR': false,
            'YIntradayScaleLabelFormatTWOMINUTE': false,
            'YIntradayScaleLabelFormatTWOSECOND': false,
            'YIntradayScaleLabelFormatTWOY': false,
            'YIntradayScaleLabelFormatWEEK': false,
            'YIntradayScaleLabelFormatYEAR': false,
            'YIntradayScaleMinorLabelFormatDAY': false,
            'YIntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'YIntradayScaleMinorLabelFormatFIVESECOND': false,
            'YIntradayScaleMinorLabelFormatFIVEY': false,
            'YIntradayScaleMinorLabelFormatHALFHOUR': false,
            'YIntradayScaleMinorLabelFormatHALFMINUTE': false,
            'YIntradayScaleMinorLabelFormatHALFY': false,
            'YIntradayScaleMinorLabelFormatHOUR': false,
            'YIntradayScaleMinorLabelFormatMINUTE': false,
            'YIntradayScaleMinorLabelFormatMONTH': false,
            'YIntradayScaleMinorLabelFormatQUARTER': false,
            'YIntradayScaleMinorLabelFormatSECOND': false,
            'YIntradayScaleMinorLabelFormatSIXHOUR': false,
            'YIntradayScaleMinorLabelFormatTENMINUTE': false,
            'YIntradayScaleMinorLabelFormatTENSECOND': false,
            'YIntradayScaleMinorLabelFormatTENY': false,
            'YIntradayScaleMinorLabelFormatTWOHOUR': false,
            'YIntradayScaleMinorLabelFormatTWOMINUTE': false,
            'YIntradayScaleMinorLabelFormatTWOSECOND': false,
            'YIntradayScaleMinorLabelFormatTWOY': false,
            'YIntradayScaleMinorLabelFormatWEEK': false,
            'YIntradayScaleMinorLabelFormatYEAR': false,
            'YIntradayScaleMinorRangeDAY': false,
            'YIntradayScaleMinorRangeFIVEMINUTE': false,
            'YIntradayScaleMinorRangeFIVESECOND': false,
            'YIntradayScaleMinorRangeFIVEY': false,
            'YIntradayScaleMinorRangeHALFHOUR': false,
            'YIntradayScaleMinorRangeHALFMINUTE': false,
            'YIntradayScaleMinorRangeHALFY': false,
            'YIntradayScaleMinorRangeHOUR': false,
            'YIntradayScaleMinorRangeMINUTE': false,
            'YIntradayScaleMinorRangeMONTH': false,
            'YIntradayScaleMinorRangeQUARTER': false,
            'YIntradayScaleMinorRangeSECOND': false,
            'YIntradayScaleMinorRangeSIXHOUR': false,
            'YIntradayScaleMinorRangeTENMINUTE': false,
            'YIntradayScaleMinorRangeTENSECOND': false,
            'YIntradayScaleMinorRangeTENY': false,
            'YIntradayScaleMinorRangeTWOHOUR': false,
            'YIntradayScaleMinorRangeTWOMINUTE': false,
            'YIntradayScaleMinorRangeTWOSECOND': false,
            'YIntradayScaleMinorRangeTWOY': false,
            'YIntradayScaleMinorRangeWEEK': false,
            'YIntradayScaleMinorRangeYEAR': false,
            'YIntradayScaleRangeDAY': false,
            'YIntradayScaleRangeFIVEMINUTE': false,
            'YIntradayScaleRangeFIVESECOND': false,
            'YIntradayScaleRangeFIVEY': false,
            'YIntradayScaleRangeHALFHOUR': false,
            'YIntradayScaleRangeHALFMINUTE': false,
            'YIntradayScaleRangeHALFY': false,
            'YIntradayScaleRangeHOUR': false,
            'YIntradayScaleRangeMINUTE': false,
            'YIntradayScaleRangeMONTH': false,
            'YIntradayScaleRangeQUARTER': false,
            'YIntradayScaleRangeSECOND': false,
            'YIntradayScaleRangeSIXHOUR': false,
            'YIntradayScaleRangeTENMINUTE': false,
            'YIntradayScaleRangeTENSECOND': false,
            'YIntradayScaleRangeTENY': false,
            'YIntradayScaleRangeTWOHOUR': false,
            'YIntradayScaleRangeTWOMINUTE': false,
            'YIntradayScaleRangeTWOSECOND': false,
            'YIntradayScaleRangeTWOY': false,
            'YIntradayScaleRangeWEEK': false,
            'YIntradayScaleRangeYEAR': false,
            'YLabel': true,
            'YLabelFormat': false,
            'YLog': true,
            'YMinorGrid': true,
            'YMinorGridFGColor': false,
            'YMinorGridFGDashFactor': false,
            'YMinorGridFGLineCap': true,
            'YMinorGridFGStyle': true,
            'YMinorGridFGWidth': false,
            'YMinorTickOffset': false,
            'YMinorTicks': true,
            'YOutlierAxis': true,
            'YOutlierAxisDynamic': true,
            'YOutlierAxisDynamicThreshold': false,
            'YOutlierAxisMarginMax': false,
            'YOutlierAxisMarginMin': false,
            'YOutlierAxisThreshMax': false,
            'YOutlierAxisThreshMin': false,
            'YReverse': true,
            'YThreshMax': false,
            'YThreshMin': false,
            'YTickDateBin': true,
            'YTickMode': true,
            'YTickOffset': false,
            'YTicks': true,
            'YTicksFGColor': false,
            'YTicksFGDashFactor': false,
            'YTicksFGLineCap': true,
            'YTicksFGStyle': true,
            'YTicksFGWidth': false,
            'YTitle': true,
            'YTitleFontAlignment': false,
            'YTitleFontColor': false,
            'YTitleFontEscapement': false,
            'YTitleFontFamily': true,
            'YTitleFontHeight': false,
            'YTitleFontItalic': true,
            'YTitleFontTruncate': true,
            'YTitleFontTruncateString': false,
            'YTitleFontUnderline': true,
            'YTitleFontWeight': false,
            'YTitleFontWidthHint': false,
            'YmaxPlotFactor': true,
            'YminPlotFactor': true
        },
        FDSDataSet: {
            'Format': false,
            'Frequency': true,
            'ImageType': true,
            'InTips': true,
            'Label': false,
            'Menu': false,
            'MenuXML': false,
            'Style': false,
            'TimeOffset': false,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipText': false,
            'TreatAsIndex': true
        },
        FDSLegend: {
            'AxisPosition': true,
            'BGAlpha': false,
            'BGColor': false,
            'BGGradientAlpha': false,
            'BGGradientAngle': false,
            'BGGradientColor': false,
            'BGGradientFactor': false,
            'BGGradientStyle': true,
            'BGImageName': false,
            'BGRadialGradientOffsetX': false,
            'BGRadialGradientOffsetY': false,
            'BGStyle': true,
            'BasePosition': true,
            'Break': false,
            'CenterRows': true,
            'DataMask': true,
            'Direction': true,
            'ExtendBounds': true,
            'FGColor': false,
            'FGDashFactor': false,
            'FGLineCap': true,
            'FGStyle': true,
            'FGWidth': false,
            'FontAlignment': false,
            'FontColor': false,
            'FontEscapement': false,
            'FontFamily': true,
            'FontHeight': false,
            'FontItalic': true,
            'FontTruncate': true,
            'FontTruncateString': false,
            'FontUnderline': true,
            'FontWeight': false,
            'FontWidthHint': false,
            'HeatmapLegendLabelPosition': true,
            'HeatmapLegendLabelRange': true,
            'HeatmapLegendPosition': true,
            'HeatmapLegendWidth': false,
            'IsAnnotation': true,
            'IsFootnote': true,
            'Label': false,
            'LabelMask': true,
            'Legend': true,
            'MarkerOnRight': true,
            'MarkerVPosition': true,
            'MarkerWidth': false,
            'MaxEntries': false,
            'Menu': false,
            'MenuXML': false,
            'MinEntries': false,
            'OrderCustom': true,
            'Packing': true,
            'Position': true,
            'Reverse': true,
            'ShowInvalidSeries': true,
            'ShowLabel': true,
            'ShowMarker': true,
            'Style': false,
            'SublabelMask': true,
            'Text': false,
            'TextFollowsSeriesColor': true,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipText': false,
            'VPosition': true,
            'WrapEntries': true,
            'XOffset': false,
            'YOffset': false
        },
        FDSPlot: {
            'AllowTopOverhang': true,
            'AnnotationEventMask': true,
            'AnnotationLegendCursor': true,
            'AxisGap': false,
            'AxisRefreshMask': true,
            'AxisResetOnDataChange': true,
            'BinMode': true,
            'BottomMargin': false,
            'BottomPlotMargin': false,
            'COLORAlias': true,
            'COLORAlternatingBackground': true,
            'COLORAlternatingBackgroundFactor': false,
            'COLORAutomaticHolidayDetection': true,
            'COLORAutomaticStartEndDayDetection': true,
            'COLORAxis': true,
            'COLORAxisFGColor': false,
            'COLORAxisFGDashFactor': false,
            'COLORAxisFGLineCap': true,
            'COLORAxisFGStyle': true,
            'COLORAxisFGWidth': false,
            'COLORAxisOffset': false,
            'COLORAxisPosition': true,
            'COLORAxisSeries': false,
            'COLORBaseRangesOnIntervals': true,
            'COLORBin': true,
            'COLORBinFactor': false,
            'COLORBinLabelMode': true,
            'COLORBinMinorLabelMode': true,
            'COLORCrosshairsLabel': true,
            'COLORCrosshairsLabelDrawnWithoutAxisLabels': true,
            'COLORCrosshairsLabelFontAlignment': false,
            'COLORCrosshairsLabelFontColor': false,
            'COLORCrosshairsLabelFontEscapement': false,
            'COLORCrosshairsLabelFontFamily': true,
            'COLORCrosshairsLabelFontHeight': false,
            'COLORCrosshairsLabelFontItalic': true,
            'COLORCrosshairsLabelFontTruncate': true,
            'COLORCrosshairsLabelFontTruncateString': false,
            'COLORCrosshairsLabelFontUnderline': true,
            'COLORCrosshairsLabelFontWeight': false,
            'COLORCrosshairsLabelFontWidthHint': false,
            'COLORCrosshairsLabelShowText': true,
            'COLORCrosshairsLabelText': false,
            'COLORCrosshairsLabelTextBox': true,
            'COLORCrosshairsLabelTextBoxArrowMultiplier': false,
            'COLORCrosshairsLabelTextBoxBGAlpha': false,
            'COLORCrosshairsLabelTextBoxBGColor': false,
            'COLORCrosshairsLabelTextBoxBGGradientAlpha': false,
            'COLORCrosshairsLabelTextBoxBGGradientAngle': false,
            'COLORCrosshairsLabelTextBoxBGGradientColor': false,
            'COLORCrosshairsLabelTextBoxBGGradientFactor': false,
            'COLORCrosshairsLabelTextBoxBGGradientStyle': true,
            'COLORCrosshairsLabelTextBoxBGImageName': false,
            'COLORCrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'COLORCrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'COLORCrosshairsLabelTextBoxBGStyle': true,
            'COLORCrosshairsLabelTextBoxClipText': true,
            'COLORCrosshairsLabelTextBoxDisplayMargins': false,
            'COLORCrosshairsLabelTextBoxDisplayStyle': true,
            'COLORCrosshairsLabelTextBoxFGColor': false,
            'COLORCrosshairsLabelTextBoxFGDashFactor': false,
            'COLORCrosshairsLabelTextBoxFGLineCap': true,
            'COLORCrosshairsLabelTextBoxFGStyle': true,
            'COLORCrosshairsLabelTextBoxFGWidth': false,
            'COLORCrosshairsLabelTextBoxHeightHint': false,
            'COLORCrosshairsLabelTextBoxPlacement': false,
            'COLORCrosshairsLabelTextBoxSizingMode': true,
            'COLORCrosshairsLabelTextBoxWidthHint': false,
            'COLORDateLabelShift': false,
            'COLORDateMinorLabelShift': false,
            'COLORDisplayHolidays': true,
            'COLOREndLabelLeftFormat': false,
            'COLOREndLabelLeftPosition': true,
            'COLOREndLabelMinorLeftFormat': false,
            'COLOREndLabelMinorLeftPosition': true,
            'COLOREndLabelMinorRightFormat': false,
            'COLOREndLabelMinorRightPosition': true,
            'COLOREndLabelRightFormat': false,
            'COLOREndLabelRightPosition': true,
            'COLOREndLabelSnapToDatapoint': true,
            'COLOREndMinorLabelSnapToDatapoint': true,
            'COLORExtendMajorTicks': true,
            'COLORExtendMinorTicks': true,
            'COLORFadeNonZoomedRegion': true,
            'COLORFont2Alignment': false,
            'COLORFont2Color': false,
            'COLORFont2Escapement': false,
            'COLORFont2Family': true,
            'COLORFont2Height': false,
            'COLORFont2Italic': true,
            'COLORFont2Truncate': true,
            'COLORFont2TruncateString': false,
            'COLORFont2Underline': true,
            'COLORFont2Weight': false,
            'COLORFont2WidthHint': false,
            'COLORFontAlignment': false,
            'COLORFontColor': false,
            'COLORFontEscapement': false,
            'COLORFontFamily': true,
            'COLORFontHeight': false,
            'COLORFontItalic': true,
            'COLORFontTruncate': true,
            'COLORFontTruncateString': false,
            'COLORFontUnderline': true,
            'COLORFontWeight': false,
            'COLORFontWidthHint': false,
            'COLORForceEndLabels': true,
            'COLORForceMinorEndLabels': true,
            'COLORGrid': true,
            'COLORGridFGColor': false,
            'COLORGridFGDashFactor': false,
            'COLORGridFGLineCap': true,
            'COLORGridFGStyle': true,
            'COLORGridFGWidth': false,
            'COLORHLBinsHint': false,
            'COLORHolidayDataset': false,
            'COLORIgnoreIntradayScaleLeastVisibleInterval': true,
            'COLORInnerBinPadding': false,
            'COLORIntradayLabeling': true,
            'COLORIntradayLabelingMask': true,
            'COLORIntradayScaleLabelFormatDAY': false,
            'COLORIntradayScaleLabelFormatFIVEMINUTE': false,
            'COLORIntradayScaleLabelFormatFIVESECOND': false,
            'COLORIntradayScaleLabelFormatFIVEY': false,
            'COLORIntradayScaleLabelFormatHALFHOUR': false,
            'COLORIntradayScaleLabelFormatHALFMINUTE': false,
            'COLORIntradayScaleLabelFormatHALFY': false,
            'COLORIntradayScaleLabelFormatHOUR': false,
            'COLORIntradayScaleLabelFormatMINUTE': false,
            'COLORIntradayScaleLabelFormatMONTH': false,
            'COLORIntradayScaleLabelFormatNONE': false,
            'COLORIntradayScaleLabelFormatQUARTER': false,
            'COLORIntradayScaleLabelFormatSECOND': false,
            'COLORIntradayScaleLabelFormatSIXHOUR': false,
            'COLORIntradayScaleLabelFormatTENMINUTE': false,
            'COLORIntradayScaleLabelFormatTENSECOND': false,
            'COLORIntradayScaleLabelFormatTENY': false,
            'COLORIntradayScaleLabelFormatTWOHOUR': false,
            'COLORIntradayScaleLabelFormatTWOMINUTE': false,
            'COLORIntradayScaleLabelFormatTWOSECOND': false,
            'COLORIntradayScaleLabelFormatTWOY': false,
            'COLORIntradayScaleLabelFormatWEEK': false,
            'COLORIntradayScaleLabelFormatYEAR': false,
            'COLORIntradayScaleLengthForPartialDays': true,
            'COLORIntradayScaleMajorUnitBGAlpha': false,
            'COLORIntradayScaleMajorUnitBGColor': false,
            'COLORIntradayScaleMajorUnitBGGradientAlpha': false,
            'COLORIntradayScaleMajorUnitBGGradientAngle': false,
            'COLORIntradayScaleMajorUnitBGGradientColor': false,
            'COLORIntradayScaleMajorUnitBGGradientFactor': false,
            'COLORIntradayScaleMajorUnitBGGradientStyle': true,
            'COLORIntradayScaleMajorUnitBGImageName': false,
            'COLORIntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'COLORIntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'COLORIntradayScaleMajorUnitBGStyle': true,
            'COLORIntradayScaleMinorLabelFormatDAY': false,
            'COLORIntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'COLORIntradayScaleMinorLabelFormatFIVESECOND': false,
            'COLORIntradayScaleMinorLabelFormatFIVEY': false,
            'COLORIntradayScaleMinorLabelFormatHALFHOUR': false,
            'COLORIntradayScaleMinorLabelFormatHALFMINUTE': false,
            'COLORIntradayScaleMinorLabelFormatHALFY': false,
            'COLORIntradayScaleMinorLabelFormatHOUR': false,
            'COLORIntradayScaleMinorLabelFormatMINUTE': false,
            'COLORIntradayScaleMinorLabelFormatMONTH': false,
            'COLORIntradayScaleMinorLabelFormatNONE': false,
            'COLORIntradayScaleMinorLabelFormatQUARTER': false,
            'COLORIntradayScaleMinorLabelFormatSECOND': false,
            'COLORIntradayScaleMinorLabelFormatSIXHOUR': false,
            'COLORIntradayScaleMinorLabelFormatTENMINUTE': false,
            'COLORIntradayScaleMinorLabelFormatTENSECOND': false,
            'COLORIntradayScaleMinorLabelFormatTENY': false,
            'COLORIntradayScaleMinorLabelFormatTWOHOUR': false,
            'COLORIntradayScaleMinorLabelFormatTWOMINUTE': false,
            'COLORIntradayScaleMinorLabelFormatTWOSECOND': false,
            'COLORIntradayScaleMinorLabelFormatTWOY': false,
            'COLORIntradayScaleMinorLabelFormatWEEK': false,
            'COLORIntradayScaleMinorLabelFormatYEAR': false,
            'COLORIntradayScaleMinorRangeDAY': false,
            'COLORIntradayScaleMinorRangeFIVEMINUTE': false,
            'COLORIntradayScaleMinorRangeFIVESECOND': false,
            'COLORIntradayScaleMinorRangeFIVEY': false,
            'COLORIntradayScaleMinorRangeHALFHOUR': false,
            'COLORIntradayScaleMinorRangeHALFMINUTE': false,
            'COLORIntradayScaleMinorRangeHALFY': false,
            'COLORIntradayScaleMinorRangeHOUR': false,
            'COLORIntradayScaleMinorRangeMINUTE': false,
            'COLORIntradayScaleMinorRangeMONTH': false,
            'COLORIntradayScaleMinorRangeNONE': false,
            'COLORIntradayScaleMinorRangeQUARTER': false,
            'COLORIntradayScaleMinorRangeSECOND': false,
            'COLORIntradayScaleMinorRangeSIXHOUR': false,
            'COLORIntradayScaleMinorRangeTENMINUTE': false,
            'COLORIntradayScaleMinorRangeTENSECOND': false,
            'COLORIntradayScaleMinorRangeTENY': false,
            'COLORIntradayScaleMinorRangeTWOHOUR': false,
            'COLORIntradayScaleMinorRangeTWOMINUTE': false,
            'COLORIntradayScaleMinorRangeTWOSECOND': false,
            'COLORIntradayScaleMinorRangeTWOY': false,
            'COLORIntradayScaleMinorRangeWEEK': false,
            'COLORIntradayScaleMinorRangeYEAR': false,
            'COLORIntradayScaleRangeDAY': false,
            'COLORIntradayScaleRangeFIVEMINUTE': false,
            'COLORIntradayScaleRangeFIVESECOND': false,
            'COLORIntradayScaleRangeFIVEY': false,
            'COLORIntradayScaleRangeHALFHOUR': false,
            'COLORIntradayScaleRangeHALFMINUTE': false,
            'COLORIntradayScaleRangeHALFY': false,
            'COLORIntradayScaleRangeHOUR': false,
            'COLORIntradayScaleRangeMINUTE': false,
            'COLORIntradayScaleRangeMONTH': false,
            'COLORIntradayScaleRangeNONE': false,
            'COLORIntradayScaleRangeQUARTER': false,
            'COLORIntradayScaleRangeSECOND': false,
            'COLORIntradayScaleRangeSIXHOUR': false,
            'COLORIntradayScaleRangeTENMINUTE': false,
            'COLORIntradayScaleRangeTENSECOND': false,
            'COLORIntradayScaleRangeTENY': false,
            'COLORIntradayScaleRangeTWOHOUR': false,
            'COLORIntradayScaleRangeTWOMINUTE': false,
            'COLORIntradayScaleRangeTWOSECOND': false,
            'COLORIntradayScaleRangeTWOY': false,
            'COLORIntradayScaleRangeWEEK': false,
            'COLORIntradayScaleRangeYEAR': false,
            'COLORLabel': true,
            'COLORLabelAnchor': false,
            'COLORLabelCentered': true,
            'COLORLabelCentered2': true,
            'COLORLabelFormat': false,
            'COLORLabelFormat2': false,
            'COLORLabelMinorPadding': false,
            'COLORLabelOffset': false,
            'COLORLabelOverride': false,
            'COLORLabelPadded': true,
            'COLORLabelPosition': true,
            'COLORLabelPostfix': false,
            'COLORLabelPostfix2': false,
            'COLORLabelPrefix': false,
            'COLORLabelPrefix2': false,
            'COLORLabelTooltipEnabled': true,
            'COLORLabelTooltipText': false,
            'COLORLabelsLevelsMask': true,
            'COLORLog': true,
            'COLORMajorTickMultiplier': false,
            'COLORMajorTickSnapToDate': true,
            'COLORMajorUnitStart': false,
            'COLORMinorGrid': true,
            'COLORMinorGridFGColor': false,
            'COLORMinorGridFGDashFactor': false,
            'COLORMinorGridFGLineCap': true,
            'COLORMinorGridFGStyle': true,
            'COLORMinorGridFGWidth': false,
            'COLORMinorGridInheritsColor': true,
            'COLORMinorTickDateBin': true,
            'COLORMinorTickMultiplier': false,
            'COLORMinorTickOffset': false,
            'COLORMinorTickSnapToDate': true,
            'COLORMinorTicks': true,
            'COLORMinorTicksLengthFactor': false,
            'COLORMinorUnitEnd': false,
            'COLORMinorUnitStart': false,
            'COLOROutlierAxis': true,
            'COLOROutlierAxisDynamic': true,
            'COLOROutlierAxisDynamicThreshold': false,
            'COLOROutlierAxisMarginMax': false,
            'COLOROutlierAxisMarginMin': false,
            'COLOROutlierAxisThreshMax': false,
            'COLOROutlierAxisThreshMin': false,
            'COLOROutlierIndicator': true,
            'COLOROutlierIndicatorBGAlpha': false,
            'COLOROutlierIndicatorBGColor': false,
            'COLOROutlierIndicatorBGGradientAlpha': false,
            'COLOROutlierIndicatorBGGradientAngle': false,
            'COLOROutlierIndicatorBGGradientColor': false,
            'COLOROutlierIndicatorBGGradientFactor': false,
            'COLOROutlierIndicatorBGGradientStyle': true,
            'COLOROutlierIndicatorBGImageName': false,
            'COLOROutlierIndicatorBGRadialGradientOffsetX': false,
            'COLOROutlierIndicatorBGRadialGradientOffsetY': false,
            'COLOROutlierIndicatorBGStyle': true,
            'COLOROutlierIndicatorFGColor': false,
            'COLOROutlierIndicatorFGDashFactor': false,
            'COLOROutlierIndicatorFGLineCap': true,
            'COLOROutlierIndicatorFGStyle': true,
            'COLOROutlierIndicatorFGWidth': false,
            'COLOROutlierIndicatorFactor': false,
            'COLOROutlierIndicatorMarkerSize': false,
            'COLOROutlierIndicatorMarkerStyle': true,
            'COLORReference': false,
            'COLORReferenceLine': true,
            'COLORReferenceLineFGColor': false,
            'COLORReferenceLineFGDashFactor': false,
            'COLORReferenceLineFGLineCap': true,
            'COLORReferenceLineFGStyle': true,
            'COLORReferenceLineFGWidth': false,
            'COLORRefreshAxis': true,
            'COLORRemoveGapsFromMajorIntervals': true,
            'COLORRemoveGapsFromMinorIntervals': true,
            'COLORReverse': true,
            'COLORRoundMinMax': true,
            'COLORSecondaryFrequency': true,
            'COLORShowMajorUnitWhenNoTicks': true,
            'COLORSubBinLabels': false,
            'COLORSubBinLabelsDefault': false,
            'COLORThreshConsider': true,
            'COLORThreshConsiderFactor': false,
            'COLORThreshConsiderValue': false,
            'COLORThreshMax': false,
            'COLORThreshMaxMargin': false,
            'COLORThreshMin': false,
            'COLORThreshMinMargin': false,
            'COLORTickBin': true,
            'COLORTickDateBin': true,
            'COLORTickMode': true,
            'COLORTickOffset': false,
            'COLORTickSafety': false,
            'COLORTicks': true,
            'COLORTicksFGColor': false,
            'COLORTicksFGDashFactor': false,
            'COLORTicksFGLineCap': true,
            'COLORTicksFGStyle': true,
            'COLORTicksFGWidth': false,
            'COLORTicksLength': false,
            'COLORTicksOffset': false,
            'COLORTicksPosition': true,
            'COLORTicksResize': true,
            'COLORTitle': true,
            'COLORTitleAtEnd': true,
            'COLORTitleFontAlignment': false,
            'COLORTitleFontColor': false,
            'COLORTitleFontEscapement': false,
            'COLORTitleFontFamily': true,
            'COLORTitleFontHeight': false,
            'COLORTitleFontItalic': true,
            'COLORTitleFontTruncate': true,
            'COLORTitleFontTruncateString': false,
            'COLORTitleFontUnderline': true,
            'COLORTitleFontWeight': false,
            'COLORTitleFontWidthHint': false,
            'COLORTitleOffset': false,
            'COLORTitlePosition': true,
            'COLORTitleRotationMode': true,
            'COLORTitleText': false,
            'COLORTitleTieWithEndLabel': true,
            'COLORTitleValuePosition': true,
            'COLORTreatWeekendsAsHolidays': true,
            'COLORWeekType': true,
            'COLORZoomDefaultMax': false,
            'COLORZoomDefaultMin': false,
            'COLORZoomEnabled': true,
            'COLORZoomGroup': false,
            'COLORZoomSliderHandleWidth': false,
            'COLORZoomSliderRegion': true,
            'COLORZoomSliderStickyMode': true,
            'COLORmaxPlotFactor': true,
            'COLORminPlotFactor': true,
            'ChartBGAlpha': false,
            'ChartBGColor': false,
            'ChartBGGradientAlpha': false,
            'ChartBGGradientAngle': false,
            'ChartBGGradientColor': false,
            'ChartBGGradientFactor': false,
            'ChartBGGradientStyle': true,
            'ChartBGImageName': false,
            'ChartBGRadialGradientOffsetX': false,
            'ChartBGRadialGradientOffsetY': false,
            'ChartBGStyle': true,
            'ChartFGColor': false,
            'ChartFGDashFactor': false,
            'ChartFGLineCap': true,
            'ChartFGStyle': true,
            'ChartFGWidth': false,
            'ClipPlot': true,
            'ClipSubPlot': true,
            'ClipSubPlotX': true,
            'CrosshairsBoundToPlot': true,
            'CrosshairsDrawOnPlot': true,
            'CrosshairsLineColor': false,
            'CrosshairsLineSize': false,
            'CrosshairsShowHorizontal': true,
            'CrosshairsShowVertical': true,
            'CrosshairsSnapToSeries': false,
            'CrosshairsSnapXToSeries': true,
            'CrosshairsSnapYToSeries': true,
            'Cursor': true,
            'DrawStyle': true,
            'EmptyMessage': false,
            'EmptyMessageFontAlignment': false,
            'EmptyMessageFontColor': false,
            'EmptyMessageFontEscapement': false,
            'EmptyMessageFontFamily': true,
            'EmptyMessageFontHeight': false,
            'EmptyMessageFontItalic': true,
            'EmptyMessageFontTruncate': true,
            'EmptyMessageFontTruncateString': false,
            'EmptyMessageFontUnderline': true,
            'EmptyMessageFontWeight': false,
            'EmptyMessageFontWidthHint': false,
            'EquateLRMargins': true,
            'Footer': true,
            'FooterAltText': false,
            'FooterBasePosition': true,
            'FooterCenterText': false,
            'FooterFontAlignment': false,
            'FooterFontColor': false,
            'FooterFontEscapement': false,
            'FooterFontFamily': true,
            'FooterFontHeight': false,
            'FooterFontItalic': true,
            'FooterFontTruncate': true,
            'FooterFontTruncateString': false,
            'FooterFontUnderline': true,
            'FooterFontWeight': false,
            'FooterFontWidthHint': false,
            'FooterPosition': true,
            'FooterText': false,
            'FootnoteLegendCursor': true,
            'Grouped': true,
            'GroupedBottom': true,
            'GroupedLeft': true,
            'GroupedLegend': true,
            'GroupedRight': true,
            'GroupedTop': true,
            'GroupedY': true,
            'Header': true,
            'HeaderAltText': false,
            'HeaderBasePosition': true,
            'HeaderCenterText': false,
            'HeaderFontAlignment': false,
            'HeaderFontColor': false,
            'HeaderFontEscapement': false,
            'HeaderFontFamily': true,
            'HeaderFontHeight': false,
            'HeaderFontItalic': true,
            'HeaderFontTruncate': true,
            'HeaderFontTruncateString': false,
            'HeaderFontUnderline': true,
            'HeaderFontWeight': false,
            'HeaderFontWidthHint': false,
            'HeaderPosition': true,
            'HeaderText': false,
            'Heading1': true,
            'Heading1AltText': false,
            'Heading1BasePosition': true,
            'Heading1CenterText': false,
            'Heading1FontAlignment': false,
            'Heading1FontColor': false,
            'Heading1FontEscapement': false,
            'Heading1FontFamily': true,
            'Heading1FontHeight': false,
            'Heading1FontItalic': true,
            'Heading1FontTruncate': true,
            'Heading1FontTruncateString': false,
            'Heading1FontUnderline': true,
            'Heading1FontWeight': false,
            'Heading1FontWidthHint': false,
            'Heading1Position': true,
            'Heading1Text': false,
            'Heading2': true,
            'Heading2AltText': false,
            'Heading2BasePosition': true,
            'Heading2CenterText': false,
            'Heading2FontAlignment': false,
            'Heading2FontColor': false,
            'Heading2FontEscapement': false,
            'Heading2FontFamily': true,
            'Heading2FontHeight': false,
            'Heading2FontItalic': true,
            'Heading2FontTruncate': true,
            'Heading2FontTruncateString': false,
            'Heading2FontUnderline': true,
            'Heading2FontWeight': false,
            'Heading2FontWidthHint': false,
            'Heading2Position': true,
            'Heading2Text': false,
            'Heading3': true,
            'Heading3AltText': false,
            'Heading3BasePosition': true,
            'Heading3CenterText': false,
            'Heading3FontAlignment': false,
            'Heading3FontColor': false,
            'Heading3FontEscapement': false,
            'Heading3FontFamily': true,
            'Heading3FontHeight': false,
            'Heading3FontItalic': true,
            'Heading3FontTruncate': true,
            'Heading3FontTruncateString': false,
            'Heading3FontUnderline': true,
            'Heading3FontWeight': false,
            'Heading3FontWidthHint': false,
            'Heading3Position': true,
            'Heading3Text': false,
            'Heading4': true,
            'Heading4AltText': false,
            'Heading4BasePosition': true,
            'Heading4CenterText': false,
            'Heading4FontAlignment': false,
            'Heading4FontColor': false,
            'Heading4FontEscapement': false,
            'Heading4FontFamily': true,
            'Heading4FontHeight': false,
            'Heading4FontItalic': true,
            'Heading4FontTruncate': true,
            'Heading4FontTruncateString': false,
            'Heading4FontUnderline': true,
            'Heading4FontWeight': false,
            'Heading4FontWidthHint': false,
            'Heading4Position': true,
            'Heading4Text': false,
            'HorizontalZoomFadeAlpha': false,
            'HorizontalZoomFadeColor': false,
            'HorizontalZoomFadeGradientAlpha': false,
            'HorizontalZoomFadeGradientAngle': false,
            'HorizontalZoomFadeGradientColor': false,
            'HorizontalZoomFadeGradientFactor': false,
            'HorizontalZoomFadeGradientStyle': true,
            'HorizontalZoomFadeImageName': false,
            'HorizontalZoomFadeRadialGradientOffsetX': false,
            'HorizontalZoomFadeRadialGradientOffsetY': false,
            'HorizontalZoomFadeStyle': true,
            'HorizontalZoomHandleAlpha': false,
            'HorizontalZoomHandleColor': false,
            'HorizontalZoomHandleGradientAlpha': false,
            'HorizontalZoomHandleGradientAngle': false,
            'HorizontalZoomHandleGradientColor': false,
            'HorizontalZoomHandleGradientFactor': false,
            'HorizontalZoomHandleGradientStyle': true,
            'HorizontalZoomHandleImageName': false,
            'HorizontalZoomHandleRadialGradientOffsetX': false,
            'HorizontalZoomHandleRadialGradientOffsetY': false,
            'HorizontalZoomHandleStyle': true,
            'HorizontalZoomRectAlpha': false,
            'HorizontalZoomRectColor': false,
            'HorizontalZoomRectGradientAlpha': false,
            'HorizontalZoomRectGradientAngle': false,
            'HorizontalZoomRectGradientColor': false,
            'HorizontalZoomRectGradientFactor': false,
            'HorizontalZoomRectGradientStyle': true,
            'HorizontalZoomRectImageName': false,
            'HorizontalZoomRectRadialGradientOffsetX': false,
            'HorizontalZoomRectRadialGradientOffsetY': false,
            'HorizontalZoomRectStyle': true,
            'InteractivityMode': true,
            'Label': false,
            'LeftMargin': false,
            'LeftPlotMargin': false,
            'Legend': true,
            'LegendAxisPosition': true,
            'LegendBGAlpha': false,
            'LegendBGColor': false,
            'LegendBGGradientAlpha': false,
            'LegendBGGradientAngle': false,
            'LegendBGGradientColor': false,
            'LegendBGGradientFactor': false,
            'LegendBGGradientStyle': true,
            'LegendBGImageName': false,
            'LegendBGRadialGradientOffsetX': false,
            'LegendBGRadialGradientOffsetY': false,
            'LegendBGStyle': true,
            'LegendBasePosition': true,
            'LegendBreak': false,
            'LegendCenterRows': true,
            'LegendCursor': false,
            'LegendDataMask': true,
            'LegendDirection': true,
            'LegendExtendBounds': true,
            'LegendFGColor': false,
            'LegendFGDashFactor': false,
            'LegendFGLineCap': true,
            'LegendFGStyle': true,
            'LegendFGWidth': false,
            'LegendFontAlignment': false,
            'LegendFontColor': false,
            'LegendFontEscapement': false,
            'LegendFontFamily': true,
            'LegendFontHeight': false,
            'LegendFontItalic': true,
            'LegendFontTruncate': true,
            'LegendFontTruncateString': false,
            'LegendFontUnderline': true,
            'LegendFontWeight': false,
            'LegendFontWidthHint': false,
            'LegendHeatmapLegendLabelPosition': true,
            'LegendHeatmapLegendLabelRange': true,
            'LegendHeatmapLegendPosition': true,
            'LegendHeatmapLegendWidth': false,
            'LegendIsAnnotation': true,
            'LegendIsFootnote': true,
            'LegendLabelMask': true,
            'LegendMarkerOnRight': true,
            'LegendMarkerVPosition': true,
            'LegendMarkerWidth': false,
            'LegendMaxEntries': false,
            'LegendMinEntries': false,
            'LegendOrderCustom': true,
            'LegendPacking': true,
            'LegendPosition': true,
            'LegendReverse': true,
            'LegendShowInvalidSeries': true,
            'LegendShowLabel': true,
            'LegendShowMarker': true,
            'LegendSublabelMask': true,
            'LegendText': false,
            'LegendTextFollowsSeriesColor': true,
            'LegendVPosition': true,
            'LegendWrapEntries': true,
            'LegendXOffset': false,
            'LegendYOffset': false,
            'MaxZoom': false,
            'Menu': false,
            'MenuXML': false,
            'MinZoom': false,
            'OnLeftButtonClick': false,
            'OnLeftButtonDoubleClick': false,
            'OnMiddleButtonClick': false,
            'OnMiddleButtonDoubleClick': false,
            'OnRightButtonClick': false,
            'OnRightButtonDoubleClick': false,
            'PlotBGAlpha': false,
            'PlotBGColor': false,
            'PlotBGGradientAlpha': false,
            'PlotBGGradientAngle': false,
            'PlotBGGradientColor': false,
            'PlotBGGradientFactor': false,
            'PlotBGGradientStyle': true,
            'PlotBGImageName': false,
            'PlotBGRadialGradientOffsetX': false,
            'PlotBGRadialGradientOffsetY': false,
            'PlotBGStyle': true,
            'PlotDragEnabled': true,
            'PlotFGColor': false,
            'PlotFGDashFactor': false,
            'PlotFGLineCap': true,
            'PlotFGStyle': true,
            'PlotFGWidth': false,
            'ReferenceLineEventMask': true,
            'ResizeAllAxesOnZoom': true,
            'ResizeEnabled': true,
            'ResizeMinFactorX': false,
            'ResizeMinFactorY': false,
            'ResizeTouchingOnly': true,
            'RightMargin': false,
            'RightPlotMargin': false,
            'SVGElementID': false,
            'SVGElementIDAJAX': false,
            'SeriesEventMask': true,
            'SeriesQuickLabel': true,
            'SeriesQuickLabelAutoPosition': true,
            'SeriesQuickLabelColorFollowsSeriesColor': true,
            'SeriesQuickLabelColorMaximumContrast': true,
            'SeriesQuickLabelFontAlignment': false,
            'SeriesQuickLabelFontColor': false,
            'SeriesQuickLabelFontEscapement': false,
            'SeriesQuickLabelFontFamily': true,
            'SeriesQuickLabelFontHeight': false,
            'SeriesQuickLabelFontItalic': true,
            'SeriesQuickLabelFontTruncate': true,
            'SeriesQuickLabelFontTruncateString': false,
            'SeriesQuickLabelFontUnderline': true,
            'SeriesQuickLabelFontWeight': false,
            'SeriesQuickLabelFontWidthHint': false,
            'SeriesQuickLabelLeftPositionModifier': true,
            'SeriesQuickLabelPosition': true,
            'SeriesQuickLabelRightPositionModifier': true,
            'SeriesQuickLabelText': false,
            'SeriesQuickLabelTextBox': true,
            'SeriesQuickLabelTextBoxBGAlpha': false,
            'SeriesQuickLabelTextBoxBGColor': false,
            'SeriesQuickLabelTextBoxBGGradientAlpha': false,
            'SeriesQuickLabelTextBoxBGGradientAngle': false,
            'SeriesQuickLabelTextBoxBGGradientColor': false,
            'SeriesQuickLabelTextBoxBGGradientFactor': false,
            'SeriesQuickLabelTextBoxBGGradientStyle': true,
            'SeriesQuickLabelTextBoxBGImageName': false,
            'SeriesQuickLabelTextBoxBGRadialGradientOffsetX': false,
            'SeriesQuickLabelTextBoxBGRadialGradientOffsetY': false,
            'SeriesQuickLabelTextBoxBGStyle': true,
            'SeriesQuickLabelTextBoxDisplayStyle': true,
            'SeriesQuickLabelTextBoxFGColor': false,
            'SeriesQuickLabelTextBoxFGDashFactor': false,
            'SeriesQuickLabelTextBoxFGLineCap': true,
            'SeriesQuickLabelTextBoxFGStyle': true,
            'SeriesQuickLabelTextBoxFGWidth': false,
            'SeriesQuickLabelVerticalPosition': true,
            'SeriesShadowBlurAmount': false,
            'SharedAxisAnchorDimension': false,
            'SharedAxisAnchorValueX': false,
            'SharedAxisAnchorValueY': false,
            'SimpleZoom': true,
            'Style': false,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipText': false,
            'TopMargin': false,
            'TopPlotMargin': false,
            'UseIntradayScale': true,
            'XAlias': true,
            'XAlternatingBackground': true,
            'XAlternatingBackgroundFactor': false,
            'XAutomaticHolidayDetection': true,
            'XAutomaticStartEndDayDetection': true,
            'XAxis': true,
            'XAxisFGColor': false,
            'XAxisFGDashFactor': false,
            'XAxisFGLineCap': true,
            'XAxisFGStyle': true,
            'XAxisFGWidth': false,
            'XAxisOffset': false,
            'XAxisPosition': true,
            'XAxisSeries': false,
            'XBaseRangesOnIntervals': true,
            'XBin': true,
            'XBinFactor': false,
            'XBinLabelMode': true,
            'XBinMinorLabelMode': true,
            'XCrosshairsLabel': true,
            'XCrosshairsLabelDrawnWithoutAxisLabels': true,
            'XCrosshairsLabelFontAlignment': false,
            'XCrosshairsLabelFontColor': false,
            'XCrosshairsLabelFontEscapement': false,
            'XCrosshairsLabelFontFamily': true,
            'XCrosshairsLabelFontHeight': false,
            'XCrosshairsLabelFontItalic': true,
            'XCrosshairsLabelFontTruncate': true,
            'XCrosshairsLabelFontTruncateString': false,
            'XCrosshairsLabelFontUnderline': true,
            'XCrosshairsLabelFontWeight': false,
            'XCrosshairsLabelFontWidthHint': false,
            'XCrosshairsLabelShowText': true,
            'XCrosshairsLabelText': false,
            'XCrosshairsLabelTextBox': true,
            'XCrosshairsLabelTextBoxArrowMultiplier': false,
            'XCrosshairsLabelTextBoxBGAlpha': false,
            'XCrosshairsLabelTextBoxBGColor': false,
            'XCrosshairsLabelTextBoxBGGradientAlpha': false,
            'XCrosshairsLabelTextBoxBGGradientAngle': false,
            'XCrosshairsLabelTextBoxBGGradientColor': false,
            'XCrosshairsLabelTextBoxBGGradientFactor': false,
            'XCrosshairsLabelTextBoxBGGradientStyle': true,
            'XCrosshairsLabelTextBoxBGImageName': false,
            'XCrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'XCrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'XCrosshairsLabelTextBoxBGStyle': true,
            'XCrosshairsLabelTextBoxClipText': true,
            'XCrosshairsLabelTextBoxDisplayMargins': false,
            'XCrosshairsLabelTextBoxDisplayStyle': true,
            'XCrosshairsLabelTextBoxFGColor': false,
            'XCrosshairsLabelTextBoxFGDashFactor': false,
            'XCrosshairsLabelTextBoxFGLineCap': true,
            'XCrosshairsLabelTextBoxFGStyle': true,
            'XCrosshairsLabelTextBoxFGWidth': false,
            'XCrosshairsLabelTextBoxHeightHint': false,
            'XCrosshairsLabelTextBoxPlacement': false,
            'XCrosshairsLabelTextBoxSizingMode': true,
            'XCrosshairsLabelTextBoxWidthHint': false,
            'XDateLabelShift': false,
            'XDateMinorLabelShift': false,
            'XDisplayHolidays': true,
            'XEndLabelLeftFormat': false,
            'XEndLabelLeftPosition': true,
            'XEndLabelMinorLeftFormat': false,
            'XEndLabelMinorLeftPosition': true,
            'XEndLabelMinorRightFormat': false,
            'XEndLabelMinorRightPosition': true,
            'XEndLabelRightFormat': false,
            'XEndLabelRightPosition': true,
            'XEndLabelSnapToDatapoint': true,
            'XEndMinorLabelSnapToDatapoint': true,
            'XExtendMajorTicks': true,
            'XExtendMinorTicks': true,
            'XFadeNonZoomedRegion': true,
            'XFont2Alignment': false,
            'XFont2Color': false,
            'XFont2Escapement': false,
            'XFont2Family': true,
            'XFont2Height': false,
            'XFont2Italic': true,
            'XFont2Truncate': true,
            'XFont2TruncateString': false,
            'XFont2Underline': true,
            'XFont2Weight': false,
            'XFont2WidthHint': false,
            'XFontAlignment': false,
            'XFontColor': false,
            'XFontEscapement': false,
            'XFontFamily': true,
            'XFontHeight': false,
            'XFontItalic': true,
            'XFontTruncate': true,
            'XFontTruncateString': false,
            'XFontUnderline': true,
            'XFontWeight': false,
            'XFontWidthHint': false,
            'XForceEndLabels': true,
            'XForceMinorEndLabels': true,
            'XGrid': true,
            'XGridFGColor': false,
            'XGridFGDashFactor': false,
            'XGridFGLineCap': true,
            'XGridFGStyle': true,
            'XGridFGWidth': false,
            'XHLBinsHint': false,
            'XHolidayDataset': false,
            'XIgnoreIntradayScaleLeastVisibleInterval': true,
            'XInnerBinPadding': false,
            'XIntradayLabeling': true,
            'XIntradayLabelingMask': true,
            'XIntradayScaleLabelFormatDAY': false,
            'XIntradayScaleLabelFormatFIVEMINUTE': false,
            'XIntradayScaleLabelFormatFIVESECOND': false,
            'XIntradayScaleLabelFormatFIVEY': false,
            'XIntradayScaleLabelFormatHALFHOUR': false,
            'XIntradayScaleLabelFormatHALFMINUTE': false,
            'XIntradayScaleLabelFormatHALFY': false,
            'XIntradayScaleLabelFormatHOUR': false,
            'XIntradayScaleLabelFormatMINUTE': false,
            'XIntradayScaleLabelFormatMONTH': false,
            'XIntradayScaleLabelFormatNONE': false,
            'XIntradayScaleLabelFormatQUARTER': false,
            'XIntradayScaleLabelFormatSECOND': false,
            'XIntradayScaleLabelFormatSIXHOUR': false,
            'XIntradayScaleLabelFormatTENMINUTE': false,
            'XIntradayScaleLabelFormatTENSECOND': false,
            'XIntradayScaleLabelFormatTENY': false,
            'XIntradayScaleLabelFormatTWOHOUR': false,
            'XIntradayScaleLabelFormatTWOMINUTE': false,
            'XIntradayScaleLabelFormatTWOSECOND': false,
            'XIntradayScaleLabelFormatTWOY': false,
            'XIntradayScaleLabelFormatWEEK': false,
            'XIntradayScaleLabelFormatYEAR': false,
            'XIntradayScaleLengthForPartialDays': true,
            'XIntradayScaleMajorUnitBGAlpha': false,
            'XIntradayScaleMajorUnitBGColor': false,
            'XIntradayScaleMajorUnitBGGradientAlpha': false,
            'XIntradayScaleMajorUnitBGGradientAngle': false,
            'XIntradayScaleMajorUnitBGGradientColor': false,
            'XIntradayScaleMajorUnitBGGradientFactor': false,
            'XIntradayScaleMajorUnitBGGradientStyle': true,
            'XIntradayScaleMajorUnitBGImageName': false,
            'XIntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'XIntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'XIntradayScaleMajorUnitBGStyle': true,
            'XIntradayScaleMinorLabelFormatDAY': false,
            'XIntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'XIntradayScaleMinorLabelFormatFIVESECOND': false,
            'XIntradayScaleMinorLabelFormatFIVEY': false,
            'XIntradayScaleMinorLabelFormatHALFHOUR': false,
            'XIntradayScaleMinorLabelFormatHALFMINUTE': false,
            'XIntradayScaleMinorLabelFormatHALFY': false,
            'XIntradayScaleMinorLabelFormatHOUR': false,
            'XIntradayScaleMinorLabelFormatMINUTE': false,
            'XIntradayScaleMinorLabelFormatMONTH': false,
            'XIntradayScaleMinorLabelFormatNONE': false,
            'XIntradayScaleMinorLabelFormatQUARTER': false,
            'XIntradayScaleMinorLabelFormatSECOND': false,
            'XIntradayScaleMinorLabelFormatSIXHOUR': false,
            'XIntradayScaleMinorLabelFormatTENMINUTE': false,
            'XIntradayScaleMinorLabelFormatTENSECOND': false,
            'XIntradayScaleMinorLabelFormatTENY': false,
            'XIntradayScaleMinorLabelFormatTWOHOUR': false,
            'XIntradayScaleMinorLabelFormatTWOMINUTE': false,
            'XIntradayScaleMinorLabelFormatTWOSECOND': false,
            'XIntradayScaleMinorLabelFormatTWOY': false,
            'XIntradayScaleMinorLabelFormatWEEK': false,
            'XIntradayScaleMinorLabelFormatYEAR': false,
            'XIntradayScaleMinorRangeDAY': false,
            'XIntradayScaleMinorRangeFIVEMINUTE': false,
            'XIntradayScaleMinorRangeFIVESECOND': false,
            'XIntradayScaleMinorRangeFIVEY': false,
            'XIntradayScaleMinorRangeHALFHOUR': false,
            'XIntradayScaleMinorRangeHALFMINUTE': false,
            'XIntradayScaleMinorRangeHALFY': false,
            'XIntradayScaleMinorRangeHOUR': false,
            'XIntradayScaleMinorRangeMINUTE': false,
            'XIntradayScaleMinorRangeMONTH': false,
            'XIntradayScaleMinorRangeNONE': false,
            'XIntradayScaleMinorRangeQUARTER': false,
            'XIntradayScaleMinorRangeSECOND': false,
            'XIntradayScaleMinorRangeSIXHOUR': false,
            'XIntradayScaleMinorRangeTENMINUTE': false,
            'XIntradayScaleMinorRangeTENSECOND': false,
            'XIntradayScaleMinorRangeTENY': false,
            'XIntradayScaleMinorRangeTWOHOUR': false,
            'XIntradayScaleMinorRangeTWOMINUTE': false,
            'XIntradayScaleMinorRangeTWOSECOND': false,
            'XIntradayScaleMinorRangeTWOY': false,
            'XIntradayScaleMinorRangeWEEK': false,
            'XIntradayScaleMinorRangeYEAR': false,
            'XIntradayScaleRangeDAY': false,
            'XIntradayScaleRangeFIVEMINUTE': false,
            'XIntradayScaleRangeFIVESECOND': false,
            'XIntradayScaleRangeFIVEY': false,
            'XIntradayScaleRangeHALFHOUR': false,
            'XIntradayScaleRangeHALFMINUTE': false,
            'XIntradayScaleRangeHALFY': false,
            'XIntradayScaleRangeHOUR': false,
            'XIntradayScaleRangeMINUTE': false,
            'XIntradayScaleRangeMONTH': false,
            'XIntradayScaleRangeNONE': false,
            'XIntradayScaleRangeQUARTER': false,
            'XIntradayScaleRangeSECOND': false,
            'XIntradayScaleRangeSIXHOUR': false,
            'XIntradayScaleRangeTENMINUTE': false,
            'XIntradayScaleRangeTENSECOND': false,
            'XIntradayScaleRangeTENY': false,
            'XIntradayScaleRangeTWOHOUR': false,
            'XIntradayScaleRangeTWOMINUTE': false,
            'XIntradayScaleRangeTWOSECOND': false,
            'XIntradayScaleRangeTWOY': false,
            'XIntradayScaleRangeWEEK': false,
            'XIntradayScaleRangeYEAR': false,
            'XLabel': true,
            'XLabelAnchor': false,
            'XLabelCentered': true,
            'XLabelCentered2': true,
            'XLabelFormat': false,
            'XLabelFormat2': false,
            'XLabelMinorPadding': false,
            'XLabelOffset': false,
            'XLabelOverride': false,
            'XLabelPadded': true,
            'XLabelPosition': true,
            'XLabelPostfix': false,
            'XLabelPostfix2': false,
            'XLabelPrefix': false,
            'XLabelPrefix2': false,
            'XLabelTooltipEnabled': true,
            'XLabelTooltipText': false,
            'XLabelsLevelsMask': true,
            'XLog': true,
            'XMajorTickMultiplier': false,
            'XMajorTickSnapToDate': true,
            'XMajorUnitStart': false,
            'XMinorGrid': true,
            'XMinorGridFGColor': false,
            'XMinorGridFGDashFactor': false,
            'XMinorGridFGLineCap': true,
            'XMinorGridFGStyle': true,
            'XMinorGridFGWidth': false,
            'XMinorGridInheritsColor': true,
            'XMinorTickDateBin': true,
            'XMinorTickMultiplier': false,
            'XMinorTickOffset': false,
            'XMinorTickSnapToDate': true,
            'XMinorTicks': true,
            'XMinorTicksLengthFactor': false,
            'XMinorUnitEnd': false,
            'XMinorUnitStart': false,
            'XOutlierAxis': true,
            'XOutlierAxisDynamic': true,
            'XOutlierAxisDynamicThreshold': false,
            'XOutlierAxisMarginMax': false,
            'XOutlierAxisMarginMin': false,
            'XOutlierAxisThreshMax': false,
            'XOutlierAxisThreshMin': false,
            'XOutlierIndicator': true,
            'XOutlierIndicatorBGAlpha': false,
            'XOutlierIndicatorBGColor': false,
            'XOutlierIndicatorBGGradientAlpha': false,
            'XOutlierIndicatorBGGradientAngle': false,
            'XOutlierIndicatorBGGradientColor': false,
            'XOutlierIndicatorBGGradientFactor': false,
            'XOutlierIndicatorBGGradientStyle': true,
            'XOutlierIndicatorBGImageName': false,
            'XOutlierIndicatorBGRadialGradientOffsetX': false,
            'XOutlierIndicatorBGRadialGradientOffsetY': false,
            'XOutlierIndicatorBGStyle': true,
            'XOutlierIndicatorFGColor': false,
            'XOutlierIndicatorFGDashFactor': false,
            'XOutlierIndicatorFGLineCap': true,
            'XOutlierIndicatorFGStyle': true,
            'XOutlierIndicatorFGWidth': false,
            'XOutlierIndicatorFactor': false,
            'XOutlierIndicatorMarkerSize': false,
            'XOutlierIndicatorMarkerStyle': true,
            'XReference': false,
            'XReferenceLine': true,
            'XReferenceLineFGColor': false,
            'XReferenceLineFGDashFactor': false,
            'XReferenceLineFGLineCap': true,
            'XReferenceLineFGStyle': true,
            'XReferenceLineFGWidth': false,
            'XRefreshAxis': true,
            'XRemoveGapsFromMajorIntervals': true,
            'XRemoveGapsFromMinorIntervals': true,
            'XReverse': true,
            'XRoundMinMax': true,
            'XSecondaryFrequency': true,
            'XShowMajorUnitWhenNoTicks': true,
            'XSubBinLabels': false,
            'XSubBinLabelsDefault': false,
            'XThreshConsider': true,
            'XThreshConsiderFactor': false,
            'XThreshConsiderValue': false,
            'XThreshMax': false,
            'XThreshMaxMargin': false,
            'XThreshMin': false,
            'XThreshMinMargin': false,
            'XTickBin': true,
            'XTickDateBin': true,
            'XTickMode': true,
            'XTickOffset': false,
            'XTickSafety': false,
            'XTicks': true,
            'XTicksFGColor': false,
            'XTicksFGDashFactor': false,
            'XTicksFGLineCap': true,
            'XTicksFGStyle': true,
            'XTicksFGWidth': false,
            'XTicksLength': false,
            'XTicksOffset': false,
            'XTicksPosition': true,
            'XTicksResize': true,
            'XTitle': true,
            'XTitleAtEnd': true,
            'XTitleFontAlignment': false,
            'XTitleFontColor': false,
            'XTitleFontEscapement': false,
            'XTitleFontFamily': true,
            'XTitleFontHeight': false,
            'XTitleFontItalic': true,
            'XTitleFontTruncate': true,
            'XTitleFontTruncateString': false,
            'XTitleFontUnderline': true,
            'XTitleFontWeight': false,
            'XTitleFontWidthHint': false,
            'XTitleOffset': false,
            'XTitlePosition': true,
            'XTitleRotationMode': true,
            'XTitleText': false,
            'XTitleTieWithEndLabel': true,
            'XTitleValuePosition': true,
            'XTreatWeekendsAsHolidays': true,
            'XWeekType': true,
            'XZoomDefaultMax': false,
            'XZoomDefaultMin': false,
            'XZoomEnabled': true,
            'XZoomGroup': false,
            'XZoomSliderHandleWidth': false,
            'XZoomSliderRegion': true,
            'XZoomSliderStickyMode': true,
            'XmaxPlotFactor': true,
            'XminPlotFactor': true,
            'Y2Alias': true,
            'Y2AlternatingBackground': true,
            'Y2AlternatingBackgroundFactor': false,
            'Y2AutomaticHolidayDetection': true,
            'Y2AutomaticStartEndDayDetection': true,
            'Y2Axis': true,
            'Y2AxisFGColor': false,
            'Y2AxisFGDashFactor': false,
            'Y2AxisFGLineCap': true,
            'Y2AxisFGStyle': true,
            'Y2AxisFGWidth': false,
            'Y2AxisOffset': false,
            'Y2AxisPosition': true,
            'Y2AxisSeries': false,
            'Y2BaseRangesOnIntervals': true,
            'Y2Bin': true,
            'Y2BinFactor': false,
            'Y2BinLabelMode': true,
            'Y2BinMinorLabelMode': true,
            'Y2CrosshairsLabel': true,
            'Y2CrosshairsLabelDrawnWithoutAxisLabels': true,
            'Y2CrosshairsLabelFontAlignment': false,
            'Y2CrosshairsLabelFontColor': false,
            'Y2CrosshairsLabelFontEscapement': false,
            'Y2CrosshairsLabelFontFamily': true,
            'Y2CrosshairsLabelFontHeight': false,
            'Y2CrosshairsLabelFontItalic': true,
            'Y2CrosshairsLabelFontTruncate': true,
            'Y2CrosshairsLabelFontTruncateString': false,
            'Y2CrosshairsLabelFontUnderline': true,
            'Y2CrosshairsLabelFontWeight': false,
            'Y2CrosshairsLabelFontWidthHint': false,
            'Y2CrosshairsLabelShowText': true,
            'Y2CrosshairsLabelText': false,
            'Y2CrosshairsLabelTextBox': true,
            'Y2CrosshairsLabelTextBoxArrowMultiplier': false,
            'Y2CrosshairsLabelTextBoxBGAlpha': false,
            'Y2CrosshairsLabelTextBoxBGColor': false,
            'Y2CrosshairsLabelTextBoxBGGradientAlpha': false,
            'Y2CrosshairsLabelTextBoxBGGradientAngle': false,
            'Y2CrosshairsLabelTextBoxBGGradientColor': false,
            'Y2CrosshairsLabelTextBoxBGGradientFactor': false,
            'Y2CrosshairsLabelTextBoxBGGradientStyle': true,
            'Y2CrosshairsLabelTextBoxBGImageName': false,
            'Y2CrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'Y2CrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'Y2CrosshairsLabelTextBoxBGStyle': true,
            'Y2CrosshairsLabelTextBoxClipText': true,
            'Y2CrosshairsLabelTextBoxDisplayMargins': false,
            'Y2CrosshairsLabelTextBoxDisplayStyle': true,
            'Y2CrosshairsLabelTextBoxFGColor': false,
            'Y2CrosshairsLabelTextBoxFGDashFactor': false,
            'Y2CrosshairsLabelTextBoxFGLineCap': true,
            'Y2CrosshairsLabelTextBoxFGStyle': true,
            'Y2CrosshairsLabelTextBoxFGWidth': false,
            'Y2CrosshairsLabelTextBoxHeightHint': false,
            'Y2CrosshairsLabelTextBoxPlacement': false,
            'Y2CrosshairsLabelTextBoxSizingMode': true,
            'Y2CrosshairsLabelTextBoxWidthHint': false,
            'Y2DateLabelShift': false,
            'Y2DateMinorLabelShift': false,
            'Y2DisplayHolidays': true,
            'Y2EndLabelLeftFormat': false,
            'Y2EndLabelLeftPosition': true,
            'Y2EndLabelMinorLeftFormat': false,
            'Y2EndLabelMinorLeftPosition': true,
            'Y2EndLabelMinorRightFormat': false,
            'Y2EndLabelMinorRightPosition': true,
            'Y2EndLabelRightFormat': false,
            'Y2EndLabelRightPosition': true,
            'Y2EndLabelSnapToDatapoint': true,
            'Y2EndMinorLabelSnapToDatapoint': true,
            'Y2ExtendMajorTicks': true,
            'Y2ExtendMinorTicks': true,
            'Y2FadeNonZoomedRegion': true,
            'Y2Font2Alignment': false,
            'Y2Font2Color': false,
            'Y2Font2Escapement': false,
            'Y2Font2Family': true,
            'Y2Font2Height': false,
            'Y2Font2Italic': true,
            'Y2Font2Truncate': true,
            'Y2Font2TruncateString': false,
            'Y2Font2Underline': true,
            'Y2Font2Weight': false,
            'Y2Font2WidthHint': false,
            'Y2FontAlignment': false,
            'Y2FontColor': false,
            'Y2FontEscapement': false,
            'Y2FontFamily': true,
            'Y2FontHeight': false,
            'Y2FontItalic': true,
            'Y2FontTruncate': true,
            'Y2FontTruncateString': false,
            'Y2FontUnderline': true,
            'Y2FontWeight': false,
            'Y2FontWidthHint': false,
            'Y2ForceEndLabels': true,
            'Y2ForceMinorEndLabels': true,
            'Y2Grid': true,
            'Y2GridFGColor': false,
            'Y2GridFGDashFactor': false,
            'Y2GridFGLineCap': true,
            'Y2GridFGStyle': true,
            'Y2GridFGWidth': false,
            'Y2HLBinsHint': false,
            'Y2HolidayDataset': false,
            'Y2IgnoreIntradayScaleLeastVisibleInterval': true,
            'Y2InnerBinPadding': false,
            'Y2IntradayLabeling': true,
            'Y2IntradayLabelingMask': true,
            'Y2IntradayScaleLabelFormatDAY': false,
            'Y2IntradayScaleLabelFormatFIVEMINUTE': false,
            'Y2IntradayScaleLabelFormatFIVESECOND': false,
            'Y2IntradayScaleLabelFormatFIVEY': false,
            'Y2IntradayScaleLabelFormatHALFHOUR': false,
            'Y2IntradayScaleLabelFormatHALFMINUTE': false,
            'Y2IntradayScaleLabelFormatHALFY': false,
            'Y2IntradayScaleLabelFormatHOUR': false,
            'Y2IntradayScaleLabelFormatMINUTE': false,
            'Y2IntradayScaleLabelFormatMONTH': false,
            'Y2IntradayScaleLabelFormatNONE': false,
            'Y2IntradayScaleLabelFormatQUARTER': false,
            'Y2IntradayScaleLabelFormatSECOND': false,
            'Y2IntradayScaleLabelFormatSIXHOUR': false,
            'Y2IntradayScaleLabelFormatTENMINUTE': false,
            'Y2IntradayScaleLabelFormatTENSECOND': false,
            'Y2IntradayScaleLabelFormatTENY': false,
            'Y2IntradayScaleLabelFormatTWOHOUR': false,
            'Y2IntradayScaleLabelFormatTWOMINUTE': false,
            'Y2IntradayScaleLabelFormatTWOSECOND': false,
            'Y2IntradayScaleLabelFormatTWOY': false,
            'Y2IntradayScaleLabelFormatWEEK': false,
            'Y2IntradayScaleLabelFormatYEAR': false,
            'Y2IntradayScaleLengthForPartialDays': true,
            'Y2IntradayScaleMajorUnitBGAlpha': false,
            'Y2IntradayScaleMajorUnitBGColor': false,
            'Y2IntradayScaleMajorUnitBGGradientAlpha': false,
            'Y2IntradayScaleMajorUnitBGGradientAngle': false,
            'Y2IntradayScaleMajorUnitBGGradientColor': false,
            'Y2IntradayScaleMajorUnitBGGradientFactor': false,
            'Y2IntradayScaleMajorUnitBGGradientStyle': true,
            'Y2IntradayScaleMajorUnitBGImageName': false,
            'Y2IntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'Y2IntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'Y2IntradayScaleMajorUnitBGStyle': true,
            'Y2IntradayScaleMinorLabelFormatDAY': false,
            'Y2IntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'Y2IntradayScaleMinorLabelFormatFIVESECOND': false,
            'Y2IntradayScaleMinorLabelFormatFIVEY': false,
            'Y2IntradayScaleMinorLabelFormatHALFHOUR': false,
            'Y2IntradayScaleMinorLabelFormatHALFMINUTE': false,
            'Y2IntradayScaleMinorLabelFormatHALFY': false,
            'Y2IntradayScaleMinorLabelFormatHOUR': false,
            'Y2IntradayScaleMinorLabelFormatMINUTE': false,
            'Y2IntradayScaleMinorLabelFormatMONTH': false,
            'Y2IntradayScaleMinorLabelFormatNONE': false,
            'Y2IntradayScaleMinorLabelFormatQUARTER': false,
            'Y2IntradayScaleMinorLabelFormatSECOND': false,
            'Y2IntradayScaleMinorLabelFormatSIXHOUR': false,
            'Y2IntradayScaleMinorLabelFormatTENMINUTE': false,
            'Y2IntradayScaleMinorLabelFormatTENSECOND': false,
            'Y2IntradayScaleMinorLabelFormatTENY': false,
            'Y2IntradayScaleMinorLabelFormatTWOHOUR': false,
            'Y2IntradayScaleMinorLabelFormatTWOMINUTE': false,
            'Y2IntradayScaleMinorLabelFormatTWOSECOND': false,
            'Y2IntradayScaleMinorLabelFormatTWOY': false,
            'Y2IntradayScaleMinorLabelFormatWEEK': false,
            'Y2IntradayScaleMinorLabelFormatYEAR': false,
            'Y2IntradayScaleMinorRangeDAY': false,
            'Y2IntradayScaleMinorRangeFIVEMINUTE': false,
            'Y2IntradayScaleMinorRangeFIVESECOND': false,
            'Y2IntradayScaleMinorRangeFIVEY': false,
            'Y2IntradayScaleMinorRangeHALFHOUR': false,
            'Y2IntradayScaleMinorRangeHALFMINUTE': false,
            'Y2IntradayScaleMinorRangeHALFY': false,
            'Y2IntradayScaleMinorRangeHOUR': false,
            'Y2IntradayScaleMinorRangeMINUTE': false,
            'Y2IntradayScaleMinorRangeMONTH': false,
            'Y2IntradayScaleMinorRangeNONE': false,
            'Y2IntradayScaleMinorRangeQUARTER': false,
            'Y2IntradayScaleMinorRangeSECOND': false,
            'Y2IntradayScaleMinorRangeSIXHOUR': false,
            'Y2IntradayScaleMinorRangeTENMINUTE': false,
            'Y2IntradayScaleMinorRangeTENSECOND': false,
            'Y2IntradayScaleMinorRangeTENY': false,
            'Y2IntradayScaleMinorRangeTWOHOUR': false,
            'Y2IntradayScaleMinorRangeTWOMINUTE': false,
            'Y2IntradayScaleMinorRangeTWOSECOND': false,
            'Y2IntradayScaleMinorRangeTWOY': false,
            'Y2IntradayScaleMinorRangeWEEK': false,
            'Y2IntradayScaleMinorRangeYEAR': false,
            'Y2IntradayScaleRangeDAY': false,
            'Y2IntradayScaleRangeFIVEMINUTE': false,
            'Y2IntradayScaleRangeFIVESECOND': false,
            'Y2IntradayScaleRangeFIVEY': false,
            'Y2IntradayScaleRangeHALFHOUR': false,
            'Y2IntradayScaleRangeHALFMINUTE': false,
            'Y2IntradayScaleRangeHALFY': false,
            'Y2IntradayScaleRangeHOUR': false,
            'Y2IntradayScaleRangeMINUTE': false,
            'Y2IntradayScaleRangeMONTH': false,
            'Y2IntradayScaleRangeNONE': false,
            'Y2IntradayScaleRangeQUARTER': false,
            'Y2IntradayScaleRangeSECOND': false,
            'Y2IntradayScaleRangeSIXHOUR': false,
            'Y2IntradayScaleRangeTENMINUTE': false,
            'Y2IntradayScaleRangeTENSECOND': false,
            'Y2IntradayScaleRangeTENY': false,
            'Y2IntradayScaleRangeTWOHOUR': false,
            'Y2IntradayScaleRangeTWOMINUTE': false,
            'Y2IntradayScaleRangeTWOSECOND': false,
            'Y2IntradayScaleRangeTWOY': false,
            'Y2IntradayScaleRangeWEEK': false,
            'Y2IntradayScaleRangeYEAR': false,
            'Y2Label': true,
            'Y2LabelAnchor': false,
            'Y2LabelCentered': true,
            'Y2LabelCentered2': true,
            'Y2LabelFormat': false,
            'Y2LabelFormat2': false,
            'Y2LabelMinorPadding': false,
            'Y2LabelOffset': false,
            'Y2LabelOverride': false,
            'Y2LabelPadded': true,
            'Y2LabelPosition': true,
            'Y2LabelPostfix': false,
            'Y2LabelPostfix2': false,
            'Y2LabelPrefix': false,
            'Y2LabelPrefix2': false,
            'Y2LabelTooltipEnabled': true,
            'Y2LabelTooltipText': false,
            'Y2LabelsLevelsMask': true,
            'Y2Log': true,
            'Y2MajorTickMultiplier': false,
            'Y2MajorTickSnapToDate': true,
            'Y2MajorUnitStart': false,
            'Y2MinorGrid': true,
            'Y2MinorGridFGColor': false,
            'Y2MinorGridFGDashFactor': false,
            'Y2MinorGridFGLineCap': true,
            'Y2MinorGridFGStyle': true,
            'Y2MinorGridFGWidth': false,
            'Y2MinorGridInheritsColor': true,
            'Y2MinorTickDateBin': true,
            'Y2MinorTickMultiplier': false,
            'Y2MinorTickOffset': false,
            'Y2MinorTickSnapToDate': true,
            'Y2MinorTicks': true,
            'Y2MinorTicksLengthFactor': false,
            'Y2MinorUnitEnd': false,
            'Y2MinorUnitStart': false,
            'Y2OutlierAxis': true,
            'Y2OutlierAxisDynamic': true,
            'Y2OutlierAxisDynamicThreshold': false,
            'Y2OutlierAxisMarginMax': false,
            'Y2OutlierAxisMarginMin': false,
            'Y2OutlierAxisThreshMax': false,
            'Y2OutlierAxisThreshMin': false,
            'Y2OutlierIndicator': true,
            'Y2OutlierIndicatorBGAlpha': false,
            'Y2OutlierIndicatorBGColor': false,
            'Y2OutlierIndicatorBGGradientAlpha': false,
            'Y2OutlierIndicatorBGGradientAngle': false,
            'Y2OutlierIndicatorBGGradientColor': false,
            'Y2OutlierIndicatorBGGradientFactor': false,
            'Y2OutlierIndicatorBGGradientStyle': true,
            'Y2OutlierIndicatorBGImageName': false,
            'Y2OutlierIndicatorBGRadialGradientOffsetX': false,
            'Y2OutlierIndicatorBGRadialGradientOffsetY': false,
            'Y2OutlierIndicatorBGStyle': true,
            'Y2OutlierIndicatorFGColor': false,
            'Y2OutlierIndicatorFGDashFactor': false,
            'Y2OutlierIndicatorFGLineCap': true,
            'Y2OutlierIndicatorFGStyle': true,
            'Y2OutlierIndicatorFGWidth': false,
            'Y2OutlierIndicatorFactor': false,
            'Y2OutlierIndicatorMarkerSize': false,
            'Y2OutlierIndicatorMarkerStyle': true,
            'Y2Reference': false,
            'Y2ReferenceLine': true,
            'Y2ReferenceLineFGColor': false,
            'Y2ReferenceLineFGDashFactor': false,
            'Y2ReferenceLineFGLineCap': true,
            'Y2ReferenceLineFGStyle': true,
            'Y2ReferenceLineFGWidth': false,
            'Y2RefreshAxis': true,
            'Y2RemoveGapsFromMajorIntervals': true,
            'Y2RemoveGapsFromMinorIntervals': true,
            'Y2Reverse': true,
            'Y2RoundMinMax': true,
            'Y2SecondaryFrequency': true,
            'Y2ShowMajorUnitWhenNoTicks': true,
            'Y2SubBinLabels': false,
            'Y2SubBinLabelsDefault': false,
            'Y2ThreshConsider': true,
            'Y2ThreshConsiderFactor': false,
            'Y2ThreshConsiderValue': false,
            'Y2ThreshMax': false,
            'Y2ThreshMaxMargin': false,
            'Y2ThreshMin': false,
            'Y2ThreshMinMargin': false,
            'Y2TickBin': true,
            'Y2TickDateBin': true,
            'Y2TickMode': true,
            'Y2TickOffset': false,
            'Y2TickSafety': false,
            'Y2Ticks': true,
            'Y2TicksFGColor': false,
            'Y2TicksFGDashFactor': false,
            'Y2TicksFGLineCap': true,
            'Y2TicksFGStyle': true,
            'Y2TicksFGWidth': false,
            'Y2TicksLength': false,
            'Y2TicksOffset': false,
            'Y2TicksPosition': true,
            'Y2TicksResize': true,
            'Y2Title': true,
            'Y2TitleAtEnd': true,
            'Y2TitleFontAlignment': false,
            'Y2TitleFontColor': false,
            'Y2TitleFontEscapement': false,
            'Y2TitleFontFamily': true,
            'Y2TitleFontHeight': false,
            'Y2TitleFontItalic': true,
            'Y2TitleFontTruncate': true,
            'Y2TitleFontTruncateString': false,
            'Y2TitleFontUnderline': true,
            'Y2TitleFontWeight': false,
            'Y2TitleFontWidthHint': false,
            'Y2TitleOffset': false,
            'Y2TitlePosition': true,
            'Y2TitleRotationMode': true,
            'Y2TitleText': false,
            'Y2TitleTieWithEndLabel': true,
            'Y2TitleValuePosition': true,
            'Y2TreatWeekendsAsHolidays': true,
            'Y2WeekType': true,
            'Y2ZoomDefaultMax': false,
            'Y2ZoomDefaultMin': false,
            'Y2ZoomEnabled': true,
            'Y2ZoomGroup': false,
            'Y2ZoomSliderHandleWidth': false,
            'Y2ZoomSliderRegion': true,
            'Y2ZoomSliderStickyMode': true,
            'Y2maxPlotFactor': true,
            'Y2minPlotFactor': true,
            'Y3Alias': true,
            'Y3AlternatingBackground': true,
            'Y3AlternatingBackgroundFactor': false,
            'Y3AutomaticHolidayDetection': true,
            'Y3AutomaticStartEndDayDetection': true,
            'Y3Axis': true,
            'Y3AxisFGColor': false,
            'Y3AxisFGDashFactor': false,
            'Y3AxisFGLineCap': true,
            'Y3AxisFGStyle': true,
            'Y3AxisFGWidth': false,
            'Y3AxisOffset': false,
            'Y3AxisPosition': true,
            'Y3AxisSeries': false,
            'Y3BaseRangesOnIntervals': true,
            'Y3Bin': true,
            'Y3BinFactor': false,
            'Y3BinLabelMode': true,
            'Y3BinMinorLabelMode': true,
            'Y3CrosshairsLabel': true,
            'Y3CrosshairsLabelDrawnWithoutAxisLabels': true,
            'Y3CrosshairsLabelFontAlignment': false,
            'Y3CrosshairsLabelFontColor': false,
            'Y3CrosshairsLabelFontEscapement': false,
            'Y3CrosshairsLabelFontFamily': true,
            'Y3CrosshairsLabelFontHeight': false,
            'Y3CrosshairsLabelFontItalic': true,
            'Y3CrosshairsLabelFontTruncate': true,
            'Y3CrosshairsLabelFontTruncateString': false,
            'Y3CrosshairsLabelFontUnderline': true,
            'Y3CrosshairsLabelFontWeight': false,
            'Y3CrosshairsLabelFontWidthHint': false,
            'Y3CrosshairsLabelShowText': true,
            'Y3CrosshairsLabelText': false,
            'Y3CrosshairsLabelTextBox': true,
            'Y3CrosshairsLabelTextBoxArrowMultiplier': false,
            'Y3CrosshairsLabelTextBoxBGAlpha': false,
            'Y3CrosshairsLabelTextBoxBGColor': false,
            'Y3CrosshairsLabelTextBoxBGGradientAlpha': false,
            'Y3CrosshairsLabelTextBoxBGGradientAngle': false,
            'Y3CrosshairsLabelTextBoxBGGradientColor': false,
            'Y3CrosshairsLabelTextBoxBGGradientFactor': false,
            'Y3CrosshairsLabelTextBoxBGGradientStyle': true,
            'Y3CrosshairsLabelTextBoxBGImageName': false,
            'Y3CrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'Y3CrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'Y3CrosshairsLabelTextBoxBGStyle': true,
            'Y3CrosshairsLabelTextBoxClipText': true,
            'Y3CrosshairsLabelTextBoxDisplayMargins': false,
            'Y3CrosshairsLabelTextBoxDisplayStyle': true,
            'Y3CrosshairsLabelTextBoxFGColor': false,
            'Y3CrosshairsLabelTextBoxFGDashFactor': false,
            'Y3CrosshairsLabelTextBoxFGLineCap': true,
            'Y3CrosshairsLabelTextBoxFGStyle': true,
            'Y3CrosshairsLabelTextBoxFGWidth': false,
            'Y3CrosshairsLabelTextBoxHeightHint': false,
            'Y3CrosshairsLabelTextBoxPlacement': false,
            'Y3CrosshairsLabelTextBoxSizingMode': true,
            'Y3CrosshairsLabelTextBoxWidthHint': false,
            'Y3DateLabelShift': false,
            'Y3DateMinorLabelShift': false,
            'Y3DisplayHolidays': true,
            'Y3EndLabelLeftFormat': false,
            'Y3EndLabelLeftPosition': true,
            'Y3EndLabelMinorLeftFormat': false,
            'Y3EndLabelMinorLeftPosition': true,
            'Y3EndLabelMinorRightFormat': false,
            'Y3EndLabelMinorRightPosition': true,
            'Y3EndLabelRightFormat': false,
            'Y3EndLabelRightPosition': true,
            'Y3EndLabelSnapToDatapoint': true,
            'Y3EndMinorLabelSnapToDatapoint': true,
            'Y3ExtendMajorTicks': true,
            'Y3ExtendMinorTicks': true,
            'Y3FadeNonZoomedRegion': true,
            'Y3Font2Alignment': false,
            'Y3Font2Color': false,
            'Y3Font2Escapement': false,
            'Y3Font2Family': true,
            'Y3Font2Height': false,
            'Y3Font2Italic': true,
            'Y3Font2Truncate': true,
            'Y3Font2TruncateString': false,
            'Y3Font2Underline': true,
            'Y3Font2Weight': false,
            'Y3Font2WidthHint': false,
            'Y3FontAlignment': false,
            'Y3FontColor': false,
            'Y3FontEscapement': false,
            'Y3FontFamily': true,
            'Y3FontHeight': false,
            'Y3FontItalic': true,
            'Y3FontTruncate': true,
            'Y3FontTruncateString': false,
            'Y3FontUnderline': true,
            'Y3FontWeight': false,
            'Y3FontWidthHint': false,
            'Y3ForceEndLabels': true,
            'Y3ForceMinorEndLabels': true,
            'Y3Grid': true,
            'Y3GridFGColor': false,
            'Y3GridFGDashFactor': false,
            'Y3GridFGLineCap': true,
            'Y3GridFGStyle': true,
            'Y3GridFGWidth': false,
            'Y3HLBinsHint': false,
            'Y3HolidayDataset': false,
            'Y3IgnoreIntradayScaleLeastVisibleInterval': true,
            'Y3InnerBinPadding': false,
            'Y3IntradayLabeling': true,
            'Y3IntradayLabelingMask': true,
            'Y3IntradayScaleLabelFormatDAY': false,
            'Y3IntradayScaleLabelFormatFIVEMINUTE': false,
            'Y3IntradayScaleLabelFormatFIVESECOND': false,
            'Y3IntradayScaleLabelFormatFIVEY': false,
            'Y3IntradayScaleLabelFormatHALFHOUR': false,
            'Y3IntradayScaleLabelFormatHALFMINUTE': false,
            'Y3IntradayScaleLabelFormatHALFY': false,
            'Y3IntradayScaleLabelFormatHOUR': false,
            'Y3IntradayScaleLabelFormatMINUTE': false,
            'Y3IntradayScaleLabelFormatMONTH': false,
            'Y3IntradayScaleLabelFormatNONE': false,
            'Y3IntradayScaleLabelFormatQUARTER': false,
            'Y3IntradayScaleLabelFormatSECOND': false,
            'Y3IntradayScaleLabelFormatSIXHOUR': false,
            'Y3IntradayScaleLabelFormatTENMINUTE': false,
            'Y3IntradayScaleLabelFormatTENSECOND': false,
            'Y3IntradayScaleLabelFormatTENY': false,
            'Y3IntradayScaleLabelFormatTWOHOUR': false,
            'Y3IntradayScaleLabelFormatTWOMINUTE': false,
            'Y3IntradayScaleLabelFormatTWOSECOND': false,
            'Y3IntradayScaleLabelFormatTWOY': false,
            'Y3IntradayScaleLabelFormatWEEK': false,
            'Y3IntradayScaleLabelFormatYEAR': false,
            'Y3IntradayScaleLengthForPartialDays': true,
            'Y3IntradayScaleMajorUnitBGAlpha': false,
            'Y3IntradayScaleMajorUnitBGColor': false,
            'Y3IntradayScaleMajorUnitBGGradientAlpha': false,
            'Y3IntradayScaleMajorUnitBGGradientAngle': false,
            'Y3IntradayScaleMajorUnitBGGradientColor': false,
            'Y3IntradayScaleMajorUnitBGGradientFactor': false,
            'Y3IntradayScaleMajorUnitBGGradientStyle': true,
            'Y3IntradayScaleMajorUnitBGImageName': false,
            'Y3IntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'Y3IntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'Y3IntradayScaleMajorUnitBGStyle': true,
            'Y3IntradayScaleMinorLabelFormatDAY': false,
            'Y3IntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'Y3IntradayScaleMinorLabelFormatFIVESECOND': false,
            'Y3IntradayScaleMinorLabelFormatFIVEY': false,
            'Y3IntradayScaleMinorLabelFormatHALFHOUR': false,
            'Y3IntradayScaleMinorLabelFormatHALFMINUTE': false,
            'Y3IntradayScaleMinorLabelFormatHALFY': false,
            'Y3IntradayScaleMinorLabelFormatHOUR': false,
            'Y3IntradayScaleMinorLabelFormatMINUTE': false,
            'Y3IntradayScaleMinorLabelFormatMONTH': false,
            'Y3IntradayScaleMinorLabelFormatNONE': false,
            'Y3IntradayScaleMinorLabelFormatQUARTER': false,
            'Y3IntradayScaleMinorLabelFormatSECOND': false,
            'Y3IntradayScaleMinorLabelFormatSIXHOUR': false,
            'Y3IntradayScaleMinorLabelFormatTENMINUTE': false,
            'Y3IntradayScaleMinorLabelFormatTENSECOND': false,
            'Y3IntradayScaleMinorLabelFormatTENY': false,
            'Y3IntradayScaleMinorLabelFormatTWOHOUR': false,
            'Y3IntradayScaleMinorLabelFormatTWOMINUTE': false,
            'Y3IntradayScaleMinorLabelFormatTWOSECOND': false,
            'Y3IntradayScaleMinorLabelFormatTWOY': false,
            'Y3IntradayScaleMinorLabelFormatWEEK': false,
            'Y3IntradayScaleMinorLabelFormatYEAR': false,
            'Y3IntradayScaleMinorRangeDAY': false,
            'Y3IntradayScaleMinorRangeFIVEMINUTE': false,
            'Y3IntradayScaleMinorRangeFIVESECOND': false,
            'Y3IntradayScaleMinorRangeFIVEY': false,
            'Y3IntradayScaleMinorRangeHALFHOUR': false,
            'Y3IntradayScaleMinorRangeHALFMINUTE': false,
            'Y3IntradayScaleMinorRangeHALFY': false,
            'Y3IntradayScaleMinorRangeHOUR': false,
            'Y3IntradayScaleMinorRangeMINUTE': false,
            'Y3IntradayScaleMinorRangeMONTH': false,
            'Y3IntradayScaleMinorRangeNONE': false,
            'Y3IntradayScaleMinorRangeQUARTER': false,
            'Y3IntradayScaleMinorRangeSECOND': false,
            'Y3IntradayScaleMinorRangeSIXHOUR': false,
            'Y3IntradayScaleMinorRangeTENMINUTE': false,
            'Y3IntradayScaleMinorRangeTENSECOND': false,
            'Y3IntradayScaleMinorRangeTENY': false,
            'Y3IntradayScaleMinorRangeTWOHOUR': false,
            'Y3IntradayScaleMinorRangeTWOMINUTE': false,
            'Y3IntradayScaleMinorRangeTWOSECOND': false,
            'Y3IntradayScaleMinorRangeTWOY': false,
            'Y3IntradayScaleMinorRangeWEEK': false,
            'Y3IntradayScaleMinorRangeYEAR': false,
            'Y3IntradayScaleRangeDAY': false,
            'Y3IntradayScaleRangeFIVEMINUTE': false,
            'Y3IntradayScaleRangeFIVESECOND': false,
            'Y3IntradayScaleRangeFIVEY': false,
            'Y3IntradayScaleRangeHALFHOUR': false,
            'Y3IntradayScaleRangeHALFMINUTE': false,
            'Y3IntradayScaleRangeHALFY': false,
            'Y3IntradayScaleRangeHOUR': false,
            'Y3IntradayScaleRangeMINUTE': false,
            'Y3IntradayScaleRangeMONTH': false,
            'Y3IntradayScaleRangeNONE': false,
            'Y3IntradayScaleRangeQUARTER': false,
            'Y3IntradayScaleRangeSECOND': false,
            'Y3IntradayScaleRangeSIXHOUR': false,
            'Y3IntradayScaleRangeTENMINUTE': false,
            'Y3IntradayScaleRangeTENSECOND': false,
            'Y3IntradayScaleRangeTENY': false,
            'Y3IntradayScaleRangeTWOHOUR': false,
            'Y3IntradayScaleRangeTWOMINUTE': false,
            'Y3IntradayScaleRangeTWOSECOND': false,
            'Y3IntradayScaleRangeTWOY': false,
            'Y3IntradayScaleRangeWEEK': false,
            'Y3IntradayScaleRangeYEAR': false,
            'Y3Label': true,
            'Y3LabelAnchor': false,
            'Y3LabelCentered': true,
            'Y3LabelCentered2': true,
            'Y3LabelFormat': false,
            'Y3LabelFormat2': false,
            'Y3LabelMinorPadding': false,
            'Y3LabelOffset': false,
            'Y3LabelOverride': false,
            'Y3LabelPadded': true,
            'Y3LabelPosition': true,
            'Y3LabelPostfix': false,
            'Y3LabelPostfix2': false,
            'Y3LabelPrefix': false,
            'Y3LabelPrefix2': false,
            'Y3LabelTooltipEnabled': true,
            'Y3LabelTooltipText': false,
            'Y3LabelsLevelsMask': true,
            'Y3Log': true,
            'Y3MajorTickMultiplier': false,
            'Y3MajorTickSnapToDate': true,
            'Y3MajorUnitStart': false,
            'Y3MinorGrid': true,
            'Y3MinorGridFGColor': false,
            'Y3MinorGridFGDashFactor': false,
            'Y3MinorGridFGLineCap': true,
            'Y3MinorGridFGStyle': true,
            'Y3MinorGridFGWidth': false,
            'Y3MinorGridInheritsColor': true,
            'Y3MinorTickDateBin': true,
            'Y3MinorTickMultiplier': false,
            'Y3MinorTickOffset': false,
            'Y3MinorTickSnapToDate': true,
            'Y3MinorTicks': true,
            'Y3MinorTicksLengthFactor': false,
            'Y3MinorUnitEnd': false,
            'Y3MinorUnitStart': false,
            'Y3OutlierAxis': true,
            'Y3OutlierAxisDynamic': true,
            'Y3OutlierAxisDynamicThreshold': false,
            'Y3OutlierAxisMarginMax': false,
            'Y3OutlierAxisMarginMin': false,
            'Y3OutlierAxisThreshMax': false,
            'Y3OutlierAxisThreshMin': false,
            'Y3OutlierIndicator': true,
            'Y3OutlierIndicatorBGAlpha': false,
            'Y3OutlierIndicatorBGColor': false,
            'Y3OutlierIndicatorBGGradientAlpha': false,
            'Y3OutlierIndicatorBGGradientAngle': false,
            'Y3OutlierIndicatorBGGradientColor': false,
            'Y3OutlierIndicatorBGGradientFactor': false,
            'Y3OutlierIndicatorBGGradientStyle': true,
            'Y3OutlierIndicatorBGImageName': false,
            'Y3OutlierIndicatorBGRadialGradientOffsetX': false,
            'Y3OutlierIndicatorBGRadialGradientOffsetY': false,
            'Y3OutlierIndicatorBGStyle': true,
            'Y3OutlierIndicatorFGColor': false,
            'Y3OutlierIndicatorFGDashFactor': false,
            'Y3OutlierIndicatorFGLineCap': true,
            'Y3OutlierIndicatorFGStyle': true,
            'Y3OutlierIndicatorFGWidth': false,
            'Y3OutlierIndicatorFactor': false,
            'Y3OutlierIndicatorMarkerSize': false,
            'Y3OutlierIndicatorMarkerStyle': true,
            'Y3Reference': false,
            'Y3ReferenceLine': true,
            'Y3ReferenceLineFGColor': false,
            'Y3ReferenceLineFGDashFactor': false,
            'Y3ReferenceLineFGLineCap': true,
            'Y3ReferenceLineFGStyle': true,
            'Y3ReferenceLineFGWidth': false,
            'Y3RefreshAxis': true,
            'Y3RemoveGapsFromMajorIntervals': true,
            'Y3RemoveGapsFromMinorIntervals': true,
            'Y3Reverse': true,
            'Y3RoundMinMax': true,
            'Y3SecondaryFrequency': true,
            'Y3ShowMajorUnitWhenNoTicks': true,
            'Y3SubBinLabels': false,
            'Y3SubBinLabelsDefault': false,
            'Y3ThreshConsider': true,
            'Y3ThreshConsiderFactor': false,
            'Y3ThreshConsiderValue': false,
            'Y3ThreshMax': false,
            'Y3ThreshMaxMargin': false,
            'Y3ThreshMin': false,
            'Y3ThreshMinMargin': false,
            'Y3TickBin': true,
            'Y3TickDateBin': true,
            'Y3TickMode': true,
            'Y3TickOffset': false,
            'Y3TickSafety': false,
            'Y3Ticks': true,
            'Y3TicksFGColor': false,
            'Y3TicksFGDashFactor': false,
            'Y3TicksFGLineCap': true,
            'Y3TicksFGStyle': true,
            'Y3TicksFGWidth': false,
            'Y3TicksLength': false,
            'Y3TicksOffset': false,
            'Y3TicksPosition': true,
            'Y3TicksResize': true,
            'Y3Title': true,
            'Y3TitleAtEnd': true,
            'Y3TitleFontAlignment': false,
            'Y3TitleFontColor': false,
            'Y3TitleFontEscapement': false,
            'Y3TitleFontFamily': true,
            'Y3TitleFontHeight': false,
            'Y3TitleFontItalic': true,
            'Y3TitleFontTruncate': true,
            'Y3TitleFontTruncateString': false,
            'Y3TitleFontUnderline': true,
            'Y3TitleFontWeight': false,
            'Y3TitleFontWidthHint': false,
            'Y3TitleOffset': false,
            'Y3TitlePosition': true,
            'Y3TitleRotationMode': true,
            'Y3TitleText': false,
            'Y3TitleTieWithEndLabel': true,
            'Y3TitleValuePosition': true,
            'Y3TreatWeekendsAsHolidays': true,
            'Y3WeekType': true,
            'Y3ZoomDefaultMax': false,
            'Y3ZoomDefaultMin': false,
            'Y3ZoomEnabled': true,
            'Y3ZoomGroup': false,
            'Y3ZoomSliderHandleWidth': false,
            'Y3ZoomSliderRegion': true,
            'Y3ZoomSliderStickyMode': true,
            'Y3maxPlotFactor': true,
            'Y3minPlotFactor': true,
            'Y4Alias': true,
            'Y4AlternatingBackground': true,
            'Y4AlternatingBackgroundFactor': false,
            'Y4AutomaticHolidayDetection': true,
            'Y4AutomaticStartEndDayDetection': true,
            'Y4Axis': true,
            'Y4AxisFGColor': false,
            'Y4AxisFGDashFactor': false,
            'Y4AxisFGLineCap': true,
            'Y4AxisFGStyle': true,
            'Y4AxisFGWidth': false,
            'Y4AxisOffset': false,
            'Y4AxisPosition': true,
            'Y4AxisSeries': false,
            'Y4BaseRangesOnIntervals': true,
            'Y4Bin': true,
            'Y4BinFactor': false,
            'Y4BinLabelMode': true,
            'Y4BinMinorLabelMode': true,
            'Y4CrosshairsLabel': true,
            'Y4CrosshairsLabelDrawnWithoutAxisLabels': true,
            'Y4CrosshairsLabelFontAlignment': false,
            'Y4CrosshairsLabelFontColor': false,
            'Y4CrosshairsLabelFontEscapement': false,
            'Y4CrosshairsLabelFontFamily': true,
            'Y4CrosshairsLabelFontHeight': false,
            'Y4CrosshairsLabelFontItalic': true,
            'Y4CrosshairsLabelFontTruncate': true,
            'Y4CrosshairsLabelFontTruncateString': false,
            'Y4CrosshairsLabelFontUnderline': true,
            'Y4CrosshairsLabelFontWeight': false,
            'Y4CrosshairsLabelFontWidthHint': false,
            'Y4CrosshairsLabelShowText': true,
            'Y4CrosshairsLabelText': false,
            'Y4CrosshairsLabelTextBox': true,
            'Y4CrosshairsLabelTextBoxArrowMultiplier': false,
            'Y4CrosshairsLabelTextBoxBGAlpha': false,
            'Y4CrosshairsLabelTextBoxBGColor': false,
            'Y4CrosshairsLabelTextBoxBGGradientAlpha': false,
            'Y4CrosshairsLabelTextBoxBGGradientAngle': false,
            'Y4CrosshairsLabelTextBoxBGGradientColor': false,
            'Y4CrosshairsLabelTextBoxBGGradientFactor': false,
            'Y4CrosshairsLabelTextBoxBGGradientStyle': true,
            'Y4CrosshairsLabelTextBoxBGImageName': false,
            'Y4CrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'Y4CrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'Y4CrosshairsLabelTextBoxBGStyle': true,
            'Y4CrosshairsLabelTextBoxClipText': true,
            'Y4CrosshairsLabelTextBoxDisplayMargins': false,
            'Y4CrosshairsLabelTextBoxDisplayStyle': true,
            'Y4CrosshairsLabelTextBoxFGColor': false,
            'Y4CrosshairsLabelTextBoxFGDashFactor': false,
            'Y4CrosshairsLabelTextBoxFGLineCap': true,
            'Y4CrosshairsLabelTextBoxFGStyle': true,
            'Y4CrosshairsLabelTextBoxFGWidth': false,
            'Y4CrosshairsLabelTextBoxHeightHint': false,
            'Y4CrosshairsLabelTextBoxPlacement': false,
            'Y4CrosshairsLabelTextBoxSizingMode': true,
            'Y4CrosshairsLabelTextBoxWidthHint': false,
            'Y4DateLabelShift': false,
            'Y4DateMinorLabelShift': false,
            'Y4DisplayHolidays': true,
            'Y4EndLabelLeftFormat': false,
            'Y4EndLabelLeftPosition': true,
            'Y4EndLabelMinorLeftFormat': false,
            'Y4EndLabelMinorLeftPosition': true,
            'Y4EndLabelMinorRightFormat': false,
            'Y4EndLabelMinorRightPosition': true,
            'Y4EndLabelRightFormat': false,
            'Y4EndLabelRightPosition': true,
            'Y4EndLabelSnapToDatapoint': true,
            'Y4EndMinorLabelSnapToDatapoint': true,
            'Y4ExtendMajorTicks': true,
            'Y4ExtendMinorTicks': true,
            'Y4FadeNonZoomedRegion': true,
            'Y4Font2Alignment': false,
            'Y4Font2Color': false,
            'Y4Font2Escapement': false,
            'Y4Font2Family': true,
            'Y4Font2Height': false,
            'Y4Font2Italic': true,
            'Y4Font2Truncate': true,
            'Y4Font2TruncateString': false,
            'Y4Font2Underline': true,
            'Y4Font2Weight': false,
            'Y4Font2WidthHint': false,
            'Y4FontAlignment': false,
            'Y4FontColor': false,
            'Y4FontEscapement': false,
            'Y4FontFamily': true,
            'Y4FontHeight': false,
            'Y4FontItalic': true,
            'Y4FontTruncate': true,
            'Y4FontTruncateString': false,
            'Y4FontUnderline': true,
            'Y4FontWeight': false,
            'Y4FontWidthHint': false,
            'Y4ForceEndLabels': true,
            'Y4ForceMinorEndLabels': true,
            'Y4Grid': true,
            'Y4GridFGColor': false,
            'Y4GridFGDashFactor': false,
            'Y4GridFGLineCap': true,
            'Y4GridFGStyle': true,
            'Y4GridFGWidth': false,
            'Y4HLBinsHint': false,
            'Y4HolidayDataset': false,
            'Y4IgnoreIntradayScaleLeastVisibleInterval': true,
            'Y4InnerBinPadding': false,
            'Y4IntradayLabeling': true,
            'Y4IntradayLabelingMask': true,
            'Y4IntradayScaleLabelFormatDAY': false,
            'Y4IntradayScaleLabelFormatFIVEMINUTE': false,
            'Y4IntradayScaleLabelFormatFIVESECOND': false,
            'Y4IntradayScaleLabelFormatFIVEY': false,
            'Y4IntradayScaleLabelFormatHALFHOUR': false,
            'Y4IntradayScaleLabelFormatHALFMINUTE': false,
            'Y4IntradayScaleLabelFormatHALFY': false,
            'Y4IntradayScaleLabelFormatHOUR': false,
            'Y4IntradayScaleLabelFormatMINUTE': false,
            'Y4IntradayScaleLabelFormatMONTH': false,
            'Y4IntradayScaleLabelFormatNONE': false,
            'Y4IntradayScaleLabelFormatQUARTER': false,
            'Y4IntradayScaleLabelFormatSECOND': false,
            'Y4IntradayScaleLabelFormatSIXHOUR': false,
            'Y4IntradayScaleLabelFormatTENMINUTE': false,
            'Y4IntradayScaleLabelFormatTENSECOND': false,
            'Y4IntradayScaleLabelFormatTENY': false,
            'Y4IntradayScaleLabelFormatTWOHOUR': false,
            'Y4IntradayScaleLabelFormatTWOMINUTE': false,
            'Y4IntradayScaleLabelFormatTWOSECOND': false,
            'Y4IntradayScaleLabelFormatTWOY': false,
            'Y4IntradayScaleLabelFormatWEEK': false,
            'Y4IntradayScaleLabelFormatYEAR': false,
            'Y4IntradayScaleLengthForPartialDays': true,
            'Y4IntradayScaleMajorUnitBGAlpha': false,
            'Y4IntradayScaleMajorUnitBGColor': false,
            'Y4IntradayScaleMajorUnitBGGradientAlpha': false,
            'Y4IntradayScaleMajorUnitBGGradientAngle': false,
            'Y4IntradayScaleMajorUnitBGGradientColor': false,
            'Y4IntradayScaleMajorUnitBGGradientFactor': false,
            'Y4IntradayScaleMajorUnitBGGradientStyle': true,
            'Y4IntradayScaleMajorUnitBGImageName': false,
            'Y4IntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'Y4IntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'Y4IntradayScaleMajorUnitBGStyle': true,
            'Y4IntradayScaleMinorLabelFormatDAY': false,
            'Y4IntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'Y4IntradayScaleMinorLabelFormatFIVESECOND': false,
            'Y4IntradayScaleMinorLabelFormatFIVEY': false,
            'Y4IntradayScaleMinorLabelFormatHALFHOUR': false,
            'Y4IntradayScaleMinorLabelFormatHALFMINUTE': false,
            'Y4IntradayScaleMinorLabelFormatHALFY': false,
            'Y4IntradayScaleMinorLabelFormatHOUR': false,
            'Y4IntradayScaleMinorLabelFormatMINUTE': false,
            'Y4IntradayScaleMinorLabelFormatMONTH': false,
            'Y4IntradayScaleMinorLabelFormatNONE': false,
            'Y4IntradayScaleMinorLabelFormatQUARTER': false,
            'Y4IntradayScaleMinorLabelFormatSECOND': false,
            'Y4IntradayScaleMinorLabelFormatSIXHOUR': false,
            'Y4IntradayScaleMinorLabelFormatTENMINUTE': false,
            'Y4IntradayScaleMinorLabelFormatTENSECOND': false,
            'Y4IntradayScaleMinorLabelFormatTENY': false,
            'Y4IntradayScaleMinorLabelFormatTWOHOUR': false,
            'Y4IntradayScaleMinorLabelFormatTWOMINUTE': false,
            'Y4IntradayScaleMinorLabelFormatTWOSECOND': false,
            'Y4IntradayScaleMinorLabelFormatTWOY': false,
            'Y4IntradayScaleMinorLabelFormatWEEK': false,
            'Y4IntradayScaleMinorLabelFormatYEAR': false,
            'Y4IntradayScaleMinorRangeDAY': false,
            'Y4IntradayScaleMinorRangeFIVEMINUTE': false,
            'Y4IntradayScaleMinorRangeFIVESECOND': false,
            'Y4IntradayScaleMinorRangeFIVEY': false,
            'Y4IntradayScaleMinorRangeHALFHOUR': false,
            'Y4IntradayScaleMinorRangeHALFMINUTE': false,
            'Y4IntradayScaleMinorRangeHALFY': false,
            'Y4IntradayScaleMinorRangeHOUR': false,
            'Y4IntradayScaleMinorRangeMINUTE': false,
            'Y4IntradayScaleMinorRangeMONTH': false,
            'Y4IntradayScaleMinorRangeNONE': false,
            'Y4IntradayScaleMinorRangeQUARTER': false,
            'Y4IntradayScaleMinorRangeSECOND': false,
            'Y4IntradayScaleMinorRangeSIXHOUR': false,
            'Y4IntradayScaleMinorRangeTENMINUTE': false,
            'Y4IntradayScaleMinorRangeTENSECOND': false,
            'Y4IntradayScaleMinorRangeTENY': false,
            'Y4IntradayScaleMinorRangeTWOHOUR': false,
            'Y4IntradayScaleMinorRangeTWOMINUTE': false,
            'Y4IntradayScaleMinorRangeTWOSECOND': false,
            'Y4IntradayScaleMinorRangeTWOY': false,
            'Y4IntradayScaleMinorRangeWEEK': false,
            'Y4IntradayScaleMinorRangeYEAR': false,
            'Y4IntradayScaleRangeDAY': false,
            'Y4IntradayScaleRangeFIVEMINUTE': false,
            'Y4IntradayScaleRangeFIVESECOND': false,
            'Y4IntradayScaleRangeFIVEY': false,
            'Y4IntradayScaleRangeHALFHOUR': false,
            'Y4IntradayScaleRangeHALFMINUTE': false,
            'Y4IntradayScaleRangeHALFY': false,
            'Y4IntradayScaleRangeHOUR': false,
            'Y4IntradayScaleRangeMINUTE': false,
            'Y4IntradayScaleRangeMONTH': false,
            'Y4IntradayScaleRangeNONE': false,
            'Y4IntradayScaleRangeQUARTER': false,
            'Y4IntradayScaleRangeSECOND': false,
            'Y4IntradayScaleRangeSIXHOUR': false,
            'Y4IntradayScaleRangeTENMINUTE': false,
            'Y4IntradayScaleRangeTENSECOND': false,
            'Y4IntradayScaleRangeTENY': false,
            'Y4IntradayScaleRangeTWOHOUR': false,
            'Y4IntradayScaleRangeTWOMINUTE': false,
            'Y4IntradayScaleRangeTWOSECOND': false,
            'Y4IntradayScaleRangeTWOY': false,
            'Y4IntradayScaleRangeWEEK': false,
            'Y4IntradayScaleRangeYEAR': false,
            'Y4Label': true,
            'Y4LabelAnchor': false,
            'Y4LabelCentered': true,
            'Y4LabelCentered2': true,
            'Y4LabelFormat': false,
            'Y4LabelFormat2': false,
            'Y4LabelMinorPadding': false,
            'Y4LabelOffset': false,
            'Y4LabelOverride': false,
            'Y4LabelPadded': true,
            'Y4LabelPosition': true,
            'Y4LabelPostfix': false,
            'Y4LabelPostfix2': false,
            'Y4LabelPrefix': false,
            'Y4LabelPrefix2': false,
            'Y4LabelTooltipEnabled': true,
            'Y4LabelTooltipText': false,
            'Y4LabelsLevelsMask': true,
            'Y4Log': true,
            'Y4MajorTickMultiplier': false,
            'Y4MajorTickSnapToDate': true,
            'Y4MajorUnitStart': false,
            'Y4MinorGrid': true,
            'Y4MinorGridFGColor': false,
            'Y4MinorGridFGDashFactor': false,
            'Y4MinorGridFGLineCap': true,
            'Y4MinorGridFGStyle': true,
            'Y4MinorGridFGWidth': false,
            'Y4MinorGridInheritsColor': true,
            'Y4MinorTickDateBin': true,
            'Y4MinorTickMultiplier': false,
            'Y4MinorTickOffset': false,
            'Y4MinorTickSnapToDate': true,
            'Y4MinorTicks': true,
            'Y4MinorTicksLengthFactor': false,
            'Y4MinorUnitEnd': false,
            'Y4MinorUnitStart': false,
            'Y4OutlierAxis': true,
            'Y4OutlierAxisDynamic': true,
            'Y4OutlierAxisDynamicThreshold': false,
            'Y4OutlierAxisMarginMax': false,
            'Y4OutlierAxisMarginMin': false,
            'Y4OutlierAxisThreshMax': false,
            'Y4OutlierAxisThreshMin': false,
            'Y4OutlierIndicator': true,
            'Y4OutlierIndicatorBGAlpha': false,
            'Y4OutlierIndicatorBGColor': false,
            'Y4OutlierIndicatorBGGradientAlpha': false,
            'Y4OutlierIndicatorBGGradientAngle': false,
            'Y4OutlierIndicatorBGGradientColor': false,
            'Y4OutlierIndicatorBGGradientFactor': false,
            'Y4OutlierIndicatorBGGradientStyle': true,
            'Y4OutlierIndicatorBGImageName': false,
            'Y4OutlierIndicatorBGRadialGradientOffsetX': false,
            'Y4OutlierIndicatorBGRadialGradientOffsetY': false,
            'Y4OutlierIndicatorBGStyle': true,
            'Y4OutlierIndicatorFGColor': false,
            'Y4OutlierIndicatorFGDashFactor': false,
            'Y4OutlierIndicatorFGLineCap': true,
            'Y4OutlierIndicatorFGStyle': true,
            'Y4OutlierIndicatorFGWidth': false,
            'Y4OutlierIndicatorFactor': false,
            'Y4OutlierIndicatorMarkerSize': false,
            'Y4OutlierIndicatorMarkerStyle': true,
            'Y4Reference': false,
            'Y4ReferenceLine': true,
            'Y4ReferenceLineFGColor': false,
            'Y4ReferenceLineFGDashFactor': false,
            'Y4ReferenceLineFGLineCap': true,
            'Y4ReferenceLineFGStyle': true,
            'Y4ReferenceLineFGWidth': false,
            'Y4RefreshAxis': true,
            'Y4RemoveGapsFromMajorIntervals': true,
            'Y4RemoveGapsFromMinorIntervals': true,
            'Y4Reverse': true,
            'Y4RoundMinMax': true,
            'Y4SecondaryFrequency': true,
            'Y4ShowMajorUnitWhenNoTicks': true,
            'Y4SubBinLabels': false,
            'Y4SubBinLabelsDefault': false,
            'Y4ThreshConsider': true,
            'Y4ThreshConsiderFactor': false,
            'Y4ThreshConsiderValue': false,
            'Y4ThreshMax': false,
            'Y4ThreshMaxMargin': false,
            'Y4ThreshMin': false,
            'Y4ThreshMinMargin': false,
            'Y4TickBin': true,
            'Y4TickDateBin': true,
            'Y4TickMode': true,
            'Y4TickOffset': false,
            'Y4TickSafety': false,
            'Y4Ticks': true,
            'Y4TicksFGColor': false,
            'Y4TicksFGDashFactor': false,
            'Y4TicksFGLineCap': true,
            'Y4TicksFGStyle': true,
            'Y4TicksFGWidth': false,
            'Y4TicksLength': false,
            'Y4TicksOffset': false,
            'Y4TicksPosition': true,
            'Y4TicksResize': true,
            'Y4Title': true,
            'Y4TitleAtEnd': true,
            'Y4TitleFontAlignment': false,
            'Y4TitleFontColor': false,
            'Y4TitleFontEscapement': false,
            'Y4TitleFontFamily': true,
            'Y4TitleFontHeight': false,
            'Y4TitleFontItalic': true,
            'Y4TitleFontTruncate': true,
            'Y4TitleFontTruncateString': false,
            'Y4TitleFontUnderline': true,
            'Y4TitleFontWeight': false,
            'Y4TitleFontWidthHint': false,
            'Y4TitleOffset': false,
            'Y4TitlePosition': true,
            'Y4TitleRotationMode': true,
            'Y4TitleText': false,
            'Y4TitleTieWithEndLabel': true,
            'Y4TitleValuePosition': true,
            'Y4TreatWeekendsAsHolidays': true,
            'Y4WeekType': true,
            'Y4ZoomDefaultMax': false,
            'Y4ZoomDefaultMin': false,
            'Y4ZoomEnabled': true,
            'Y4ZoomGroup': false,
            'Y4ZoomSliderHandleWidth': false,
            'Y4ZoomSliderRegion': true,
            'Y4ZoomSliderStickyMode': true,
            'Y4maxPlotFactor': true,
            'Y4minPlotFactor': true,
            'YAlias': true,
            'YAlternatingBackground': true,
            'YAlternatingBackgroundFactor': false,
            'YAutomaticHolidayDetection': true,
            'YAutomaticStartEndDayDetection': true,
            'YAxis': true,
            'YAxisFGColor': false,
            'YAxisFGDashFactor': false,
            'YAxisFGLineCap': true,
            'YAxisFGStyle': true,
            'YAxisFGWidth': false,
            'YAxisOffset': false,
            'YAxisPosition': true,
            'YAxisSeries': false,
            'YBaseRangesOnIntervals': true,
            'YBin': true,
            'YBinFactor': false,
            'YBinLabelMode': true,
            'YBinMinorLabelMode': true,
            'YCrosshairsLabel': true,
            'YCrosshairsLabelDrawnWithoutAxisLabels': true,
            'YCrosshairsLabelFontAlignment': false,
            'YCrosshairsLabelFontColor': false,
            'YCrosshairsLabelFontEscapement': false,
            'YCrosshairsLabelFontFamily': true,
            'YCrosshairsLabelFontHeight': false,
            'YCrosshairsLabelFontItalic': true,
            'YCrosshairsLabelFontTruncate': true,
            'YCrosshairsLabelFontTruncateString': false,
            'YCrosshairsLabelFontUnderline': true,
            'YCrosshairsLabelFontWeight': false,
            'YCrosshairsLabelFontWidthHint': false,
            'YCrosshairsLabelShowText': true,
            'YCrosshairsLabelText': false,
            'YCrosshairsLabelTextBox': true,
            'YCrosshairsLabelTextBoxArrowMultiplier': false,
            'YCrosshairsLabelTextBoxBGAlpha': false,
            'YCrosshairsLabelTextBoxBGColor': false,
            'YCrosshairsLabelTextBoxBGGradientAlpha': false,
            'YCrosshairsLabelTextBoxBGGradientAngle': false,
            'YCrosshairsLabelTextBoxBGGradientColor': false,
            'YCrosshairsLabelTextBoxBGGradientFactor': false,
            'YCrosshairsLabelTextBoxBGGradientStyle': true,
            'YCrosshairsLabelTextBoxBGImageName': false,
            'YCrosshairsLabelTextBoxBGRadialGradientOffsetX': false,
            'YCrosshairsLabelTextBoxBGRadialGradientOffsetY': false,
            'YCrosshairsLabelTextBoxBGStyle': true,
            'YCrosshairsLabelTextBoxClipText': true,
            'YCrosshairsLabelTextBoxDisplayMargins': false,
            'YCrosshairsLabelTextBoxDisplayStyle': true,
            'YCrosshairsLabelTextBoxFGColor': false,
            'YCrosshairsLabelTextBoxFGDashFactor': false,
            'YCrosshairsLabelTextBoxFGLineCap': true,
            'YCrosshairsLabelTextBoxFGStyle': true,
            'YCrosshairsLabelTextBoxFGWidth': false,
            'YCrosshairsLabelTextBoxHeightHint': false,
            'YCrosshairsLabelTextBoxPlacement': false,
            'YCrosshairsLabelTextBoxSizingMode': true,
            'YCrosshairsLabelTextBoxWidthHint': false,
            'YDateLabelShift': false,
            'YDateMinorLabelShift': false,
            'YDisplayHolidays': true,
            'YEndLabelLeftFormat': false,
            'YEndLabelLeftPosition': true,
            'YEndLabelMinorLeftFormat': false,
            'YEndLabelMinorLeftPosition': true,
            'YEndLabelMinorRightFormat': false,
            'YEndLabelMinorRightPosition': true,
            'YEndLabelRightFormat': false,
            'YEndLabelRightPosition': true,
            'YEndLabelSnapToDatapoint': true,
            'YEndMinorLabelSnapToDatapoint': true,
            'YExtendMajorTicks': true,
            'YExtendMinorTicks': true,
            'YFadeNonZoomedRegion': true,
            'YFont2Alignment': false,
            'YFont2Color': false,
            'YFont2Escapement': false,
            'YFont2Family': true,
            'YFont2Height': false,
            'YFont2Italic': true,
            'YFont2Truncate': true,
            'YFont2TruncateString': false,
            'YFont2Underline': true,
            'YFont2Weight': false,
            'YFont2WidthHint': false,
            'YFontAlignment': false,
            'YFontColor': false,
            'YFontEscapement': false,
            'YFontFamily': true,
            'YFontHeight': false,
            'YFontItalic': true,
            'YFontTruncate': true,
            'YFontTruncateString': false,
            'YFontUnderline': true,
            'YFontWeight': false,
            'YFontWidthHint': false,
            'YForceEndLabels': true,
            'YForceMinorEndLabels': true,
            'YGrid': true,
            'YGridFGColor': false,
            'YGridFGDashFactor': false,
            'YGridFGLineCap': true,
            'YGridFGStyle': true,
            'YGridFGWidth': false,
            'YHLBinsHint': false,
            'YHolidayDataset': false,
            'YIgnoreIntradayScaleLeastVisibleInterval': true,
            'YInnerBinPadding': false,
            'YIntradayLabeling': true,
            'YIntradayLabelingMask': true,
            'YIntradayScaleLabelFormatDAY': false,
            'YIntradayScaleLabelFormatFIVEMINUTE': false,
            'YIntradayScaleLabelFormatFIVESECOND': false,
            'YIntradayScaleLabelFormatFIVEY': false,
            'YIntradayScaleLabelFormatHALFHOUR': false,
            'YIntradayScaleLabelFormatHALFMINUTE': false,
            'YIntradayScaleLabelFormatHALFY': false,
            'YIntradayScaleLabelFormatHOUR': false,
            'YIntradayScaleLabelFormatMINUTE': false,
            'YIntradayScaleLabelFormatMONTH': false,
            'YIntradayScaleLabelFormatNONE': false,
            'YIntradayScaleLabelFormatQUARTER': false,
            'YIntradayScaleLabelFormatSECOND': false,
            'YIntradayScaleLabelFormatSIXHOUR': false,
            'YIntradayScaleLabelFormatTENMINUTE': false,
            'YIntradayScaleLabelFormatTENSECOND': false,
            'YIntradayScaleLabelFormatTENY': false,
            'YIntradayScaleLabelFormatTWOHOUR': false,
            'YIntradayScaleLabelFormatTWOMINUTE': false,
            'YIntradayScaleLabelFormatTWOSECOND': false,
            'YIntradayScaleLabelFormatTWOY': false,
            'YIntradayScaleLabelFormatWEEK': false,
            'YIntradayScaleLabelFormatYEAR': false,
            'YIntradayScaleLengthForPartialDays': true,
            'YIntradayScaleMajorUnitBGAlpha': false,
            'YIntradayScaleMajorUnitBGColor': false,
            'YIntradayScaleMajorUnitBGGradientAlpha': false,
            'YIntradayScaleMajorUnitBGGradientAngle': false,
            'YIntradayScaleMajorUnitBGGradientColor': false,
            'YIntradayScaleMajorUnitBGGradientFactor': false,
            'YIntradayScaleMajorUnitBGGradientStyle': true,
            'YIntradayScaleMajorUnitBGImageName': false,
            'YIntradayScaleMajorUnitBGRadialGradientOffsetX': false,
            'YIntradayScaleMajorUnitBGRadialGradientOffsetY': false,
            'YIntradayScaleMajorUnitBGStyle': true,
            'YIntradayScaleMinorLabelFormatDAY': false,
            'YIntradayScaleMinorLabelFormatFIVEMINUTE': false,
            'YIntradayScaleMinorLabelFormatFIVESECOND': false,
            'YIntradayScaleMinorLabelFormatFIVEY': false,
            'YIntradayScaleMinorLabelFormatHALFHOUR': false,
            'YIntradayScaleMinorLabelFormatHALFMINUTE': false,
            'YIntradayScaleMinorLabelFormatHALFY': false,
            'YIntradayScaleMinorLabelFormatHOUR': false,
            'YIntradayScaleMinorLabelFormatMINUTE': false,
            'YIntradayScaleMinorLabelFormatMONTH': false,
            'YIntradayScaleMinorLabelFormatNONE': false,
            'YIntradayScaleMinorLabelFormatQUARTER': false,
            'YIntradayScaleMinorLabelFormatSECOND': false,
            'YIntradayScaleMinorLabelFormatSIXHOUR': false,
            'YIntradayScaleMinorLabelFormatTENMINUTE': false,
            'YIntradayScaleMinorLabelFormatTENSECOND': false,
            'YIntradayScaleMinorLabelFormatTENY': false,
            'YIntradayScaleMinorLabelFormatTWOHOUR': false,
            'YIntradayScaleMinorLabelFormatTWOMINUTE': false,
            'YIntradayScaleMinorLabelFormatTWOSECOND': false,
            'YIntradayScaleMinorLabelFormatTWOY': false,
            'YIntradayScaleMinorLabelFormatWEEK': false,
            'YIntradayScaleMinorLabelFormatYEAR': false,
            'YIntradayScaleMinorRangeDAY': false,
            'YIntradayScaleMinorRangeFIVEMINUTE': false,
            'YIntradayScaleMinorRangeFIVESECOND': false,
            'YIntradayScaleMinorRangeFIVEY': false,
            'YIntradayScaleMinorRangeHALFHOUR': false,
            'YIntradayScaleMinorRangeHALFMINUTE': false,
            'YIntradayScaleMinorRangeHALFY': false,
            'YIntradayScaleMinorRangeHOUR': false,
            'YIntradayScaleMinorRangeMINUTE': false,
            'YIntradayScaleMinorRangeMONTH': false,
            'YIntradayScaleMinorRangeNONE': false,
            'YIntradayScaleMinorRangeQUARTER': false,
            'YIntradayScaleMinorRangeSECOND': false,
            'YIntradayScaleMinorRangeSIXHOUR': false,
            'YIntradayScaleMinorRangeTENMINUTE': false,
            'YIntradayScaleMinorRangeTENSECOND': false,
            'YIntradayScaleMinorRangeTENY': false,
            'YIntradayScaleMinorRangeTWOHOUR': false,
            'YIntradayScaleMinorRangeTWOMINUTE': false,
            'YIntradayScaleMinorRangeTWOSECOND': false,
            'YIntradayScaleMinorRangeTWOY': false,
            'YIntradayScaleMinorRangeWEEK': false,
            'YIntradayScaleMinorRangeYEAR': false,
            'YIntradayScaleRangeDAY': false,
            'YIntradayScaleRangeFIVEMINUTE': false,
            'YIntradayScaleRangeFIVESECOND': false,
            'YIntradayScaleRangeFIVEY': false,
            'YIntradayScaleRangeHALFHOUR': false,
            'YIntradayScaleRangeHALFMINUTE': false,
            'YIntradayScaleRangeHALFY': false,
            'YIntradayScaleRangeHOUR': false,
            'YIntradayScaleRangeMINUTE': false,
            'YIntradayScaleRangeMONTH': false,
            'YIntradayScaleRangeNONE': false,
            'YIntradayScaleRangeQUARTER': false,
            'YIntradayScaleRangeSECOND': false,
            'YIntradayScaleRangeSIXHOUR': false,
            'YIntradayScaleRangeTENMINUTE': false,
            'YIntradayScaleRangeTENSECOND': false,
            'YIntradayScaleRangeTENY': false,
            'YIntradayScaleRangeTWOHOUR': false,
            'YIntradayScaleRangeTWOMINUTE': false,
            'YIntradayScaleRangeTWOSECOND': false,
            'YIntradayScaleRangeTWOY': false,
            'YIntradayScaleRangeWEEK': false,
            'YIntradayScaleRangeYEAR': false,
            'YLabel': true,
            'YLabelAnchor': false,
            'YLabelCentered': true,
            'YLabelCentered2': true,
            'YLabelFormat': false,
            'YLabelFormat2': false,
            'YLabelMinorPadding': false,
            'YLabelOffset': false,
            'YLabelOverride': false,
            'YLabelPadded': true,
            'YLabelPosition': true,
            'YLabelPostfix': false,
            'YLabelPostfix2': false,
            'YLabelPrefix': false,
            'YLabelPrefix2': false,
            'YLabelTooltipEnabled': true,
            'YLabelTooltipText': false,
            'YLabelsLevelsMask': true,
            'YLog': true,
            'YMajorTickMultiplier': false,
            'YMajorTickSnapToDate': true,
            'YMajorUnitStart': false,
            'YMinorGrid': true,
            'YMinorGridFGColor': false,
            'YMinorGridFGDashFactor': false,
            'YMinorGridFGLineCap': true,
            'YMinorGridFGStyle': true,
            'YMinorGridFGWidth': false,
            'YMinorGridInheritsColor': true,
            'YMinorTickDateBin': true,
            'YMinorTickMultiplier': false,
            'YMinorTickOffset': false,
            'YMinorTickSnapToDate': true,
            'YMinorTicks': true,
            'YMinorTicksLengthFactor': false,
            'YMinorUnitEnd': false,
            'YMinorUnitStart': false,
            'YOutlierAxis': true,
            'YOutlierAxisDynamic': true,
            'YOutlierAxisDynamicThreshold': false,
            'YOutlierAxisMarginMax': false,
            'YOutlierAxisMarginMin': false,
            'YOutlierAxisThreshMax': false,
            'YOutlierAxisThreshMin': false,
            'YOutlierIndicator': true,
            'YOutlierIndicatorBGAlpha': false,
            'YOutlierIndicatorBGColor': false,
            'YOutlierIndicatorBGGradientAlpha': false,
            'YOutlierIndicatorBGGradientAngle': false,
            'YOutlierIndicatorBGGradientColor': false,
            'YOutlierIndicatorBGGradientFactor': false,
            'YOutlierIndicatorBGGradientStyle': true,
            'YOutlierIndicatorBGImageName': false,
            'YOutlierIndicatorBGRadialGradientOffsetX': false,
            'YOutlierIndicatorBGRadialGradientOffsetY': false,
            'YOutlierIndicatorBGStyle': true,
            'YOutlierIndicatorFGColor': false,
            'YOutlierIndicatorFGDashFactor': false,
            'YOutlierIndicatorFGLineCap': true,
            'YOutlierIndicatorFGStyle': true,
            'YOutlierIndicatorFGWidth': false,
            'YOutlierIndicatorFactor': false,
            'YOutlierIndicatorMarkerSize': false,
            'YOutlierIndicatorMarkerStyle': true,
            'YReference': false,
            'YReferenceLine': true,
            'YReferenceLineFGColor': false,
            'YReferenceLineFGDashFactor': false,
            'YReferenceLineFGLineCap': true,
            'YReferenceLineFGStyle': true,
            'YReferenceLineFGWidth': false,
            'YRefreshAxis': true,
            'YRemoveGapsFromMajorIntervals': true,
            'YRemoveGapsFromMinorIntervals': true,
            'YReverse': true,
            'YRoundMinMax': true,
            'YSecondaryFrequency': true,
            'YShowMajorUnitWhenNoTicks': true,
            'YSubBinLabels': false,
            'YSubBinLabelsDefault': false,
            'YThreshConsider': true,
            'YThreshConsiderFactor': false,
            'YThreshConsiderValue': false,
            'YThreshMax': false,
            'YThreshMaxMargin': false,
            'YThreshMin': false,
            'YThreshMinMargin': false,
            'YTickBin': true,
            'YTickDateBin': true,
            'YTickMode': true,
            'YTickOffset': false,
            'YTickSafety': false,
            'YTicks': true,
            'YTicksFGColor': false,
            'YTicksFGDashFactor': false,
            'YTicksFGLineCap': true,
            'YTicksFGStyle': true,
            'YTicksFGWidth': false,
            'YTicksLength': false,
            'YTicksOffset': false,
            'YTicksPosition': true,
            'YTicksResize': true,
            'YTitle': true,
            'YTitleAtEnd': true,
            'YTitleFontAlignment': false,
            'YTitleFontColor': false,
            'YTitleFontEscapement': false,
            'YTitleFontFamily': true,
            'YTitleFontHeight': false,
            'YTitleFontItalic': true,
            'YTitleFontTruncate': true,
            'YTitleFontTruncateString': false,
            'YTitleFontUnderline': true,
            'YTitleFontWeight': false,
            'YTitleFontWidthHint': false,
            'YTitleOffset': false,
            'YTitlePosition': true,
            'YTitleRotationMode': true,
            'YTitleText': false,
            'YTitleTieWithEndLabel': true,
            'YTitleValuePosition': true,
            'YTreatWeekendsAsHolidays': true,
            'YWeekType': true,
            'YZoomDefaultMax': false,
            'YZoomDefaultMin': false,
            'YZoomEnabled': true,
            'YZoomGroup': false,
            'YZoomSliderHandleWidth': false,
            'YZoomSliderRegion': true,
            'YZoomSliderStickyMode': true,
            'YmaxPlotFactor': true,
            'YminPlotFactor': true,
            'ZoomGrouped': true,
            'ZoomMode': true,
            'maxXFactor': false,
            'maxXPlotFactor': true,
            'maxXPlotPadding': false,
            'maxYFactor': false,
            'maxYPlotFactor': true,
            'maxYPlotPadding': false,
            'minXFactor': false,
            'minXPlotFactor': true,
            'minXPlotPadding': false,
            'minYFactor': false,
            'minYPlotFactor': true,
            'minYPlotPadding': false,
            'seriesId': false
        },
        FDSSeries: {
            'AdjustAxes': true,
            'AllowDragableMarkerInterpolation': true,
            'AnnotationAllowAnnotInLegend': true,
            'AnnotationArrowFraction': false,
            'AnnotationDisappearOnNoValidXData': true,
            'AnnotationDisappearOnNoValidYData': true,
            'AnnotationDraggingStepSizeLarge': false,
            'AnnotationDraggingStepSizeSmall': false,
            'AnnotationDrawStyle': true,
            'AnnotationFollowsParentValue': true,
            'AnnotationInLegend': true,
            'AnnotationInTips': true,
            'AnnotationMode': true,
            'AnnotationSeriesBGStyle': true,
            'AnnotationSeriesColor': false,
            'AnnotationSeriesOulineColor': false,
            'AnnotationSeriesValue': true,
            'AnnotationSeriesValueArrow': true,
            'AnnotationSeriesValueSublabelMask': true,
            'AreaDrawTopLineOnly': true,
            'ArrowLengthScale': false,
            'ArrowScalesWithLength': true,
            'ArrowSize': false,
            'ArrowWidthScale': false,
            'BarColumn3dDepthFactor': false,
            'BaseLineVisible': true,
            'BaselineFGColor': false,
            'BaselineFGDashFactor': false,
            'BaselineFGLineCap': true,
            'BaselineFGStyle': true,
            'BaselineFGWidth': false,
            'BreakOnGap': true,
            'BreakOnNA': true,
            'CandleDrawRectOutline': true,
            'CandleLineColorFollowsFillColor': true,
            'CandlePositiveFillColor': false,
            'CandlePositiveFillStyle': true,
            'ColorIsIndex': true,
            'ColorMap': false,
            'ColorMapActive': true,
            'ColorMapCustomDataName': false,
            'ColorMapLightenFactor': false,
            'CrosshairsDrawMarker': true,
            'CrosshairsFallbackOnLinear': true,
            'CrosshairsMarkerColor': false,
            'CrosshairsMarkerSize': false,
            'CrosshairsMarkerStyle': true,
            'CrosshairsSwapIndexedAxis': true,
            'Cursor': true,
            'CurvedRegressionOnLogScale': true,
            'CycleColorIndex': true,
            'DataClipStdDeviation': false,
            'DatapointHitShapeSize': false,
            'DrawBelow': true,
            'DrawStyle': true,
            'DrawThinColumnBrackets': true,
            'DrawingToolType': true,
            'DrawingToolsLevels': false,
            'EnableAreaTopBottomConditionalColor': true,
            'EndDatapoint': false,
            'ExtendLine': true,
            'ExtendLineLeftOrDown': true,
            'ExtendLineRightOrUp': true,
            'FibonacciLevels': false,
            'HighAnnotation': true,
            'HighlightLevelTreemap': false,
            'HighlightModeTreemap': true,
            'HistogramAdjustForNiceBins': true,
            'HistogramAggregateDataOutOfRange': true,
            'HistogramAsColumnsNumDecimals': true,
            'HistogramBinCount': false,
            'HistogramBinMax': false,
            'HistogramBinMin': false,
            'HistogramBinSize': false,
            'HistogramCountAsPercents': true,
            'InLegend': true,
            'InTips': true,
            'InteractionHandleFGColor': false,
            'InteractionHandleFGDashFactor': false,
            'InteractionHandleFGLineCap': true,
            'InteractionHandleFGStyle': true,
            'InteractionHandleFGWidth': false,
            'InteractionHandleSize': false,
            'InteractivityClampToPlot': true,
            'InteractivityMode': true,
            'IsAnnotation': true,
            'IsAppAnnotation': true,
            'IsStacked': true,
            'KMLMapUseZeroBasedColors': true,
            'Label': false,
            'LabelsMask': true,
            'LegendOrderIndex': false,
            'LegendTextFollowsSeriesColor': true,
            'LowAnnotation': true,
            'MaxElementWidth': false,
            'MaxLabels': false,
            'MaxPoints': false,
            'Menu': false,
            'MenuXML': false,
            'NegativeColor': false,
            'OnLeftButtonClick': false,
            'OnLeftButtonDoubleClick': false,
            'OnMiddleButtonClick': false,
            'OnMiddleButtonDoubleClick': false,
            'OnRightButtonClick': false,
            'OnRightButtonDoubleClick': false,
            'OnXAxis': false,
            'OnY2': true,
            'OnYAxis': false,
            'PieAnimationTime': false,
            'PieCenterIsFactor': true,
            'PieCenterXOffset': false,
            'PieCenterYOffset': false,
            'PieClickExplosionMode': true,
            'PieDepthSize': false,
            'PieDonutRadius': false,
            'PieExplodeOnClickAnimation': true,
            'PieExploded': true,
            'PieExplodedSliceAmount': false,
            'PieExplodedSliceIndices': false,
            'PieExplosionIncreasesRadius': true,
            'PieGroupExplodedSlices': true,
            'PieLabelFactor': true,
            'PieLabelPercent': true,
            'PieMinimumSlice': false,
            'PiePercentFormat': false,
            'PieRadius': false,
            'PieRadiusIsFactor': true,
            'PieStartAngle': false,
            'PieTiltAngle': false,
            'PieTotalAngle': false,
            'PositiveColor': false,
            'RangeBarSameDataToLine': true,
            'ReferenceSeriesIsRegression': true,
            'ReferenceSeriesName': false,
            'RegressionFormulaCollapseInts': true,
            'RegressionFormulaExpandPolynomial': true,
            'RegressionFormulaFormat': false,
            'RegressionFormulaInterceptIsMin': true,
            'RegressionFormulaParens': true,
            'RegressionFormulaSpaces': true,
            'RegressionFormulaX': false,
            'RegressionFormulaY': false,
            'RegressionOrder': false,
            'RegressionScaleInfluenceMode': true,
            'RegressionStdDevBands': false,
            'RegressionStdDevFromTrend': true,
            'RegressionStdDevMirror': true,
            'RegressionStdDevOffset': false,
            'RegressionType': false,
            'RegressionZeroOrderIsHarmonicMean': true,
            'RegressionZeroOrderIsMedian': true,
            'SampleMode': true,
            'SelectableItemPointMarkerSize': false,
            'SelectableItemPointMarkerType': true,
            'SelectableItemSamplingEnabled': true,
            'SelectableItemSamplingMinPixelsPerMarker': false,
            'SeriesAlternateBGAlpha': false,
            'SeriesAlternateBGColor': false,
            'SeriesAlternateBGGradientAlpha': false,
            'SeriesAlternateBGGradientAngle': false,
            'SeriesAlternateBGGradientColor': false,
            'SeriesAlternateBGGradientFactor': false,
            'SeriesAlternateBGGradientStyle': true,
            'SeriesAlternateBGImageName': false,
            'SeriesAlternateBGRadialGradientOffsetX': false,
            'SeriesAlternateBGRadialGradientOffsetY': false,
            'SeriesAlternateBGStyle': true,
            'SeriesAlternateFGColor': false,
            'SeriesAlternateFGDashFactor': false,
            'SeriesAlternateFGLineCap': true,
            'SeriesAlternateFGStyle': true,
            'SeriesAlternateFGWidth': false,
            'SeriesAlternateOutlineColor': false,
            'SeriesAlternateOutlineDashFactor': false,
            'SeriesAlternateOutlineLineCap': true,
            'SeriesAlternateOutlineStyle': true,
            'SeriesAlternateOutlineWidth': false,
            'SeriesBGAlpha': false,
            'SeriesBGColor': false,
            'SeriesBGGradientAlpha': false,
            'SeriesBGGradientAngle': false,
            'SeriesBGGradientColor': false,
            'SeriesBGGradientFactor': false,
            'SeriesBGGradientStyle': true,
            'SeriesBGImageName': false,
            'SeriesBGRadialGradientOffsetX': false,
            'SeriesBGRadialGradientOffsetY': false,
            'SeriesBGStyle': true,
            'SeriesBin': false,
            'SeriesColor': false,
            'SeriesColorDown': false,
            'SeriesColorList': false,
            'SeriesColorNeutral': false,
            'SeriesColorUp': false,
            'SeriesConditionalColorAdvanced': true,
            'SeriesConditionalColorDimension': true,
            'SeriesConditionalColorIsIndex': true,
            'SeriesConditionalColorProperty': false,
            'SeriesEnableAlternateBGBrush': true,
            'SeriesEnableAlternateFGPen': true,
            'SeriesFGColor': false,
            'SeriesFGDashFactor': false,
            'SeriesFGLineCap': true,
            'SeriesFGStyle': true,
            'SeriesFGWidth': false,
            'SeriesFGWidthMax': false,
            'SeriesHighlightColor': false,
            'SeriesInteractivityStatus': true,
            'SeriesLabel1ColorFollowsSeriesColor': true,
            'SeriesLabel1FontAlignment': false,
            'SeriesLabel1FontColor': false,
            'SeriesLabel1FontEscapement': false,
            'SeriesLabel1FontFamily': true,
            'SeriesLabel1FontHeight': false,
            'SeriesLabel1FontItalic': true,
            'SeriesLabel1FontTruncate': true,
            'SeriesLabel1FontTruncateString': false,
            'SeriesLabel1FontUnderline': true,
            'SeriesLabel1FontWeight': false,
            'SeriesLabel1FontWidthHint': false,
            'SeriesLabel1Format': false,
            'SeriesLabel1HPosition': true,
            'SeriesLabel1LevelsMask': true,
            'SeriesLabel1Text': false,
            'SeriesLabel1VPosition': true,
            'SeriesLabel1XOffset': false,
            'SeriesLabel1YOffset': false,
            'SeriesLabel2ColorFollowsSeriesColor': true,
            'SeriesLabel2FontAlignment': false,
            'SeriesLabel2FontColor': false,
            'SeriesLabel2FontEscapement': false,
            'SeriesLabel2FontFamily': true,
            'SeriesLabel2FontHeight': false,
            'SeriesLabel2FontItalic': true,
            'SeriesLabel2FontTruncate': true,
            'SeriesLabel2FontTruncateString': false,
            'SeriesLabel2FontUnderline': true,
            'SeriesLabel2FontWeight': false,
            'SeriesLabel2FontWidthHint': false,
            'SeriesLabel2Format': false,
            'SeriesLabel2HPosition': true,
            'SeriesLabel2LevelsMask': true,
            'SeriesLabel2VPosition': true,
            'SeriesLabel2XOffset': false,
            'SeriesLabel2YOffset': false,
            'SeriesLineStyleList': true,
            'SeriesLineWidthList': false,
            'SeriesMarker': true,
            'SeriesMarker3D': true,
            'SeriesMarker3DLightPosition': true,
            'SeriesMarkerAutoPosition': true,
            'SeriesMarkerAutoPositionDirection': true,
            'SeriesMarkerAutoPositionMode': true,
            'SeriesMarkerAutoPositionXFactor': false,
            'SeriesMarkerAutoPositionYFactor': false,
            'SeriesMarkerBGAlpha': false,
            'SeriesMarkerBGColor': false,
            'SeriesMarkerBGGradientAlpha': false,
            'SeriesMarkerBGGradientAngle': false,
            'SeriesMarkerBGGradientColor': false,
            'SeriesMarkerBGGradientFactor': false,
            'SeriesMarkerBGGradientStyle': true,
            'SeriesMarkerBGImageName': false,
            'SeriesMarkerBGRadialGradientOffsetX': false,
            'SeriesMarkerBGRadialGradientOffsetY': false,
            'SeriesMarkerBGStyle': true,
            'SeriesMarkerColor': false,
            'SeriesMarkerFGColor': false,
            'SeriesMarkerFGDashFactor': false,
            'SeriesMarkerFGLineCap': true,
            'SeriesMarkerFGStyle': true,
            'SeriesMarkerFGWidth': false,
            'SeriesMarkerFontAlignment': false,
            'SeriesMarkerFontColor': false,
            'SeriesMarkerFontColorFollowsSeriesColor': true,
            'SeriesMarkerFontEscapement': false,
            'SeriesMarkerFontFamily': true,
            'SeriesMarkerFontHeight': false,
            'SeriesMarkerFontItalic': true,
            'SeriesMarkerFontTruncate': true,
            'SeriesMarkerFontTruncateString': false,
            'SeriesMarkerFontUnderline': true,
            'SeriesMarkerFontWeight': false,
            'SeriesMarkerFontWidthHint': false,
            'SeriesMarkerMaxSize': false,
            'SeriesMarkerOutlineColor': false,
            'SeriesMarkerOutlineDashFactor': false,
            'SeriesMarkerOutlineLineCap': true,
            'SeriesMarkerOutlineStyle': true,
            'SeriesMarkerOutlineWidth': false,
            'SeriesMarkerSize': false,
            'SeriesMarkerStyle': true,
            'SeriesMarkerStyleList': true,
            'SeriesMarkerText': false,
            'SeriesMarkerXOffset': false,
            'SeriesMarkerYOffset': false,
            'SeriesNumber': false,
            'SeriesOutlierIndicator': true,
            'SeriesOutlierIndicatorBGAlpha': false,
            'SeriesOutlierIndicatorBGColor': false,
            'SeriesOutlierIndicatorBGGradientAlpha': false,
            'SeriesOutlierIndicatorBGGradientAngle': false,
            'SeriesOutlierIndicatorBGGradientColor': false,
            'SeriesOutlierIndicatorBGGradientFactor': false,
            'SeriesOutlierIndicatorBGGradientStyle': true,
            'SeriesOutlierIndicatorBGImageName': false,
            'SeriesOutlierIndicatorBGRadialGradientOffsetX': false,
            'SeriesOutlierIndicatorBGRadialGradientOffsetY': false,
            'SeriesOutlierIndicatorBGStyle': true,
            'SeriesOutlierIndicatorBreakSize': false,
            'SeriesOutlierIndicatorFGColor': false,
            'SeriesOutlierIndicatorFGDashFactor': false,
            'SeriesOutlierIndicatorFGLineCap': true,
            'SeriesOutlierIndicatorFGStyle': true,
            'SeriesOutlierIndicatorFGWidth': false,
            'SeriesOutlierIndicatorHatchAngle': false,
            'SeriesOutlierIndicatorHatchSize': false,
            'SeriesOutlierIndicatorMarkerStyle': true,
            'SeriesOutlierIndicatorSize': false,
            'SeriesOutlierIndicatorStyle': true,
            'SeriesOutlineColor': false,
            'SeriesOutlineColorList': false,
            'SeriesOutlineDashFactor': false,
            'SeriesOutlineLineCap': true,
            'SeriesOutlineMatchColor': true,
            'SeriesOutlineStyle': true,
            'SeriesOutlineWidth': false,
            'SeriesQuickLabel': true,
            'SeriesQuickLabelArrowMultiplier': false,
            'SeriesQuickLabelAutoPositionFactor': false,
            'SeriesQuickLabelColorFollowsSeriesColor': true,
            'SeriesQuickLabelColorMaximumContrast': true,
            'SeriesQuickLabelConsolidatedTextBoxes': true,
            'SeriesQuickLabelFontAlignment': false,
            'SeriesQuickLabelFontAlignmentLeft': true,
            'SeriesQuickLabelFontAlignmentRight': true,
            'SeriesQuickLabelFontColor': false,
            'SeriesQuickLabelFontEscapement': false,
            'SeriesQuickLabelFontFamily': true,
            'SeriesQuickLabelFontHeight': false,
            'SeriesQuickLabelFontItalic': true,
            'SeriesQuickLabelFontTruncate': true,
            'SeriesQuickLabelFontTruncateString': false,
            'SeriesQuickLabelFontUnderline': true,
            'SeriesQuickLabelFontWeight': false,
            'SeriesQuickLabelFontWidthHint': false,
            'SeriesQuickLabelGap': false,
            'SeriesQuickLabelLeftPositionModifier': false,
            'SeriesQuickLabelPosition': true,
            'SeriesQuickLabelRightPositionModifier': false,
            'SeriesQuickLabelShowText': true,
            'SeriesQuickLabelText': false,
            'SeriesQuickLabelTextBox': true,
            'SeriesQuickLabelTextBoxBGAlpha': false,
            'SeriesQuickLabelTextBoxBGColor': false,
            'SeriesQuickLabelTextBoxBGColorFollowsSeriesColor': true,
            'SeriesQuickLabelTextBoxBGGradientAlpha': false,
            'SeriesQuickLabelTextBoxBGGradientAngle': false,
            'SeriesQuickLabelTextBoxBGGradientColor': false,
            'SeriesQuickLabelTextBoxBGGradientFactor': false,
            'SeriesQuickLabelTextBoxBGGradientStyle': true,
            'SeriesQuickLabelTextBoxBGImageName': false,
            'SeriesQuickLabelTextBoxBGRadialGradientOffsetX': false,
            'SeriesQuickLabelTextBoxBGRadialGradientOffsetY': false,
            'SeriesQuickLabelTextBoxBGStyle': true,
            'SeriesQuickLabelTextBoxDisplayMargins': false,
            'SeriesQuickLabelTextBoxDisplayStyle': true,
            'SeriesQuickLabelTextBoxFGColor': false,
            'SeriesQuickLabelTextBoxFGDashFactor': false,
            'SeriesQuickLabelTextBoxFGLineCap': true,
            'SeriesQuickLabelTextBoxFGStyle': true,
            'SeriesQuickLabelTextBoxFGWidth': false,
            'SeriesQuickLabelTextBoxHeightHint': false,
            'SeriesQuickLabelTextBoxPlacement': true,
            'SeriesQuickLabelTextBoxSizingMode': true,
            'SeriesQuickLabelTextBoxTextClipping': true,
            'SeriesQuickLabelTextBoxWidthHint': false,
            'SeriesQuickLabelVerticalPosition': true,
            'SeriesSetHitVector': true,
            'SeriesValue': true,
            'SeriesValueArrow': true,
            'SeriesValueArrowBGAlpha': false,
            'SeriesValueArrowBGColor': false,
            'SeriesValueArrowBGGradientAlpha': false,
            'SeriesValueArrowBGGradientAngle': false,
            'SeriesValueArrowBGGradientColor': false,
            'SeriesValueArrowBGGradientFactor': false,
            'SeriesValueArrowBGGradientStyle': true,
            'SeriesValueArrowBGImageName': false,
            'SeriesValueArrowBGRadialGradientOffsetX': false,
            'SeriesValueArrowBGRadialGradientOffsetY': false,
            'SeriesValueArrowBGStyle': true,
            'SeriesValueArrowFGColor': false,
            'SeriesValueArrowFGDashFactor': false,
            'SeriesValueArrowFGLineCap': true,
            'SeriesValueArrowFGStyle': true,
            'SeriesValueArrowFGWidth': false,
            'SeriesValueArrowPosition': true,
            'SeriesValueArrowRatio': false,
            'SeriesValueArrowSize': false,
            'SeriesValueArrowStyle': true,
            'SeriesValueAutoPosition': true,
            'SeriesValueAutoPositionMaxDistance': false,
            'SeriesValueAutoPositionMethod': true,
            'SeriesValueAutoPositionSteps': false,
            'SeriesValueBGAlpha': false,
            'SeriesValueBGColor': false,
            'SeriesValueBGGradientAlpha': false,
            'SeriesValueBGGradientAngle': false,
            'SeriesValueBGGradientColor': false,
            'SeriesValueBGGradientFactor': false,
            'SeriesValueBGGradientStyle': true,
            'SeriesValueBGImageName': false,
            'SeriesValueBGRadialGradientOffsetX': false,
            'SeriesValueBGRadialGradientOffsetY': false,
            'SeriesValueBGStyle': true,
            'SeriesValueBorderRadius': false,
            'SeriesValueBoundMode': true,
            'SeriesValueDataMask': true,
            'SeriesValueDisplayMargins': false,
            'SeriesValueDisplayStyle': true,
            'SeriesValueFGColor': false,
            'SeriesValueFGDashFactor': false,
            'SeriesValueFGLineCap': true,
            'SeriesValueFGStyle': true,
            'SeriesValueFGWidth': false,
            'SeriesValueFontAlignment': false,
            'SeriesValueFontColor': false,
            'SeriesValueFontEscapement': false,
            'SeriesValueFontFamily': true,
            'SeriesValueFontHeight': false,
            'SeriesValueFontItalic': true,
            'SeriesValueFontTruncate': true,
            'SeriesValueFontTruncateString': false,
            'SeriesValueFontUnderline': true,
            'SeriesValueFontWeight': false,
            'SeriesValueFontWidthHint': false,
            'SeriesValueHeightHint': false,
            'SeriesValueLabelMask': true,
            'SeriesValueLineFGColor': false,
            'SeriesValueLineFGDashFactor': false,
            'SeriesValueLineFGLineCap': true,
            'SeriesValueLineFGStyle': true,
            'SeriesValueLineFGWidth': false,
            'SeriesValueOutsideDrawnOnEdge': true,
            'SeriesValuePlacement': true,
            'SeriesValuePlotCoordX': false,
            'SeriesValuePlotCoordY': false,
            'SeriesValueShowLabel': true,
            'SeriesValueSizingMode': true,
            'SeriesValueStyle': true,
            'SeriesValueSublabelMask': true,
            'SeriesValueText': false,
            'SeriesValueTextClipping': true,
            'SeriesValueTextFollowsSeriesColor': true,
            'SeriesValueUsePlotCoordX': true,
            'SeriesValueUsePlotCoordY': true,
            'SeriesValueWidthHint': false,
            'SeriesValueXOffset': false,
            'SeriesValueYOffset': false,
            'SeriesXReference': false,
            'SeriesYReference': false,
            'StartDatapoint': false,
            'StepDirection': true,
            'SteppedSkipFirst': true,
            'Style': false,
            'SysPickable': true,
            'TooltipAltText': false,
            'TooltipCenterText': false,
            'TooltipDataMask': true,
            'TooltipLabelMask': true,
            'TooltipShowLabel': true,
            'TooltipSublabelMask': true,
            'TooltipText': false,
            'TreemapAllowDrilldown': true,
            'TreemapAutoSizeLabels': true,
            'TreemapCategoryLabelBGAlpha': false,
            'TreemapCategoryLabelBGColor': false,
            'TreemapCategoryLabelBGColorList': false,
            'TreemapCategoryLabelBGGradientAlpha': false,
            'TreemapCategoryLabelBGGradientAngle': false,
            'TreemapCategoryLabelBGGradientColor': false,
            'TreemapCategoryLabelBGGradientColorList': false,
            'TreemapCategoryLabelBGGradientFactor': false,
            'TreemapCategoryLabelBGGradientStyle': true,
            'TreemapCategoryLabelBGImageName': false,
            'TreemapCategoryLabelBGRadialGradientOffsetX': false,
            'TreemapCategoryLabelBGRadialGradientOffsetY': false,
            'TreemapCategoryLabelBGStyle': true,
            'TreemapCategoryLabelFGColor': false,
            'TreemapCategoryLabelFGDashFactor': false,
            'TreemapCategoryLabelFGLineCap': true,
            'TreemapCategoryLabelFGStyle': true,
            'TreemapCategoryLabelFGWidth': false,
            'TreemapCategoryLabelFontAlignment': false,
            'TreemapCategoryLabelFontColor': false,
            'TreemapCategoryLabelFontColorList': false,
            'TreemapCategoryLabelFontEscapement': false,
            'TreemapCategoryLabelFontFamily': true,
            'TreemapCategoryLabelFontHeight': false,
            'TreemapCategoryLabelFontHeightList': false,
            'TreemapCategoryLabelFontHeightMin': false,
            'TreemapCategoryLabelFontItalic': true,
            'TreemapCategoryLabelFontTruncate': true,
            'TreemapCategoryLabelFontTruncateString': false,
            'TreemapCategoryLabelFontUnderline': true,
            'TreemapCategoryLabelFontWeight': false,
            'TreemapCategoryLabelFontWidthHint': false,
            'TreemapCategoryLabelHeight': false,
            'TreemapCategoryLabelMaximumContrast': true,
            'TreemapCategoryLabelPosition': true,
            'TreemapDrawLabelsRecursively': true,
            'TreemapFadeColorWithHierarchy': true,
            'TreemapForceAllLabels': true,
            'TreemapLabelFontHeightMin': false,
            'TreemapLabelMaximumContrast': true,
            'TreemapRestrictColorRange': false,
            'TreemapShowHighlightRect': true,
            'Visible': true,
            'WickStyle': true,
            'ZigZagDimensionsMask': true,
            'ZigZagPriceMovementThreshold': false
        },
    };
    
    var LoggingStatus = /** @class */ (function () {
        function LoggingStatus() {
        }
        LoggingStatus.enableUsageLogging = function () {
            // Logging is turned on by default, we should remove this in the next major version.
        };
        // Disables logging on all charts created after this function is called
        // Does not override constructor parameters, so logging can be enabled on a per-chart basis
        LoggingStatus.disableUsageLogging = function () {
            LoggingStatus._usageLoggingEnabled = false;
        };
        LoggingStatus.isUsageLoggingEnabled = function () {
            return LoggingStatus._usageLoggingEnabled && !LoggingStatus._insideJSBin() && !isHeadlessMode;
        };
        LoggingStatus._usageLoggingEnabled = true;
        LoggingStatus._insideJSBin = function () {
            if (typeof (window) !== 'undefined' && window) {
                return (window.location.hostname).indexOf('jsbin') >= 0;
            }
            else {
                return false;
            }
        };
        return LoggingStatus;
    }());
    
    var AttributeLogger = /** @class */ (function () {
        function AttributeLogger(sender) {
            this._logSender = sender;
            this.isEnabled = false;
            this._previousValuesMap = {
                'FDSAxis': {},
                'FDSChart': {},
                'FDSChartObject': {},
                'FDSData': {},
                'FDSLegend': {},
                'FDSPlot': {},
                'FDSSeries': {},
            };
            this._loggingBlacklist = {
                'FDSAxis': {},
                'FDSChart': {},
                'FDSChartObject': {},
                'FDSData': {},
                'FDSLegend': {},
                'FDSPlot': {},
                'FDSSeries': {},
            };
        }
        AttributeLogger.prototype.logUnrecognized = function (object, attr) {
            if (!this.isEnabled || !(LoggingStatus.isUsageLoggingEnabled())) {
                return;
            }
            var objectName = object.getObjectTypeName();
            var fields = {
                'object': objectName,
                'unrecognizedAttr': attr
            };
            this._logSender.pushMessage(fields);
        };
        AttributeLogger.prototype.log = function (object, attr, level, value, type) {
            if (!this.isEnabled || !(LoggingStatus.isUsageLoggingEnabled())) {
                return;
            }
            var objectName = object.getObjectTypeName();
            if (value === undefined) {
                value = 'undefined';
            }
            else if (value === null) {
                value = 'null';
            }
            if (this._isBlacklisted(objectName, attr)) {
                return;
            }
            if (this._isValueAlreadyLogged(objectName, attr, value)) {
                return;
            }
            this._addValueToMap(objectName, attr, value);
            value = this._shouldLogValues(objectName, attr, value);
            var fields = {
                'attribute': attr,
                'object': objectName,
                'level': level,
                'value': value,
                'type': type,
                'isDefault': this._isDefault(object, attr, value)
            };
            this._logSender.pushMessage(fields);
        };
        AttributeLogger.prototype._isBlacklisted = function (objectName, attr) {
            return (_$1.has(this._loggingBlacklist[objectName], attr));
        };
        AttributeLogger.prototype._addValueToMap = function (objectName, attr, value) {
            if (this._previousValuesMap[objectName][attr] === undefined) {
                this._previousValuesMap[objectName][attr] = {};
            }
            this._previousValuesMap[objectName][attr][value.toString()] = true;
        };
        AttributeLogger.prototype._isValueAlreadyLogged = function (objectName, attr, value) {
            return _$1.has(this._previousValuesMap, [objectName, attr, value.toString()]);
        };
        AttributeLogger.prototype._isDefault = function (object, attr, value) {
            return value === object.attributeSet.defaultMap.lookup(attr).value;
        };
        AttributeLogger.prototype._shouldLogValues = function (objectName, attr, value) {
            if (!_$1.has(LoggingWhitelist[objectName], attr)) {
                return 'missingFromWhitelist';
            }
            else if (LoggingWhitelist[objectName][attr]) {
                return value.toString();
            }
            else {
                return 'ignoredValue';
            }
        };
        return AttributeLogger;
    }());
    
    var GeneralInfoLogger = /** @class */ (function () {
        function GeneralInfoLogger(sender) {
            this._logSender = sender;
            this.isEnabled = false;
        }
        GeneralInfoLogger.prototype.log = function (messageObject) {
            if (!this.isEnabled || !(LoggingStatus.isUsageLoggingEnabled())) {
                return;
            }
            var fields = {
                'level': 'info',
                'message': messageObject
            };
            this._logSender.pushMessage(fields);
        };
        return GeneralInfoLogger;
    }());
    
    var HttpSender = /** @class */ (function () {
        function HttpSender(appName) {
            this._messageCount = 0;
            this._delay = 5000;
            this._maxMessages = 2000;
            this._maxBufferLength = 1000000;
            this._msgRetryMarker = 'FDSChartJS_CLP_RETRY';
            this._debouncedFlush = _$1.debounce(this._sendBuffer, this._delay);
            this._chartAppName = appName;
            this._messageBuffer = '';
        }
        HttpSender.prototype.pushMessage = function (msgFields) {
            var msg = this._buildLogMessage(msgFields);
            var lengthCheck = this._messageBuffer.length + msg.length;
            var messageCheck = this._messageCount + 1;
            if ((lengthCheck >= this._maxBufferLength) || (messageCheck >= this._maxMessages)) {
                this._debouncedFlush.cancel();
                this._sendBuffer();
            }
            this._messageBuffer += ('\n' + msg);
            this._messageCount++;
            this._debouncedFlush();
        };
        HttpSender.prototype._buildLogMessage = function (chartFields) {
            var fields = {};
            var universalFields = {
                'applicationName': this._chartAppName,
                'version': new Version().semver,
                'clientTime': (new Date(Date.now())).toISOString(),
            };
            if (window) {
                universalFields['url'] = window.location.href;
            }
            _$1.extend(fields, universalFields, chartFields);
            var message = {
                '@fields': fields
            };
            return JSON.stringify(message);
        };
        HttpSender.prototype._sendBuffer = function () {
            var bufferToSend = this._messageBuffer;
            this._messageBuffer = '';
            this._messageCount = 0;
            $$1.ajax(HttpSender._centralLoggingPlatformUrl, {
                method: 'POST',
                headers: HttpSender._messageHeaders,
                data: bufferToSend,
                error: function (response) {
                    HttpSender._handleAjaxErrors(response.status, true, bufferToSend);
                }
            });
        };
        HttpSender._handleAjaxErrors = function (responseCode, shouldRetry, retryBuffer) {
            var errorTemplate = function (code, message) {
                return "An HTTP " + code + " error was received trying to POST to " + HttpSender._centralLoggingPlatformUrl + ". " + message;
            };
            if (responseCode === 404) {
                console.warn(errorTemplate(404, 'Did you embed the CLP service in Lima?'));
            }
            else if (responseCode === 413) {
                console.warn(errorTemplate(413, 'Either the content length or the message count exceeded CLP limits.'));
            }
            else if (responseCode >= 400 && responseCode < 500) {
                console.warn(errorTemplate(400, ''));
            }
            else if (responseCode >= 500) {
                if (shouldRetry) {
                    $$1.ajax(HttpSender._centralLoggingPlatformUrl, {
                        method: 'POST',
                        headers: HttpSender._messageHeaders,
                        data: retryBuffer,
                        error: function (response) {
                            HttpSender._handleAjaxErrors(response.status, false);
                        }
                    });
                }
                else {
                    console.warn(errorTemplate(500, 'The retry was unsuccessful and the messages were not sent.'));
                }
            }
        };
        // We add the Lima header here instead of using the Lima extension because this is the only place FDSChartJS deals
        // with Lima.
        HttpSender._messageHeaders = {};
        HttpSender._centralLoggingPlatformUrl = '/services/CLP/fdschartjs/log';
        return HttpSender;
    }());
    
    var MinimumSizeManager = /** @class */ (function () {
        function MinimumSizeManager(chart) {
            this._isScaledForMinimumSize = false;
            this._widthScaleFactor = 1;
            this._heightScaleFactor = 1;
            this._chart = chart;
        }
        MinimumSizeManager.prototype.resetScale = function (options) {
            if (options === void 0) { options = { chartRectsNeedScaling: true, canvasesNeedScaling: true }; }
            if (!this._isScaledForMinimumSize) {
                return;
            }
            var widthScaleFactor = this._widthScaleFactor;
            var heightScaleFactor = this._heightScaleFactor;
            // If the chart rects were previously upscaled, scale them back down.
            if (options.chartRectsNeedScaling) {
                this._chart.chartRect.scaleRect(widthScaleFactor, heightScaleFactor);
                this._chart.chartSubRect.scaleRect(widthScaleFactor, heightScaleFactor);
                this._chart.footerRect.scaleRect(widthScaleFactor, heightScaleFactor);
                this._chart.headerRect.scaleRect(widthScaleFactor, heightScaleFactor);
            }
            // If the canvases were previously scaled, upscale them back up.
            if (options.canvasesNeedScaling) {
                this._chart.getLayerManager().unscaleForMinimumSize(widthScaleFactor, heightScaleFactor);
            }
            this._isScaledForMinimumSize = false;
            this._widthScaleFactor = 1;
            this._heightScaleFactor = 1;
        };
        MinimumSizeManager.prototype.scaleRenderingContextForMinimumSize = function () {
            // Currently minimum size for the KMLMAP drawstyle is not supported.
            // The KMLMAP drawstyle uses SVG instead of the canvas api, so KMLMAP needs specific scaling code to be written
            // for it. Furthermore, the KMLMAP drawstyle already scales the map portion of the drawing properly, though
            // headers are not scaled.
            if (this._isKMLMap() || !this._chartDimensionIsLessThanMinimumSize()) {
                return;
            }
            var drawWidth = this._chart.getWidth();
            var drawHeight = this._chart.getHeight();
            var _a = this._upscaleChartRectsToMinimumSize(), upscaledWidth = _a[0], upscaledHeight = _a[1];
            var widthScaleFactor = drawWidth / upscaledWidth;
            var heightScaleFactor = drawHeight / upscaledHeight;
            this._widthScaleFactor = widthScaleFactor;
            this._heightScaleFactor = heightScaleFactor;
            this._chart.getLayerManager().scaleForMinimumSize(widthScaleFactor, heightScaleFactor);
            this._isScaledForMinimumSize = true;
        };
        MinimumSizeManager.prototype.scalePoint = function (pt) {
            return new Point(this.scaleWidth(pt.x), this.scaleHeight(pt.y));
        };
        MinimumSizeManager.prototype.scaleRectangle = function (rect) {
            return new Rectangle(this.scaleWidth(rect.x1), this.scaleHeight(rect.y1), this.scaleWidth(rect.x2), this.scaleHeight(rect.y2));
        };
        MinimumSizeManager.prototype.scaleWidth = function (value) {
            return value * this._widthScaleFactor;
        };
        MinimumSizeManager.prototype.scaleHeight = function (value) {
            return value * this._heightScaleFactor;
        };
        MinimumSizeManager.prototype.unscaleWidth = function (value) {
            return value / this._widthScaleFactor;
        };
        MinimumSizeManager.prototype.unscaleHeight = function (value) {
            return value / this._heightScaleFactor;
        };
        MinimumSizeManager.prototype.scaleRenderingContext = function (ctx) {
            ctx.scale(this._widthScaleFactor, this._heightScaleFactor);
        };
        MinimumSizeManager.prototype.unscaleRenderingContext = function (ctx) {
            ctx.scale(1 / this._widthScaleFactor, 1 / this._heightScaleFactor);
        };
        MinimumSizeManager.prototype.setAttributes = function (attributeSet) {
            if (attributeSet.defaultMap.isInitialized()) {
                return;
            }
            attributeSet.addMultiple([
                ['MinimumSize', Number, 0],
            ]);
        };
        MinimumSizeManager.prototype.syncMembers = function (attributeSet) {
            var getAttribute = attributeSet.get.bind(attributeSet);
            var oldMinimumSize = this._minimumSize;
            this._minimumSize = scaleByDevicePixelRatio(getAttribute('MinimumSize'));
            if (oldMinimumSize !== this._minimumSize) {
                this.resetScale();
                this.scaleRenderingContextForMinimumSize();
            }
        };
        MinimumSizeManager.prototype._isKMLMap = function () {
            for (var _i = 0, _a = this._chart.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                if (plot.allPlotSeriesDrawStylesMatch([41 /* KMLMAP */])) {
                    return true;
                }
            }
            return false;
        };
        MinimumSizeManager.prototype._chartDimensionIsLessThanMinimumSize = function () {
            var width = this._chart.getWidth();
            var height = this._chart.getHeight();
            var minimumSize = this._minimumSize;
            if (width < minimumSize || height < minimumSize) {
                return true;
            }
            else {
                return false;
            }
        };
        // Scale up the chart rects so that the shorter side is equal to the minimum size, while maintaing the
        // width-to-height ratio.
        MinimumSizeManager.prototype._upscaleChartRectsToMinimumSize = function () {
            var width = this._chart.getWidth();
            var height = this._chart.getHeight();
            var minimumSize = this._minimumSize;
            var widthHeightRatio = width / height;
            // Figure out which side is less than the minimum size. If both are, figure out which side is the shorter of the
            // two.
            var useWidthForMinSize = width < minimumSize && width < height;
            var newWidth;
            var newHeight;
            if (useWidthForMinSize) {
                newWidth = minimumSize;
                newHeight = minimumSize / widthHeightRatio;
            }
            else {
                newWidth = minimumSize * widthHeightRatio;
                newHeight = minimumSize;
            }
            var widthUpscaleFactor = newWidth / width;
            var heightUpscaleFactor = newHeight / height;
            this._chart.chartRect.scaleRect(widthUpscaleFactor, heightUpscaleFactor);
            this._chart.chartSubRect.scaleRect(widthUpscaleFactor, heightUpscaleFactor);
            this._chart.footerRect.scaleRect(widthUpscaleFactor, heightUpscaleFactor);
            this._chart.headerRect.scaleRect(widthUpscaleFactor, heightUpscaleFactor);
            return [this._chart.getWidth(), this._chart.getHeight()];
        };
        return MinimumSizeManager;
    }());
    
    var models = {
        plot: FDSPlotWrapper,
        series: FDSSeriesWrapper,
        data: FDSDataWrapper,
        axis: FDSAxisWrapper
    };
    
    /**
     * A collection of FDSLineHitShape objects that act as a combined hitshape
     *
     * @class FDSSegmentedLineHitShape
     * @extends FDSShape
     */
    var FDSSegmentedLineHitShape = /** @class */ (function (_super) {
        __extends(FDSSegmentedLineHitShape, _super);
        /**
         * Creates an instance of FDSSegmentedLineHitShape.
         *
         * @param lines - an array of line segments
         */
        function FDSSegmentedLineHitShape(lines, thickness, sliderInfo) {
            var _this = _super.call(this) || this;
            _this.lines = [];
            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                var line = lines_1[_i];
                _this.lines.push(new FDSLineHitShape(line.pt1.x, line.pt1.y, line.pt2.x, line.pt2.y));
            }
            _this.name = 'Segmented Line';
            _this.direction = sliderInfo.direction;
            _this.aboveOrLeftPlots = sliderInfo.aboveOrLeftPlots;
            _this.belowOrRightPlots = sliderInfo.belowOrRightPlots;
            return _this;
        }
        /**
         * Performs a hit test on all child line segments and returns true if any of them hit
         *
         * @param x - the x-coordinate of the point being tested
         * @param y - the y-coordinate of the point being tested
         * @returns true if any of the lines were hit
         */
        FDSSegmentedLineHitShape.prototype.onHitTest = function (x, y) {
            return _$1.some(this.lines, function (line) { return line.onHitTest(x, y); });
        };
        /**
         * Test if the segmented line intersects a given rectangle, represented by diagonal coordinates
         *
         * @param x1 - The x-coordinate of the corner of the rectangle
         * @param y1 - The y-coordinate of the corner of the rectangle
         * @param x2 - The x-coordinate of the diagonally opposite corner of the rectangle
         * @param y2 - The y-coordinate of the diagonally opposite corner of the rectangle
         * @returns whether or not the shape and rectangle intersect
         */
        FDSSegmentedLineHitShape.prototype.hitTest = function (x1, y1, x2, y2) {
            return _$1.some(this.lines, function (line) { return line.hitTest(x1, y1, x2, y2); });
        };
        /**
         * finds the minimum x-coordinate of all the line segments
         */
        FDSSegmentedLineHitShape.prototype.getMinX = function () {
            return this.lines.map(function (line) { return line.x1; })
                .reduce(function (prev, curr) {
                return Math.min(prev, curr);
            }, Infinity);
        };
        /**
         * finds the maximum x-coordinate of all the line segments
         */
        FDSSegmentedLineHitShape.prototype.getMaxX = function () {
            return this.lines.map(function (line) { return line.x2; })
                .reduce(function (prev, curr) {
                return Math.max(prev, curr);
            }, 0);
        };
        /**
         * finds the minimum y-coordinate of all the line segments
         */
        FDSSegmentedLineHitShape.prototype.getMinY = function () {
            return this.lines.map(function (line) { return line.y1; })
                .reduce(function (prev, curr) {
                return Math.min(prev, curr);
            }, Infinity);
        };
        /**
         * finds the maximum y-coordinate of all the line segments
         */
        FDSSegmentedLineHitShape.prototype.getMaxY = function () {
            return this.lines.map(function (line) { return line.y2; })
                .reduce(function (prev, curr) {
                return Math.max(prev, curr);
            }, 0);
        };
        FDSSegmentedLineHitShape.prototype.shadeShape = function (ctx) {
            for (var _i = 0, _a = this.lines; _i < _a.length; _i++) {
                var line = _a[_i];
                line.shadeShape(ctx);
            }
        };
        return FDSSegmentedLineHitShape;
    }(FDSShape));
    
    var PlotResizeManager = /** @class */ (function () {
        function PlotResizeManager(chart) {
            this._hitShapesNeedUpdate = false;
            this._needsNewSliders = false;
            this._resizeSliderDrawSegmented = true;
            this._resizeSliderWidth = 6;
            this._resizeSliderBGColor = 13158600 /* GRAY8 */;
            this._resizeSliderButtonRestColor = 14803425 /* GRAY9 */;
            this._resizeSliderButtonHoverColor = 15391665 /* BLUE6 */;
            this._resizeSliderButtonPressedColor = 10092543 /* YELLOW6 */;
            this._resizeSliderStyle = 0 /* DEFAULT */;
            this._resizeSliderMobileRectPen = new FDSPen();
            this._resizeSliderMobileRectBrush = new FDSBrush();
            this._resizeSliderMobileRectPadding = 3;
            this._resizeSliderMobileRectWidth = 0.1;
            this._resizeSliderMobileRectHeight = 0.015;
            this._refreshPlotOnResize = false;
            this._hitlines = [];
            this._hitrects = [];
            this._chart = chart;
        }
        PlotResizeManager.prototype.setHitShapesDirty = function () {
            this._hitShapesNeedUpdate = true;
        };
        PlotResizeManager.prototype.setSlidersDirty = function () {
            this._needsNewSliders = true;
        };
        PlotResizeManager.prototype.setThemeAttributes = function (theme, themeAttrs) {
            if (theme === 1 /* QUARTZ */) {
                themeAttrs['ResizeSliderBGColor'] = 13158600 /* GRAY8 */;
                themeAttrs['ResizeSliderButtonRestColor'] = 14803425 /* GRAY9 */;
                themeAttrs['ResizeSliderButtonHoverColor'] = 15391665 /* BLUE6 */;
                themeAttrs['ResizeSliderButtonPressedColor'] = 10092543 /* YELLOW6 */;
            }
            else if (theme === 2 /* CARBON */) {
                themeAttrs['ResizeSliderBGColor'] = 4934475 /* GRAY3 */;
                themeAttrs['ResizeSliderButtonRestColor'] = 6579300 /* GRAY4 */;
                themeAttrs['ResizeSliderButtonHoverColor'] = 11037743 /* BLUE3 */;
                themeAttrs['ResizeSliderButtonPressedColor'] = 7557941 /* BLUE13 */;
            }
        };
        PlotResizeManager.prototype.setAttributes = function (attributeSet) {
            if (attributeSet.defaultMap.isInitialized()) {
                return;
            }
            this._resizeSliderMobileRectBrush.writeToAttrSet(attributeSet, 'ResizeSliderMobileRectBG');
            this._resizeSliderMobileRectPen.writeToAttrSet(attributeSet, 'ResizeSliderMobileRectFG');
            attributeSet.addMultiple([
                ['ResizeSliderWidth', Number, 6],
                ['ResizeSliderBGColor', Number, 13158600 /* GRAY8 */],
                ['ResizeSliderButtonRestColor', Number, 14803425 /* GRAY9 */],
                ['ResizeSliderButtonHoverColor', Number, 15391665 /* BLUE6 */],
                ['ResizeSliderButtonPressedColor', Number, 10092543 /* YELLOW6 */],
                ['ResizeSliderDrawSegmented', Boolean, true],
                ['ResizeSliderStyle', Number, 0 /* DEFAULT */],
                ['RefreshPlotOnResize', Boolean, false],
                ['ResizeEnabled', Boolean, false],
                ['ResizeTouchingOnly', Boolean, true],
                ['ResizeMinFactorX', Number, 0],
                ['ResizeMinFactorY', Number, 0],
                ['ResizeSliderMobileRectWidth', Number, 0.1],
                ['ResizeSliderMobileRectHeight', Number, 0.015],
                ['ResizeSliderMobileRectPadding', Number, 3]
            ]);
        };
        PlotResizeManager.prototype.syncMembers = function (attributeSet) {
            // Saves on property access and minified file size
            var getAttribute = attributeSet.get.bind(attributeSet);
            this._resizeSliderWidth = getAttribute('ResizeSliderWidth');
            this._resizeSliderBGColor = getAttribute('ResizeSliderBGColor');
            this._resizeSliderButtonRestColor = getAttribute('ResizeSliderButtonRestColor');
            this._resizeSliderButtonHoverColor = getAttribute('ResizeSliderButtonHoverColor');
            this._resizeSliderButtonPressedColor = getAttribute('ResizeSliderButtonPressedColor');
            var oldResizeSegmented = this._resizeSliderDrawSegmented;
            this._resizeSliderDrawSegmented = getAttribute('ResizeSliderDrawSegmented');
            if (this._resizeSliderDrawSegmented !== oldResizeSegmented) {
                this._hitShapesNeedUpdate = true;
            }
            this._resizeSliderStyle = getAttribute('ResizeSliderStyle');
            this._resizeSliderMobileRectBrush.constructFromAttributes(attributeSet, 'ResizeSliderMobileRectBG');
            this._resizeSliderMobileRectPen = FDSPen.constructFromAttributes(attributeSet, 'ResizeSliderMobileRectFG');
            this._resizeSliderMobileRectWidth = getAttribute('ResizeSliderMobileRectWidth');
            this._resizeSliderMobileRectHeight = getAttribute('ResizeSliderMobileRectHeight');
            this._resizeSliderMobileRectPadding = getAttribute('ResizeSliderMobileRectPadding');
            this._refreshPlotOnResize = getAttribute('RefreshPlotOnResize');
        };
        // This function associates the slider objects with plots. This association continues even after
        // the plots have been dragged around.
        PlotResizeManager.prototype.createPlotResizeSliders = function () {
            if (!this._needsNewSliders) {
                // just return the existant ones
                if (this._hitShapesNeedUpdate) {
                    this._createHitShapesFromSliderInfo(this._hitlines);
                }
                return;
            }
            var plotList = this._chart.chartPlotList;
            var sliders = [];
            for (var i = 0; i < plotList.length; i++) {
                var plot1 = plotList[i];
                if (!plot1.resizeEnabled) {
                    continue;
                }
                for (var j = i; j < plotList.length; j++) {
                    var plot2 = plotList[j];
                    // avoid repeating comparisons
                    if (!plot2.resizeEnabled) {
                        continue;
                    }
                    if (fuzzyEQ(plot1.minYFactor, plot2.maxYFactor) ||
                        fuzzyEQ(plot2.minYFactor, plot1.maxYFactor)) {
                        var slider = this._createOrAddSlider(plot1, plot2, sliders, 1 /* ROW */);
                        if (slider != null) {
                            sliders.push(slider);
                        }
                    }
                    if (fuzzyEQ(plot1.minXFactor, plot2.maxXFactor) ||
                        fuzzyEQ(plot2.minXFactor, plot1.maxXFactor)) {
                        var slider = this._createOrAddSlider(plot1, plot2, sliders, 0 /* COLUMN */);
                        if (slider != null) {
                            sliders.push(slider);
                        }
                    }
                }
            }
            // now that the list of slider objects is created, turn them into consolidated hit shapes
            this._createHitShapesFromSliderInfo(sliders);
            this._needsNewSliders = false;
            this.setHitShapesDirty();
        };
        PlotResizeManager.prototype.handleResizeDrag = function (cursor, finalResize) {
            if (finalResize === void 0) { finalResize = false; }
            if (!this._chart.pickedObj || !(this._chart.pickedObj instanceof FDSSegmentedLineHitShape)) {
                return false;
            }
            var lineShape = this._chart.pickedObj;
            if (!(lineShape instanceof FDSSegmentedLineHitShape)) {
                throw new Error('unexpected slider hit shape');
            }
            var newFactor = this._getNewFactorFromPickedObj(cursor);
            if (this._refreshPlotOnResize || finalResize) {
                this._setPlotFactorsFromPickedObj(newFactor, false);
                // don't change the plots they're attached to,
                // but do recreate new hitshapes based on where those plots now are
                this.setHitShapesDirty();
                this._chart.invalidate();
            }
            else {
                this._chart.renderManager.draw(false);
                // just draw a line on the canvas showing where the new plot borders will be
                var ctx = this._chart.getUIContext();
                if (lineShape.direction === 1 /* ROW */) {
                    var positionOverride = ~~this._chart.chartRect.fromNDC(newFactor, 2 /* Y */);
                    for (var _i = 0, _a = lineShape.lines; _i < _a.length; _i++) {
                        var line = _a[_i];
                        line.y1 = line.y2 = positionOverride;
                    }
                }
                else {
                    var positionOverride = ~~this._chart.chartRect.fromNDC(newFactor, 1 /* X */);
                    for (var _b = 0, _c = lineShape.lines; _b < _c.length; _b++) {
                        var line = _c[_b];
                        line.x1 = line.x2 = positionOverride;
                    }
                }
                this.drawResizeSliders(ctx, lineShape);
            }
            return true;
        };
        // function to adjust all the plots surrounding the picked object
        // @param newFactor [Number] the factor to adjust the plots to
        PlotResizeManager.prototype._setPlotFactorsFromPickedObj = function (newFactor, shouldFireDropEvent) {
            if (shouldFireDropEvent === void 0) { shouldFireDropEvent = true; }
            var lineShape = this._chart.pickedObj;
            if (!(lineShape instanceof FDSSegmentedLineHitShape)) {
                throw new Error('unexpected slider hit shape');
            }
            // update plots
            for (var _i = 0, _a = lineShape.aboveOrLeftPlots; _i < _a.length; _i++) {
                var plot = _a[_i];
                switch (lineShape.direction) {
                    case 1 /* ROW */:
                        plot.attributeSet.setAt('minYFactor', 'user', newFactor);
                        break;
                    default:// Direction.COLUMN
                        plot.attributeSet.setAt('maxXFactor', 'user', newFactor);
                }
            }
            for (var _b = 0, _c = lineShape.belowOrRightPlots; _b < _c.length; _b++) {
                var plot = _c[_b];
                switch (lineShape.direction) {
                    case 1 /* ROW */:
                        plot.attributeSet.setAt('maxYFactor', 'user', newFactor);
                        break;
                    default:// Direction.COLUMN
                        plot.attributeSet.setAt('minXFactor', 'user', newFactor);
                }
            }
            if (!shouldFireDropEvent) {
                return;
            }
            // fire event
            var isHorizontal = lineShape.direction === 1;
            var aboveOrLeftPlotIds = lineShape.aboveOrLeftPlots.map(function (p) { return p.id; });
            var belowOrRightPlotIds = lineShape.belowOrRightPlots.map(function (p) { return p.id; });
            var eventObj = {
                isHorizontal: isHorizontal,
                minFactorPlotList: isHorizontal ? aboveOrLeftPlotIds : belowOrRightPlotIds,
                maxFactorPlotList: isHorizontal ? belowOrRightPlotIds : aboveOrLeftPlotIds,
                value: newFactor
            };
            this._chart.fireNonLocationEvent('PlotSizerDrop', JSON.stringify(eventObj));
        };
        // turns a point on the chart in pixels into a factor
        // just a helper fn to keep the code a little cleaner
        PlotResizeManager.prototype._factor = function (point, direction) {
            if (direction === 1 /* ROW */) {
                return this._chart.chartRect.toRectNDC(point, 1 /* X */);
            }
            else {
                // Y is backwards!
                return 1 - this._chart.chartRect.toRectNDC(point, 2 /* Y */);
            }
        };
        // function to find a new factor for the plots surrounding the picked object
        // @return [Number] the new factor to use for the plots
        PlotResizeManager.prototype._getNewFactorFromPickedObj = function (cursor) {
            var newFactor;
            var minFactor;
            var maxFactor;
            var lineShape = this._chart.pickedObj;
            if (!(lineShape instanceof FDSSegmentedLineHitShape)) {
                throw new Error('unexpected slider hit shape');
            }
            // figure out the new x/y factor for the current point
            switch (lineShape.direction) {
                case 1 /* ROW */:
                    newFactor = this._factor(cursor.y, 0 /* COLUMN */);
                    break;
                default:
                    newFactor = this._factor(cursor.x, 1 /* ROW */);
            }
            // adjust the factor to be ok for our limits
            for (var _i = 0, _a = lineShape.belowOrRightPlots; _i < _a.length; _i++) {
                var plot = _a[_i];
                switch (lineShape.direction) {
                    case 1 /* ROW */:
                        // again, remember that the Y factor variables are backwards from the attributes
                        minFactor = this._factor(plot.maxYFactor, 0 /* COLUMN */);
                        if (newFactor - minFactor < plot.resizeMinFactorY) {
                            newFactor = plot.resizeMinFactorY + minFactor;
                        }
                        break;
                    default:// Direction.COLUMN
                        maxFactor = this._factor(plot.maxXFactor, 1 /* ROW */);
                        if (maxFactor - newFactor < plot.resizeMinFactorX) {
                            newFactor = maxFactor - plot.resizeMinFactorX;
                        }
                }
            }
            for (var _b = 0, _c = lineShape.aboveOrLeftPlots; _b < _c.length; _b++) {
                var plot = _c[_b];
                switch (lineShape.direction) {
                    case 1 /* ROW */:
                        maxFactor = this._factor(plot.minYFactor, 0 /* COLUMN */);
                        if (maxFactor - newFactor < plot.resizeMinFactorY) {
                            newFactor = maxFactor - plot.resizeMinFactorY;
                        }
                        break;
                    default:// Direction.COLUMN
                        minFactor = this._factor(plot.minXFactor, 1 /* ROW */);
                        if (newFactor - minFactor < plot.resizeMinFactorX) {
                            newFactor = plot.resizeMinFactorX + minFactor;
                        }
                }
            }
            return newFactor;
        };
        PlotResizeManager.prototype.hitTest = function (point, pick$$1, hitShape) {
            if (this._chart.dragMode === 10 /* PLOT_RESIZE */) {
                return null;
            }
            var hitline = undefined;
            // First try to find a direct hit
            hitline = _$1.find(this._hitlines, function (line) { return line.onHitTest(point.x, point.y); });
            if (!hitline) {
                // If we didn't hit a line, check
                var hitrect = _$1.find(this._hitrects, function (rect) { return rect.associatedHitLine != null && rect.onHitTest(point.x, point.y); });
                if (hitrect) {
                    hitline = hitrect.associatedHitLine;
                }
            }
            return hitline ? [hitline.aboveOrLeftPlots[0], hitline] : null;
        };
        // Creates a new slider or adds plots to an existing slider
        // Going in we know these plots share an edge but we don't know if they are adjacent on that edge
        // @return [slider object] A new slider object created for a new slider
        // @return [undefined] Returns undefined when no new object is created, either because
        //    plots are added to an existing one, or because the plots are not adjacent
        PlotResizeManager.prototype._createOrAddSlider = function (plot1, plot2, sliders, direction) {
            function getAttrs() {
                if (direction === 1 /* ROW */) {
                    return {
                        perpMin: 'minYFactor',
                        perpMax: 'maxYFactor',
                        parMin: 'minXFactor',
                        parMax: 'maxXFactor',
                    };
                }
                else {
                    return {
                        perpMin: 'minXFactor',
                        perpMax: 'maxXFactor',
                        parMin: 'minYFactor',
                        parMax: 'maxYFactor',
                    };
                }
            }
            var _a = getAttrs(), perpMin = _a.perpMin, perpMax = _a.perpMax, parMin = _a.parMin, parMax = _a.parMax;
            // make sure plot1 is the one on the bottom or right, for consistency
            if (plot1[perpMin] !== plot2[perpMax]) {
                _b = [plot2, plot1], plot1 = _b[0], plot2 = _b[1];
            }
            var plotsMustTouch = plot1.resizeTouchingOnly || plot2.resizeTouchingOnly;
            if (!plotsMustTouch) {
                // just add these plots to a slider if one exists at this point
                for (var _i = 0, sliders_1 = sliders; _i < sliders_1.length; _i++) {
                    var slider = sliders_1[_i];
                    if (slider.direction !== direction) {
                        continue;
                    }
                    if (plot1[perpMin] === slider.belowOrRightPlots[0][perpMin]) {
                        if (slider.belowOrRightPlots.indexOf(plot1) === -1) {
                            slider.belowOrRightPlots.push(plot1);
                        }
                        if (slider.aboveOrLeftPlots.indexOf(plot2) === -1) {
                            slider.aboveOrLeftPlots.push(plot2);
                        }
                        return undefined;
                    }
                }
            }
            // no matching sliders found, or didn't look. make a new one!
            if ((!plotsMustTouch) || (plot1[parMax] > plot2[parMin] && plot1[parMin] < plot2[parMax])) {
                // slider objects just store relevant plots
                return {
                    direction: direction,
                    belowOrRightPlots: [plot1],
                    aboveOrLeftPlots: [plot2]
                };
            }
            // no slider was created
            return undefined;
            var _b;
        };
        /**
         * Creates new hit shapes from the slider info
         */
        PlotResizeManager.prototype._createHitShapesFromSliderInfo = function (sliders) {
            if (!this._hitShapesNeedUpdate) {
                return;
            }
            var hitlines = [];
            var index = 0;
            function isResizeEnabled(plot) {
                return plot.resizeEnabled;
            }
            function _comparePlotsX(plot1, plot2) {
                return plot1.minXFactor - plot2.minXFactor;
            }
            function _comparePlotsY(plot1, plot2) {
                return plot1.minYFactor - plot2.minYFactor;
            }
            // make sure all plots want to be resized, and delete objects
            // which don't need to exist anymore (if not enough plots are connected to them)
            // this is necessary because when an individual plot enables/disables resizing
            // it doesn't recreate the objects but it does reconsolidate them
            var newSliders = [];
            for (var _i = 0, sliders_2 = sliders; _i < sliders_2.length; _i++) {
                var slider = sliders_2[_i];
                var aboveOrLeftPlots = _$1.filter(slider.aboveOrLeftPlots, isResizeEnabled);
                var belowOrRightPlots = _$1.filter(slider.belowOrRightPlots, isResizeEnabled);
                if (_$1.some(aboveOrLeftPlots) && _$1.some(belowOrRightPlots)) {
                    slider.aboveOrLeftPlots = aboveOrLeftPlots;
                    slider.belowOrRightPlots = belowOrRightPlots;
                    newSliders.push(slider);
                }
            }
            for (var _a = 0, newSliders_1 = newSliders; _a < newSliders_1.length; _a++) {
                var slider = newSliders_1[_a];
                var plots = slider.aboveOrLeftPlots.concat(slider.belowOrRightPlots);
                var lines = [];
                if (this._resizeSliderDrawSegmented && plots.length > 1) {
                    // no point in segmenting only one plot
                    var start = void 0;
                    var end = void 0;
                    var x = void 0;
                    var y = void 0;
                    if (slider.direction === 1 /* ROW */) {
                        plots.sort(_comparePlotsX);
                        start = plots[0].minXFactor;
                    }
                    else {
                        plots.sort(_comparePlotsY);
                        start = plots[0].minYFactor;
                    }
                    var i = 0;
                    while (i < plots.length - 1) {
                        var p1 = plots[i];
                        var p2 = plots[++i];
                        if (slider.direction === 1 /* ROW */ && p1.maxXFactor < p2.minXFactor) {
                            y = slider.belowOrRightPlots[0].minYFactor;
                            lines.push(Line.constructFromValues(start, y, p1.maxXFactor, y));
                            start = p2.minXFactor;
                        }
                        else if (slider.direction === 0 /* COLUMN */ && p1.maxYFactor < p2.minYFactor) {
                            x = slider.belowOrRightPlots[0].minXFactor;
                            lines.push(Line.constructFromValues(x, start, x, p1.maxYFactor));
                            start = p2.minYFactor;
                        }
                        if (i === plots.length - 1) {
                            // this is the last plot, let's just save the line and get out of here
                            if (slider.direction === 1 /* ROW */) {
                                y = slider.belowOrRightPlots[0].minYFactor;
                                end = Math.max(p1.maxXFactor, p2.maxXFactor);
                                lines.push(Line.constructFromValues(start, y, end, y));
                            }
                            else {
                                x = slider.belowOrRightPlots[0].minXFactor;
                                end = Math.max(p1.maxYFactor, p2.maxYFactor);
                                lines.push(Line.constructFromValues(x, start, x, end));
                            }
                        }
                    }
                    hitlines.push(this._createPlotHitObj(lines, slider, index++));
                }
                else {
                    // find the min and max point and make a line stretching across it
                    var min$$1 = Infinity;
                    var max$$1 = 0;
                    for (var _b = 0, plots_1 = plots; _b < plots_1.length; _b++) {
                        var plot = plots_1[_b];
                        if (slider.direction === 1 /* ROW */) {
                            if (plot.minXFactor < min$$1) {
                                min$$1 = plot.minXFactor;
                            }
                            if (plot.maxXFactor > max$$1) {
                                max$$1 = plot.maxXFactor;
                            }
                        }
                        else {
                            if (plot.minYFactor < min$$1) {
                                min$$1 = plot.minYFactor;
                            }
                            if (plot.maxYFactor > max$$1) {
                                max$$1 = plot.maxYFactor;
                            }
                        }
                    }
                    // create a hitline based on the points found, going the correct direction
                    if (slider.direction === 1 /* ROW */) {
                        // the first plot is an aboveOrLeft plot
                        var cNum = plots[0].maxYFactor;
                        lines = [Line.constructFromValues(min$$1, cNum, max$$1, cNum)];
                        hitlines.push(this._createPlotHitObj(lines, slider, index++));
                    }
                    else {
                        var cNum = plots[0].maxXFactor;
                        lines = [Line.constructFromValues(cNum, min$$1, cNum, max$$1)];
                        hitlines.push(this._createPlotHitObj(lines, slider, index++));
                    }
                }
            }
            this._hitShapesNeedUpdate = false;
            this._hitlines = hitlines;
        };
        PlotResizeManager.prototype._createPlotHitObj = function (lines, sliderInfo, index) {
            var hitline = new FDSSegmentedLineHitShape(lines, this._resizeSliderWidth * 2, sliderInfo);
            hitline.index = index;
            // also while we're here, save a point to the points array
            var line = lines[0];
            // we save the x and y of a random line in the line. All we need is one point that
            // the slider will respond to
            var x = line.xMid;
            var y = line.yMid;
            for (var _i = 0, _a = hitline.belowOrRightPlots; _i < _a.length; _i++) {
                var p1 = _a[_i];
                for (var _b = 0, _c = hitline.aboveOrLeftPlots; _b < _c.length; _b++) {
                    var p2 = _c[_b];
                    // save under every combo of plot names the user could use to ask for it
                    // this won't end up being that many - maybe 18 tops
                    var id1 = p1.id + "_" + p2.id;
                    var id2 = p2.id + "_" + p1.id;
                    this._chart.plotSliderPixelPoints[id1] = { x: x, y: y };
                    this._chart.plotSliderPixelPoints[id2] = { x: x, y: y };
                }
            }
            return hitline;
        };
        PlotResizeManager.prototype._drawResizeSlider = function (ctx, slider, isPressed) {
            if (isPressed === void 0) { isPressed = false; }
            var sliderBrush = new FDSBrush();
            sliderBrush.style = 0 /* SOLID */;
            var sliderThickness = scaleByDevicePixelRatio(this._resizeSliderWidth);
            var drawPart = function (xPos, yPos, width, height, color) {
                sliderBrush.color = color;
                sliderBrush.setOnCanvas(ctx);
                ctx.fillRect(~~(xPos - (width / 2)), ~~(yPos - (height / 2)), width, height);
            };
            var isHovered = this._chart.mousedOverPlotSliderIndex === slider.index;
            var barColor = this._resizeSliderBGColor;
            var buttonColor = isPressed ? this._resizeSliderButtonPressedColor :
                isHovered ? this._resizeSliderButtonHoverColor : this._resizeSliderButtonRestColor;
            if (slider.direction === 0 /* COLUMN */) {
                for (var _i = 0, _a = slider.lines; _i < _a.length; _i++) {
                    var line = _a[_i];
                    var pos = line.x1;
                    var center = (line.y1 + line.y2) / 2;
                    var height = line.y2 - line.y1;
                    // draw main bar
                    drawPart(pos, center, sliderThickness, height, barColor);
                    // draw button
                    var buttonSize = ~~Math.min(0.75 * height, scaleByDevicePixelRatio(70));
                    drawPart(pos, center, sliderThickness - scaleByDevicePixelRatio(2), buttonSize, buttonColor);
                    // draw dash
                    var dashSize = ~~Math.min(0.25 * buttonSize, 10);
                    drawPart(pos, center, scaleByDevicePixelRatio(2), dashSize, barColor);
                }
            }
            else {
                for (var _b = 0, _c = slider.lines; _b < _c.length; _b++) {
                    var line = _c[_b];
                    var pos = line.y1;
                    var center = (line.x1 + line.x2) / 2;
                    var width = line.x2 - line.x1;
                    // draw main bar
                    drawPart(center, pos, width, sliderThickness, barColor);
                    // draw button
                    var buttonSize = ~~Math.min(0.75 * width, scaleByDevicePixelRatio(70));
                    drawPart(center, pos, buttonSize, sliderThickness - scaleByDevicePixelRatio(2), buttonColor);
                    // draw dash
                    var dashSize = ~~Math.min(0.25 * buttonSize, 10);
                    drawPart(center, pos, dashSize, scaleByDevicePixelRatio(2), barColor);
                }
            }
        };
        PlotResizeManager.prototype.drawResizeSliders = function (ctx, activeSlider) {
            if (this._hitlines.length === 0) {
                return;
            }
            if (activeSlider == null) {
                if (_$1.includes(this._hitlines, this._chart.pickedObj)) {
                    activeSlider = this._chart.pickedObj;
                }
            }
            ctx.save();
            ctx.clear();
            for (var _i = 0, _a = this._hitlines; _i < _a.length; _i++) {
                var shape = _a[_i];
                // skip the activeSlider for now, we will draw it on top after this loop.
                if (shape !== activeSlider) {
                    this._drawResizeSlider(ctx, shape);
                }
            }
            if (activeSlider) {
                this._drawResizeSlider(ctx, activeSlider, true);
            }
            this._drawResizeSliderMobileRects(ctx);
            ctx.restore();
        };
        // function to add in rectanges on either side of the sliders, along with hitshapes
        PlotResizeManager.prototype._drawResizeSliderMobileRects = function (ctx) {
            var _this = this;
            if (this._resizeSliderStyle !== 1 /* MOBILE */) {
                return;
            }
            this._resizeSliderMobileRectPen.setOnCanvas(ctx);
            // some shorter names for easier legibility later:
            var padding = this._resizeSliderMobileRectPadding;
            var mBrush = this._resizeSliderMobileRectBrush;
            // helper function to fill and stroke a rect with brush since it's done a billion times above
            // note: this assumes the pen has already been selected
            var drawRect = function (x1, y1, x2, y2) {
                var rect = new Rectangle(x1, y1, x2, y2);
                var usedImageBrush = fillWithImage(x1, y1, x2, y2);
                if (!usedImageBrush) {
                    mBrush.setOnCanvas(ctx, rect);
                    ctx.fillRect(rect.x1, rect.y1, rect.getWidth(), rect.getHeight());
                }
                ctx.strokeRect(rect.x1, rect.y1, rect.getWidth(), rect.getHeight());
            };
            // helper function to fill an area with an image, returning false if anything goes wrong
            var fillWithImage = function (x1, y1, x2, y2) {
                if (mBrush.imageDSName === '') {
                    return false;
                }
                var imageDS = _this._chart.getTypedObject(mBrush.imageDSName, isDataSet);
                if (!imageDS) {
                    return false;
                }
                var img = document.createElement('img');
                var imageType = imageDS.attributeSet.get('ImageType');
                img.src = "data:image/" + imageType + ";base64," + imageDS.getAt(0);
                ctx.save();
                var alpha = mBrush.alpha / 255;
                ctx.drawImage(img, x1, y1, x2 - x1, y2 - y1, alpha);
                ctx.restore();
                return true;
            };
            this._hitrects = [];
            for (var _i = 0, _a = this._hitlines; _i < _a.length; _i++) {
                var shape = _a[_i];
                for (var _b = 0, _c = shape.lines; _b < _c.length; _b++) {
                    var line = _c[_b];
                    // get the center point and rect width/height
                    var centerX = ~~(line.x1 + (line.x2 - line.x1) / 2);
                    var centerY = ~~(line.y1 + (line.y2 - line.y1) / 2);
                    // one of these should be 0, the other is the length of the line
                    var lineLength = Math.max((line.x2 - line.x1), (line.y2 - line.y1));
                    var rectWidth = void 0;
                    var rectHeight = void 0;
                    if (this._resizeSliderMobileRectWidth < 1) {
                        rectWidth = lineLength * this._resizeSliderMobileRectWidth;
                    }
                    else {
                        rectWidth = this._resizeSliderMobileRectWidth;
                    }
                    if (this._resizeSliderMobileRectHeight < 1) {
                        rectHeight = lineLength * this._resizeSliderMobileRectHeight;
                    }
                    else {
                        rectHeight = this._resizeSliderMobileRectHeight;
                    }
                    var halfSliderWidth = this._resizeSliderWidth / 2;
                    var halfRectWidth = ~~(rectWidth / 2);
                    // actually draw the rectangles and add hitshapes
                    if (shape.direction === 0 /* COLUMN */) {
                        var leftX = ~~(centerX - halfSliderWidth - padding);
                        drawRect(leftX - rectHeight, centerY - halfRectWidth, leftX, centerY + halfRectWidth);
                        var rightX = ~~(centerX + halfSliderWidth + padding);
                        drawRect(rightX + rectHeight, centerY - halfRectWidth, rightX, centerY + halfRectWidth);
                        var wholeWidth = (rightX + rectHeight) - (leftX - rectHeight);
                        var hitRect = new FDSRectangleHitShape(leftX - rectHeight, centerY - halfRectWidth, wholeWidth, rectWidth);
                        hitRect.associatedHitLine = shape;
                        this._hitrects.push(hitRect);
                    }
                    else {
                        var topY = centerY - halfSliderWidth - padding;
                        drawRect(centerX - halfRectWidth, topY - rectHeight, centerX + halfRectWidth, topY);
                        var bottomY = centerY + halfSliderWidth + padding;
                        drawRect(centerX - halfRectWidth, bottomY + rectHeight, centerX + halfRectWidth, bottomY);
                        var wholeHeight = (bottomY + rectHeight) - (topY - rectHeight);
                        var hitRect = new FDSRectangleHitShape(centerX - halfRectWidth, topY - rectHeight, rectWidth, wholeHeight);
                        hitRect.associatedHitLine = shape;
                        this._hitrects.push(hitRect);
                    }
                }
            }
        };
        return PlotResizeManager;
    }());
    
    var PropertyUsageManager = /** @class */ (function () {
        function PropertyUsageManager(chart) {
            this._arePropertiesTracked = false;
            this._chart = chart;
        }
        PropertyUsageManager.prototype._beginPropertyTracking = function () {
            this._arePropertiesTracked = true;
            var usedPropertiesMap = {};
            // this runs through every child and wipes their usedProperties obj
            this._chart.resetUsedProperties();
            // make sure that everything is dirty first
            this._chart.setAllChildrenDirty();
            return usedPropertiesMap;
        };
        PropertyUsageManager.prototype._endPropertyTracking = function (usedProperties) {
            this._getPropertyUsageForAllChartObjects(usedProperties);
            this._arePropertiesTracked = false;
        };
        PropertyUsageManager.prototype.getUsedPropertiesAsync = function (callback) {
            var _this = this;
            var usedPropertiesMap = this._beginPropertyTracking();
            this._chart.postDrawHooks.push(function () {
                _this._endPropertyTracking(usedPropertiesMap);
                callback(usedPropertiesMap);
            });
        };
        PropertyUsageManager.prototype.getUsedProperties = function () {
            var usedPropertiesMap = this._beginPropertyTracking();
            var oldCanvasHandle = this._chart.setCanvasToNOP();
            try {
                this._chart.draw();
            }
            finally {
                oldCanvasHandle.resetCanvas();
            }
            this._endPropertyTracking(usedPropertiesMap);
            return usedPropertiesMap;
        };
        PropertyUsageManager.prototype.getUsedPropertiesFromPropertiesMap = function (propertiesMap) {
            var chart = this._chart;
            this._arePropertiesTracked = true;
            chart.resetUsedProperties();
            var chartObjects = _$1.compact(_$1.keys(propertiesMap).map(function (propertyName) { return chart.getObject(propertyName); }));
            this._sortChartObjectsByAscendingHierarchy(chartObjects);
            var resolvedProperties = {};
            for (var _i = 0, chartObjects_1 = chartObjects; _i < chartObjects_1.length; _i++) {
                var currObject = chartObjects_1[_i];
                var currObjectId = currObject.id;
                for (var _a = 0, _b = propertiesMap[currObjectId]; _a < _b.length; _a++) {
                    var property = _b[_a];
                    var isPropertyAlreadyResolved = (currObjectId in resolvedProperties) &&
                        (property in resolvedProperties[currObjectId]);
                    if (!isPropertyAlreadyResolved) {
                        currObject.getResolvedProperty(property);
                        this._markResolvedProperties(resolvedProperties, currObject);
                    }
                }
            }
            // We don't want the FDSChart, FDSSeries, or FDSAxis objects to call
            // _getPropertyUsageForUnrenderedAttributes() when _getPropertyUsageForAllChartObjects() so
            // we set trackingProperties to false here. If the function is called, we could have
            // duplicated properties in our return map.
            this._arePropertiesTracked = false;
            var usedPropertiesMap = {};
            this._getPropertyUsageForAllChartObjects(usedPropertiesMap);
            return usedPropertiesMap;
        };
        PropertyUsageManager.prototype.isTrackingProperties = function () {
            return this._arePropertiesTracked;
        };
        PropertyUsageManager.prototype._sortChartObjectsByAscendingHierarchy = function (chartObjects) {
            var self = this;
            chartObjects.sort(function (x, y) {
                return self._getChartObjectSortValue(x) - self._getChartObjectSortValue(y);
            });
        };
        PropertyUsageManager.prototype._getChartObjectSortValue = function (chartObject) {
            if (isRootChart(chartObject)) {
                return 5;
            }
            else if (isPlot(chartObject)) {
                return 4;
            }
            else if (isAxis(chartObject)) {
                return 3;
            }
            else if (isSeries(chartObject)) {
                return 2;
            }
            else if (isDataSet(chartObject)) {
                return 1;
            }
            return 0;
        };
        PropertyUsageManager.prototype._markResolvedProperties = function (resolvedPropertiesMap, chartObject) {
            // We need to check every object in the parent chain of the input object for newly
            // resolved properties.
            var chartObjectChain = [];
            var currObject = chartObject;
            while (currObject != null) {
                chartObjectChain.push(currObject);
                currObject = currObject.parent;
            }
            for (var _i = 0, chartObjectChain_1 = chartObjectChain; _i < chartObjectChain_1.length; _i++) {
                currObject = chartObjectChain_1[_i];
                for (var property in currObject.usedProperties) {
                    if (currObject.usedProperties[property] === true) {
                        this._markResolvedPropertyForChartObjects(resolvedPropertiesMap, currObject, chartObjectChain, property);
                    }
                }
            }
        };
        // Mark a given property as used for a given chart object and all chart objects in the chart object chain that is
        // below the chart object.
        PropertyUsageManager.prototype._markResolvedPropertyForChartObjects = function (resolvedPropertiesMap, chartObject, chartObjectChain, property) {
            for (var _i = 0, chartObjectChain_2 = chartObjectChain; _i < chartObjectChain_2.length; _i++) {
                var currObject = chartObjectChain_2[_i];
                if (!(currObject.id in resolvedPropertiesMap)) {
                    resolvedPropertiesMap[currObject.id] = {};
                }
                resolvedPropertiesMap[currObject.id][property] = true;
                if (currObject === chartObject) {
                    break;
                }
            }
        };
        PropertyUsageManager.prototype._getPropertyUsageForAllChartObjects = function (usedPropertiesMap) {
            // iterate and generate the list of stuff
            for (var objectKey in this._chart.children) {
                var object = this._chart.children[objectKey];
                if (!object.isStyleObject) {
                    object.getPropertyUsage(usedPropertiesMap);
                }
            }
            this._chart.getPropertyUsage(usedPropertiesMap); // Needs to be after the other objects in case they add to
            // FDSChart's usedProperties
        };
        return PropertyUsageManager;
    }());
    
    var NullLayerManager = /** @class */ (function (_super) {
        __extends(NullLayerManager, _super);
        function NullLayerManager() {
            return _super.call(this, undefined, function (manager, name) { return new NullLayer(manager, name); }) || this;
        }
        NullLayerManager.prototype.createLayer = function (width, height) {
            return new NullLayer(this);
        };
        NullLayerManager.prototype.flattenLayersToCanvasAsync = function (includeUI) {
            var deferred = $$1.Deferred();
            var canvasLayer = new CanvasLayer(this, this.main.getWidth(), this.main.getHeight());
            deferred.resolve(canvasLayer.canvas);
            return deferred.promise();
        };
        return NullLayerManager;
    }(BaseLayerManager));
    var NullLayer = /** @class */ (function () {
        function NullLayer(layerManager, name) {
            this.name = name;
            this.context = new NullContext(this);
            this.layerManager = layerManager;
        }
        NullLayer.prototype.getWidth = function () {
            return 800;
        };
        NullLayer.prototype.getHeight = function () {
            return 600;
        };
        NullLayer.prototype.setStyle = function (styleOptions) {
        };
        NullLayer.prototype.resize = function (width, height) {
        };
        NullLayer.prototype.hide = function () {
        };
        NullLayer.prototype.show = function () {
        };
        NullLayer.prototype.destroy = function () {
        };
        NullLayer.prototype.addRichTextLink = function (link) {
            this.layerManager.linkContainer.addLinkForLayer(link, this.name);
        };
        NullLayer.prototype.clearRichTextLinks = function () {
            this.layerManager.linkContainer.clearLinksFromLayer(this.name);
        };
        return NullLayer;
    }());
    var NullContext = /** @class */ (function () {
        function NullContext(layer) {
            this.layer = layer;
        }
        NullContext.prototype.getCanvasCtx = function () {
            return null;
        };
        NullContext.prototype.setFont = function (font) {
        };
        NullContext.prototype.setFontFillStyle = function (style) {
        };
        NullContext.prototype.setPen = function (pen) {
        };
        NullContext.prototype.setBrush = function (brush) {
        };
        NullContext.prototype.setBrushFillStyle = function (style) {
        };
        NullContext.prototype.setPenStrokeStyle = function (style, width, dashArray) {
        };
        NullContext.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
        };
        NullContext.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
        };
        NullContext.prototype.closePath = function () {
        };
        NullContext.prototype.ellipse = function (x, y, radiusX, radiusY) {
        };
        NullContext.prototype.lineTo = function (x, y) {
        };
        NullContext.prototype.moveTo = function (x, y) {
        };
        NullContext.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
        };
        NullContext.prototype.rect = function (x, y, w, h) {
        };
        NullContext.prototype.beginPath = function () {
        };
        NullContext.prototype.clear = function () {
            this.layer.clearRichTextLinks();
        };
        NullContext.prototype.clearRect = function (x, y, w, h) {
        };
        NullContext.prototype.clip = function (fillRule) {
        };
        NullContext.prototype.fill = function (fillRule) {
        };
        NullContext.prototype.fillRect = function (x, y, w, h) {
        };
        NullContext.prototype.fillText = function (text, x, y, maxWidth) {
        };
        NullContext.prototype.legacyFillText = function (text, x, y, alignment) {
        };
        NullContext.prototype.measureTextWidth = function (text) {
            return text.length;
        };
        NullContext.prototype.restore = function () {
        };
        NullContext.prototype.rotate = function (angle) {
        };
        NullContext.prototype.save = function () {
        };
        NullContext.prototype.scale = function (x, y) {
        };
        NullContext.prototype.stroke = function () {
        };
        NullContext.prototype.strokeRect = function (x, y, w, h) {
        };
        NullContext.prototype.strokeRectAligned = function (x, y, w, h) {
        };
        NullContext.prototype.strokeRectInternalAligned = function (x, y, w, h) {
        };
        NullContext.prototype.appendHorizontalLineToPath = function (x1, x2, y) {
        };
        NullContext.prototype.appendVerticalLineToPath = function (y1, y2, x) {
        };
        NullContext.prototype.translate = function (x, y) {
        };
        NullContext.prototype.drawImage = function (image, offsetX, offsetY, width, height, alpha) {
        };
        NullContext.prototype.drawLayer = function (layer, offsetX, offsetY) {
        };
        NullContext.prototype.drawLines = function (points) {
        };
        return NullContext;
    }());
    
    var PathBuilder = /** @class */ (function () {
        function PathBuilder() {
            this.beginPath();
        }
        PathBuilder.prototype.clone = function () {
            var cloned = new PathBuilder();
            cloned._currentPath = this._currentPath;
            cloned._startPos = this._startPos.copy();
            cloned._currentPos = this._currentPos.copy();
            cloned._isAxisAligned = this._isAxisAligned;
            return cloned;
        };
        PathBuilder.prototype.getShapeRenderingHint = function () {
            return this._isAxisAligned ? 'crispEdges' : undefined;
        };
        PathBuilder.prototype._appendCommand = function (x, y, command) {
            if (this._currentPath.length === 0) {
                this._isAxisAligned = false;
                this._startPos.x = this._currentPos.x = x;
                this._startPos.y = this._currentPos.y = y;
                if (command.charAt(0) !== 'M') {
                    console.warn('Expected moveto path command');
                    this._currentPath += "M " + x + " " + y;
                }
                else {
                    this._currentPath += command;
                }
            }
            else {
                this._currentPos.x = x;
                this._currentPos.y = y;
                this._currentPath += ' ' + command;
            }
        };
        PathBuilder.prototype.arc = function (x, y, radius, startAngle, endAngle, isCounterClockwise) {
            if (fuzzyEQ(startAngle, endAngle)) {
                return;
            }
            this._isAxisAligned = false;
            var normalizedStartAngle = startAngle % (2 * Math.PI);
            var normalizedEndAngle = endAngle % (2 * Math.PI);
            if (fuzzyEQ(normalizedStartAngle, normalizedEndAngle)) {
                this.ellipse(x, y, radius, radius);
                return;
            }
            var endPt = {
                x: x + radius * Math.cos(endAngle),
                y: y + radius * Math.sin(endAngle),
            };
            var startPt = {
                x: x + radius * Math.cos(startAngle),
                y: y + radius * Math.sin(startAngle),
            };
            var sweep = endAngle - startAngle;
            // Bring things back into the 0 - 2PI range
            if (sweep < 0) {
                sweep += 2 * Math.PI;
            }
            var isLargeSweep = sweep > Math.PI;
            var largeArc = (isLargeSweep !== isCounterClockwise) ? 1 : 0;
            var sweepDirection = isCounterClockwise ? 0 : 1;
            // We need to get to the start position. If there is already a path, we will line-to there
            // If there isn't an existing path, we need to move-to instead.
            if (this._currentPath.length === 0) {
                this.moveTo(startPt.x, startPt.y);
            }
            else {
                this.lineTo(startPt.x, startPt.y);
            }
            // Now we add the arc command to the path.
            this._appendCommand(endPt.x, endPt.y, "A " + radius + " " + radius + " " + 0 + " " + largeArc + " " + sweepDirection + " " + endPt.x + " " + endPt.y);
        };
        PathBuilder.prototype.beginPath = function () {
            this._isAxisAligned = false;
            this._currentPath = '';
            this._currentPos = new Point(0, 0);
            this._startPos = new Point(0, 0);
        };
        PathBuilder.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            this._isAxisAligned = false;
            this._appendCommand(x, y, "C " + cp1x + " " + cp1y + " " + cp2x + " " + cp2y + " " + x + " " + y);
        };
        PathBuilder.prototype.closePath = function () {
            if (this._currentPath.length > 0) {
                this._currentPath += ' Z';
                this._isAxisAligned = fuzzyEQ(this._currentPos.x, this._startPos.x) ||
                    fuzzyEQ(this._currentPos.y, this._startPos.y);
                this._currentPos.x = this._startPos.x;
                this._currentPos.y = this._startPos.y;
            }
        };
        PathBuilder.prototype.ellipse = function (x, y, radiusX, radiusY) {
            this._isAxisAligned = false;
            var command = "M " + (x - radiusX) + " " + y + " a " + radiusX + " " + radiusY + " 0 1 0 " + 2 *
                radiusX + " 0 a " + radiusX + " " + radiusY + " 0 1 0 " + -2 *
                radiusX + " 0";
            this._appendCommand(x, y, command);
        };
        PathBuilder.prototype.moveTo = function (x, y) {
            this._appendCommand(x, y, "M " + x + " " + y);
        };
        PathBuilder.prototype.lineTo = function (x, y) {
            this._isAxisAligned = fuzzyEQ(this._currentPos.x, x) || fuzzyEQ(this._currentPos.y, y);
            this._appendCommand(x, y, "L " + x + " " + y);
        };
        PathBuilder.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            this._isAxisAligned = false;
            this._appendCommand(x, y, "Q " + cpx + " " + cpy + " " + x + " " + y);
        };
        PathBuilder.prototype.toString = function () {
            return this._currentPath;
        };
        return PathBuilder;
    }());
    function setAttributes(element, properties) {
        _$1.forOwn(properties, function (value, key) {
            if (value !== undefined) {
                element.setAttribute(key, value.toString());
            }
        });
    }
    function rect(x, y, width, height, options) {
        if (width < 0) {
            width = -width;
            x -= width;
        }
        if (height < 0) {
            height = -height;
            y -= height;
        }
        return create('rect', __assign({ x: x, y: y, width: width, height: height }, options));
    }
    function gradientStop(offset, color, opacity) {
        return create('stop', {
            'stop-color': color,
            'offset': offset,
            'stop-opacity': opacity,
        });
    }
    function clipPath(id, d) {
        var clipPath = create('clipPath', { id: id });
        clipPath.appendChild(path(d));
        return clipPath;
    }
    function linearGradient(x1, y1, x2, y2) {
        return create('linearGradient', {
            id: _$1.uniqueId('LGRAD'),
            x1: x1 + 'px',
            y1: y1 + 'px',
            x2: x2 + 'px',
            y2: y2 + 'px',
            gradientUnits: 'userSpaceOnUse'
        });
    }
    function radialGradient(x1, y1, r1, x2, y2, r2) {
        return create('radialGradient', {
            id: _$1.uniqueId('RGRAD'),
            cx: x2 + 'px',
            cy: y2 + 'px',
            r: r2 + 'px',
            fx: x1 + 'px',
            fy: y1 + 'px',
            gradientUnits: 'userSpaceOnUse'
        });
    }
    function getTextAnchor(textAlign) {
        // TODO: support rtl languages
        var mapping = { 'left': 'start', 'right': 'end', 'center': 'middle' };
        return _$1.get(mapping, textAlign);
    }
    function text(str, x, y, fill$$1, align, opacity) {
        if (opacity === void 0) { opacity = 1; }
        var node = create('text', {
            x: x,
            y: y,
            fill: fill$$1,
            'fill-opacity': opacity,
            stroke: 'none',
            'text-align': getTextAnchor(align),
        });
        node.appendChild(document.createTextNode(str));
        return node;
    }
    function g(options) {
        return create('g', options);
    }
    function line(x1, y1, x2, y2, options) {
        return create('line', __assign({ x1: x1, y1: y1, x2: x2, y2: y2 }, options));
    }
    function path(d, options) {
        return create('path', __assign({ d: d }, options));
    }
    function pattern(options) {
        return create('pattern', __assign({ id: _$1.uniqueId('PATTERN'), patternUnits: 'userSpaceOnUse' }, options));
    }
    function svg() {
        return create('svg', {
            version: 1.1,
            xmlns: 'http://www.w3.org/2000/svg'
        });
    }
    function create(elementName, properties, resetFill) {
        if (properties === void 0) { properties = {}; }
        if (resetFill === void 0) { resetFill = false; }
        var element = document.createElementNS('http://www.w3.org/2000/svg', elementName);
        setAttributes(element, properties);
        return element;
    }
    
    var SvgLayerManager = /** @class */ (function (_super) {
        __extends(SvgLayerManager, _super);
        function SvgLayerManager(container) {
            var _this = 
            // Explaining the nonsense below... You can't reference `this` before the call to super() returns.
            // This is sometimes a pain for features like `readonly` because they need to be assigned before
            // the constructor is over, and can't be assigned otherwise.
            _super.call(this, container, function (realThis, name) {
                return new SvgLayer(realThis, realThis._svgRoot, realThis._defs, name);
            }, function (realThis) {
                realThis._svgRoot = svg();
                realThis._defs = create('defs');
                realThis._svgRoot.appendChild(realThis._defs);
            }) || this;
            _this._links = new SvgLayer(_this, _this._svgRoot, _this._defs, 'links');
            _this._svgRoot.style.position = 'absolute';
            // Disable pointer events so that they fall through to the container div instead.
            // Otherwise you can run into issues with double click events not firing because
            // of intermediate renders between clicks when the svg node you clicked on changes
            _this._svgRoot.style.pointerEvents = 'none';
            _this._svgRoot.style.left = _this._svgRoot.style.top = '0px';
            container.appendChild(_this._svgRoot);
            return _this;
        }
        SvgLayerManager.prototype.cloneSvgRoot = function () {
            return this._svgRoot.cloneNode(true);
        };
        SvgLayerManager.prototype.createLayer = function (width, height) {
            return new SvgLayer(this, width, height);
        };
        SvgLayerManager.prototype.flattenLayersToCanvasAsync = function (includeUI) {
            var deferred = $.Deferred();
            var serializer = new XMLSerializer();
            if (!includeUI) {
                this.ui.hide();
            }
            var svgString = serializer.serializeToString(this._svgRoot);
            if (!includeUI) {
                this.ui.show();
            }
            var img = new Image();
            img.width = this.main.getWidth();
            img.height = this.main.getHeight();
            var outCanvas = new CanvasLayer(this, this.main.getWidth(), this.main.getHeight());
            img.onload = function () {
                outCanvas.context.drawImage(img, 0, 0, img.width, img.height, 1);
                deferred.resolve(outCanvas.canvas);
            };
            img.src = 'data:image/svg+xml;utf8,' + svgString;
            return deferred.promise();
        };
        SvgLayerManager.prototype.destroy = function () {
            this._container.removeChild(this._svgRoot);
            this._svgRoot = null;
            _super.prototype.destroy.call(this);
        };
        return SvgLayerManager;
    }(BaseLayerManager));
    var SvgLayer = /** @class */ (function () {
        function SvgLayer(layerManager, containerOrWidth, defsOrHeight, name) {
            this.linkContainer = new RichTextLinkContainer();
            this._width = 0;
            this._height = 0;
            this.name = name;
            this.layerManager = layerManager;
            if (_$1.isObject(containerOrWidth) && _$1.isObject(defsOrHeight)) {
                this._svgRoot = containerOrWidth;
                this.defs = g();
                defsOrHeight.appendChild(this.defs);
            }
            else {
                var root = svg();
                this.defs = create('defs');
                root.appendChild(this.defs);
                this._svgRoot = root;
            }
            if (_$1.isNumber(containerOrWidth) && _$1.isNumber(defsOrHeight)) {
                var width = containerOrWidth;
                var height = defsOrHeight;
                this.resize(width, height);
            }
            this.content = g({
                'line-miter': 4
            });
            this._svgRoot.appendChild(this.content);
            this.context = new SvgContext(this);
        }
        SvgLayer.prototype.getWidth = function () {
            return this._width;
        };
        SvgLayer.prototype.getHeight = function () {
            return this._height;
        };
        SvgLayer.prototype.destroy = function () {
        };
        SvgLayer.prototype.addRichTextLink = function (link) {
            this.layerManager.linkContainer.addLinkForLayer(link, this.name);
        };
        SvgLayer.prototype.clearRichTextLinks = function () {
            this.layerManager.linkContainer.clearLinksFromLayer(this.name);
        };
        SvgLayer.prototype.setStyle = function (styleOptions) {
            _$1.assign(this.content.style, styleOptions);
        };
        SvgLayer.prototype.resize = function (width, height) {
            if (width !== this._width || height !== this._height) {
                if (this.context) {
                    this.context.clear();
                }
                setAttributes(this._svgRoot, {
                    width: scaleByDevicePixelRatioInverse(width),
                    height: scaleByDevicePixelRatioInverse(height),
                    viewBox: "0 0 " + width + " " + height
                });
                this._width = width;
                this._height = height;
            }
        };
        SvgLayer.prototype.hide = function () {
            this.content.style.display = 'none';
        };
        SvgLayer.prototype.show = function () {
            this.content.style.display = '';
        };
        return SvgLayer;
    }());
    var SvgContext = /** @class */ (function () {
        function SvgContext(layer) {
            this.layer = layer;
            this._saveStack = [];
            this._pathBuilder = new PathBuilder();
            this._translation = { x: 0, y: 0 };
            this._currentStyle = { stroke: 'none', fill: 'none', 'stroke-width': 1, 'stroke-dasharray': 'none' };
            this._fontFillStyle = 'black';
            this._canvas = document.createElement('canvas');
            this._canvasCtx = this._canvas.getContext('2d');
            this.clear();
        }
        SvgContext.prototype._setNewTransform = function (transform) {
            var group = g({ transform: transform });
            this._currentTransform = this._currentGroup.appendChild(group);
            this._setNewStyle(this._currentStyle, true);
        };
        SvgContext.prototype._setNewStyle = function (style, force) {
            if (force === void 0) { force = false; }
            var newStyle = __assign({}, this._currentStyle, style);
            var group = g(newStyle);
            this._currentTransform.appendChild(group);
            this._currentGroup = group;
            this._currentStyle = newStyle;
        };
        SvgContext.prototype.getCanvasCtx = function () {
            return null;
        };
        SvgContext.prototype.setFont = function (fontObj) {
            var _a = fontObj.toPropertyObject(), fillStyle = _a.fillStyle, font = _a.font;
            this._canvasCtx.font = font;
            this._fontFillStyle = fillStyle;
            this._setNewStyle({
                'font-family': fontObj.family,
                'font-size': fontObj.getHeight(),
                'font-weight': FDSFont.convertFontWeightToCSS(fontObj.weight),
                'font-style': fontObj.italic ? 'italic' : 'normal',
            });
        };
        SvgContext.prototype.setFontFillStyle = function (style) {
            this._fontFillStyle = style;
        };
        SvgContext.prototype.setPen = function (pen) {
            pen.closePolyline();
            var props = pen.toPropertyObject();
            this._aliasOffset = props.aliasOffset;
            this._lineWidth = props.lineWidth;
            this._setNewStyle({
                'stroke': props.willDrawStroke ? props.color : 'none',
                'stroke-width': props.lineWidth,
                'stroke-dasharray': this._dashArrayToCssString(pen.getDashArray()),
            });
        };
        SvgContext.prototype.setPenStrokeStyle = function (style, lineWidth, dashArray) {
            this._setNewStyle({
                stroke: style,
                'stroke-width': lineWidth,
                'stroke-dasharray': this._dashArrayToCssString(dashArray),
            });
        };
        SvgContext.prototype._dashArrayToCssString = function (dashArray) {
            return dashArray.length > 0 ? dashArray.join(' ') : 'none';
        };
        SvgContext.prototype.setBrush = function (brush, rect$$1) {
            var fillStyleStr = 'none';
            var opacity = undefined;
            if (brush.style !== 1 /* NULL */) {
                var fillStyle = brush.toPropertyObject(this, rect$$1).fillStyle;
                if (fillStyle.brushType === 'solid') {
                    fillStyleStr = COLORREFtoHex(fillStyle.color);
                    opacity = alphaToOpacity(fillStyle.alpha);
                }
                else {
                    var def = void 0;
                    if (fillStyle.brushType === 'linearGradient') {
                        def = this._createLinearGradient(fillStyle.x1, fillStyle.y1, fillStyle.x2, fillStyle.y2, fillStyle.stops);
                    }
                    else if (fillStyle.brushType === 'radialGradient') {
                        def = this._createRadialGradient(fillStyle.x1, fillStyle.y1, fillStyle.r1, fillStyle.x2, fillStyle.y2, fillStyle.r2, fillStyle.stops);
                    }
                    else if (fillStyle.brushType === 'pattern') {
                        def = this._createHatchPattern(brush.color);
                    }
                    if (def) {
                        fillStyleStr = "url(#" + def.id + ")";
                    }
                }
            }
            this._setNewStyle({
                'fill': fillStyleStr,
                'fill-opacity': opacity
            });
        };
        SvgContext.prototype.setBrushFillStyle = function (style) {
            this._setNewStyle({ fill: style });
        };
        SvgContext.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
            this._pathBuilder.arc(x, y, radius, startAngle, endAngle, anticlockwise);
        };
        SvgContext.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            this._pathBuilder.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        };
        SvgContext.prototype.closePath = function () {
            this._pathBuilder.closePath();
        };
        SvgContext.prototype.ellipse = function (x, y, radiusX, radiusY) {
            if (radiusY === void 0) { radiusY = radiusX; }
            this._pathBuilder.ellipse(x, y, radiusX, radiusY);
        };
        SvgContext.prototype.lineTo = function (x, y) {
            this._pathBuilder.lineTo(x, y);
        };
        SvgContext.prototype.moveTo = function (x, y) {
            this._pathBuilder.moveTo(x, y);
        };
        SvgContext.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            this._pathBuilder.quadraticCurveTo(cpx, cpy, x, y);
        };
        SvgContext.prototype.rect = function (x, y, w, h) {
            this.moveTo(x, y);
            this.lineTo(x + w, y);
            this.lineTo(x + w, y + h);
            this.lineTo(x, y + h);
            this.closePath();
        };
        SvgContext.prototype.beginPath = function () {
            this._pathBuilder.beginPath();
        };
        SvgContext.prototype.clear = function () {
            this._pathBuilder.beginPath();
            this.layer.clearRichTextLinks();
            var content = this.layer.content;
            while (content.firstChild) {
                content.removeChild(content.firstChild);
            }
            var defs = this.layer.defs;
            while (defs.firstChild) {
                defs.removeChild(defs.firstChild);
            }
            this._currentStyle = { stroke: 'none', fill: 'none', 'stroke-width': 1, 'stroke-dasharray': 'none' };
            this._currentTransform = g();
            this._currentGroup = g({
                stroke: 'none',
                fill: 'none',
                'stroke-width': 1,
            });
            this._currentTransform.appendChild(this._currentGroup);
            this.layer.content.appendChild(this._currentTransform);
        };
        SvgContext.prototype.clearRect = function (x, y, w, h) {
            // Intentionally blank at the moment.
            // Clearing part of the document is complicated in Svg, and we only call clearRect
            // In an isolated place that may or may not even be necessary. Longer term, I would
            // be more inclined to remove this function than from the ChartRenderingContext then
            // to implement this method in Svg.
            // -AH
        };
        SvgContext.prototype.clip = function (fillRule) {
            var pathData = this._pathBuilder.toString();
            if (pathData) {
                var clipId = _$1.uniqueId('CLIP');
                var clipPath$$1 = clipPath(clipId, pathData);
                this.layer.defs.appendChild(clipPath$$1);
                // set the clip path to this group
                var newGroup = g({ 'clip-path': "url(#" + clipId + ")" });
                this._currentTransform.appendChild(newGroup);
                this._currentTransform = newGroup;
                this._currentGroup = newGroup;
            }
        };
        SvgContext.prototype._createLinearGradient = function (x1, y1, x2, y2, stops) {
            var gradientNode = linearGradient(x1, y1, x2, y2);
            this.layer.defs.appendChild(gradientNode);
            for (var _i = 0, stops_1 = stops; _i < stops_1.length; _i++) {
                var _a = stops_1[_i], offset = _a.offset, color = _a.color, alpha = _a.alpha;
                var colorHex = COLORREFtoHex(color);
                var opacity = alphaToOpacity(alpha);
                gradientNode.appendChild(gradientStop(offset, colorHex, opacity));
            }
            return gradientNode;
        };
        SvgContext.prototype._createHatchPattern = function (fgColor) {
            var width = scaleByDevicePixelRatio(4 * Math.SQRT2);
            var pattern$$1 = pattern({ x: 0, y: 0, width: width, height: width, patternTransform: 'rotate(45 0 0)' });
            pattern$$1.appendChild(line(0, 0, 0, width, { stroke: COLORREFtoHex(fgColor), 'stroke-width': getDevicePixelRatio(), 'shape-rendering': 'crispEdges' }));
            this.layer.defs.appendChild(pattern$$1);
            return pattern$$1; // TODO: not this
        };
        SvgContext.prototype._createRadialGradient = function (x1, y1, r1, x2, y2, r2, stops) {
            var gradientNode = radialGradient(x1, y1, r1, x2, y2, r2);
            this.layer.defs.appendChild(gradientNode);
            for (var _i = 0, stops_2 = stops; _i < stops_2.length; _i++) {
                var _a = stops_2[_i], offset = _a.offset, color = _a.color, alpha = _a.alpha;
                var colorHex = COLORREFtoHex(color);
                var opacity = alphaToOpacity(alpha);
                gradientNode.appendChild(gradientStop(offset, colorHex, opacity));
            }
            return gradientNode;
        };
        SvgContext.prototype.fill = function (fillRule) {
            var pathData = this._pathBuilder.toString();
            if (pathData) {
                var shapeRendering = this._pathBuilder.getShapeRenderingHint();
                var pathNode = path(pathData, { stroke: 'none', 'shape-rendering': shapeRendering });
                this._currentGroup.appendChild(pathNode);
            }
        };
        SvgContext.prototype.fillRect = function (x, y, w, h) {
            this._currentGroup.appendChild(rect(x, y, w, h, { stroke: 'none', 'shape-rendering': 'crispEdges' }));
        };
        SvgContext.prototype.fillText = function (text$$1, x, y) {
            this._currentGroup.appendChild(text(text$$1, x, y, this._fontFillStyle));
        };
        SvgContext.prototype.legacyFillText = function (text$$1, x, y, align) {
            this._currentGroup.appendChild(text(text$$1, x, y, this._fontFillStyle, align));
        };
        SvgContext.prototype.measureTextWidth = function (text$$1) {
            return Math.ceil(this._canvasCtx.measureText(text$$1).width);
        };
        SvgContext.prototype.restore = function () {
            this._canvasCtx.restore();
            var prev = this._saveStack.pop();
            if (prev) {
                this._currentTransform = prev.transform;
                this._currentGroup = prev.group;
                this._currentStyle = __assign({}, prev.style);
                this._pathBuilder = prev.pathBuilder;
                this._aliasOffset = prev.aliasOffset;
                this._lineWidth = prev.lineWidth;
            }
            else {
                console.warn('too many context restores');
            }
        };
        SvgContext.prototype.rotate = function (angle) {
            if (angle !== 0) {
                this._setNewTransform("rotate(" + angle * 180 / Math.PI + ")");
            }
        };
        SvgContext.prototype.save = function () {
            this._canvasCtx.save();
            this._saveStack.push({
                aliasOffset: this._aliasOffset,
                lineWidth: this._lineWidth,
                group: this._currentGroup,
                style: __assign({}, this._currentStyle),
                transform: this._currentTransform,
                pathBuilder: this._pathBuilder,
            });
            this._pathBuilder = this._pathBuilder.clone();
            this._currentTransform = this._currentGroup;
            var newGroup = g();
            this._currentGroup.appendChild(newGroup);
            this._currentGroup = newGroup;
        };
        SvgContext.prototype.scale = function (x, y) {
            if (x !== 1 || y !== 1) {
                this._setNewTransform("scale(" + x + ", " + y + ")");
            }
        };
        SvgContext.prototype.stroke = function () {
            var pathData = this._pathBuilder.toString();
            if (pathData) {
                var shapeRendering = this._pathBuilder.getShapeRenderingHint();
                var pathNode = path(pathData, { fill: 'none', 'shape-rendering': shapeRendering });
                this._currentGroup.appendChild(pathNode);
            }
        };
        SvgContext.prototype.strokeRect = function (x, y, w, h) {
            this._currentGroup.appendChild(rect(x, y, w, h, { fill: 'none', 'shape-rendering': 'crispEdges' }));
        };
        SvgContext.prototype.strokeRectAligned = function (x, y, w, h) {
            this.strokeRect(~~x + this._aliasOffset, ~~y + this._aliasOffset, ~~w, ~~h);
        };
        SvgContext.prototype.strokeRectInternalAligned = function (x, y, w, h) {
            var lineWidth = this._lineWidth;
            var halfStroke = ~~(lineWidth / 2);
            this.strokeRectAligned(~~x + halfStroke, ~~y + halfStroke, ~~w - lineWidth, ~~h - lineWidth);
        };
        SvgContext.prototype.appendHorizontalLineToPath = function (x1, x2, y) {
            var offsetY = ~~y + this._aliasOffset;
            this.moveTo(~~x1, offsetY);
            this.lineTo(~~x2, offsetY);
        };
        SvgContext.prototype.appendVerticalLineToPath = function (y1, y2, x) {
            var offsetX = x + this._aliasOffset;
            this.moveTo(offsetX, ~~y1);
            this.lineTo(offsetX, ~~y2);
        };
        SvgContext.prototype.translate = function (x, y) {
            this._translation.x += x;
            this._translation.y += y;
            if (x !== 0 || y !== 0) {
                this._setNewTransform("translate(" + x + ", " + y + ")");
            }
        };
        SvgContext.prototype.drawImage = function (image, offsetX, offsetY, width, height) {
        };
        SvgContext.prototype.drawLayer = function (layer, offsetX, offsetY) {
            if (offsetX === void 0) { offsetX = 0; }
            if (offsetY === void 0) { offsetY = 0; }
            // Copy defs from the source layer.
            if (layer.defs !== this.layer.defs) {
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < layer.defs.childNodes.length; i++) {
                    this.layer.defs.appendChild(layer.defs.childNodes[i].cloneNode(true));
                }
            }
            // Clone the content and offset it with a transform
            var clonedContent = g({ transform: "translate(" + offsetX + ", " + offsetY + ")" });
            clonedContent.appendChild(layer.content.cloneNode(true));
            this.layer.content.appendChild(clonedContent);
            this._currentGroup = g(this._currentStyle);
            this.layer.content.appendChild(this._currentGroup);
        };
        SvgContext.prototype.drawLines = function (points, isClosed) {
            if (isClosed === void 0) { isClosed = false; }
            if (points.length < 2) {
                return;
            }
            this._pathBuilder.beginPath();
            this._pathBuilder.moveTo(points[0].x, points[0].y);
            for (var i = 1; i < points.length; i++) {
                var _a = points[i], x = _a.x, y = _a.y;
                this._pathBuilder.lineTo(x, y);
            }
            if (isClosed) {
                this._pathBuilder.closePath();
            }
            var pathNode = path(this._pathBuilder.toString(), {
                fill: 'none',
                'shape-rendering': this._pathBuilder.getShapeRenderingHint(),
            });
            this._currentGroup.appendChild(pathNode);
        };
        return SvgContext;
    }());
    function alphaToOpacity(alpha) {
        if (alpha >= 255) {
            return 1;
        }
        else if (alpha > 0) {
            return alpha / 255;
        }
        else {
            return 0;
        }
    }
    
    var StyleSetDocServiceManager = /** @class */ (function () {
        function StyleSetDocServiceManager() {
            this._stylesetDocServiceUrl = '/services/styleset-document-service';
            this._semver = new Version().semver;
        }
        StyleSetDocServiceManager.prototype.getStyleSet = function (path) {
            var encodedPath = this._encodePath(path);
            return $$1.ajax({
                type: 'GET',
                url: this._stylesetDocServiceUrl + "/styleset/" + encodedPath + "?fdschartjs-version=" + this._semver
            });
        };
        StyleSetDocServiceManager.prototype.postStyleSet = function (newStyleSet, path) {
            var encodedPath = this._encodePath(path);
            var newData = JSON.stringify({ document: newStyleSet });
            return $$1.ajax({
                data: newData,
                dataType: 'json',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': newData.length
                },
                type: 'POST',
                url: this._stylesetDocServiceUrl + "/styleset/" + encodedPath + "?fdschartjs-version=" + this._semver
            });
        };
        StyleSetDocServiceManager.prototype.putStyleSet = function (newStyleSet, path) {
            var encodedPath = this._encodePath(path);
            var newData = JSON.stringify({ document: newStyleSet });
            return $$1.ajax({
                data: newData,
                dataType: 'json',
                headers: {
                    'Content-Type': 'application/json',
                    'Content-Length': newData.length
                },
                type: 'PUT',
                url: this._stylesetDocServiceUrl + "/styleset/" + encodedPath + "?fdschartjs-version=" + this._semver
            });
        };
        StyleSetDocServiceManager.prototype.deleteStyleSet = function (path) {
            var encodedPath = this._encodePath(path);
            return $$1.ajax({
                type: 'DELETE',
                url: this._stylesetDocServiceUrl + "/styleset/" + encodedPath + "?fdschartjs-version=" + this._semver
            });
        };
        StyleSetDocServiceManager.prototype._encodePath = function (path) {
            if (path.charAt(0) !== '/') {
                path = '/' + path;
                console.warn('Styleset paths should begin with "/"');
            }
            return encodeURIComponent(path);
        };
        return StyleSetDocServiceManager;
    }());
    
    var StyleSetCache = /** @class */ (function () {
        function StyleSetCache() {
        }
        StyleSetCache.getStyleSetAsync = function (path, skipCache) {
            if (_$1.has(StyleSetCache._cache, path) && !skipCache) {
                return StyleSetCache._cache[path];
            }
            var styleSetPromise = StyleSetCache._fetcher.getStyleSet(path).done(function (data) {
                return data;
            });
            styleSetPromise.done(function () {
                StyleSetCache._cache[path] = styleSetPromise;
            }).fail(function () {
                delete StyleSetCache._cache[path];
            });
            return styleSetPromise;
        };
        StyleSetCache._cache = {};
        StyleSetCache._fetcher = new StyleSetDocServiceManager();
        return StyleSetCache;
    }());
    
    var ExternalInfoboxSubscription = /** @class */ (function () {
        function ExternalInfoboxSubscription() {
            this.useInfoboxes = false;
        }
        ExternalInfoboxSubscription.prototype.subscribeToInfobox = function (callback) {
            this._callback = callback;
        };
        ExternalInfoboxSubscription.prototype.onInfoboxChange = function (options) {
            if (this._callback) {
                this._callback(options);
            }
        };
        ExternalInfoboxSubscription.prototype.unsubscribeFromInfobox = function (callback) {
            if (this._callback === callback) {
                this._callback = undefined;
            }
        };
        return ExternalInfoboxSubscription;
    }());
    
    var FDSInfoboxClickTooltip = /** @class */ (function () {
        function FDSInfoboxClickTooltip(annotationsInfoboxAttributes, ctx) {
            this._infobox = new FDSInfoBox(ctx);
            this._infobox.setStyle(2 /* CG_CALLOUT */, ctx);
            this._annotationsInfoboxAttributes = annotationsInfoboxAttributes;
        }
        FDSInfoboxClickTooltip.prototype.displayTooltipForSeries = function (series, index, arrowPoint, infoboxPosition) {
            var uiCtx = series.root.getUIContext();
            // set up the tooltip with the text
            this._infobox.update({
                text: series.getTooltipLabel(index),
                font: this._annotationsInfoboxAttributes.annotationTooltipFont,
                BGBrush: this._annotationsInfoboxAttributes.annotationTooltipBGBrush
            }, uiCtx);
            // now add in a tail (height based on box width) so we can compute the total height
            // one twentieth the width seems like a good height
            this._infobox.update({
                arrowY: 0,
                y: this._infobox.width / 20
            }, uiCtx);
            // get the tooltip size including the tail
            var _a = this._infobox.computeWidthAndHeight(uiCtx, true), w = _a[0], h = _a[1];
            // find the parent plot (this series' parent might be another series)
            var parent = series.getPlotParent();
            // find a good x position for the tooltip
            var boxX = clamp(arrowPoint.x - (w / 2), parent.plotRect.x1, parent.plotRect.x2 - w);
            // find a good y position - first try putting it above
            var boxY = arrowPoint.y - h;
            if (boxY < parent.plotRect.y1) {
                // that failed - try putting it below
                boxY = (arrowPoint.y + h) - this._infobox.height;
                if (boxY > parent.plotRect.y2 - h) {
                    // that failed too - give up and just put it on top of the data point
                    boxY = clamp(arrowPoint.y, parent.plotRect.y1, parent.plotRect.y2 - h);
                }
            }
            this._infobox.update({
                x: boxX,
                y: boxY,
                arrowX: arrowPoint.x,
                arrowY: arrowPoint.y,
                visible: true
            }, uiCtx);
        };
        FDSInfoboxClickTooltip.prototype.hideTooltip = function () {
        };
        return FDSInfoboxClickTooltip;
    }());
    
    var ExternalClickTooltip = /** @class */ (function () {
        function ExternalClickTooltip(infoboxInteraction) {
            this._infoboxInteraction = infoboxInteraction;
        }
        ExternalClickTooltip.prototype.displayTooltipForSeries = function (series, index, arrowPoint, infoboxPosition) {
            this._infoboxInteraction.onInfoboxChange({
                type: 'show',
                location: series.root.minimumSizeManager.scalePoint(arrowPoint),
                chartObjectId: series.id,
                subObject: index,
                preferredInfoboxPosition: infoboxPosition,
            });
        };
        ExternalClickTooltip.prototype.hideTooltip = function () {
            this._infoboxInteraction.onInfoboxChange({ type: 'hide' });
        };
        return ExternalClickTooltip;
    }());
    
    var ClickTooltip = /** @class */ (function () {
        function ClickTooltip(useExternalInfoboxes, ctx) {
            this.externalInfoboxSubscription = new ExternalInfoboxSubscription();
            this._annotationsInfoboxAttributes = {
                annotationTooltipBGBrush: new FDSBrush(),
                annotationTooltipFont: new FDSFont({ widthHint: 32000 })
            };
            this._clickTooltipRenderer = this._getClickTooltipRenderer(useExternalInfoboxes, ctx);
            this._annotationsInfoboxAttributes.annotationTooltipBGBrush.style = 0 /* SOLID */;
            this._annotationsInfoboxAttributes.annotationTooltipBGBrush.color = 16777215 /* WHITE */;
        }
        ClickTooltip.prototype._getClickTooltipRenderer = function (useExternalInfoboxes, ctx) {
            if (useExternalInfoboxes) {
                return new ExternalClickTooltip(this.externalInfoboxSubscription);
            }
            else {
                return new FDSInfoboxClickTooltip(this._annotationsInfoboxAttributes, ctx);
            }
        };
        ClickTooltip.prototype.setUseExternalInfoboxes = function (useExternalInfoboxes, attributeSet, ctx) {
            this._clickTooltipRenderer.hideTooltip();
            this._clickTooltipRenderer = this._getClickTooltipRenderer(useExternalInfoboxes, ctx);
            this.syncMembers(attributeSet);
        };
        ClickTooltip.prototype.syncMembers = function (attributeSet) {
            this._annotationsInfoboxAttributes.annotationTooltipBGBrush.constructFromAttributes(attributeSet, 'ClickTooltipBG');
            this._annotationsInfoboxAttributes.annotationTooltipFont = FDSFont.constructFromAttributes(attributeSet, 'ClickTooltipFont');
        };
        ClickTooltip.prototype.setAttributes = function (attributeSet) {
            this._annotationsInfoboxAttributes.annotationTooltipBGBrush.writeToAttrSet(attributeSet, 'ClickTooltipBG');
            this._annotationsInfoboxAttributes.annotationTooltipFont.writeToAttrSet(attributeSet, 'ClickTooltipFont');
        };
        ClickTooltip.prototype.hideTooltip = function () {
            this._clickTooltipRenderer.hideTooltip();
        };
        ClickTooltip.prototype.displayTooltipForSeries = function (series, index, arrowPoint, infoboxPosition) {
            this._clickTooltipRenderer.displayTooltipForSeries(series, index, arrowPoint, infoboxPosition);
        };
        return ClickTooltip;
    }());
    
    var FDSChart = /** @class */ (function (_super) {
        __extends(FDSChart, _super);
        function FDSChart(containingElement, options, wrapper) {
            var _this = _super.call(this, null, 'FC_CHART', 7 /* FC_ROOT */, { containingElement: containingElement, options: options, wrapper: wrapper }) || this;
            _this.animationManager = new AnimationManager(function () {
                _this.draw();
            });
            _this._version = new Version().version;
            _this._invalidateHandle = null;
            _this._tooltipMap = {
                'Trendline': 'Trendline',
                'FibArc': 'Fibonacci Arc',
                'FibFan': 'Fibonacci Fan',
                'SpeedResistance': 'Speed Resistance Levels',
                'FibRetracements': 'Fibonacci Retracements',
                'FibProjection': 'Fibonacci Projection',
                'FibTimeZones': 'Fibonacci Time Zones',
                'GannFan': 'Gann Fan',
                'PriceChange': 'Change Over Range',
                'Arrow': 'Arrow',
                'Circle': 'Circle',
                'Rect': 'Rectangle',
                'LinearRegression': 'Linear Regression',
                'Average': 'Average',
                'Median': 'Median',
                'AvgStdDev': 'Average and Standard Deviation',
                'QuadrantLines': 'Quadrant Lines',
                'TironeLevels': 'Tirone Levels',
                'RaffRegression': 'Raff Regression',
                'ZigZag': 'Zig Zag',
                'SeriesTextbox': 'Series Textbox',
                'Marker': 'Draggable Marker',
                'HarmonicMean': 'Harmonic Mean',
            };
            _this.applicationName = options['appName'];
            return _this;
        }
        // Resolves `id` to a chart object. If `id` is a string, the object with that
        // key is returned. If `id` is the object itself, the operation is a no-op.
        // If `id` is a string and is empty, the object is the root chart.
        FDSChart.prototype._resolveToChartObject = function (id) {
            if (typeof id === 'string') {
                if (id.length === 0 || id === 'FC_CHART') {
                    return this;
                }
                else {
                    return this.objects[id] || this._styleObjects[id];
                }
            }
            else if (id instanceof FDSChartObject) {
                return id;
            }
            else {
                return undefined;
            }
        };
        FDSChart.prototype.setRenderingMode = function (mode) {
            if (mode !== this._renderingMode) {
                this._renderingMode = mode;
                this._destroyRenderingLayers();
                this._setupRenderLayerManager();
                this._setupBlankCanvas();
                _$1.forIn(this.objects, function (obj) { return obj.clearRenderCache(); });
                this.invalidate();
                return true;
            }
            return false;
        };
        FDSChart.prototype.createRenderingLayer = function (width, height) {
            return this._renderLayerManager.createLayer(width, height);
        };
        FDSChart.prototype._init = function (args) {
            this.root = this;
            this._defMapID = 'DEF_CHART';
            if (args) {
                this._handleContextMenu = this._handleContextMenu.bind(this);
                this._handleKeyDown = this._handleKeyDown.bind(this);
                this._handleKeyUp = this._handleKeyUp.bind(this);
                this._handleTouchStart = this._handleTouchStart.bind(this);
                this._dispatchPointerHandler = this._dispatchPointerHandler.bind(this);
                this._handlePointerUp = this._handlePointerUp.bind(this);
                this._handleMouseMove = this._handleMouseMove.bind(this);
                this._handleMouseOver = this._handleMouseOver.bind(this);
                this._handleMouseOut = this._handleMouseOut.bind(this);
                this._handleTouchEnd = this._handleTouchEnd.bind(this);
                this._tapTimeout = this._tapTimeout.bind(this);
                this._handleTouchMove = this._handleTouchMove.bind(this);
                this._handlePointerMove = this._handlePointerMove.bind(this);
                this._handleDoubleClick = this._handleDoubleClick.bind(this);
                this._handleClick = this._handleClick.bind(this);
                this._handleMouseWheel = this._handleMouseWheel.bind(this);
                this.wrapper = args.wrapper;
                var options = __assign({
                    disableLogging: false,
                    theme: 0 /* NONE */,
                    renderingMode: 'canvas',
                    width: undefined,
                    height: undefined,
                }, args.options);
                this._logSender = new HttpSender(options.appName);
                // set up vars for attribute usage logging
                this.attributeUsageLog = new AttributeLogger(this._logSender);
                options.disableLogging = args.options.disableLogging || !(LoggingStatus.isUsageLoggingEnabled());
                this.attributeUsageLog.isEnabled = !options.disableLogging;
                // set up log sender for non-attribute logging
                this.generalInfoLog = new GeneralInfoLogger(this._logSender);
                this.generalInfoLog.isEnabled = !options.disableLogging;
                this._theme = 0 /* NONE */;
                if (options.theme != null) {
                    this._theme = options.theme;
                }
                this._thiefTheme = getThiefTheme();
                logThiefInformation(this);
                this._renderingMode = 'canvas';
                if (isHeadlessMode) {
                    this._renderingMode = 'none';
                }
                else if (options.renderingMode != null) {
                    this._renderingMode = options.renderingMode;
                }
                // Provides an override to hide typically noisy output that is allowed by
                // ENABLE_DEBUG (which is first set by the closure compiler). The less
                // frequent output will still remain since it would be feasibly useful if
                // something suddenly breaks, but typical stuff like undefined attributes
                // and rendering times will be hidden.
                this.commonDebug = ENABLE_DEBUG;
                if (options.hasOwnProperty('commonDebug')) {
                    this.commonDebug = options['commonDebug'];
                }
                this._userWidth = options['width'];
                this._userHeight = options['height'];
                var container = args.containingElement;
                if (!isHeadlessMode) {
                    // convert HTMLElement to jQuery reference if we can so that we can still use .data('chart')
                    if (typeof jQuery !== 'undefined' && container instanceof HTMLDivElement) {
                        container = $$1(container);
                    }
                    if (typeof jQuery !== 'undefined' && !(container instanceof HTMLDivElement)) {
                        if (container.data('chart')) {
                            throw Error('An FDSChartJS object is already bound to this element. You should either reuse the existing instance, or call .destroy() prior to constructing a new one.');
                        }
                        // We've been passed a jQuery reference, so use the first element or
                        // punt if we don't have one
                        if (container instanceof jQuery) {
                            this._elemRef = container;
                            if (this._elemRef.length === 0) {
                                throw Error('FDSChartJS error: the query selector passed into the FDSChartJS constructor as the container element contains to matches.');
                            }
                            else if (this._elemRef.length > 1) {
                                console.warn('FDSChartJS warning: Non-unique selector. The selector passed in to the FDSChartJS constructor as the container element does not uniquely identify a single dom element. Currently the first match will be used, but future revisions may break this behavior.');
                                this._elemRef = this._elemRef.first();
                            }
                            this.containing_element = this._elemRef[0];
                        }
                        else {
                            console.warn('FDSChartJS warning: container element passed into the FDSChartJS constructor is expected to be an HTML Div or a jQuery selector. Undefined behavior may result.');
                            // try to maintain existing behavior if someone passed in an array, but still warn.
                            if (_$1.isArray(container)) {
                                if (container.length > 0) {
                                    this.containing_element = container[0];
                                }
                                else {
                                    throw Error("FDSChartJS error: an empty selector was passed into the FDSChartJS constructor.");
                                }
                            }
                            else {
                                this.containing_element = args.containingElement;
                            }
                        }
                    }
                    else {
                        if (!(container instanceof HTMLDivElement)) {
                            console.warn('FDSChartJS warning: container element passed into the FDSChartJS constructor is expected to be an HTML Div or a jQuery selector. Undefined behavior may result.');
                        }
                        this.containing_element = args.containingElement;
                    }
                }
            }
            _super.prototype._init.call(this);
            this._chartTheme = undefined;
            this.mousedOverPlotSliderIndex = -1;
            this.postDrawHooks = [];
            this.chartRect = new Rectangle();
            this.chartSubRect = new Rectangle();
            this.headerRect = new Rectangle();
            this.footerRect = new Rectangle();
            this.crosshairsLineColor = 0;
            this.plotResizeManager = new PlotResizeManager(this);
            this.minimumSizeManager = new MinimumSizeManager(this);
            this._setupRenderLayerManager();
            if (this.containing_element) {
                if (this.containing_element.className.indexOf('fdschartctl') === -1) {
                    this.containing_element.className += ' fdschartctl ';
                }
                if ((this.containing_element.offsetWidth === 0 && this._userWidth == null) ||
                    (this.containing_element.offsetHeight === 0 && this._userHeight == null)) {
                    throw Error("FDSChartJS error: div width is " + this.containing_element.offsetWidth + " and height is " + this.containing_element.offsetHeight + ". Either" +
                        " set the div size or pass a width/height with the FDSChartJS constructor options object.");
                }
                // Associate the chart object wrapper based on the id on the div. This allows folks to find
                // the specific instance of this object via jquery easily for E2E testing.
                if (this._elemRef != null) {
                    this._elemRef.data('chart', this.wrapper);
                }
                // we need this so we can add keypress event listeners.
                this.containing_element.tabIndex = -1;
                this._setupBlankCanvas();
                this._hookEventHandlers();
            }
            this.objects = {};
            this._styleObjects = {};
            this._seriesColorCycle = 14;
            // Stores default series colors for use with themes
            this._seriesColors = [];
            this._seriesColors[0] = 13395507 /* OCEAN_BLUE */;
            this._seriesColors[1] = 3342540 /* RETINA_RED */;
            this._seriesColors[2] = 3394815 /* CREAM_ORANGE */;
            this._seriesColors[3] = 39168 /* PINE_GREEN */;
            this._seriesColors[4] = 6684774 /* LAMENTABLE_PURPLE */;
            this._seriesColors[5] = 10040319 /* PINK */;
            this._seriesColors[6] = 16750899 /* SELECT_TOOL_BLUE */;
            this._seriesColors[7] = 10053273 /* GRAPE */;
            this._seriesColors[8] = 26316 /* DARK_ORANGE */;
            this._seriesColors[9] = 10066176 /* BLUE14 */;
            this._seriesColors[10] = 3394560 /* BURNING_GREEN */;
            this._seriesColors[11] = 10066329 /* KIND_OF_GREY */;
            this._seriesColors[12] = 10768680 /* LAKE_BLUE */;
            this._seriesColors[13] = 2687140 /* LIGHT_MAROON */;
            this._seriesColors[14] = 47607 /* YELLOW */;
            this._seriesColors[15] = 31488 /* GRASS */;
            this._seriesOutlineColors = new Array(SERIES_COLOR_COUNT);
            _$1.fill(this._seriesOutlineColors, 0 /* BLACK */);
            this._seriesLineWidths = new Array(SERIES_COLOR_COUNT);
            _$1.fill(this._seriesLineWidths, 1);
            this._seriesLineStyles = new Array(SERIES_COLOR_COUNT);
            _$1.fill(this._seriesLineStyles, 0 /* SOLID */);
            // Canvas BG Brush
            this.canvasBGBrush = new FDSBrush();
            this.canvasBGBrush.color = 16777215 /* WHITE */;
            this.canvasBGBrush.style = 0 /* SOLID */;
            // Chart BG Brush
            this.chartBGBrush = new FDSBrush();
            this.chartBGBrush.color = 16777215 /* WHITE */;
            this.chartBGBrush.style = 1 /* NULL */;
            // Chart FG Pen
            this._chartFGPen = new FDSPen({ color: 0 /* BLACK */, style: 5 /* NULL */ });
            // Canvas FG Pen
            this.canvasFGPen = new FDSPen({ color: 0 /* BLACK */, style: 5 /* NULL */ });
            // plot BG brush
            this._plotBGBrush = new FDSBrush();
            this._plotBGBrush.color = 16777215 /* WHITE */;
            this._plotBGBrush.style = 0 /* SOLID */;
            // Base font
            this._baseFont = new FDSFont({ widthHint: 32000 });
            this._baseFont2 = new FDSFont({ widthHint: 32000 });
            // title fonts
            this._XTitleFont = new FDSFont({ widthHint: 32000, alignment: 2 /* CENTER */ });
            this._YTitleFont = new FDSFont({ widthHint: 32000, alignment: 2 /* CENTER */, escapement: -Math.PI / 2 }); // default
            // for
            // Y-axes
            // to
            // rotate
            // 90
            // degrees
            // plot FG pen
            this._plotFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this.selectionToolBrush = new FDSBrush();
            this.selectionToolBrush.color = 16750899 /* SELECT_TOOL_BLUE */;
            this.selectionToolBrush.alpha = 64;
            this.selectionToolBrush.style = 0 /* SOLID */;
            this._setSeriesCycle(12);
            this._seriesAutoLighten = true;
            // grid FG pen
            // also x and y grid and minor grid pens, for inheritance
            this._gridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this._xGridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this._yGridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this._minorGridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this._xMinorGridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            this._yMinorGridFGPen = new FDSPen({ color: 13421772 /* PLOT_FG_GREY */ });
            // Create the stand-in objects for chart-global headings; plot-level
            // headings will inherit from these attributes
            this._heading = new FDSHeading(this, 'Heading', this, { weight: 700 /* BOLD */ });
            this._heading.visible = true;
            this._subHeading = new FDSHeading(this, 'SubHeading', this);
            this._header = new FDSHeading(this, 'Header', this, { weight: 700 /* BOLD */ });
            this._header.visible = false;
            this._footer = new FDSHeading(this, 'Footer', this, { italic: true, height: 10, family: 'Times New Roman' });
            // Footers default to displaying the standard copyright
            // message on the right-side with a few other trimmings.
            this._footer.text = 'Â©FactSet Research Systems';
            this._footer.arrangement = 1 /* RIGHT_CENTER_LEFT */;
            this._footer.extendsToEdge = true;
            // this sets up BaseFont
            this._baseHeader = new FDSHeading(this, 'Base', this);
            this._baseHeader.visible = false;
            // now set up the individual default headings
            this._heading1 = new FDSHeading(this, 'Heading1', this, { weight: 700 /* BOLD */ });
            this._heading2 = new FDSHeading(this, 'Heading2', this);
            this._heading3 = new FDSHeading(this, 'Heading3', this);
            this._heading4 = new FDSHeading(this, 'Heading4', this);
            // Create the chart level headers and footers
            this.chartHeader = new FDSHeading(this, 'ChartHeader', this, { weight: 700 /* BOLD */ });
            this.chartHeading1 = new FDSHeading(this, 'ChartHeading1', this, { weight: 700 /* BOLD */ });
            this.chartHeading2 = new FDSHeading(this, 'ChartHeading2', this);
            this.chartHeading3 = new FDSHeading(this, 'ChartHeading3', this);
            this.chartHeading4 = new FDSHeading(this, 'ChartHeading4', this);
            this.chartFooter = new FDSHeading(this, 'ChartFooter', this, { italic: true, height: 10, family: 'Times New Roman' });
            this.chartHeadersTopOffset = this.chartHeadersBotOffset = 5;
            this._chartHeadersUsePlotOffsets = true;
            // Headings 1 and 2 default to visible
            this._heading1.visible = true;
            this._heading2.visible = true;
            // Footers default to displaying the standard copyright
            // message on the right-side with a few other trimmings.
            this.chartFooter.text = 'Â©FactSet Research Systems';
            this.chartFooter.arrangement = 1 /* RIGHT_CENTER_LEFT */;
            this.chartFooter.extendsToEdge = true;
            this._cumulativeHeaderHeight = 0;
            this._footerHeight = 0;
            this._crosshairsTooltipFont = new FDSFont({ height: 12 });
            if (this.renderManager && this.renderManager.plotDragManager) {
                this.renderManager.plotDragManager.clear();
                this.renderManager.plotDragManager = null;
            }
            this.renderManager = null;
            this._isHorizontalZooming = false;
            this._setDynamicProperties({
                'FDSSeriesUnderCrosshair': true
            });
            this.tooltipsEnabled = true;
            this.tooltip = createTooltip(this);
            this.tooltip.setDelay(100);
            this.progressSpinner = createProgressSpinner(this);
            // set up annotation tooltip
            var UIContext = this.getUIContext();
            if (!this.clickTooltip) {
                var useExternalClickTooltipInfoboxes = false;
                if (args) {
                    useExternalClickTooltipInfoboxes = args.options.useExternalInfoboxesForClickTooltips || false;
                }
                this.clickTooltip = new ClickTooltip(useExternalClickTooltipInfoboxes, UIContext);
            }
            // for keeping track of taps
            this._touchMode = 0 /* NONE */;
            this._tapCount = 0;
            this._stateChanged = false;
            this.dragMode = 0 /* NONE */;
            this.pickObjectType = -1 /* FC_NULL */;
            this._interactionObject = '';
            this.interactionSignal = function (point, event, message) {
            };
            this.interacting = false;
            this.rubberBandMode = 0 /* NONE */;
            this.pickPoints = [];
            this.pickedObj = null;
            this.chartPlotList = [];
            // defaults
            this.selectableItemPointMarkerSize = 6;
            this.selectableItemPointMarkerType = 2 /* SQUARE */;
            // Cursor when selecting chart tools
            this._cursor = Cursor.DEFAULT;
            this.interactionCursor = Cursor.DEFAULT;
            this._pickMatchCursor = Cursor.CROSSHAIRS;
            this._bSnapMouseToSeries = false;
            this._snappingThreshold = 30;
            this._selectabilityMask = -1 /* ALL */;
            // Must come after brush and heading initialization
            this._setAttributes();
            this.mouseOutActions = [];
            this.copyAsActiveGraphMode = 0 /* UseFDSChartPC */;
            this.contextMenu = createContextMenu(this);
            this.pick = new FDSPick();
            // set up maps of stored pixel points for automated clicking
            this._clearAutomationPixelPoints();
            // set up vars for state logging
            this.stateLog = new FDSStateLog();
            this.stateLog.isEnabled = false;
            this._addingDT = 0 /* NONE */;
            this._addingDTCount = 0;
            this.suppressAllInteraction = isHeadlessMode;
            var testCanvasDifferenceSupport = function () {
                var canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                var ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 1, 1);
                ctx.globalCompositeOperation = 'difference';
                ctx.fillRect(0, 0, 1, 1);
                var imageData = ctx.getImageData(0, 0, 1, 1);
                if (!imageData || !imageData.data) {
                    return false;
                }
                else {
                    return imageData.data[0] === 0 && imageData.data[1] === 0 && imageData.data[2] === 0;
                }
            };
            if (!isHeadlessMode) {
                this._canvasDifferenceSupported = testCanvasDifferenceSupport();
            }
            this.setNeedUpdate(true);
            this._hitShapes = [];
            this._drawStyleToStyleObjectName = null;
            this.propertyUsageManager = new PropertyUsageManager(this);
            if (this._theme != null) {
                this._applyTheme();
            }
        };
        FDSChart.prototype.canvasDifferenceSupported = function () {
            return this._renderingMode === 'canvas' && this._canvasDifferenceSupported;
        };
        FDSChart.prototype._getObjectsOfType = function (type) {
            return _$1.values(this.objects).filter(function (object) { return (object instanceof
                type) &&
                !object.isStyleObject; });
        };
        FDSChart.prototype.isMockDrawing = function () {
            return this._renderLayerManager instanceof NullLayerManager;
        };
        FDSChart.prototype._destroyRenderingLayers = function () {
            this._renderLayerManager.destroy();
            this._renderLayerManager = null;
            if (this._markerCanvas) {
                this._markerCanvas.destroy();
            }
            this._markerCanvas = null;
        };
        FDSChart.prototype.destroy = function () {
            if ((this.wrapper != null) && this.wrapper.attached) {
                // delegate to the wrapper so that reference counting is correct
                this.wrapper.destroy();
                return;
            }
            if (this.renderManager && this.renderManager.plotDragManager) {
                this.renderManager.plotDragManager.clear();
                this.renderManager.plotDragManager = null;
            }
            if (this.containing_element != null) {
                this.tooltip.cleanUp();
                if (this.contextMenu != null) {
                    this.contextMenu.destroyMenu();
                    this.contextMenu = null;
                }
                this._cleanUp();
                this._unhookEventHandlers();
                this._destroyRenderingLayers();
                this.containing_element.removeChild(this._textEditDivWrapper);
                this.containing_element.className = this.containing_element.className.replace('fdschartctl', '');
                this.containing_element = null;
                if (this._elemRef != null) {
                    if (this._elemRef.length === 1) {
                        this._elemRef.removeData('chart');
                    }
                    else if (ENABLE_DEBUG && this.commonDebug) {
                        console.warn("The selector used no longer uniquely identifies the FDSChartJS container. Unable to remove $(...).data('chart')");
                    }
                    this._elemRef = null;
                }
            }
        };
        FDSChart.prototype._handleEventOnSeriesRenderCache = function (eventName, eventData) {
            for (var id in this.children) {
                var child = this.children[id];
                if (isSeries(child) && child.renderCache) {
                    var eventProp = 'handle' + eventName;
                    var handler = child.renderCache[eventProp];
                    if (_$1.isFunction(handler)) {
                        if (handler.call(child.renderCache, eventData)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        // Apply a theme based on what was passed into the FDSChart constructor
        FDSChart.prototype._applyTheme = function () {
            if (!_super.prototype._applyTheme.call(this)) {
                return false;
            }
            // By default, crosshairs are black
            this.crosshairsLineColor = 0;
            var themeAttrs = {};
            // Shared stuff for Quartz and Carbon
            if (this._theme === 1 /* QUARTZ */ || this._theme === 2 /* CARBON */) {
                themeAttrs['SeriesColor0'] = 15707648 /* BLUE1 */;
                themeAttrs['SeriesColor1'] = 3394713 /* GREEN2 */;
                themeAttrs['SeriesColor2'] = 6697882 /* PURPLE2 */;
                themeAttrs['SeriesColor3'] = 52479 /* YELLOW2 */;
                themeAttrs['SeriesColor4'] = 9868950 /* GRAY6 */;
                themeAttrs['SeriesColor5'] = 11037743 /* BLUE3 */;
                themeAttrs['SeriesColor6'] = 39219 /* GREEN3 */;
                themeAttrs['SeriesColor7'] = 3368601 /* BROWN1 */;
                themeAttrs['SeriesColor8'] = 39423 /* ORANGE1 */;
                themeAttrs['SeriesColor10'] = 16711935 /* PURPLE1 */;
                themeAttrs['SeriesColor11'] = 10066176 /* BLUE14 */;
                themeAttrs['SeriesColor12'] = 10079436 /* GREEN8 */;
                themeAttrs['SeriesColor14'] = 3618815 /* RED7 */;
                themeAttrs['SeriesColor15'] = 153 /* RED3 */;
                this._setSeriesCycle(15);
                themeAttrs['SeriesOutlineColor0'] = 11037743 /* BLUE3 */;
                themeAttrs['SeriesOutlineColor1'] = 2063454 /* GREEN9 */;
                themeAttrs['SeriesOutlineColor2'] = 7602528 /* PURPLE7 */;
                themeAttrs['SeriesOutlineColor3'] = 39372 /* YELLOW3 */;
                themeAttrs['SeriesOutlineColor4'] = 6579300 /* GRAY4 */;
                themeAttrs['SeriesOutlineColor5'] = 6697728 /* BLUE4 */;
                themeAttrs['SeriesOutlineColor6'] = 26163 /* GREEN4 */;
                themeAttrs['SeriesOutlineColor7'] = 1978701 /* BROWN2 */;
                themeAttrs['SeriesOutlineColor8'] = 28601 /* ORANGE2 */;
                themeAttrs['SeriesOutlineColor10'] = 6697882 /* PURPLE2 */;
                themeAttrs['SeriesOutlineColor11'] = 6706728 /* BLUE5 */;
                themeAttrs['SeriesOutlineColor12'] = 2063454 /* GREEN9 */;
                themeAttrs['SeriesOutlineColor14'] = 153 /* RED3 */;
                themeAttrs['SeriesOutlineColor15'] = 102 /* RED4 */;
                themeAttrs['CanvasFGStyle'] = 5;
                themeAttrs['CanvasBGStyle'] = 0;
                themeAttrs['GridFGStyle'] = 0;
                themeAttrs['CanvasBGGradientStyle'] = 0;
                themeAttrs['HeadingFontFamily'] = 'Arial';
                themeAttrs['HeadingFontHeight'] = 11;
                themeAttrs['SubHeadingFontHeight'] = 11;
            }
            if (this._theme === 1 /* QUARTZ */) {
                themeAttrs['SeriesColor9'] = 11513775 /* GRAY7 */;
                themeAttrs['SeriesColor13'] = 4934475 /* GRAY3 */;
                themeAttrs['SeriesOutlineColor9'] = 6579300 /* GRAY4 */;
                themeAttrs['SeriesOutlineColor13'] = 3289650 /* GRAY2 */;
                themeAttrs['CanvasBGColor'] = 16777215 /* WHITE */;
                themeAttrs['CrosshairsLineColor'] = 0 /* BLACK */;
                themeAttrs['BaseFontColor'] = 0 /* BLACK */;
            }
            else if (this._theme === 2 /* CARBON */) {
                themeAttrs['SeriesColor9'] = 13158600 /* GRAY8 */;
                themeAttrs['SeriesColor13'] = 15790320 /* GRAY10 */;
                themeAttrs['SeriesOutlineColor9'] = 9868950 /* GRAY6 */;
                themeAttrs['SeriesOutlineColor13'] = 13158600 /* GRAY8 */;
                themeAttrs['CanvasBGColor'] = 3289650 /* CARBON */;
                themeAttrs['CrosshairsLineColor'] = 16777215 /* WHITE */;
                themeAttrs['BaseFontColor'] = 16777215 /* WHITE */;
            }
            this.plotResizeManager.setThemeAttributes(this._theme, themeAttrs);
            for (var key in themeAttrs) {
                this.attributeSet.setAt(key, 'app', themeAttrs[key]);
            }
            return true;
        };
        FDSChart.prototype._setAttributes = function () {
            if (!this.attributeSet.defaultMap.startInitialization()) {
                return;
            }
            _super.prototype._setAttributes.call(this);
            this.attributeSet.addMultiple([
                ['EquateLRMargins', Boolean, true],
                ['SeriesColorCycle', Number, this._seriesColorCycle],
                ['SeriesColorAutoLighten', Boolean, this._seriesAutoLighten],
                ['SeriesColorUp', Number, 39219 /* GREEN3 */],
                ['SeriesColorDown', Number, 255 /* RED */],
                ['SeriesColorNeutral', Number, 15707648 /* BLUE1 */],
                ['SeriesQuickLabel', Boolean, false],
                ['SeriesQuickLabelText', String, '<FDSLabel>'],
                ['SeriesQuickLabelPosition', Number, 2 /* RIGHT */],
                ['SeriesQuickLabelVerticalPosition', Number, 2 /* DEFAULT */],
                ['SeriesQuickLabelLeftPositionModifier', Number, 0 /* INSIDE */],
                ['SeriesQuickLabelRightPositionModifier', Number, 0 /* INSIDE */],
                ['SeriesQuickLabelGap', Number, 0],
                ['SeriesQuickLabelColorFollowsSeriesColor', Boolean, true],
                ['SeriesQuickLabelColorMaximumContrast', Boolean, false],
                ['SeriesQuickLabelTextBox', Boolean, false],
                ['SeriesQuickLabelTextBoxDisplayStyle', Number, 0 /* RECT */],
                ['SeriesQuickLabelTextBoxHeightHint', Number, 0],
                ['SeriesQuickLabelTextBoxSizingMode', Number, 0 /* DEFAULT */],
                ['SeriesQuickLabelTextBoxWidthHint', Number, 0],
                ['SeriesQuickLabelTextBoxTextClipping', Boolean, false],
                ['SeriesQuickLabelArrowMultiplier', Number, 1],
                ['SeriesQuickLabelAutoPositionFactor', Number, 1],
                ['SeriesQuickLabelAutoPosition', Boolean, true],
                ['SeriesQuickLabelConsolidatedTextBoxes', Boolean, true],
                ['SeriesQuickLabelFontAlignmentLeft', Number, 1 /* RIGHT */],
                ['SeriesQuickLabelFontAlignmentRight', Number, 0 /* LEFT */],
                ['SeriesQuickLabelShowText', Boolean, true],
                ['SeriesQuickLabelTextBoxDisplayMargins', Number, 0],
                ['SeriesQuickLabelTextBoxBGColorFollowsSeriesColor', Boolean, false],
                ['SeriesQuickLabelTextBoxPlacement', Number, 1 /* INSIDE */],
                ['XminPlotFactor', Number, 0],
                ['XmaxPlotFactor', Number, 1],
                ['YminPlotFactor', Number, 0],
                ['YmaxPlotFactor', Number, 1],
                ['CrosshairsBoundToPlot', Boolean, false],
                ['CrosshairsDrawOnPlot', Boolean, false],
                ['CrosshairsEnabled', Boolean, false],
                ['CrosshairsLineColor', Number, this.crosshairsLineColor],
                ['CrosshairsLineSize', Number, 1],
                ['CrosshairsShowHorizontal', Boolean, true],
                ['CrosshairsShowVertical', Boolean, true],
                ['CrosshairsSnapToSeries', String, ''],
                ['CrosshairsSnapXToSeries', Boolean, true],
                ['CrosshairsSnapYToSeries', Boolean, false],
                ['CrosshairsTooltipEnabled', Boolean, false],
                ['CrosshairsTooltipText', String, ''],
                ['CrosshairsTooltipSnapX', Boolean, false],
                ['CrosshairsTooltipSnapY', Boolean, false],
                ['CrosshairsTooltipXOffset', Number, 0],
                ['CrosshairsTooltipYOffset', Number, 0],
                ['CrosshairsTooltipMode', Number, 0],
                ['CrosshairsTooltipSnapPlot', String, ''],
                ['CrosshairsDrawMarker', Boolean, false],
                ['CrosshairsMarkerColor', Number, 0 /* BLACK */],
                ['CrosshairsMarkerSize', Number, 10],
                ['CrosshairsMarkerStyle', Number, 1 /* CIRCLE */],
                ['CrosshairsLabel', Boolean, false],
                ['CrosshairsLabelDrawnWithoutAxisLabels', Boolean, false],
                ['AnnotationFollowsParentValue', Boolean, true],
                ['AnnotationDisappearOnNoValidXData', Boolean, false],
                ['AnnotationDisappearOnNoValidYData', Boolean, false],
                ['PersistInteraction', Boolean, false],
                ['ClickToolTips', Boolean, false],
                ['ToolTips', Boolean, true],
                ['ToolTipDelay', Number, 100],
                ['XAxis', Boolean, true],
                ['YAxis', Boolean, true],
                ['XLabel', Boolean, true],
                ['YLabel', Boolean, true],
                ['XTicks', Boolean, true],
                ['YTicks', Boolean, true],
                ['XMinorTicks', Boolean, true],
                ['YMinorTicks', Boolean, true],
                ['XGrid', Boolean, true],
                ['YGrid', Boolean, true],
                ['XMinorGrid', Boolean, false],
                ['YMinorGrid', Boolean, false],
                ['XTitle', Boolean, false],
                ['YTitle', Boolean, false],
                ['XAxisPosition', Number, 0],
                ['YAxisPosition', Number, 0],
                ['XTickMode', Number, 2 /* FIXED */],
                ['YTickMode', Number, 2 /* FIXED */],
                ['XTickDateBin', String, 'NONE'],
                ['YTickDateBin', String, 'NONE'],
                ['XLabelFormat', String, ''],
                ['YLabelFormat', String, ''],
                ['XThreshMin', Number, 0],
                ['YThreshMin', Number, 0],
                ['XThreshMax', Number, 1],
                ['YThreshMax', Number, 1],
                ['XHLBinsHint', Number, 1],
                ['YHLBinsHint', Number, 1],
                ['XReverse', Boolean, false],
                ['YReverse', Boolean, false],
                ['XLog', Boolean, false],
                ['YLog', Boolean, false],
                ['XTickOffset', Number, 1],
                ['XMinorTickOffset', Number, 0.5],
                ['YTickOffset', Number, 1],
                ['YMinorTickOffset', Number, 0.5],
                ['XOutlierAxis', Boolean, false],
                ['XOutlierAxisThreshMin', Number, NAN],
                ['XOutlierAxisThreshMax', Number, NAN],
                ['XOutlierAxisMarginMin', Number, 0.1],
                ['XOutlierAxisMarginMax', Number, 0.1],
                ['XOutlierAxisDynamic', Boolean, false],
                ['XOutlierAxisDynamicThreshold', Number, 1.5],
                ['YOutlierAxis', Boolean, false],
                ['YOutlierAxisThreshMin', Number, NAN],
                ['YOutlierAxisThreshMax', Number, NAN],
                ['YOutlierAxisMarginMin', Number, 0.1],
                ['YOutlierAxisMarginMax', Number, 0.1],
                ['YOutlierAxisDynamic', Boolean, false],
                ['YOutlierAxisDynamicThreshold', Number, 1.5],
                ['Legend', Boolean, true],
                ['LegendPosition', Number, 0 /* LEFT */],
                ['LegendDirection', Number, 0 /* COLUMN */],
                ['LegendAxisPosition', Number, 0 /* NORMAL */],
                ['LegendBasePosition', Number, 2 /* CENTER */],
                ['LegendVPosition', Number, 1 /* TOP */],
                ['LegendPacking', Boolean, true],
                ['LegendBGShadow', Boolean, false],
                ['LegendBGShadowColor', Number, 0 /* BLACK */],
                ['LegendBGShadowX', Number, 3],
                ['LegendBGShadowY', Number, -3],
                ['LegendText', String, ''],
                ['LegendXOffset', Number, 0],
                ['LegendYOffset', Number, 0],
                ['LongPressToInteract', Boolean, false],
                ['LongPressInteractTimeout', Number, 500],
                ['HorizontalZoom', Boolean, false],
                ['FocusPlot', String, ''],
                ['SelectableItemRenderMode', Number, 2],
                ['SelectableItemPointMarkerType', Number, 2 /* SQUARE */],
                ['SelectableItemPointMarkerSize', Number, 6],
                ['SelectableItemSamplingEnabled', Boolean, true],
                ['SelectionToolEnabled', Boolean, false],
                ['SimpleZoom', Boolean, false],
                ['InteractivityMode', Number, 1 /* SELECTABLE */],
                ['InteractivityWithoutToolTips', Boolean, false],
                ['InteractivitySelectableMask', Number, -1 /* ALL */],
                ['SeriesShadow', Boolean, false],
                ['SeriesShadowColor', Number, 0],
                ['SeriesShadowAlpha', Number, 255],
                ['SeriesShadowX', Number, 3],
                ['SeriesShadowY', Number, -3],
                ['RefreshPlotOnZoom', Boolean, false],
                ['ResizeAllAxesOnZoom', Boolean, false],
                ['PlotDragEnabled', Boolean, false],
                ['PlotDragScalePadding', Number, 25],
                ['ContextMenuEnabled', Boolean, true],
                ['OnLeftButtonClick', String, ''],
                ['OnLeftButtonDoubleClick', String, ''],
                ['OnRightButtonClick', String, ''],
                ['OnRightButtonDoubleClick', String, ''],
                ['OnMiddleButtonClick', String, ''],
                ['OnMiddleButtonDoubleClick', String, ''],
                ['FireRightButtonDownBeforeMenu', String, ''],
                ['InteractivityClampToPlot', Boolean, true],
                ['Exceptions', Boolean, false],
                ['Cursor', String, ''],
                ['SnapMouseToSeries', Boolean, this._bSnapMouseToSeries],
                ['SnappingThreshhold', Number, this._snappingThreshold],
                ['ChartHeadersTopOffset', Number, this.chartHeadersTopOffset],
                ['ChartHeadersBotOffset', Number, this.chartHeadersBotOffset],
                ['ChartHeadersUsePlotOffsets', Boolean, this._chartHeadersUsePlotOffsets],
                ['CopyAsActiveGraphEnabled', Boolean, false],
                ['CopyAsActiveGraphMode', Number, 0 /* UseFDSChartPC */],
                ['SeriesValue', Boolean, false],
                ['SeriesMarkerAutoPosition', Boolean, true],
                ['SeriesMarkerAutoPositionXFactor', Number, 0.75],
                ['SeriesMarkerAutoPositionYFactor', Number, 0.75],
                ['SeriesMarkerAutoPositionMode', Number, 0 /* ANNOTATION */],
                ['SeriesMarkerAutoPositionDirection', Number, 0 /* POSITIVE */],
            ]);
            // add intraday attributes for the axis to inherit
            var intradayAtts = [];
            // these are the ones that need to inherit for the formatter to be happy
            var fmtrInherits = [
                'SECOND',
                'TWOSECOND',
                'FIVESECOND',
                'TENSECOND',
                'HALFMINUTE',
                'MINUTE',
                'TWOMINUTE',
                'FIVEMINUTE',
                'TENMINUTE',
                'HALFHOUR',
                'HOUR',
                'TWOHOUR',
                'SIXHOUR',
                'DAY',
                'WEEK',
                'MONTH',
                'QUARTER',
                'HALFY',
                'YEAR',
                'TWOY',
                'FIVEY',
                'TENY'
            ];
            for (var _i = 0, fmtrInherits_1 = fmtrInherits; _i < fmtrInherits_1.length; _i++) {
                var str = fmtrInherits_1[_i];
                var bin = DateTimeBinArray.indexOf(str);
                var rangeStr = 'IntradayScaleRange' + str;
                var minRangeStr = 'IntradayScaleMinorRange' + str;
                var formatStr = 'IntradayScaleLabelFormat' + str;
                var minFormatStr = 'IntradayScaleMinorLabelFormat' + str;
                intradayAtts.push(['X' + rangeStr, Number, IntradayScaleRanges[bin]]);
                intradayAtts.push(['X' + minRangeStr, Number, IntradayScaleMinorRanges[bin]]);
                intradayAtts.push(['X' + formatStr, String, '']);
                intradayAtts.push(['X' + minFormatStr, String, '']);
                intradayAtts.push(['Y' + rangeStr, Number, IntradayScaleRanges[bin]]);
                intradayAtts.push(['Y' + minRangeStr, Number, IntradayScaleMinorRanges[bin]]);
                intradayAtts.push(['Y' + formatStr, String, '']);
                intradayAtts.push(['Y' + minFormatStr, String, '']);
            }
            this.attributeSet.addMultiple(intradayAtts);
            this._setSeriesColorAttributes();
            this.plotResizeManager.setAttributes(this.attributeSet);
            this.minimumSizeManager.setAttributes(this.attributeSet);
            this.attributeSet.add('SeriesMarkerStyleList', Number, []);
            this.canvasBGBrush.writeToAttrSet(this.attributeSet, 'CanvasBG');
            this.chartBGBrush.writeToAttrSet(this.attributeSet, 'ChartBG');
            this._chartFGPen.writeToAttrSet(this.attributeSet, 'ChartFG');
            this.canvasFGPen.writeToAttrSet(this.attributeSet, 'CanvasFG');
            this._plotBGBrush.writeToAttrSet(this.attributeSet, 'PlotBG');
            this._plotFGPen.writeToAttrSet(this.attributeSet, 'PlotFG');
            var axisPen = new FDSPen({ color: 6710886 /* TICK_FG_GREY */ });
            axisPen.writeToAttrSet(this.attributeSet, 'AxisFG');
            axisPen.writeToAttrSet(this.attributeSet, 'XAxisFG', 'AxisFG');
            axisPen.writeToAttrSet(this.attributeSet, 'YAxisFG', 'AxisFG');
            axisPen.writeToAttrSet(this.attributeSet, 'XTicksFG', 'XAxisFG');
            axisPen.writeToAttrSet(this.attributeSet, 'YTicksFG', 'YAxisFG');
            this.selectionToolBrush.writeToAttrSet(this.attributeSet, 'SelectionToolBG');
            // set up the legend pen/brush/font attributes with default values
            var legendPen = new FDSPen({ color: 0 /* BLACK */, style: 5 /* NULL */ });
            legendPen.writeToAttrSet(this.attributeSet, 'LegendFG');
            var legendBrush = new FDSBrush();
            legendBrush.color = 16777215 /* WHITE */;
            legendBrush.style = 1;
            legendBrush.writeToAttrSet(this.attributeSet, 'LegendBG');
            var legendFont = new FDSFont({ widthHint: 32000 });
            legendFont.writeToAttrSet(this.attributeSet, 'LegendFont', 'BaseFont');
            // this is the base header for all headers and all fonts
            this._baseHeader.writeToAttrSet(this.attributeSet, 'Base');
            this._baseFont2.writeToAttrSet(this.attributeSet, 'BaseFont2');
            // these are the general heading defaults. they all inherit from base
            this._header.writeToAttrSet(this.attributeSet, 'Header', 'Base');
            this._heading.writeToAttrSet(this.attributeSet, 'Heading', 'Base');
            this._subHeading.writeToAttrSet(this.attributeSet, 'SubHeading', 'Base');
            this._footer.writeToAttrSet(this.attributeSet, 'Footer', 'Base');
            // now the individual defaults, they all inherit from the general defaults
            this._heading1.writeToAttrSet(this.attributeSet, 'Heading1', 'Heading');
            this._heading2.writeToAttrSet(this.attributeSet, 'Heading2', 'SubHeading');
            this._heading3.writeToAttrSet(this.attributeSet, 'Heading3', 'SubHeading');
            this._heading4.writeToAttrSet(this.attributeSet, 'Heading4', 'SubHeading');
            // the actual chart headings inherit from the general defaults
            this.chartHeader.writeToAttrSet(this.attributeSet, 'ChartHeader', 'Header');
            this.chartHeading1.writeToAttrSet(this.attributeSet, 'ChartHeading1', 'Heading1');
            this.chartHeading2.writeToAttrSet(this.attributeSet, 'ChartHeading2', 'Heading2');
            this.chartHeading3.writeToAttrSet(this.attributeSet, 'ChartHeading3', 'Heading3');
            this.chartHeading4.writeToAttrSet(this.attributeSet, 'ChartHeading4', 'Heading4');
            this.chartFooter.writeToAttrSet(this.attributeSet, 'ChartFooter', 'Footer');
            this._XTitleFont.writeToAttrSet(this.attributeSet, 'XTitleFont', 'BaseFont');
            this._YTitleFont.writeToAttrSet(this.attributeSet, 'YTitleFont', 'BaseFont');
            // set up the axis x/y font
            var xFont = new FDSFont();
            xFont.writeToAttrSet(this.attributeSet, 'XFont', 'BaseFont');
            var yFont = new FDSFont();
            yFont.writeToAttrSet(this.attributeSet, 'YFont', 'BaseFont');
            this._crosshairsTooltipFont.writeToAttrSet(this.attributeSet, 'CrosshairsTooltipFont');
            // set up annotation tooltip
            var UIContext = this.getUIContext();
            this._annotationCallout = new FDSInfoBox(UIContext);
            this._annotationCallout.setStyle(2 /* CG_CALLOUT */, UIContext);
            this.clickTooltip.setAttributes(this.attributeSet);
            this._gridFGPen.writeToAttrSet(this.attributeSet, 'GridFG');
            this._xGridFGPen.writeToAttrSet(this.attributeSet, 'XGridFG', 'GridFG');
            this._yGridFGPen.writeToAttrSet(this.attributeSet, 'YGridFG', 'GridFG');
            this._minorGridFGPen.writeToAttrSet(this.attributeSet, 'MinorGridFG');
            this._xMinorGridFGPen.writeToAttrSet(this.attributeSet, 'XMinorGridFG');
            this._yMinorGridFGPen.writeToAttrSet(this.attributeSet, 'YMinorGridFG');
            // series value defaults
            var brush = new FDSBrush();
            brush.style = 0 /* SOLID */;
            brush.writeToAttrSet(this.attributeSet, 'SeriesValueBG', 'PlotBG');
            var pen = new FDSPen({ color: 6710886 /* TICK_FG_GREY */ });
            pen.writeToAttrSet(this.attributeSet, 'SeriesValueFG', 'AxisFG');
            var font = new FDSFont({ height: 10, alignment: 2 /* CENTER */ });
            font.writeToAttrSet(this.attributeSet, 'SeriesValueFont', 'BaseFont');
            // series quicklabel defaults
            pen = new FDSPen();
            pen.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelTextBoxFG');
            brush = new FDSBrush();
            brush.color = 16777215 /* WHITE */;
            brush.style = 0 /* SOLID */;
            brush.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelTextBoxBG');
            font = new FDSFont({ height: 10, color: 13421772 /* PLOT_FG_GREY */, weight: 800 /* EXTRABOLD */ });
            font.writeToAttrSet(this.attributeSet, 'SeriesQuickLabelFont');
            this.attributeSet.defaultMap.finalizeInitialization();
        };
        FDSChart.prototype._setSeriesColorAttributes = function () {
            for (var i = 0; i < SERIES_COLOR_COUNT; i++) {
                var color = this.getSeriesColor(i, undefined, false);
                this.attributeSet.add("SeriesColor" + i, Number, color);
                var outlineColor = this.getSeriesOutlineColor(i, undefined, false);
                this.attributeSet.add("SeriesOutlineColor" + i, Number, outlineColor);
                var lineStyle = this.getSeriesLineStyle(i, undefined, false);
                this.attributeSet.add("SeriesLineStyle" + i, Number, lineStyle);
                var lineWidth = this.getSeriesLineWidth(i, undefined, false);
                this.attributeSet.add("SeriesLineWidth" + i, Number, lineWidth);
            }
            this.attributeSet.add('SeriesColorList', Number, []);
            this.attributeSet.add('SeriesOutlineColorList', Number, []);
            this.attributeSet.add('SeriesLineStyleList', Number, []);
            this.attributeSet.add('SeriesLineWidthList', Number, []);
        };
        FDSChart.prototype.syncMembers = function () {
            var _this = this;
            _super.prototype.syncMembers.call(this);
            if (!this.attributeSet.isDirty()) {
                return;
            }
            // Saves on property access and minified file size
            var getAttribute = this.attributeSet.get.bind(this.attributeSet);
            this.compiledCrosshairsTooltipText = this.properties.compilePropertyString(getAttribute('CrosshairsTooltipText'));
            this.crosshairsTooltipEnabled = getAttribute('CrosshairsTooltipEnabled');
            this.crosshairsTooltipSnapX = getAttribute('CrosshairsTooltipSnapX');
            this.crosshairsTooltipSnapY = getAttribute('CrosshairsTooltipSnapY');
            this.crosshairsTooltipXOffset = getAttribute('CrosshairsTooltipXOffset');
            this.crosshairsTooltipYOffset = getAttribute('CrosshairsTooltipYOffset');
            this.crosshairsTooltipMode = getAttribute('CrosshairsTooltipMode');
            this._crosshairsTooltipSnapPlot = getAttribute('CrosshairsTooltipSnapPlot');
            this.clickTooltipEnabled = getAttribute('ClickToolTips');
            this.crosshairsSnapToSeries = getAttribute('CrosshairsSnapToSeries');
            this._crosshairsSnapToSeriesDefault = this.attributeSet.isDefault('CrosshairsSnapToSeries');
            this._crosshairsSnapXToSeries = getAttribute('CrosshairsSnapXToSeries');
            this._crosshairsSnapYToSeries = getAttribute('CrosshairsSnapYToSeries');
            this._crosshairsDrawOnPlot = getAttribute('CrosshairsDrawOnPlot');
            this.crosshairsEnabled = getAttribute('CrosshairsEnabled');
            this.persist = getAttribute('PersistInteraction');
            this.selectionToolBrush.constructFromAttributes(this.attributeSet, 'SelectionToolBG');
            this._crosshairsTooltipFont = FDSFont.constructFromAttributes(this.attributeSet, 'CrosshairsTooltipFont');
            var fillWithAttrValues = function (prefix) { return _$1.times(SERIES_COLOR_COUNT, function (i) { return _this.attributeSet.get(prefix + i); }); };
            this._seriesColors = this.attributeSet.getWithFallback('SeriesColorList', function () { return fillWithAttrValues('SeriesColor'); });
            this._seriesOutlineColors = this.attributeSet.getWithFallback('SeriesOutlineColorList', function () { return fillWithAttrValues('SeriesOutlineColor'); });
            this._seriesLineWidths = this.attributeSet.getWithFallback('SeriesLineWidthList', function () { return fillWithAttrValues('SeriesLineWidth'); });
            this._seriesLineStyles = this.attributeSet.getWithFallback('SeriesLineStyleList', function () { return fillWithAttrValues('SeriesLineStyle'); });
            this._seriesMarkerStyles = getAttribute('SeriesMarkerStyleList');
            this._seriesColorCycle = getAttribute('SeriesColorCycle');
            this._seriesAutoLighten = getAttribute('SeriesColorAutoLighten');
            this._gridFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'GridFG');
            this.horizontalZoomEnabled = getAttribute('HorizontalZoom');
            this.refreshPlotOnZoom = getAttribute('RefreshPlotOnZoom');
            this.plotDragScalePadding = getAttribute('PlotDragScalePadding');
            if (this.crosshairTooltip != null) {
                this.crosshairTooltip.update({ font: this._crosshairsTooltipFont }, this.getOverlayContext());
            }
            this._longPressToInteract = getAttribute('LongPressToInteract');
            this._longPressInteractTimeout = getAttribute('LongPressInteractTimeout');
            this.clickTooltip.syncMembers(this.attributeSet);
            this.tooltip.setDelay(getAttribute('ToolTipDelay'));
            this.tooltipsEnabled = getAttribute('ToolTips');
            if (!this.tooltipsEnabled) {
                this.tooltip.cleanUp();
            }
            this.selectableItemPointMarkerType = getAttribute('SelectableItemPointMarkerType');
            this.selectableItemPointMarkerSize = getAttribute('SelectableItemPointMarkerSize');
            this.selectionToolEnabled = getAttribute('SelectionToolEnabled');
            this.contextMenuEnabled = getAttribute('ContextMenuEnabled');
            this._selectabilityMask = getAttribute('InteractivitySelectableMask');
            this.setInteractivityMode(getAttribute('InteractivityMode'));
            this.interactivityWithoutTooltips = getAttribute('InteractivityWithoutToolTips');
            this._bSnapMouseToSeries = getAttribute('SnapMouseToSeries');
            this._snappingThreshold = getAttribute('SnappingThreshhold');
            this.chartHeader.constructFromAttributes(this.attributeSet, 'ChartHeader');
            this.chartHeading1.constructFromAttributes(this.attributeSet, 'ChartHeading1');
            this.chartHeading2.constructFromAttributes(this.attributeSet, 'ChartHeading2');
            this.chartHeading3.constructFromAttributes(this.attributeSet, 'ChartHeading3');
            this.chartHeading4.constructFromAttributes(this.attributeSet, 'ChartHeading4');
            this.chartFooter.constructFromAttributes(this.attributeSet, 'ChartFooter');
            this.chartHeadersBotOffset = getAttribute('ChartHeadersBotOffset');
            this.chartHeadersTopOffset = getAttribute('ChartHeadersTopOffset');
            this._chartHeadersUsePlotOffsets = getAttribute('ChartHeadersUsePlotOffsets');
            this._calculateHeaderFooter();
            this.canvasBGBrush.constructFromAttributes(this.attributeSet, 'CanvasBG');
            this.canvasFGPen = FDSPen.constructFromAttributes(this.attributeSet, 'CanvasFG');
            this._syncInteractivity();
            var oldCopyAsActiveGraphEnabled = this.copyAsActiveGraphEnabled;
            this.copyAsActiveGraphEnabled = getAttribute('CopyAsActiveGraphEnabled');
            this.copyAsActiveGraphMode = getAttribute('CopyAsActiveGraphMode');
            this.minimumSizeManager.syncMembers(this.attributeSet);
            this.plotResizeManager.syncMembers(this.attributeSet);
        };
        FDSChart.prototype._syncInteractivity = function () {
        };
        FDSChart.prototype.toChartImageShellAsync = function () {
            var _this = this;
            var deferred = jQuery.Deferred();
            var serializedData = this.dumpJSON();
            var xmlTemplateDS = this.getTypedObject('XMLTemplate', isDataSet);
            var xmlTemplateStr;
            if (xmlTemplateDS) {
                xmlTemplateStr = xmlTemplateDS.getStringAt(0);
            }
            this._getPngAndSvgAsync().then(function (images) {
                var dataToClipboard = {
                    appAttributes: {
                        ControlClearMode: 2,
                        ScreenRenderer: 3,
                        CanvasFGStyle: 5,
                        CanvasBGImageScaleMode: 2,
                        CanvasBGImageName: 'JSChartImage',
                        IsChartImageShell: true,
                    },
                    properties: {
                        FDSChartJSVersion: getClosestRelease(_this._version),
                        ApplicationName: _this.applicationName,
                    },
                    objects: [
                        {
                            id: 'JSChartImage',
                            type: 'FDSData',
                            appAttributes: {
                                ImageType: 'png',
                                MultiImageType: 'png;svg',
                                UseAlpha: true,
                            },
                            data: [
                                images.png.split(',')[1].replace(/\s/g, ''),
                                images.svg,
                            ],
                            dataType: 'STRING',
                            dataId: ''
                        },
                        {
                            id: 'SerializedChart',
                            type: 'FDSData',
                            data: [
                                serializedData
                            ],
                            dataType: 'STRING',
                            dataId: ''
                        }
                    ]
                };
                if (xmlTemplateStr) {
                    dataToClipboard.objects.push({
                        id: 'XMLTemplate',
                        type: 'FDSData',
                        data: [
                            xmlTemplateStr
                        ],
                        dataType: 'STRING',
                        dataId: ''
                    });
                }
                deferred.resolve(JSON.stringify(dataToClipboard));
            });
            return deferred.promise();
        };
        FDSChart.prototype._getPngAndSvgAsync = function () {
            var _this = this;
            var oldRenderingMode = this._renderingMode;
            var imagePromise;
            var svg;
            var getRenderedCanvas = function () {
                imagePromise = _this.toImageAsync();
            };
            var getRenderedSvg = function () {
                svg = new XMLSerializer().serializeToString(_this.toSvg());
            };
            var reRenderWithCanvas = function () {
                _this.setRenderingMode('canvas');
                _this.draw();
            };
            var reRenderWithSvg = function () {
                _this.setRenderingMode('svg');
                _this.draw();
            };
            // If we are in svg, then the assumption is we only need to redraw using canvas.
            // Similarly, if we are in canvas, then we only need to redraw using svg.
            if (oldRenderingMode === 'svg') {
                // We have already rendered the svg, so lets just get it directly
                getRenderedSvg();
                // now re-render and fetch the canvas image
                reRenderWithCanvas();
                getRenderedCanvas();
            }
            else if (oldRenderingMode === 'canvas') {
                // We have already rendered the canvas, so lets just get it directly
                getRenderedCanvas();
                // now re-render and fetch the  image
                reRenderWithSvg();
                getRenderedSvg();
            }
            else {
                // We probably shouldn't be here, but if we are we need to re-render both
                reRenderWithCanvas();
                getRenderedCanvas();
                reRenderWithSvg();
                getRenderedSvg();
            }
            this.setRenderingMode(oldRenderingMode);
            this.invalidate();
            return imagePromise.then(function (imageData) {
                return {
                    svg: svg,
                    png: imageData
                };
            });
        };
        // function to serialize the current chart as xml
        FDSChart.prototype.dumpXML = function (level) {
            if (level === void 0) { level = 0 /* GENERATE_FULL */; }
            // get the xml
            return this.serialize(level);
        };
        // function to serialize the current chart as json
        FDSChart.prototype.dumpJSON = function (level) {
            if (level === void 0) { level = 0 /* GENERATE_FULL */; }
            // get the json
            return JSON.stringify(this.serializeToJSON(level));
        };
        FDSChart.prototype._setupRenderLayerManager = function () {
            if (!this._renderLayerManager) {
                if (this._renderingMode === 'none') {
                    this._renderLayerManager = new NullLayerManager();
                }
                else if (this._renderingMode === 'svg') {
                    this._renderLayerManager = new SvgLayerManager(this.containing_element);
                }
                else {
                    this._renderLayerManager = new CanvasLayerManager(this.containing_element);
                }
                if (this._renderingMode !== 'none') {
                    this.containing_element.style.position = 'relative';
                    this._resetCanvasSize(true);
                }
            }
        };
        FDSChart.prototype._setupBlankCanvas = function () {
            var _this = this;
            if (this._textEditDivWrapper != null) {
                this._textEditDivWrapper.parentNode.removeChild(this._textEditDivWrapper);
                this._textEditDiv.parentNode.removeChild(this._textEditDiv);
            }
            this._textEditDivWrapper = document.createElement('div');
            this._textEditDiv = document.createElement('div');
            this._textEditDiv.contentEditable = 'false';
            this._textEditDiv.style.display = 'none';
            this._textEditDiv.style.zIndex = '11';
            this._textEditDiv.style.backgroundColor = 'white';
            this._textEditDiv.tabIndex = -1;
            this._textEditDivWrapper.style.display = 'table';
            this._textEditDivWrapper.appendChild(this._textEditDiv);
            this.containing_element.appendChild(this._textEditDivWrapper);
            var stopHandler = function (e) {
                e.stopPropagation();
            };
            var keyHandler = function (e) {
                e.stopPropagation();
                if (e.which === 27 /* ESCAPE */) {
                    _this.getInteractionObject().cancelTextEdit();
                }
                else {
                    _this.getInteractionObject().onUpdateText();
                }
            };
            this._textEditDivWrapper.addEventListener('mousedown', stopHandler);
            this._textEditDivWrapper.addEventListener('mouseup', stopHandler);
            this._textEditDivWrapper.addEventListener('touchstart', stopHandler);
            this._textEditDivWrapper.addEventListener('touchend', stopHandler);
            this._textEditDivWrapper.addEventListener('keydown', stopHandler);
            this._textEditDivWrapper.addEventListener('keyup', keyHandler);
            // place the tooltip canvas above the other canvases, and prevent it from blocking clicks
            this._renderLayerManager.ui.setStyle({
                zIndex: 3 /* TOOLTIP */.toString(),
            });
            if (!this.crosshairTooltip) {
                this.crosshairTooltip = new FDSInfoBox(this.getOverlayContext());
            }
            var width = this._renderLayerManager.main.getWidth();
            var height = this._renderLayerManager.main.getHeight();
            this.chartRect = new Rectangle(0, 0, width, height);
            this.chartSubRect = new Rectangle(0, 0, width, height);
        };
        FDSChart.prototype._resetCanvasSize = function (tryUserDim) {
            if (tryUserDim === void 0) { tryUserDim = false; }
            // Get the dimensions of the element in the same way jQuery's `width` and
            // `height` methods operate.
            var cssWidth;
            var cssHeight;
            if (tryUserDim) {
                if (this._userWidth) {
                    cssWidth = this._userWidth;
                    this.containing_element.style.width = this._userWidth + 'px';
                }
                else {
                    cssWidth = this.containing_element.offsetWidth;
                }
                if (this._userHeight) {
                    cssHeight = this._userHeight;
                    this.containing_element.style.height = this._userHeight + 'px';
                }
                else {
                    cssHeight = this.containing_element.offsetHeight;
                }
            }
            else {
                cssWidth = this.containing_element.offsetWidth;
                cssHeight = this.containing_element.offsetHeight;
            }
            // If we're running on a Retina iPad and canvas effective width is
            // 2048px, we need to lop off two pixels otherwise we hit a texture limit
            // and performance plummets.
            if (getDevicePixelRatio() === 2) {
                if (cssWidth === 1024) {
                    cssWidth -= 1;
                }
                if (cssHeight === 1024) {
                    cssHeight -= 1;
                }
            }
            var layerWidth = ~~scaleByDevicePixelRatio(cssWidth);
            var layerHeight = ~~scaleByDevicePixelRatio(cssHeight);
            this._renderLayerManager.resize(layerWidth, layerHeight);
            if (this._markerCanvas) {
                this._markerCanvas.resize(layerWidth, layerHeight);
            }
            this.chartRect.setRect(0, 0, layerWidth, layerHeight);
            this.chartSubRect.setRect(0, 0, layerWidth, layerHeight);
            // resizing the canvas means finding new positions for the sliders
            this.plotResizeManager.setHitShapesDirty();
        };
        FDSChart.prototype._eventListenerHelper = function (addOrRemoveFunc) {
            addOrRemoveFunc('mousedown', this._dispatchPointerHandler);
            addOrRemoveFunc('touchstart', this._handleTouchStart); // this will control our longpress to itneract thing
            addOrRemoveFunc('touchend', this._handleTouchEnd);
            addOrRemoveFunc('mouseup', this._handlePointerUp);
            addOrRemoveFunc('click', this._handleClick);
            addOrRemoveFunc('dblclick', this._handleDoubleClick);
            addOrRemoveFunc('mousewheel', this._handleMouseWheel);
            addOrRemoveFunc('mousemove', this._handlePointerMove);
            addOrRemoveFunc('touchmove', this._handlePointerMove);
            addOrRemoveFunc('mouseover', this._handleMouseOver);
            addOrRemoveFunc('mouseout', this._handleMouseOut);
            addOrRemoveFunc('mousemove', this._handleMouseMove);
            addOrRemoveFunc('touchmove', this._handleTouchMove);
            addOrRemoveFunc('keydown', this._handleKeyDown);
            addOrRemoveFunc('keyup', this._handleKeyUp);
            addOrRemoveFunc('contextmenu', this._handleContextMenu);
        };
        // The event handler functions, as properties of the chart object, are bound
        // (since they're defined with the fat-arrow operator), so all we need to do
        // is assign them to the appropriate events on the overlay canvas.
        FDSChart.prototype._hookEventHandlers = function () {
            if (!this._eventsAreHooked) {
                this._eventListenerHelper(this.containing_element.addEventListener.bind(this.containing_element));
                this._eventsAreHooked = true;
            }
        };
        FDSChart.prototype._unhookEventHandlers = function () {
            if (this._eventsAreHooked) {
                this._eventListenerHelper(this.containing_element.removeEventListener.bind(this.containing_element));
                this._eventsAreHooked = false;
            }
        };
        FDSChart.prototype._handleContextMenu = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                event.preventDefault();
                event.stopPropagation();
                return;
            }
            else if (this.contextMenu instanceof ThiefAngularMenu) {
                if (this.dragMode === 0 /* NONE */) {
                    var point = this.renderManager.getCursorPos(event);
                    this.contextMenu.doContextMenu(event);
                    this.doPick('ContextMenu', point);
                    this._firePickEventing();
                }
            }
        };
        FDSChart.prototype._handleKeyDown = function (event) {
            if (this.interactionSignal.call(this.getInteractionObject(), Point.zero(), event, 4 /* KEYDOWN */)) {
                this.invalidate();
            }
        };
        FDSChart.prototype._handleKeyUp = function (event) {
            if (this.interactionSignal.call(this.getInteractionObject(), Point.zero(), event, 5 /* KEYUP */)) {
                this.invalidate();
            }
        };
        FDSChart.prototype._handleTouchStart = function (event) {
            var _this = this;
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            this._handleEventOnSeriesRenderCache('TouchStart', event);
            if (this._touchMode === 0 /* NONE */) {
                this._touchMode = 1 /* TAP */;
            }
            else if (this._touchMode === 1 /* TAP */) {
                this._touchMode = 2 /* GESTURE */;
            }
            var point = this.renderManager.getCursorPos(event);
            this.renderManager.cursorX = point.x;
            this.renderManager.cursorY = point.y;
            if (this.dragMode !== 0 /* NONE */ || this._interactionObject !== '') {
                this._handlePointerDown(point, event, true, 1);
                this.interacting = true;
                if (this.renderManager) {
                    this.renderManager.startInteraction(event);
                }
                return;
            }
            var startInteract = function () {
                _this.interacting = true;
                _this.renderManager.startInteraction(event);
                _this._doPrimaryPointerPick('LButtonDown', point, event);
            };
            if (this._longPressToInteract) {
                if (this.renderManager && !isHeadlessMode) {
                    this._touchTimeout = window.setTimeout(startInteract, this._longPressInteractTimeout);
                }
            }
            else {
                startInteract();
                this._handlePointerDown(point, event, true, 1);
            }
        };
        FDSChart.prototype._dispatchPointerHandler = function (event) {
            if (!this.renderManager) {
                return;
            }
            this.contextMenu.destroyMenu();
            var point = this.renderManager.getCursorPos(event);
            this.renderManager.cursorX = point.x;
            this.renderManager.cursorY = point.y;
            var which = event['which'];
            // if this gets called with a touch event, just assume it's a left click
            if ((typeof TouchEvent !== 'undefined' && TouchEvent !== null) && event instanceof TouchEvent) {
                which = 1 /* LEFT */;
            }
            switch (which) {
                case 1 /* LEFT */:
                    return this._handlePointerDown(point, event);
                case 2 /* MIDDLE */:
                    return this._handleMiddleButtonDown(point, event);
                case 3 /* RIGHT */:
                    return this._handleRightButtonDown(point, event);
            }
        };
        FDSChart.prototype._handleMiddleButtonDown = function (point, event) {
            if (this.dragMode === 0 /* NONE */) {
                if (this._handlePointerAction('MButtonDown', 'OnMiddleButtonClick', point)) {
                    this._firePickEventing();
                }
            }
        };
        FDSChart.prototype._handleRightButtonDown = function (point, event) {
            if (this.dragMode === 0 /* NONE */) {
                if (this._handlePointerAction('RButtonDown', 'OnRightButtonClick', point)) {
                    this._firePickEventing();
                    return;
                }
                if (this.contextMenu instanceof ThiefClassicMenu) {
                    this.contextMenu.doContextMenu(event);
                }
                this.doPick('RButtonDown', point);
                this._firePickEventing();
            }
        };
        FDSChart.prototype._handlePointerDown = function (point, event, touch, numTouches) {
            if (touch === void 0) { touch = false; }
            if (numTouches === void 0) { numTouches = 0; }
            // set these here for events (like a single tap) which don't hit crm.drawInteraction()
            if (!this.renderManager) {
                return;
            }
            this.renderManager.cursorX = point.x;
            this.renderManager.cursorY = point.y;
            if (this.dragMode === 0 /* NONE */) {
                if (this._handlePointerAction('LButtonDown', 'OnLeftButtonClick', point)) {
                    this._firePickEventing();
                    return;
                }
                this._doPrimaryPointerPick('LButtonDown', point, event);
            }
            var doRefresh = {
                value: false
            };
            var ret = false;
            if (this.rubberBandMode !== 0 /* NONE */ && !this.suppressAllInteraction) {
                if (this.rubberBandMode === 3 /* LINE */ && this.pickPoints.length < this._pickPointsLength &&
                    this._pickPointsLength > 2) {
                    var focusPlot = this.attributeSet.get('FocusPlot');
                    if (focusPlot.length === 0) {
                        focusPlot = this.activePlot;
                    }
                    var retPt = new Point(0, 0);
                    if (!this.snapMouseToSeries(point, retPt, null, event)) {
                        retPt = point;
                    }
                    this.pickPoints.push({
                        point: retPt,
                        series: this._snappingSeries
                    });
                    if (this.pickPoints.length === this._pickPointsLength) {
                        var out = [];
                        var result = '';
                        for (var _i = 0, _a = this.pickPoints; _i < _a.length; _i++) {
                            var trendPt = _a[_i];
                            var tmpStr = this._setWorldPtEvent(focusPlot, trendPt.point);
                            result += ' ' + tmpStr;
                            var _b = tmpStr.split(' '), xStr = _b[0], yStr = _b[1];
                            var tmp = {
                                X: xStr,
                                Y: yStr,
                                Series: trendPt.series ? trendPt.series : undefined
                            };
                            out.push(tmp);
                        }
                        this.pick.init('MultiTrend', retPt);
                        this.pick.setAccessObject(focusPlot);
                        this.pick.setAccessData(result.trim());
                        var axis = this._getWorldEventAxisId(focusPlot);
                        this.pick.setAccessDrilldown(axis);
                        this.pick.setAccessObjectPart(JSON.stringify(out));
                        var worldPts = this._pickPointsToArray(this.pick);
                        var plotObj = this.getTypedObject(focusPlot, isPlot).wrapper;
                        var axisObj = this.getTypedObject(axis, isAxis).wrapper;
                        // try to add a drawing tool, if we should
                        this._addDTFromTrend(plotObj, axisObj, worldPts);
                        this.wrapper.handleEvent('Trend', [plotObj, axisObj, worldPts]);
                        this.fireChartEvent(this.pick.accessMessage(), new Point(0, 0), this.pick.getPick());
                        this._onCancelMode();
                        doRefresh.value = true;
                    }
                }
                else {
                    this.pickPoints[0] = {
                        point: point,
                        series: this._snappingSeries
                    };
                }
            }
            else {
                doRefresh.value = true;
                var chartObject = this.getChild(this.pick.accessObject());
                var series = void 0;
                if (isSeries(chartObject)) {
                    series = chartObject;
                }
                if ((series != null) && this.clickTooltipEnabled && (!touch || (touch && numTouches === 1)) &&
                    !this.suppressAllInteraction) {
                    series.displayToolTip(point.x, point.y, Number(this.pick.accessSubObject()));
                    doRefresh.value = false;
                }
                else {
                    this.clickTooltip.hideTooltip();
                }
                if (!this.horizontalZoomEnabled || ((series != null) && series.isInteractive())) {
                    var selectionPermitted = chartObject && chartObject.isInteractive() &&
                        this.isPermittedSelectableObject(chartObject.getInteractivityObjectType());
                    var effectiveDraStyle = series ? series.getEffectiveDrawStyle() : -1;
                    var isPie = (effectiveDraStyle === 19 /* PIE */ || effectiveDraStyle === 36 /* PIE3D */);
                    if (selectionPermitted && isPie && series.pieDesc.explodeMode !== 0 /* NONE */) {
                        ret = this._startObjectInteraction(this.pick.accessObject(), point, event, doRefresh, 16 /* SINGLEINTERACTION */);
                    }
                    if (!ret) {
                        ret = this._startObjectInteraction(this.pick.accessObject(), point, event, doRefresh);
                    }
                }
                else {
                    this.emptyInteractionList();
                }
                this._doPrimaryPointerPick('LButtonDown', point, event);
                // to stop the cursor from being changed to a text select
                if (ret === false) {
                    if (this.pick.accessLClickAction().length !== 0 && !this.suppressAllInteraction) {
                        if (this.pick.accessLClickAction().substr(0, 12) === '<ActionList>') {
                            var driver = new FDSActionXMLDriver(point);
                            if (!driver.interpretXML(this, this.pick.accessLClickAction(), this.pick)) {
                                this._FDSThrowError('RichTextActionHandler', this.id, 'Rich text based action is malformed');
                            }
                        }
                        else {
                            var obj = this.getChild(this.pick.accessLClickAction());
                            if (typeof obj === 'undefined' || obj === null) {
                                this._FDSThrowError('HandlePointerAction', this.id, 'Action child object name invalid.');
                            }
                            else {
                                this.handleAction(this, this.pick.accessLClickAction(), point);
                            }
                        }
                    }
                    else {
                        this.fireChartEvent(this.pick.accessMessage(), this.pick.accessPoint(), this.pick.getPick());
                    }
                }
            }
            // this is a side-effect of "suppressAllInteraction" not suppressing all interaction.
            // in particular, calling draw() can blow away the current plotDragManager state
            if (this.renderManager && this.renderManager.plotDragManager) {
                doRefresh.value = doRefresh.value && !this.renderManager.plotDragManager.isActive();
            }
            doRefresh.value = doRefresh.value && !this.geoTooltipVisible; // don't overdraw the geo tooltip if it's showing
            if (doRefresh.value) {
                this.invalidate();
                this.renderManager.handleCrosshairEvent(point);
            }
        };
        FDSChart.prototype._pickPointsToArray = function (pick$$1) {
            var worldPts = [];
            var pickPts = pick$$1.accessData().split(' ');
            for (var i = 0; i < pickPts.length; i += 2) {
                var val = pickPts[i];
                var xWorld = Number(pickPts[i]);
                var yWorld = Number(pickPts[i + 1]);
                worldPts.push(new Point(xWorld, yWorld));
            }
            return worldPts;
        };
        FDSChart.prototype._handlePointerUp = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            var refresh = false;
            var fireEvent = true;
            var pickMatch = true;
            var point = this.renderManager.getCursorPos(event, true);
            this.doPick('LButtonUp', point);
            var eventData;
            if (this.dragMode === 10 /* PLOT_RESIZE */) {
                // no need to do all the series-based stuff below, just clear the dragmode
                this.dragMode = 0 /* NONE */;
                this.plotResizeManager.handleResizeDrag(point, true);
                refresh = true;
            }
            else if (this.dragMode !== 0 /* NONE */) {
                var focusPlot = this.attributeSet.get('FocusPlot');
                if (focusPlot === '') {
                    focusPlot = this.activePlot;
                }
                var axis = this._getWorldEventAxisId(focusPlot);
                var worldPts = void 0;
                var plotObj = void 0;
                var axisObj = void 0;
                switch (this.dragMode) {
                    case 2 /* PICKPOINT */:
                        this.pick.init('PickPoint', point);
                        this._setWorldPtEvent(focusPlot, point, this.pick);
                        this.pick.setAccessDrilldown(axis);
                        eventData = this.pick.getPick();
                        worldPts = this._pickPointsToArray(this.pick);
                        plotObj = this.getTypedObject(focusPlot, isPlot).wrapper;
                        axisObj = this.getTypedObject(axis, isAxis).wrapper;
                        this.wrapper.handleEvent('PickPoint', [plotObj, axisObj, worldPts[0]]);
                        // try to add a drawing tool, if we should
                        this._addDTFromPickPoint(plotObj, axisObj, worldPts[0]);
                        break;
                    case 5 /* TREND */:
                    case 6 /* DRAWBOX */:
                        if (this._pickPointsLength === 2) {
                            this.pick.init('Trend', point);
                            var ret = new Point(0, 0);
                            if (!this.snapMouseToSeries(point, ret, null, event)) {
                                ret = point;
                            }
                            this._setWorldRectEvent(focusPlot, this.pickPoints[0].point, ret, this.pick, true);
                            this.pick.setAccessDrilldown(axis);
                            eventData = this.pick.getPick();
                            worldPts = this._pickPointsToArray(this.pick);
                            plotObj = this.getTypedObject(focusPlot, isPlot).wrapper;
                            axisObj = this.getTypedObject(axis, isAxis).wrapper;
                            this.wrapper.handleEvent('Trend', [plotObj, axisObj, worldPts]);
                            // try to add a drawing tool, if we should
                            this._addDTFromTrend(plotObj, axisObj, worldPts);
                        }
                        else {
                            // dont fire event for lbuttonup when we are in multitrend mode
                            fireEvent = false;
                            pickMatch = false;
                        }
                        break;
                    case 1 /* PICK */:
                        pickMatch = this._pickMatchesObjectType();
                        this.pick.setAccessMessage('Pick');
                        this.pick.setAccessDrilldown(axis);
                        eventData = this.pick.getPick();
                        var object = this.getObject(this.pick.accessObject()).wrapper;
                        var pickDetails = {
                            subObject: this.pick.accessSubObject(),
                            axis: this.getTypedObject(axis, isAxis).wrapper,
                            plot: this.getTypedObject(focusPlot, isPlot).wrapper
                        };
                        // try to add a drawing tool, if we should
                        this._addDTFromPick(object, pickDetails);
                        this.wrapper.handleEvent('Pick', [object, pickDetails]);
                        break;
                    case 3 /* ZOOM */:
                        this.pick.init('Zoom', point);
                        this._setWorldRectEvent(focusPlot, this.pickPoints[0].point, point, this.pick, true);
                        break;
                }
                if (this.dragMode === 3 /* ZOOM */) {
                    if (this._simpleZoom(focusPlot, this.pickPoints[0].point, point, 1 /* ZOOM */)) {
                        refresh = true;
                    }
                    eventData = this.pick.getPick();
                }
                if (fireEvent && pickMatch) {
                    this.fireChartEvent(this.pick.accessMessage(), point, eventData);
                }
            }
            else if (this.horizontalZoomEnabled && this._isHorizontalZooming) {
                this.fireZoomEvent(this.activeSlider.leftPt, this.activeSlider.rightPt, this.activeSlider.axis);
                refresh = false;
            }
            else {
                var redrawTheWholeChart = false;
                if (!this._isInteractionListEmpty()) {
                    redrawTheWholeChart = this.interactionSignal.call(this.getInteractionObject(), point, event, 2 /* LMBUTTONUP */);
                }
                refresh = refresh || redrawTheWholeChart;
                if (redrawTheWholeChart) {
                    this.setNeedUpdate(true);
                }
            }
            if (pickMatch) {
                refresh = this._onCancelMode() || refresh;
            }
            if (refresh) {
                this.invalidate();
            }
        };
        // start the drawing tool event and mark that we should add it when done
        FDSChart.prototype._addDT = function (name, toolType, args, numPts) {
            if (numPts === void 0) { numPts = 2; }
            // save the callback for when we're done adding the DT
            this._addedDTCallback = args[0];
            this._addedDTAttributes = args[1];
            this._dontAddDTObjects = args[2];
            // key for cursor and tool enums. eg: FibArc -> FIBARC
            var key = name.toUpperCase();
            var cursor = Cursor[key];
            this._addingDT = DrawingToolExported[key];
            this._addingDTName = name;
            switch (toolType) {
                case 1 /* LINE */:
                    return this._onPopupTrendline(cursor, numPts);
                case 2 /* BOX */:
                    return this._onPopupDrawbox(cursor);
                case 3 /* PICK */:
                    return this._onPopupPick(cursor);
                case 4 /* PICKPOINT */:
                    return this._onPopupPickPoint(cursor);
            }
        };
        FDSChart.prototype._getDrawStyleFromDrawingTool = function (tool) {
            switch (tool) {
                case 7 /* PRICECHANGE */:
                    return 54 /* PRICE_CHANGE */;
                case 10 /* CIRCLE */:
                    return 55 /* ELLIPSE */;
                case 14 /* LINEARREGRESSION */:
                    return 21 /* REGRESSION */;
                case 15 /* AVERAGE */:
                    return 21 /* REGRESSION */;
                case 16 /* MEDIAN */:
                    return 21 /* REGRESSION */;
                case 17 /* AVGSTDDEV */:
                    return 21 /* REGRESSION */;
                case 20 /* SERIESTEXTBOX */:
                    return -1 /* NONE */;
                case 23 /* SPEEDRESISTANCE */:
                    return 50 /* SPEED_RESISTANCE_LEVELS */;
                case 25 /* MARKER */:
                    return 59 /* DRAGGABLE_MARKER */;
                case 1 /* TRENDLINE */:
                    return 53 /* TRENDLINE */;
                case 2 /* FIBARC */:
                    return 43 /* FIBARC */;
                case 3 /* FIBFAN */:
                    return 44 /* FIBFAN */;
                case 4 /* FIBRETRACEMENTS */:
                    return 42 /* FIBRETRACEMENTS */;
                case 5 /* FIBTIMEZONES */:
                    return 45 /* FIBTIMEZONES */;
                case 6 /* GANNFAN */:
                    return 46 /* GANNFAN */;
                case 8 /* HORIZONTAL */:
                    return 17 /* HORIZONTAL */;
                case 9 /* VERTICAL */:
                    return 16 /* VERTICAL */;
                case 11 /* RECT */:
                    return 27 /* RECT */;
                case 12 /* ARROW */:
                    return 56 /* ARROW */;
                case 18 /* QUADRANTLINES */:
                    return 47 /* QUADRANTLINES */;
                case 19 /* TIRONELEVELS */:
                    return 49 /* TIRONELEVELS */;
                case 21 /* ZIGZAG */:
                    return 51 /* ZIGZAG */;
                case 22 /* RAFFREGRESSION */:
                    return 48 /* RAFFREGRESSION */;
                case 24 /* FIBPROJECTION */:
                    return 57 /* FIBPROJECTION */;
                case 9 /* VERTICAL */:
                    return 16 /* VERTICAL */;
                case 8 /* HORIZONTAL */:
                    return 17 /* HORIZONTAL */;
                case 26 /* HARMONICMEAN */:
                    return 21 /* REGRESSION */;
                default:
                    return -1 /* NONE */;
            }
        };
        // helper fn because this is done all over the place
        FDSChart.prototype._getAxisTypesFromObj = function (yAxisObj, plotObj) {
            var xAxisObj = plotObj.getChildAxisByDimension('x');
            var xAxisType = xAxisObj.getAxisType();
            var yAxisType = yAxisObj.getAxisType();
            // String datasets need to be treated as float because the datapoints that are being used
            // for drawing tools are based around the index and not the actual string values.
            xAxisType = (xAxisType === 'STRING') ? 'FLOAT' : xAxisType;
            yAxisType = (yAxisType === 'STRING') ? 'FLOAT' : yAxisType;
            return { xAxisType: xAxisType, yAxisType: yAxisType };
        };
        FDSChart.prototype._getDTSeriesAndDataNames = function () {
            // eg: SERIES4(DT-Trendline2)
            var series = "SERIES" + this._addingDTCount + "(DT-" + (this._addingDTName + this._addingDTCount) + ")";
            var ret = {
                series: series,
                x: 'X(' + series + ')',
                y: 'Y(' + series + ')',
                label: 'LABEL(' + series + ')'
            };
            // now increase the number of tools
            // do this here so we start numbering at 0
            this._addingDTCount += 1;
            return ret;
        };
        FDSChart.prototype._addDTFromTrend = function (plotObj, axisObj, worldPts) {
            // quit out immediately if you aren't drawing a tool right now
            if (this._addingDT === 0 /* NONE */) {
                return;
            }
            // list of trendline/drawbox drawing tools
            if (!_$1.includes([
                1 /* TRENDLINE */, 2 /* FIBARC */, 3 /* FIBFAN */,
                23 /* SPEEDRESISTANCE */, 4 /* FIBRETRACEMENTS */, 24 /* FIBPROJECTION */,
                5 /* FIBTIMEZONES */, 6 /* GANNFAN */, 7 /* PRICECHANGE */, 12 /* ARROW */,
                10 /* CIRCLE */, 11 /* RECT */
            ], this._addingDT)) {
                return;
            }
            var _a = this._getAxisTypesFromObj(axisObj, plotObj), xAxisType = _a.xAxisType, yAxisType = _a.yAxisType;
            var xPoints = [];
            var yPoints = [];
            for (var _i = 0, worldPts_1 = worldPts; _i < worldPts_1.length; _i++) {
                var pt = worldPts_1[_i];
                xPoints.push(pt.x);
                yPoints.push(pt.y);
            }
            var names = this._getDTSeriesAndDataNames();
            var xData = new models.data({
                id: names.x,
                label: names.x,
                dataType: xAxisType,
                data: xPoints
            });
            var yData = new models.data({
                id: names.y,
                label: names.y,
                dataType: yAxisType,
                data: yPoints
            });
            var dtSeries = new models.series({
                id: names.series,
                label: names.series,
                x: xData,
                y: yData,
                drawStyle: -1 /* NONE */
            });
            var addedObjs;
            if (this._dontAddDTObjects) {
                addedObjs = {
                    parent: plotObj.id,
                    series: dtSeries,
                    x: xData,
                    y: yData,
                    attributes: [
                        { id: 'Frequency', val: 'S', obj: xData.id },
                        { id: 'Frequency', val: 'S', obj: yData.id }
                    ]
                };
            }
            else {
                addedObjs = {
                    series: names.series,
                    x: names.x,
                    y: names.y
                };
                plotObj.addSeries(dtSeries);
                xData.setAttribute('Frequency', 'app', 'S');
                yData.setAttribute('Frequency', 'app', 'S');
            }
            var attributes = [
                { id: 'InLegend', val: false },
                { id: 'AdjustAxes', val: false },
                { id: 'SeriesColor', val: 16761098 },
                { id: 'InteractionHandleFGColor', val: 15707648 },
                { id: 'InteractionHandleFGWidth', val: 5 },
                { id: 'SysPickable', val: false },
                { id: 'TooltipText', val: this._tooltipMap[this._addingDTName] }
            ];
            this._addDTAttrsAndDraw(dtSeries, attributes, addedObjs);
        };
        FDSChart.prototype._addDTFromPickPoint = function (plot, axis, point) {
            // quit out immediately if you aren't drawing a tool right now
            if (this._addingDT === 0 /* NONE */) {
                return;
            }
            // list of trendline/drawbox drawing tools
            if (!_$1.includes([8 /* HORIZONTAL */, 9 /* VERTICAL */, 13 /* TEXTBOX */], this._addingDT)) {
                return;
            }
            var _a = this._createSeriesAndData(this._addingDT, ['Enter Text Here.'], [point.x], [point.y], plot, axis), dtObjs = _a[0], names = _a[1];
            var addedObjs;
            if (this._dontAddDTObjects) {
                addedObjs = {
                    parent: plot.id,
                    series: dtObjs.series,
                    x: dtObjs.x,
                    y: dtObjs.y,
                    attributes: []
                };
            }
            else {
                addedObjs = {
                    series: names.series,
                    x: names.x,
                    y: names.y
                };
                plot.addSeries(dtObjs.series);
            }
            var attributes = [
                { id: 'InLegend', val: false },
                { id: 'AdjustAxes', val: false },
                { id: 'SeriesFGColor', val: 16761098 },
                { id: 'SysPickable', val: false },
                { id: 'InteractivityMode', val: -1 }
            ];
            if (this._addingDT === 13 /* TEXTBOX */) {
                if (this._dontAddDTObjects) {
                    addedObjs.label = dtObjs.label;
                }
                else {
                    addedObjs.label = names.label;
                }
            }
            this._addDTAttrsAndDraw(dtObjs.series, attributes, addedObjs);
        };
        FDSChart.prototype._createSeriesAndData = function (toolType, valueArr, xArr, yArr, plot, axis) {
            var names = this._getDTSeriesAndDataNames();
            var _a = this._getAxisTypesFromObj(axis, plot), xAxisType = _a.xAxisType, yAxisType = _a.yAxisType;
            var yAxisPrefix = axis.getPrefix();
            var vdata;
            if (toolType === 13 /* TEXTBOX */ || toolType === 20 /* SERIESTEXTBOX */) {
                vdata = new models.data({
                    dataType: 'string',
                    data: valueArr,
                    id: names.label,
                    label: ''
                });
            }
            var xdata = new models.data({
                id: names.x,
                dataType: xAxisType,
                data: xArr
            });
            var ydata = new models.data({
                id: names.y,
                dataType: yAxisType,
                data: yArr
            });
            var dtSeries = new models.series({
                drawStyle: -1 /* NONE */,
                id: names.series,
                label: names.series,
                x: xdata,
                y: ydata,
                value: vdata,
                onYAxis: yAxisPrefix
            });
            var objs = { series: dtSeries, x: xdata, y: ydata, label: vdata };
            return [objs, names];
        };
        FDSChart.prototype._addSeriesTextboxFromPick = function (object, pickInfo) {
            if (!(object instanceof FDSSeriesWrapper)) {
                return;
            }
            var yAxis = pickInfo.axis;
            var seriesData = object.getData();
            var seriesIndex = Number(pickInfo.subObject);
            var xPt = seriesData.x.getPoint(seriesIndex);
            var yPt = seriesData.y.getPoint(seriesIndex);
            var _a = this._createSeriesAndData(20 /* SERIESTEXTBOX */, ['Enter Text Here.'], xPt, yPt, pickInfo.plot, yAxis), dtObjs = _a[0], names = _a[1];
            var addedObjs;
            if (this._dontAddDTObjects) {
                addedObjs = {
                    parent: object.id,
                    series: dtObjs.series,
                    x: dtObjs.x,
                    y: dtObjs.y,
                    label: dtObjs.label,
                    attributes: []
                };
            }
            else {
                object.addSeriesChild(dtObjs.series);
                // we're using all 4 fields so we can just copy this over
                addedObjs = names;
            }
            var attributes = [
                { id: 'SeriesValueBGColor', val: 16777215 },
                { id: 'SeriesValueFGColor', val: 0 },
                { id: 'SeriesValueFontItalic', val: false },
                { id: 'SeriesValueFontUnderline', val: false },
                { id: 'SeriesValueFontColor', val: 0 },
                { id: 'SeriesValueFontHeight', val: 14 },
                { id: 'SeriesValueSizingMode', val: 1 },
                { id: 'SeriesValue', val: true },
                { id: 'SeriesFGStyle', val: 5 },
                { id: 'SeriesBGStyle', val: 1 },
                { id: 'IsAnnotation', val: true },
                { id: 'AnnotationDrawStyle', val: 27 /* RECT */ },
                { id: 'DrawStyle', val: 0 },
                { id: 'TooltipText', val: '' },
                { id: 'AnnotationSeriesValueArrow', val: true },
                { id: 'SeriesValueArrow', val: true },
                { id: 'SeriesValueYOffset', val: 40 },
                { id: 'InteractivityMode', val: -1 },
                { id: 'SysPickable', val: false },
                { id: 'DrawStyle', val: -1 }
            ];
            this._addDTAttrsAndDraw(dtObjs.series, attributes, addedObjs);
        };
        FDSChart.prototype._addDTFromPick = function (object, pickInfo) {
            if (!(object instanceof FDSSeriesWrapper)) {
                return;
            }
            // quit out immediately if you aren't drawing a tool right now
            if (this._addingDT === 0 /* NONE */) {
                return;
            }
            var series = object;
            if (this._addingDT === 20 /* SERIESTEXTBOX */) {
                this._addSeriesTextboxFromPick(series, pickInfo);
                return;
            }
            // list of pick drawing tools
            var pickDrawingTools = [
                14 /* LINEARREGRESSION */,
                15 /* AVERAGE */,
                16 /* MEDIAN */,
                17 /* AVGSTDDEV */,
                18 /* QUADRANTLINES */,
                19 /* TIRONELEVELS */,
                22 /* RAFFREGRESSION */,
                21 /* ZIGZAG */,
                25 /* MARKER */,
                26 /* HARMONICMEAN */,
            ];
            if (!(_$1.includes(pickDrawingTools, this._addingDT))) {
                return;
            }
            var plot = pickInfo.plot;
            var yAxis = pickInfo.axis;
            // We're going to cheat a bit here to get the data to add for the dt
            var seriesData = series.getData();
            var xData = seriesData.x;
            var yData = seriesData.y;
            var names = this._getDTSeriesAndDataNames();
            var dtSeries = new models.series({
                drawStyle: -1 /* NONE */,
                id: names.series,
                label: names.series,
                x: xData,
                y: yData
            });
            var addedObjs;
            if (this._dontAddDTObjects) {
                addedObjs = {
                    parent: plot.id,
                    series: dtSeries,
                    attributes: []
                };
            }
            else {
                plot.addSeries(dtSeries);
                addedObjs = { series: names.series };
            }
            var attributes = [
                { id: 'InLegend', val: false },
                { id: 'AdjustAxes', val: false },
                { id: 'SeriesColor', val: 16761098 },
                { id: 'InteractionHandleFGColor', val: 15707648 },
                { id: 'InteractionHandleFGWidth', val: 5 },
                { id: 'SysPickable', val: false },
            ];
            this._addDTAttrsAndDraw(dtSeries, attributes, addedObjs);
        };
        FDSChart.prototype._addDTAttrsAndDraw = function (series, attributes, addedObjs) {
            // moving styles that are based on series data around doesn't make any sense
            var seriesDataBasedDrawingTools = [
                14 /* LINEARREGRESSION */,
                15 /* AVERAGE */,
                16 /* MEDIAN */,
                17 /* AVGSTDDEV */,
                26 /* HARMONICMEAN */,
            ];
            if (!_$1.includes(seriesDataBasedDrawingTools, this._addingDT)) {
                attributes.push({ id: 'InteractivityMode', val: -1 });
            }
            // add these first because they may be overriden by the tool itself (specifically, the tooltip)
            attributes.push({ id: 'TooltipText', val: this._tooltipMap[this._addingDTName] }, { id: 'DrawingToolType', val: this._addingDT });
            switch (this._addingDT) {
                case 7 /* PRICECHANGE */:
                    var format = '<FDSIf COND=\"<FDSMath OP=\"GT\" L=\"<FDSMath OP=\"SUB\" L=\"<FDSLastY>\" R=\"<FDSFirstY>\">\" R=\"1\">\"' +
                        ' TRUE=\"<FDSProperty type=\"FLOAT\" value=\"<FDSMath OP=\"SUB\" L=\"<FDSLastY>\" R=\"<FDSFirstY>\">\" format=\"#.2F\">\"' +
                        ' FALSE=' +
                        '\"<FDSIf COND=\"<FDSMath OP=\"LT\" L=\"<FDSMath OP=\"SUB\" L=\"<FDSLastY>\" R=\"<FDSFirstY>\">\" R=\"-1\">\"' +
                        ' TRUE=\"<FDSProperty type=\"FLOAT\" value=\"<FDSMath OP=\"SUB\" L=\"<FDSLastY>\" R=\"<FDSFirstY>\">\" format=\"#.2F\">\"' +
                        ' FALSE=\"<FDSProperty type=\"FLOAT\" value=\"<FDSMath OP=\"SUB\" L=\"<FDSLastY>\" R=\"<FDSFirstY>\">\" format=\"#.4F\">\">\">' +
                        ' <FDSIf COND=\"<FDSMath OP=\"OR\" L=\"<FDSMath OP=\"LTE\" L=\"<FDSFirstY>\" R=\"0\">  \" R=\"<FDSMath OP=\"LTE\" L=\"<FDSLastY>\"' +
                        ' R=\"0\">\">\"' + ' TRUE=\"\"' +
                        ' FALSE=\"<FDSProperty type=\"FLOAT\" value=\"<FDSMath OP=\"MUL\" L=\"100\" ' +
                        'R=\"<FDSMath OP=\"SUB\" ' +
                        'L=\"<FDSMath OP=\"DIV\" L=\"<FDSLastY>\" R=\"<FDSFirstY>\">\" ' + 'R=\"1\">\">\" ' +
                        'format=\"#.2%F\">\">';
                    attributes.push({ id: 'SeriesMarkerSize', val: 8 }, { id: 'SeriesLabel1LevelsMask', val: 2 }, { id: 'PositiveColor', val: 3394560 }, { id: 'NegativeColor', val: 255 }, { id: 'SeriesLabel1Format', val: format });
                    break;
                case 12 /* ARROW */:
                    attributes.push({ id: 'ArrowLengthScale', val: 4 }, { id: 'ArrowSize', val: 4 }, { id: 'ArrowWidthScale', val: 4 }, { id: 'SeriesBGStyle', val: 0 });
                    break;
                case 10 /* CIRCLE */:
                    attributes.push({ id: 'SeriesBGStyle', val: 1 }, { id: 'SeriesFGColor', val: 16761098 });
                    break;
                case 2 /* FIBARC */:
                    attributes.push({ id: 'FibonacciLevels', val: 30 }, { id: 'SeriesLabel1Format', val: '#.1F%' }, { id: 'SeriesLabel1FontHeight', val: 12 }, { id: 'SeriesLabel1FontEscapement', val: 2900 });
                    break;
                case 3 /* FIBFAN */:
                    attributes.push({ id: 'FibonacciLevels', val: 14 }, { id: 'ExtendLine', val: true }, { id: 'SeriesLabel1Format', val: '#.1F%' }, { id: 'SeriesLabel1FontHeight', val: 12 });
                    break;
                case 5 /* FIBTIMEZONES */:
                    attributes.push({ id: 'ExtendLine', val: true }, { id: 'SeriesFGStyle', val: 1 }, { id: 'BaselineFGStyle', val: 1 }, { id: 'SeriesLabel1Format', val: '#I' }, { id: 'SeriesLabel1FontHeight', val: 12 });
                    break;
                case 11 /* RECT */:
                    attributes.push({ id: 'SeriesBGStyle', val: 1 }, { id: 'SeriesFGColor', val: 16761098 });
                    break;
                case 4 /* FIBRETRACEMENTS */:
                    attributes.push({ id: 'SeriesFGStyle', val: 3 }, { id: 'SeriesLabel1Format', val: '#.1F%' }, { id: 'SeriesLabel1FontHeight', val: 12 }, { id: 'SeriesLabel2Format', val: '#.2F' }, { id: 'SeriesLabel2FontHeight', val: 12 }, { id: 'BaselineFGStyle', val: 3 });
                    break;
                case 14 /* LINEARREGRESSION */:
                    attributes.push({ id: 'SeriesFGStyle', val: 1 }, { id: 'RegressionFormulaInterceptIsMin', val: true }, { id: 'SeriesQuickLabel', val: false });
                    break;
                case 15 /* AVERAGE */:
                    attributes.push({ id: 'SeriesFGStyle', val: 1 }, { id: 'RegressionFormulaInterceptIsMin', val: true }, { id: 'SeriesQuickLabel', val: false }, { id: 'SeriesQuickLabelText', val: 'AVG: <FDSRegressionFormula>' }, { id: 'RegressionOrder', val: 0 }, { id: 'RegressionFormulaInterceptIsMin', val: true }, { id: 'RegressionFormulaY', val: '' });
                    break;
                case 16 /* MEDIAN */:
                    attributes.push({ id: 'SeriesFGStyle', val: 1 }, { id: 'SeriesQuickLabel', val: false }, { id: 'SeriesQuickLabelText', val: 'MED: <FDSRegressionFormula>' }, { id: 'RegressionOrder', val: 0 }, { id: 'RegressionZeroOrderIsMedian', val: true }, { id: 'RegressionFormulaInterceptIsMin', val: true }, { id: 'RegressionFormulaY', val: '' });
                    break;
                case 17 /* AVGSTDDEV */:
                    attributes.push({ id: 'SeriesFGStyle', val: 1 }, { id: 'SeriesQuickLabel', val: false }, { id: 'RegressionOrder', val: 0 }, { id: 'RegressionStdDevBands', val: 1 }, { id: 'RegressionStdDevMirror', val: true }, { id: 'RegressionFormulaInterceptIsMin', val: true }, { id: 'RegressionFormulaY', val: '' });
                    break;
                case 21 /* ZIGZAG */:
                    attributes.push({ id: 'SeriesFGStyle', val: 1 });
                    break;
                case 25 /* MARKER */:
                    attributes.push({ id: 'SeriesMarkerSize', val: 30 });
                    break;
                case 13 /* TEXTBOX */:
                    attributes.push({ id: 'SeriesValueBGColor', val: 16777215 }, { id: 'SeriesValueFGColor', val: 0 }, { id: 'SeriesValueFontItalic', val: false }, { id: 'SeriesValueFontUnderline', val: false }, { id: 'SeriesValueFontColor', val: 0 }, { id: 'SeriesValueFontHeight', val: 14 }, { id: 'SeriesValueSizingMode', val: 1 }, { id: 'SeriesValue', val: true }, { id: 'SeriesFGStyle', val: 5 }, { id: 'SeriesBGStyle', val: 1 }, { id: 'IsAnnotation', val: true }, { id: 'AnnotationDrawStyle', val: 27 /* RECT */ }, { id: 'TooltipText', val: '' });
                    break;
                case 20 /* SERIESTEXTBOX */:
                    attributes.push({ id: 'TooltipText', val: '' });
                    break;
                case 26 /* HARMONICMEAN */:
                    attributes.push({ id: 'SeriesFGStyle', val: 1 }, { id: 'SeriesQuickLabel', val: false }, { id: 'SeriesQuickLabelText', val: 'HARMONICMEAN: <FDSRegressionFormula>' }, { id: 'RegressionOrder', val: 0 }, { id: 'RegressionZeroOrderIsHarmonicMean', val: true }, { id: 'RegressionFormulaInterceptIsMin', val: true }, { id: 'RegressionFormulaY', val: '' });
                    break;
            }
            var ds = this._getDrawStyleFromDrawingTool(this._addingDT);
            if (ds != null) {
                attributes.push({ id: 'DrawStyle', val: ds });
            }
            // add in any user-specified attributes (these should override the above ones)
            if (_$1.isArray(this._addedDTAttributes) && this._addedDTAttributes.length > 0) {
                attributes = attributes.concat(this._addedDTAttributes);
            }
            if (!this._dontAddDTObjects) {
                series.setAttributes([{ level: 'app', attrs: attributes }]);
            }
            else {
                // we have to add the series id to the attributes
                for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
                    var attr = attributes_1[_i];
                    attr.obj = series.id;
                    addedObjs.attributes.push(attr);
                }
            }
            this.invalidate();
            if (typeof this._addedDTCallback === 'function') {
                this._addedDTCallback(addedObjs);
            }
            this._addingDT = 0 /* NONE */;
            this._addedDTCallback = undefined;
            this._addedDTAttributes = [];
        };
        FDSChart.prototype._handlePointerAction = function (pickName, actionAttributeName, point) {
            this.doPick(pickName, point);
            if (this.suppressAllInteraction || !this.renderManager) {
                return false;
            }
            var chartObject = this.getChild(this.pick.accessObject());
            if (chartObject) {
                chartObject.processEventHandling(pickName, this.pick, point);
                return this._actionHandlerHook(actionAttributeName, chartObject, this.pick);
            }
            else {
                this._FDSThrowError('HandlePointerAction', '', 'Picked chart object does not exist');
            }
            return false;
        };
        FDSChart.prototype._actionHandlerHook = function (actionAttributeName, object, pick$$1) {
            if (object == null) {
                this._FDSThrowError('ActionHandlerHook', object.id, 'Object not defined');
            }
            var retval = object.attributeSet.get(actionAttributeName);
            if (typeof retval === 'string' && retval.length > 0) {
                var propInfo = void 0;
                if (isSeries(object)) {
                    var index = Number(pick$$1.accessSubObject());
                    propInfo = { seriesIndex: index, allowNL: true };
                }
                var resolved = object.properties.compilePropertyString(retval).fromValue(propInfo);
                if (resolved.length > 0) {
                    if (this.handleAction(object, resolved, pick$$1.accessPoint())) {
                        this.emptyInteractionList();
                        return true;
                    }
                }
                else {
                    this._FDSThrowError('ActionHandlerHook', object.id, 'Resolved attribute not defined');
                }
            }
            return false;
        };
        FDSChart.prototype.handleAction = function (chartObject, actionName, point) {
            var dataSet = this.getTypedObject(actionName, isDataSet);
            if (dataSet == null) {
                this._FDSThrowError('HandleAction', chartObject.id, 'Action child object name invalid.');
                return false;
            }
            if (dataSet.dataType !== 'STRING') {
                this._FDSThrowError('HandleAction', dataSet.id, 'DataSet not defined or not of type STRING.');
                return false;
            }
            for (var index = 0; index < dataSet.data.length; index++) {
                var elem = dataSet.data[index];
                if (dataSet != null) {
                    var action = dataSet.getAt(index, 0);
                    if (action.length > 0) {
                        var driver = new FDSActionXMLDriver(point);
                        if (!driver.interpretXML(chartObject, action, this.pick)) {
                            this._FDSThrowError('HandleAction', chartObject.id, "Action XML not interpreted properly at index = " + index);
                        }
                    }
                    else {
                        this._FDSThrowError('HandleAction', chartObject.id, "Given action does not have a length at index = " + index);
                    }
                }
            }
            return true;
        };
        FDSChart.prototype._FDSThrowError = function (method, object, error) {
            var errMsg;
            if (arguments.length === 1) {
                errMsg = method;
            }
            else {
                errMsg = method + " on " + object + " -> " + error;
            }
            if (this.attributeSet.get('Exceptions')) {
                throw errMsg;
            }
        };
        FDSChart.prototype._handleMouseMove = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            this._handleEventOnSeriesRenderCache('MouseMove', event);
            if (!this.interacting) {
                // it is now
                this.interacting = true;
                if (this.renderManager) {
                    this.renderManager.startInteraction(event);
                }
            }
            if (this.renderManager) {
                this.renderManager.drawInteraction(event);
            }
            event.preventDefault();
        };
        FDSChart.prototype._handleMouseOver = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            this.interacting = true;
            if (this.renderManager) {
                this.renderManager.startInteraction(event);
            }
        };
        FDSChart.prototype._checkMouseOut = function (event) {
            // check if this event is truly a mouseout event
            var target = event.currentTarget ? event.currentTarget : event.srcElement;
            var child = event.relatedTarget ? event.relatedTarget : event.toElement;
            while (child && child.parentElement) {
                if (target === child) {
                    return false;
                }
                child = child.parentElement;
            }
            return true;
        };
        FDSChart.prototype._handleMouseOut = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            var needsFullRedraw = this._handleEventOnSeriesRenderCache('MouseOut', event);
            var needsAnyRedraw = this._renderLayerManager.linkContainer.resetHoverStates();
            this.interacting = false;
            if (this._checkMouseOut(event)) {
                this.renderManager.stopInteraction(event, needsFullRedraw, needsAnyRedraw);
            }
        };
        FDSChart.prototype._handleTouchEnd = function (event) {
            var _this = this;
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            this._handleEventOnSeriesRenderCache('TouchEnd', event);
            if (this._touchMode === 1 /* TAP */) {
                // set up timeout counter
                this._tapCount = this._tapCount + 1;
                if (this._tapCount === 1) {
                    var clientRect = this.containing_element.getBoundingClientRect();
                    var x_1 = scaleByDevicePixelRatio(event.changedTouches[0].clientX - clientRect.left);
                    var y_1 = scaleByDevicePixelRatio(event.changedTouches[0].clientY - clientRect.top);
                    setTimeout((function () { return _this._tapTimeout(x_1, y_1, event, true); }), CLICK_TIMEOUT_MS);
                }
            }
            if (event.touches.length === 0) {
                this._handlePointerUp(event);
                // done touching entirely! reset the touch counter
                this._touchMode = 0 /* NONE */;
                this.interacting = false;
                if (this.renderManager != null) {
                    this.renderManager.stopInteraction(event);
                }
            }
            if (this._touchTimeout != null) {
                clearTimeout(this._touchTimeout);
            }
        };
        FDSChart.prototype._tapTimeout = function (x, y, event, touch) {
            if (touch === void 0) { touch = false; }
            var which = event['which'];
            if (this._tapCount === 1) {
                if (which === 1 /* LEFT */) {
                    this._handlePointerDown(new Point(x, y), event, true, 1);
                }
            }
            else if (this._tapCount === 2) {
                var point = new Point(x, y);
                if (touch || which === 1 /* LEFT */) {
                    this._handleDoublePointer(point, event);
                }
                else if (which === 2 /* MIDDLE */) {
                    this._handleMButtonDoubleClick(point, event);
                }
                else if (which === 3 /* RIGHT */) {
                    this._handleRButtonDoubleClick(point, event);
                }
            }
            return this._tapCount = 0;
        };
        FDSChart.prototype._handleTouchMove = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            this._handleEventOnSeriesRenderCache('TouchMove', event);
            // we're not tapping if we're moving
            this._touchMode = 2 /* GESTURE */;
            // want to cancel the long press if you move
            if (this._touchTimeout != null) {
                clearTimeout(this._touchTimeout);
            }
            if (this.renderManager) {
                this.renderManager.drawInteraction(event);
            }
        };
        FDSChart.prototype._handlePointerMove = function (event, point) {
            // If we haven't initialized the render manager, there is nothing to do yet
            if (!this.renderManager) {
                return;
            }
            this._snappedPoint = null;
            point = this.renderManager.getCursorPos(event);
            this.doPick('OnMouseMove', point);
            // Save the picked cursor so the tooltip pick doesn't wipe it out
            var hoverCursor = this.pick.cursor;
            // we return *after* we pick the pickpoint because we need that info to select a series when we click
            if (this.suppressAllInteraction) {
                return;
            }
            var doRefresh = false;
            if (this.rubberBandMode === 0 /* NONE */ && this.dragMode === 0 /* NONE */) {
                var hit = this.doPick('Tooltip', point);
                var richTextChanged = this._renderLayerManager.linkContainer.updateHoverStates(point);
                if (this.tooltipHandled) {
                    // tooltip already handled (eg, by geo heatmap svg), don't override it. but also unset this flag.
                    this.tooltipHandled = false;
                }
                else {
                    this.tooltip.doTooltip(hit, event);
                }
                if (!this._isFocusedSliderHere(point)) {
                    this._setCursor(this._getCursorName(this.pick));
                }
                if (!this._isInteractionListEmpty()) {
                    doRefresh = this.interactionSignal.call(this.getInteractionObject(), point, event, 1 /* MOUSEMOVE */);
                }
                if (doRefresh) {
                    this.renderManager.draw(false);
                    this.drawSnappedMarker();
                }
                else if (richTextChanged) {
                    this.renderRichTextLinks();
                }
            }
            else if (this.rubberBandMode === 1 /* POINT */) {
                if (this.dragMode === 1 /* PICK */) {
                    if (this._pickMatchesObjectType()) {
                        this._setCursor(this._getCursorData(this._pickMatchCursor));
                    }
                    else {
                        this._setCursor(Cursor.NOT_ALLOWED);
                    }
                    return;
                }
            }
            if (this.interactionCursor !== Cursor.DEFAULT) {
                this._setCursor(this._getCursorData(this.interactionCursor));
            }
            else {
                if (hoverCursor !== '') {
                    this._setCursor(this._getCursorData(hoverCursor));
                }
            }
        };
        FDSChart.prototype._handleDoubleClick = function (event) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            var point = this.renderManager.getCursorPos(event);
            this._handleDoublePointer(point, event);
        };
        FDSChart.prototype._handleClick = function (event) {
            return this._handleEventOnSeriesRenderCache('MouseClick', event);
        };
        FDSChart.prototype._handleMouseWheel = function (event) {
            return this._handleEventOnSeriesRenderCache('MouseWheel', event);
        };
        FDSChart.prototype._handleDoublePointer = function (point, event) {
            if (this.dragMode === 0 /* NONE */) {
                if (this._handlePointerAction('LButtonDblClick', 'OnLeftButtonDoubleClick', point)) {
                    this._firePickEventing();
                    return;
                }
            }
            if (this.doPick('Pick', point)) {
                this._firePickEventing();
            }
            var doRefresh = { value: false };
            this._startObjectInteraction(this.pick.accessObject(), point, event, doRefresh, 10 /* STARTINTERACTION_LMBUTTON_DBLCLICK */);
            if (doRefresh.value) {
                this.invalidate();
            }
        };
        FDSChart.prototype._handleRButtonDoubleClick = function (point, event) {
            if (this.dragMode === 0 /* NONE */) {
                if (this._handlePointerAction('RButtonDblClick', 'OnRightButtonDoubleClick', point)) {
                    this._firePickEventing();
                }
            }
        };
        FDSChart.prototype._handleMButtonDoubleClick = function (point, event) {
            if (this.dragMode === 0 /* NONE */) {
                if (this._handlePointerAction('MButtonDblClick', 'OnMiddleButtonDoubleClick', point)) {
                    this._firePickEventing();
                }
            }
        };
        FDSChart.prototype._handleZoom = function (zoomGroup, start, end) {
            if (this.suppressAllInteraction || !this.renderManager) {
                return;
            }
            for (var id in this.objects) {
                // if this object has an updateFromSlider method, assume it is an axis
                var obj = this.objects[id];
                if (isAxis(obj) && obj.zoomEnabled && obj.zoomGroup === zoomGroup) {
                    obj.updateFromSlider(start, end);
                }
            }
            // need to redraw to update the changed plot
            this.invalidate();
        };
        FDSChart.prototype.setActiveSlider = function (slider, point) {
            this._isHorizontalZooming = true;
            this.activeSlider = slider;
            this.activeSlider.setDragOffset(point);
        };
        FDSChart.prototype._clearActiveSlider = function () {
            // Defensive coding... this method can get called even if there isn't an active slider
            // in particular, when setting zoom extents via the API, there isn't an active slider
            // (unless one was simultaneously being dragged when the api call happened).
            if (this.activeSlider) {
                this.activeSlider.active = false;
                this.activeSlider.dragPoint = null;
            }
            this.activeSlider = null;
            this._isHorizontalZooming = false;
        };
        FDSChart.prototype.didTriggerResize = function (options) {
            var _a = options ? options : {}, _b = _a.redraw, redraw = _b === void 0 ? true : _b, _c = _a.userWidth, userWidth = _c === void 0 ? null : _c, _d = _a.userHeight, userHeight = _d === void 0 ? null : _d;
            var hasUserDims = (userWidth != null || userHeight != null);
            if (hasUserDims) {
                if (userWidth != null) {
                    this._userWidth = userWidth;
                }
                if (userHeight != null) {
                    this._userHeight = userHeight;
                }
            }
            // Resizing the canvas, or more likely rotating the host device, should
            // clear all interactions
            if (this.renderManager) {
                this.renderManager.clearInteractions();
            }
            this._resetCanvasSize(hasUserDims);
            if (redraw) {
                this.invalidate();
            }
            if (this.minimumSizeManager) {
                // Resizing canvases resets their contexts, so we do not need to reset their scaling.
                this.minimumSizeManager.resetScale({ chartRectsNeedScaling: false, canvasesNeedScaling: false });
                this.minimumSizeManager.scaleRenderingContextForMinimumSize();
            }
        };
        FDSChart.prototype._addObject = function (id, object) {
            this.objects[id] = object;
            this.addChild(object);
            if (isPlot(object) && !object.isStyleObject) {
                this.chartPlotList.push(object);
                this.wrapper.setPlotListDirty();
            }
        };
        // Searches parentElement for the children based on the selector of
        // objectPrototype and adds them to the chart-wide object list.
        // returns an array of newly-created objects
        FDSChart.prototype._addAllObjects = function (parentElement, objectPrototype, createObjects) {
            var newObjects = [];
            var objects = parentElement.getElementsByTagName(objectPrototype.selector);
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < objects.length; i++) {
                var objectTag = objects[i];
                var objID = objectTag.getAttribute('ID');
                if (!objID) {
                    continue;
                }
                var chartObject = void 0;
                if (this.isDefaultStyleObject(objID)) {
                    this._addStyleObjectXML(createObjects, this._getReservedType(objID), objID, objectTag);
                }
                else {
                    if (createObjects) {
                        chartObject = new objectPrototype(this, objID);
                        this._addObject(objID, chartObject);
                        newObjects.push(chartObject);
                    }
                    else {
                        chartObject = this._getObjectByPrototype(objID, objectPrototype);
                    }
                    if (chartObject) {
                        chartObject.initFromElement(objectTag);
                    }
                }
            }
            return newObjects;
        };
        // Searches parentElement for the children based on the object type given
        // and adds them to the chart-wide object list. doesn't return anything
        // since style objects have no children
        FDSChart.prototype._addAllStyleObjects = function (parentElement, objectType, createObjects) {
            var newObjects = [];
            var objects = parentElement.getElementsByTagName(objectType);
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < objects.length; i++) {
                var objectTag = objects[i];
                var objID = objectTag.getAttribute('ID');
                if (objID) {
                    this._addStyleObjectXML(createObjects, this._getObjectTypeFromString(objectType), objID, objectTag);
                }
            }
        };
        FDSChart.prototype._addStyleObjectXML = function (createObjects, objectType, objID, objectTag) {
            var objectPrototype;
            var chartObject;
            if (createObjects) {
                switch (objectType) {
                    case 11 /* FC_SERIES_STYLE */:
                        objectPrototype = FDSSeriesStyle;
                        break;
                    case 13 /* FC_PLOT_STYLE */:
                        objectPrototype = FDSPlotStyle;
                        break;
                    case 10 /* FC_DATA_STYLE */:
                        objectPrototype = FDSDataStyle;
                        break;
                    case 16 /* FC_AXIS_STYLE */:
                        objectPrototype = FDSAxisStyle;
                        break;
                    case 17 /* FC_CHART_STYLE */:
                        objectPrototype = FDSChartStyle;
                        break;
                    default:
                        return;
                }
                chartObject = new objectPrototype(this, objID);
                this.addStyleObject(chartObject);
                chartObject.attributeSet.setDirty(false);
                this.attributeSet.setDirty(true);
            }
            else {
                chartObject = this._getObjectByPrototype(objID, objectPrototype);
                if ((chartObject == null) && this.isDefaultStyleObject(objID)) {
                    // If we didn't get a valid chart object from `objID`, then it's
                    // probably a default style object, which we'll need to create.
                    chartObject = new objectPrototype(this, objID);
                    this.addStyleObject(chartObject);
                }
            }
            chartObject.initFromElement(objectTag);
            this._addObject(objID, chartObject);
        };
        // Browser-agnostic XML parsing
        FDSChart.prototype._parseXML = function (xmlString) {
            if (!_$1.isString(xmlString)) {
                return xmlString;
            }
            try {
                if (typeof DOMParser !== 'undefined') {
                    var parser = new DOMParser();
                    return parser.parseFromString(xmlString, 'text/xml');
                }
                else if (typeof window['ActiveXObject'] !== 'undefined') {
                    var doc = new window['ActiveXObject']('Microsoft.XMLDOM');
                    doc.loadXML(xmlString);
                    return doc;
                }
                else {
                    return null;
                }
            }
            catch (error) {
                return null;
            }
        };
        FDSChart.prototype._parseJSON = function (jsonString) {
            try {
                return JSON.parse(jsonString);
            }
            catch (error) {
                return null;
            }
        };
        FDSChart.prototype._resetChart = function () {
            this.tooltip.cleanUp();
            this.contextMenu.destroyMenu();
            this.progressSpinner.hide();
            this.animationManager.reset();
            this.clickTooltip.hideTooltip();
            if (this.minimumSizeManager) {
                this.minimumSizeManager.resetScale();
            }
            var deleteItem = function (collection, key) { return delete collection[key]; };
            // TODO: can these just be replaced with this.objects = {} etc?
            for (var key in this.objects) {
                deleteItem(this.objects, key);
            }
            for (var key in this.children) {
                deleteItem(this.children, key);
            }
            for (var key in this.attributeSet) {
                deleteItem(this.attributeSet, key);
            }
            this._init();
            // clear canvas including any svg map stuff
            this._clearCanvas(true);
        };
        FDSChart.prototype._cleanUp = function () {
            var _this = this;
            var nodesToRemove = [];
            var patternsToRemove = [hZoomSliderRegion, 'Blur', svgDivClassPrefix];
            // clean up any stray slider divs
            if (this.containing_element) {
                // tslint:disable-next-line:prefer-for-of
                for (var i = 0; i < this.containing_element.childNodes.length; i++) {
                    var node = this.containing_element.childNodes[i];
                    if (!(node instanceof HTMLDivElement)) {
                        continue;
                    }
                    for (var _i = 0, patternsToRemove_1 = patternsToRemove; _i < patternsToRemove_1.length; _i++) {
                        var pattern = patternsToRemove_1[_i];
                        if ((node.id.indexOf(pattern)) !== -1 || node.className.indexOf(pattern) !== -1) {
                            nodesToRemove.push(node);
                        }
                    }
                }
            }
            return nodesToRemove.map(function (node) {
                return _this.containing_element.removeChild(node);
            });
        };
        FDSChart.prototype._clearCanvas = function (deleteDivs) {
            if (deleteDivs === void 0) { deleteDivs = false; }
            var ctx = this.getContext();
            var uiCtx = this.getUIContext();
            var overlayCtx = this.getOverlayContext();
            ctx.clear();
            uiCtx.clear();
            overlayCtx.clear();
            if (deleteDivs) {
                this._cleanUp();
            }
        };
        FDSChart.prototype._preDraw = function () {
            if (this._stateChanged) {
                this.fireChartEvent('StateChanged', { x: 0, y: 0 }, '');
            }
            if (!this.preserveTreemapTooltip) {
                this.tooltip.hide();
                this.tooltip.resetTimeouts();
            }
            this.contextMenu.destroyMenu();
            // remove any tooltips
            this.setCrosshairTooltipOptions({
                visible: false
            });
        };
        FDSChart.prototype._clearAutomationPixelPoints = function () {
            this.pixelPoints = {};
            this.infoboxPixelPoints = {};
            this.plotSliderPixelPoints = {};
            this.plotGrabberPixelPoints = {};
            this.zoomSliderPixelPoints = {};
            this.interactionHandlePixelPoints = {};
            this.interactionElements = [this.containing_element];
            this.legendPixelPoints = {};
            this.axisTitlePixelPoints = {};
            this.quicklabelPixelPoints = {};
            this.seriesLabelPixelPoints = {};
            this.headerPixelPoints = {};
            this.heatmapLegendLabels = {};
        };
        // Clear the canvas and force a redraw of the entire chart.
        FDSChart.prototype.draw = function () {
            if (!this.containing_element) {
                return;
            }
            if (this.renderManager && this.renderManager.plotDragManager && this.renderManager.plotDragManager.isDragging()) {
                console.log('FDSChart.draw(): Suppressed by PlotDragManager');
                return;
            }
            if (this.progressSpinner && this.progressSpinner.isSpinning) {
                console.log('FDSChart.draw(): Suppressed by progress spinner');
                return;
            }
            // Cancel any pending invalidates in the event draw was called synchronously before it triggered.
            if (this.hasQueuedInvalidate()) {
                this.cancelQueuedInvalidate();
            }
            var startTime = timerFunc();
            this._clearCanvas();
            if (this.renderManager == null) {
                this.renderManager = new ChartRenderManager(this);
            }
            this._preDraw();
            this.renderManager.draw();
            this._setStateChanged(false);
            var endTime = timerFunc();
            var duration = (endTime - startTime);
            if (ENABLE_DEBUG && this.commonDebug) {
                if (this.isMockDrawing()) {
                    console.log("[nop-canvas] FDSChart.draw(): " + (duration).toFixed(3) + "ms");
                }
                else {
                    console.log("FDSChart.draw(): " + (duration).toFixed(3) + "ms");
                }
            }
            if (!this.isMockDrawing()) {
                this._postDraw();
            }
            this._dispatchEvent('ChartRender', { startTime: startTime, endTime: endTime, duration: duration });
        };
        FDSChart.prototype._postDraw = function () {
            var hooks = this.postDrawHooks;
            this.postDrawHooks = [];
            for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {
                var evt = hooks_1[_i];
                evt();
            }
        };
        // Get the chart object specified by `objectId` regardless of type
        // if subObjectId is provided, function returns that instead, or objectId for invalid or unknown sub-objects
        // For example, if objectId is Plot1, and subObjectId is YAxis, return the FC_Plot1_Y_Axis instead.
        // However, if objectId is Plot1, and subObjectId is FunkyChicken, we return the Plot1 object.
        FDSChart.prototype.getObject = function (objectId, subObjectId) {
            if (objectId == null) {
                return null;
            }
            var obj = objectId.length === 0 || objectId === 'FC_CHART' || objectId === 'FDSChart' ?
                this :
                this.objects[objectId];
            if (!_$1.isString(subObjectId)) {
                return obj;
            }
            // parse the subobject when applicable, and attempt to return that object instead
            // For example, if objectId is Plot1, and subObjectId is YAxis, return the FC_Plot1_Y_Axis instead.
            if (isPlot(obj)) {
                var match = subObjectId.match(/^(.+)(Axis|AxisTitle)$/);
                if (match) {
                    subObjectId = match[1];
                    if (_$1.includes(['X', 'Y', 'Y2', 'Y3', 'Y4', 'Z', 'Color', 'DSIZE', 'HIT'], subObjectId)) {
                        subObjectId = "FC_" + objectId + "_" + subObjectId + "_AXIS";
                    }
                    obj = this.getObject(subObjectId);
                }
                else if (subObjectId === 'Legend') {
                    obj = this.getObject(objectId + "_Legend");
                }
            }
            return obj;
        };
        FDSChart.prototype.getRoot = function () {
            return this;
        };
        // Get an object of a particular `type`, returning `undefined` if the object
        // either isn't found or isn't of the specified type
        FDSChart.prototype.getTypedObject = function (id, typeCheck) {
            var obj = this.objects[id];
            if (typeCheck(obj)) {
                return obj;
            }
            else {
                return undefined;
            }
        };
        FDSChart.prototype._getObjectByPrototype = function (objectId, type) {
            if ((this.objects[objectId] != null) && this.objects[objectId] instanceof type) {
                return this.objects[objectId];
            }
            else {
                return undefined;
            }
        };
        FDSChart.prototype.loadFromJSONString = function (jsonString) {
            if (!jsonString) {
                return;
            }
            var chartJSON;
            if (typeof jsonString === 'object') {
                // it's probably already been parsed by http get or something
                chartJSON = jsonString;
            }
            else {
                chartJSON = this._parseJSON(jsonString);
            }
            if (!chartJSON) {
                return;
            }
            this._loadChartFromJSON(chartJSON);
            if (this._styleSet) {
                this._loadChartFromJSON(this._styleSet);
            }
        };
        FDSChart.prototype.loadFromXMLString = function (xmlString) {
            if (!xmlString) {
                return false;
            }
            var chartDOM = this._parseXML(xmlString);
            var returnValue = this._loadChartFromDOM(chartDOM);
            if (returnValue && this._styleSet) {
                this._loadChartFromJSON(this._styleSet);
            }
            return returnValue;
        };
        FDSChart.prototype._loadChartFromJSON = function (chartJSON) {
            if (!chartJSON) {
                return;
            }
            // this is the equivalent of "refresh" which is default
            var clearAll = true;
            var createObjects = true;
            if (typeof chartJSON.action === 'string') {
                if (chartJSON.action === 'append') {
                    clearAll = false;
                }
                else if (chartJSON.action === 'snippit') {
                    createObjects = false;
                    this.setAllChildrenDirty(); // C++ side doesn't do this, but we do with XML - ???
                }
            }
            if (clearAll && createObjects) {
                this._resetChart();
            }
            this._processAllAttributesFromObject('', chartJSON);
            var objects = chartJSON.objects;
            if (!objects.length) {
                return;
            }
            var seriesObjects = [];
            var otherObjects = [];
            for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
                var object = objects_1[_i];
                if (object == null) {
                    continue;
                }
                this._processChartObject(object, createObjects);
                if (object.type === 'FDSSeries') {
                    seriesObjects.push(object);
                }
                else {
                    otherObjects.push(object);
                }
            }
            // Make a second pass over the chart objects to establish parent/child
            // relationships, since we can't do this before all of the objects are
            // actually created in the chart control itself.
            for (var _a = 0, seriesObjects_1 = seriesObjects; _a < seriesObjects_1.length; _a++) {
                var object = seriesObjects_1[_a];
                if (object == null) {
                    continue;
                }
                this._applyRelationshipsFromObject(object);
            }
            for (var _b = 0, otherObjects_1 = otherObjects; _b < otherObjects_1.length; _b++) {
                var object = otherObjects_1[_b];
                if (object == null) {
                    continue;
                }
                this._applyRelationshipsFromObject(object);
            }
            if (chartJSON.drawStyleMappings != null) {
                this._setDrawStyleToStyleObjectMapping(chartJSON.drawStyleMappings);
            }
            this.wrapper.setPlotListDirty();
        };
        FDSChart.prototype._processAllAttributesFromObject = function (objId, chartObj) {
            this._processAttributesFromObject('user', 'attributes', objId, chartObj, false);
            this._processAttributesFromObject('app', 'appAttributes', objId, chartObj, false);
            this._processAttributesFromObject(null, 'properties', objId, chartObj, true);
        };
        // modeled on PC-side function inside JSONLoader.cpp
        // @param level [String] the level at which to add an attribute
        // @param attrKey [String] what object to be looking in to add things
        // @param objId [String] what object to be adding stuff to
        // @param chartObj [JSON object] the object with all the info in it
        // @param property [Boolean] when true, adding properties. When false, adding attributes
        FDSChart.prototype._processAttributesFromObject = function (level, attrKey, objId, chartObj, property) {
            if (!chartObj[attrKey]) {
                return;
            }
            var attrObj = chartObj[attrKey];
            var attrSink = this._resolveToChartObject(objId);
            for (var member in attrObj) {
                var value = attrObj[member];
                if (property) {
                    attrSink.setProperty(member, value);
                }
                else {
                    attrSink._setAttributeRedirected(member, level, value);
                }
            }
        };
        FDSChart.prototype._processChartObject = function (object, createObject) {
            var didCreateObject = false;
            var errorString;
            if (typeof object.type !== 'string' || typeof object.id !== 'string') {
                return;
            }
            // convert from string (eg "FDSAxis") to ObjectType (eg. FC_AXIS)
            var internalObjectType = this._getObjectTypeFromString(object.type);
            if (!internalObjectType) {
                return;
            }
            if (internalObjectType !== 1 /* FC_DATA */) {
                if (createObject) {
                    _a = this.addObject(object.id, internalObjectType, 0, object.id, []), didCreateObject = _a[0], errorString = _a[1];
                }
                else {
                    // Chart loaded with "Snippit" action, so we won't create objects
                    didCreateObject = true;
                }
            }
            else {
                // Create a dataset. The dataType and data files are mandatory. To
                // create a dataset with no data items, pass an empty array.
                if (typeof object.dataType !== 'string') {
                    return;
                }
                if ((!object.data) || (!object.data.length)) {
                    return;
                }
                var addFlag = this._getAddFlagFromString(object.dataType);
                if (addFlag == null) {
                    addFlag = 2 /* FLOAT_DATA */;
                }
                var didCreateDataObject = void 0;
                _b = this.addObject(object.id, internalObjectType, addFlag, object.id, object.data), didCreateDataObject = _b[0], errorString = _b[1];
                didCreateObject = didCreateObject || didCreateDataObject;
                // get the dataset to set its data id
                var dataset = this.objects[object.id];
                dataset.dataId = object.dataId || '';
            }
            if (!didCreateObject) {
                return;
            }
            this._processAllAttributesFromObject(object.id, object);
            var _a, _b;
        };
        FDSChart.prototype._getObjectTypeFromString = function (str) {
            switch (str) {
                case 'FDSAxis':
                    return 15 /* FC_AXIS */;
                case 'FDSAxisStyle':
                    return 16 /* FC_AXIS_STYLE */;
                case 'FDSData':
                    return 1 /* FC_DATA */;
                case 'FDSDataStyle':
                    return 10 /* FC_DATA_STYLE */;
                case 'FDSPlot':
                    return 4 /* FC_PLOT */;
                case 'FDSPlotStyle':
                    return 13 /* FC_PLOT_STYLE */;
                case 'FDSSeries':
                    return 2 /* FC_SERIES */;
                case 'FDSSeriesStyle':
                    return 11 /* FC_SERIES_STYLE */;
                case 'FDSChartStyle':
                    return 17 /* FC_CHART_STYLE */;
                default:
                    return null;
            }
        };
        FDSChart.prototype._getAddFlagFromString = function (str) {
            switch (str) {
                case 'DATE':
                    return 3 /* DATE_DATA */;
                case 'DATETIME':
                    return 8 /* DATETIME_DATA */;
                case 'FLOAT':
                    return 2 /* FLOAT_DATA */;
                case 'INT':
                    return 1 /* INT_DATA */;
                case 'INTEGER':
                    return 1 /* INT_DATA */;
                case 'KML':
                case 'SVG':
                    return 9 /* KML_DATA */;
                case 'SINGLE':
                    return 5 /* SINGLE_DATA */;
                case 'STRING':
                    return 4 /* STRING_DATA */;
                case 'TIME':
                    return 7 /* TIME_DATA */;
                default:
                    return null;
            }
        };
        FDSChart.prototype._applyRelationshipsFromObject = function (object) {
            if ((typeof object.id !== 'string') || !object.children || object.children.length === 0) {
                return;
            }
            var internalObjectType = this._getObjectTypeFromString(object.type);
            var childIdList = [];
            if (internalObjectType === 1 /* FC_DATA */ || internalObjectType === 10 /* FC_DATA_STYLE */) {
                for (var _i = 0, _a = object.children; _i < _a.length; _i++) {
                    var childObj = _a[_i];
                    if (childObj.dataItems) {
                        // create a new dataset!
                        var addFlag = this._getAddFlagFromString(object.dataType);
                        if (addFlag === null) {
                            addFlag = 2 /* FLOAT_DATA */;
                        }
                        var childId = object.id + "_" + childObj.childId;
                        var _b = this.addObject(childId, internalObjectType, addFlag, childId, childObj.dataItems), success = _b[0], errorString = _b[1];
                        // set the data id
                        var dataset = this.objects[childId];
                        dataset.dataId = childObj.childId;
                        if (success) {
                            childIdList.push(childId);
                        }
                    }
                    else {
                        // just attach the existing one
                        childIdList.push(childObj.childId);
                    }
                }
            }
            else {
                for (var _c = 0, _d = object.children; _c < _d.length; _c++) {
                    var child = _d[_c];
                    if (typeof child !== 'string') {
                        continue;
                    }
                    childIdList.push(child);
                }
            }
            this.setChildrenExternal(object.id, childIdList);
        };
        // Traverses the chart DOM and adds all named chart objects we know about
        FDSChart.prototype._loadChartFromDOM = function (chartDOM) {
            if (!chartDOM) {
                return false;
            }
            // Initialize the internal `FDSChart` object from the first `<FDSChart>`
            // tag we find in the source file
            var chartTag = (chartDOM.getElementsByTagName('FDSChart'))[0];
            if (chartTag == null) {
                return false;
            }
            var actionTag = (chartTag.getElementsByTagName('Action'))[0];
            var loadAction = actionTag ? actionTag.textContent.toLowerCase() : 'refresh';
            var shouldCreateObjects = false;
            if (loadAction === 'refresh') {
                // reset everything and create new objects
                shouldCreateObjects = true;
                this._resetChart();
            }
            else if (loadAction === 'snippit') {
                // don't reset anything, but no new objects
                shouldCreateObjects = false;
                this.setAllChildrenDirty();
            }
            else if (loadAction === 'append') {
                // don't reset anything, and do add new objects
                shouldCreateObjects = true;
            }
            this.initFromElement(chartTag);
            var newObjects = [];
            // Add uniquely-named objects to the chart
            // The order matters here for the sake of parenting.
            for (var _i = 0, _a = [FDSDataSet, FDSSeries, FDSPlot, FDSAxis]; _i < _a.length; _i++) {
                var objType = _a[_i];
                // addAllObjects returns an array of newly-added objects for parenting
                newObjects = newObjects.concat(this._addAllObjects(chartTag, objType, shouldCreateObjects));
            }
            // Also add any custom style objects to the chart
            for (var _b = 0, _c = ['FDSDataStyle', 'FDSSeriesStyle', 'FDSPlotStyle', 'FDSAxisStyle', 'FDSChartStyle']; _b < _c.length; _b++) {
                var objType = _c[_b];
                this._addAllStyleObjects(chartTag, objType, shouldCreateObjects);
            }
            // We don't need to process children for snippits since no new non-style objects
            // are created in this mode
            if (loadAction !== 'snippit') {
                // run through the new objects and add all their children
                for (var _d = 0, newObjects_1 = newObjects; _d < newObjects_1.length; _d++) {
                    var obj = newObjects_1[_d];
                    obj.addChildren();
                }
                // now run through again and do any post-processing that depends on the children existing
                for (var _e = 0, newObjects_2 = newObjects; _e < newObjects_2.length; _e++) {
                    var obj = newObjects_2[_e];
                    obj.processChildren();
                }
            }
            // set this so we will create new plot sliders
            this.plotResizeManager.setSlidersDirty();
            this.wrapper.setPlotListDirty();
            return true;
        };
        FDSChart.prototype.getAttribute = function (id, attribute, flags) {
            if (flags === void 0) { flags = 0 /* NONE */; }
            var attrSource = this._resolveToChartObject(id);
            if (attrSource === undefined) {
                return undefined;
            }
            switch (flags) {
                case 0 /* NONE */:
                    return attrSource._getAttributeRedirected(attribute);
                case 1 /* DEFAULT */:
                    return attrSource._getAttributeRedirected(attribute, 'def');
                case 2 /* IF_DEFAULT */:
                    return attrSource._isDefaultRedirected(attribute);
                default:
                    return undefined;
            }
        };
        FDSChart.prototype.setAttribute = function (id, attribute, level, value) {
            var attrSink = this._resolveToChartObject(id);
            if (attrSink === undefined) {
                return [false, "Attribute set failed: No object with ID " + id];
            }
            return [(attrSink._setAttributeRedirected(attribute, level, value)), ''];
        };
        FDSChart.prototype._clearAttribute = function (id, attribute, level) {
            var attrSink = this._resolveToChartObject(id);
            if (attrSink === undefined) {
                return [false, "Attribute clear failed: No object with ID " + id];
            }
            return [(attrSink._setAttributeRedirected(attribute, level, undefined)), ''];
        };
        FDSChart.prototype._addProperty = function (id, propertyKey, value) {
            var propSink = this._resolveToChartObject(id);
            if (propSink === undefined) {
                return [false, "Property add failed: No object with ID " + id];
            }
            return [propSink.setProperty(propertyKey, value), ''];
        };
        FDSChart.prototype._removeProperty = function (id, propertyKey) {
            var propSink = this._resolveToChartObject(id);
            if (propSink === undefined) {
                return [false, "Property remove failed: No object with ID " + id];
            }
            return [propSink.deleteProperty(propertyKey), ''];
        };
        FDSChart.prototype.fetchProperty = function (id, propertyKey) {
            var propSink = this._resolveToChartObject(id);
            if (propSink === undefined) {
                return undefined;
            }
            return propSink.getUnresolvedProperty(propertyKey);
        };
        FDSChart.prototype._clearProperties = function (id) {
            var propSink = this._resolveToChartObject(id);
            if (propSink === undefined) {
                return [false, "Property clear failed: No object with ID " + id];
            }
            var propSinkParentPropSet = propSink.properties.parentPropertySet;
            propSink.properties = new PropertySet(propSink);
            propSink.properties.parentPropertySet = propSinkParentPropSet;
            return [true, ''];
        };
        FDSChart.prototype._getMenuChildren = function () {
            // The chart object has all objects as children, but we only want to consider plots
            // when traversing up the object hierarchy for menus.
            return this._getObjectsOfType(FDSPlot);
        };
        FDSChart.prototype.setAttributeExternal = function (id, flags, attribute, value) {
            var success = true;
            var failed = [];
            var errString = '';
            switch (flags) {
                case 0 /* NONE */:
                    // set at the user level
                    return this.setAttribute(id, attribute, 'user', value);
                case 1 /* APP */:
                    // set at the app level
                    return this.setAttribute(id, attribute, 'app', value);
                case 2 /* RESET */:
                    // resets to the default value - value parameter is ignored
                    this._clearAttribute(id, attribute, 'user');
                    return this._clearAttribute(id, attribute, 'app');
                case 3 /* BATCH */:
                    // set multiple attributes on the object with one call
                    // returns true if all attribute sets were successful
                    if (!(value instanceof Array)) {
                        return [false, 'You must pass in an array with Attribute batch mode'];
                    }
                    for (var _i = 0, _a = value; _i < _a.length; _i++) {
                        var entry = _a[_i];
                        // Entries in this array are of the form 'Attribute=Value'
                        var split = entry.split('=');
                        if (split.length !== 2) {
                            success = false;
                            failed.push(entry);
                            continue;
                        }
                        var key = split[0], val = split[1];
                        var ret = this.setAttribute(id, key, 'user', val)[0];
                        if (!ret) {
                            failed.push(key);
                        }
                        success = success && ret;
                    }
                    if (!success) {
                        errString = "Some attributes failed or formatted incorrectly: " + failed.join(', ');
                    }
                    return [success, errString];
                case 4 /* APPBATCH */:
                    // set multiple application default attributes
                    if (!(value instanceof Array)) {
                        return [false, 'You must pass in an array with Attribute app batch mode'];
                    }
                    for (var _b = 0, _c = value; _b < _c.length; _b++) {
                        var entry = _c[_b];
                        var split = entry.split('=');
                        if (split.length !== 2) {
                            success = false;
                            failed.push(entry);
                            continue;
                        }
                        var key = split[0], val = split[1];
                        var ret = this.setAttribute(id, key, 'app', val)[0];
                        if (!ret) {
                            failed.push(key);
                        }
                        success = success && ret;
                    }
                    if (!success) {
                        errString = "Some attributes failed or formatted incorrectly: " + failed.join(', ');
                    }
                    return [success, errString];
                case 5 /* ROOT */:
                case 6 /* ROOT_BATCH */:
                case 7 /* RESET_ROOT */:
                    return [false, 'Root level attributes are not supported in FDSChartJS'];
                case 8 /* PROPERTY */:
                    return this._addProperty(id, attribute, value.toString());
                case 9 /* PROP_BATCH */:
                    if (!(value instanceof Array)) {
                        return [false, 'You must pass in an array with Property batch mode'];
                    }
                    for (var _d = 0, _e = value; _d < _e.length; _d++) {
                        var entry = _e[_d];
                        var split = entry.split('=');
                        if (split.length !== 2) {
                            success = false;
                            failed.push(entry);
                            continue;
                        }
                        var key = split[0], val = split[1];
                        var ret = this._addProperty(id, key, val)[0];
                        if (!ret) {
                            failed.push(key);
                        }
                        success = success && ret;
                    }
                    if (!success) {
                        errString = "Some properties failed or formatted incorrectly: " + failed.join(', ');
                    }
                    return [success, errString];
                case 10 /* REMOVE_PROP */:
                    return this._removeProperty(id, attribute);
                case 11 /* CLEAR_PROPERTIES */:
                    return this._clearProperties(id);
            }
            return [false, ''];
        };
        FDSChart.prototype.getContext = function () {
            return this._renderLayerManager.main.context;
        };
        FDSChart.prototype.getOverlayContext = function () {
            return this._renderLayerManager.overlay.context;
        };
        FDSChart.prototype.getUIContext = function () {
            return this._renderLayerManager.ui.context;
        };
        FDSChart.prototype.setUIVisibility = function (visible) {
            if (visible) {
                this._renderLayerManager.ui.show();
            }
            else {
                this._renderLayerManager.ui.hide();
            }
        };
        FDSChart.prototype.resetMarkerContext = function () {
            if (this._markerCanvas) {
                this._renderLayerManager.main.show();
                this._markerCanvas.destroy();
                this._markerCanvas = null;
            }
        };
        FDSChart.prototype.runWithMarkerContext = function (func) {
            var overlayCtx = this.getOverlayContext();
            if (this.canvasDifferenceSupported()) {
                if (!this._markerCanvas) {
                    this._markerCanvas = this._renderLayerManager.createLayer(this.getWidth(), this.getHeight());
                    this._renderLayerManager.main.hide(); // hide the base canvas, since we will draw its image to the overlay
                    // canvas instead.
                }
                var ctx = this._markerCanvas.context;
                ctx.clear();
                // The drawing on the canvas and overlay canvas have already been scaled so we draw them as is.
                ctx.drawLayer(this._renderLayerManager.main);
                ctx.drawLayer(this._renderLayerManager.overlay);
                // We need to scale the marker context before drawing the markers on it.
                ctx.save();
                this.minimumSizeManager.scaleRenderingContext(ctx);
                func(ctx);
                ctx.restore();
                // Because the contents of the marker context are scaled, we need to temporarily undo the scaling on
                // the overlay context so that we do not scale twice.
                overlayCtx.save();
                this.minimumSizeManager.unscaleRenderingContext(overlayCtx);
                overlayCtx.drawLayer(this._markerCanvas);
                overlayCtx.restore();
            }
            else {
                func(overlayCtx);
            }
        };
        FDSChart.prototype._syncStyleObjects = function (reset) {
            // If we have drawstyle mapped styleset objects,
            // we need to go through and potentially update the styleset
            // assignement for that series.
            this._getObjectsOfType(FDSSeries).forEach(function (series) { return series.updateDynamicStyleObject(); });
            // Update chart style if there is one.
            this.syncStyleSetMembers();
            for (var id in this._styleObjects) {
                var object = this._styleObjects[id];
                if (reset === 0 /* RESET */) {
                    object.attributeSet.setParentAttrSet(this.attributeSet);
                }
                if (object.attributeSet.isDirty()) {
                    // style objects are just attribute placeholders... no need to syncmembers
                    // we do, however, need to update their styleset references so that they can cascade.
                    object.syncStyleSetMembers();
                    object.setNeedUpdate(false);
                    object.attributeSet.setDirty(false);
                }
            }
        };
        FDSChart.prototype._invalidateAllAttributesIfStyleObjectsAreDirty = function () {
            for (var _i = 0, _a = Object.keys(this._styleObjects); _i < _a.length; _i++) {
                var styleObjId = _a[_i];
                var styleObj = this._styleObjects[styleObjId];
                if (styleObj.attributeSet.isDirty()) {
                    this.attributeSet.setDirty(true);
                    this.setAllChildrenDirty();
                    return;
                }
            }
        };
        FDSChart.prototype.syncAll = function () {
            this._setDirtyIfDevicePixelRatioChanged();
            this._applyTheme();
            // This should happen early on in the syncAll process so that the scales
            // are correct by the time any other updating happens.
            this._resetScalesIfNeeded();
            // `_invalidateAllAttributesIfStyleObjectsAreDirty` Potentially dirties this.attributeSet,
            // so we need this to happen before we check for `this.attributeSet.isDirty()`
            this._syncStyleObjects(0 /* RESET */);
            this._invalidateAllAttributesIfStyleObjectsAreDirty();
            if (this.attributeSet.isDirty()) {
                // If the root attributes are dirty, we have to
                // dirty all the child attribute sets because of
                // inheritance
                this.setAllChildrenDirty();
                this.syncMembers();
                this.attributeSet.setDirty(false);
            }
            // Scales need to be synced before series adjust.
            for (var _i = 0, _a = this._getObjectsOfType(FDSAxis); _i < _a.length; _i++) {
                var obj_1 = _a[_i];
                if (obj_1 && obj_1.attributeSet.isDirty()) {
                    obj_1.syncScaleMembersIfSeriesChanged();
                }
            }
            var obj;
            for (var id in this.children) {
                obj = this.children[id];
                if (isSeries(obj)) {
                    this._setThemeAndAdjust(obj);
                }
            }
            for (var id in this.children) {
                obj = this.children[id];
                if (isPlot(obj)) {
                    this._setThemeAndAdjust(obj);
                }
            }
            for (var objectKey in this.objects) {
                var object = this.objects[objectKey];
                if (object.isStyleObject) {
                    continue;
                }
                if (object.attributeSet.isDirty()) {
                    object.syncMembers();
                    object.attributeSet.setDirty(false);
                }
            }
            for (var objectKey in this.objects) {
                var object = this.objects[objectKey];
                if (object.isStyleObject) {
                    continue;
                }
                // objects may have been marked for adjust during sync
                this._adjustIfNeeded(object);
            }
        };
        // helper function cause this is done twice above
        FDSChart.prototype._setThemeAndAdjust = function (obj) {
            obj._applyTheme();
            this._adjustIfNeeded(obj);
        };
        FDSChart.prototype._adjustIfNeeded = function (obj) {
            if (obj.needsUpdate) {
                obj.adjust();
                obj.setNeedUpdate(false);
                var itdScale = this._findIntradayScale({ 'object': obj });
                if (itdScale != null) {
                    // intraday depends on syncing thresholds being the last thing done
                    itdScale.resyncThresholds();
                }
            }
        };
        FDSChart.prototype._findIntradayScale = function (object) {
            for (var id in object) {
                var child = object[id];
                if (isAxis(child)) {
                    var scale = child.scale;
                    if (scale && scale instanceof FDSIntradayScale) {
                        return scale;
                    }
                }
                else if (isPlot(child)) {
                    // if it's not a plot or a series we can just return
                    var ret = this._findIntradayScale(child.children);
                    if (ret != null) {
                        return ret;
                    }
                }
            }
            // if we got here nothing was found
            return null;
        };
        FDSChart.prototype._setDirtyIfDevicePixelRatioChanged = function () {
            var currDevicePixelRatio = getDevicePixelRatio();
            if (this._lastDevicePixelRatio != null && this._lastDevicePixelRatio !== currDevicePixelRatio) {
                this.attributeSet.setDirty(true);
                this.progressSpinner.resetSpinnerSize();
            }
            this._lastDevicePixelRatio = currDevicePixelRatio;
        };
        /**
         * There are a variety of circumstances / changes that would require scales to be reset.
         * For Example:
         *   1) DataSet frequency changes
         *   2) Axis binning changes
         *   3) UseIntradayScale toggling
         *   4) Axis attributes that effect scale computation
         *
         * If any of these things happen, this funtion will reset the scale so that the correct
         * computation can happen when the reset of the chart updating occurs.
         */
        FDSChart.prototype._resetScalesIfNeeded = function () {
            for (var _i = 0, _a = this.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                plot.resetScalesToMatchUseIntradaySetting();
                var axesToReset = plot.axes.filter(function (axis) { return axis.scale && axis.scale.needsReset(); });
                for (var _b = 0, axesToReset_1 = axesToReset; _b < axesToReset_1.length; _b++) {
                    var axis = axesToReset_1[_b];
                    axis.resetScale();
                }
            }
        };
        FDSChart.prototype.setAllChildrenDirty = function () {
            for (var objectKey in this.objects) {
                var object = this.objects[objectKey];
                if (object.isStyleObject) {
                    continue;
                }
                object.attributeSet.setDirty(true);
            }
        };
        FDSChart.prototype._propFDSSeriesUnderCrosshair = function (valueContext, args) {
            // Get the first plot on the chart
            var plot = undefined;
            for (var objectKey in this.objects) {
                var object = this.objects[objectKey];
                if (isPlot(object)) {
                    plot = object;
                    break;
                }
            }
            for (var _i = 0, _a = plot.seriesInterval; _i < _a.length; _i++) {
                var interval = _a[_i];
                if (interval.first < this.renderManager.cursorX && this.renderManager.cursorX <= interval.last) {
                    return interval.series.id;
                }
            }
            return args.getArg('DEFAULT', valueContext);
        };
        FDSChart.prototype.setCrosshairTooltipOptions = function (options) {
            var visible = options.visible, top = options.top, left = options.left, text = options.text;
            var updateOptions = {};
            if ((visible != null) && this.crosshairsTooltipEnabled) {
                updateOptions.visible = visible;
            }
            if (top != null) {
                updateOptions.y = top;
            }
            if (left != null) {
                updateOptions.x = left;
            }
            if (text != null) {
                updateOptions.text = text;
            }
            // pass false as the last parameter of the update call because we do
            // not need the crosshair tooltip to remove itself since it is drawing
            // on the overlay canvas which gets erased every frame during interactions
            this.crosshairTooltip.update(updateOptions, this.getOverlayContext(), false);
        };
        // returns the series color corresponding to an index (modded if necessary)
        FDSChart.prototype.getSeriesColor = function (index, colorList, useSeriesColorCycle) {
            if (colorList === void 0) { colorList = this._seriesColors; }
            if (useSeriesColorCycle === void 0) { useSeriesColorCycle = true; }
            return this._getSeriesColorFromArray(index, colorList, useSeriesColorCycle);
        };
        FDSChart.prototype.getSeriesOutlineColor = function (index, colorList, useSeriesColorCycle) {
            if (colorList === void 0) { colorList = this._seriesOutlineColors; }
            if (useSeriesColorCycle === void 0) { useSeriesColorCycle = true; }
            return this._getSeriesColorFromArray(index, colorList, useSeriesColorCycle);
        };
        FDSChart.prototype.getSeriesLineStyle = function (index, styleList, useSeriesColorCycle) {
            if (styleList === void 0) { styleList = this._seriesLineStyles; }
            if (useSeriesColorCycle === void 0) { useSeriesColorCycle = true; }
            return this._getCyclicValueFromArray(index, styleList, useSeriesColorCycle);
        };
        FDSChart.prototype.getSeriesLineWidth = function (index, widthList, useSeriesColorCycle) {
            if (widthList === void 0) { widthList = this._seriesLineWidths; }
            if (useSeriesColorCycle === void 0) { useSeriesColorCycle = true; }
            return this._getCyclicValueFromArray(index, widthList, useSeriesColorCycle);
        };
        FDSChart.prototype.getSeriesMarkerStyle = function (index, styleList, useSeriesColorCycle) {
            if (styleList === void 0) { styleList = this._seriesMarkerStyles; }
            if (useSeriesColorCycle === void 0) { useSeriesColorCycle = true; }
            return this._getCyclicValueFromArray(index, styleList, useSeriesColorCycle);
        };
        FDSChart.prototype._getCyclicValueFromArray = function (i, arr, useSeriesColorCycle) {
            if (!arr) {
                return undefined;
            }
            var mod = Math.min(arr.length, useSeriesColorCycle ? this._seriesColorCycle : arr.length);
            var cyclicIndex = i % mod;
            return arr[cyclicIndex];
        };
        FDSChart.prototype._getSeriesColorFromArray = function (i, arr, useSeriesColorCycle) {
            if (!arr) {
                return undefined;
            }
            var mod = Math.min(arr.length, useSeriesColorCycle ? this._seriesColorCycle : arr.length);
            var cyclicIndex = i % mod;
            var color = new FDSColor(arr[cyclicIndex]);
            var cycle = ~~(i / mod);
            if (cycle > 0 && this._seriesAutoLighten) {
                var percent = (~~(cycle / 2) + 1) * 20.0;
                var sign = cycle % 2 === 0 ? 1 : -1;
                color.lightenByPercent(percent * sign);
            }
            return color.getCOLORREF();
        };
        FDSChart.prototype._setSeriesCycle = function (size) {
            return this._seriesColorCycle = clamp(size, 1, SERIES_COLOR_COUNT);
        };
        FDSChart.prototype.serialize = function (level) {
            var xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><FDSChart xmlns = \"http:// xml.factset.com/chart\">';
            xml += '<Version>0</Version>';
            if (level === 0 /* GENERATE_FULL */) {
                xml += '<Action>Refresh</Action>';
                xml += this._serializeProperties();
            }
            else {
                xml += '<Action>Snippit</Action>';
            }
            xml += this._serializeAttributes(level);
            for (var id in this.objects) {
                var obj = this.objects[id];
                xml += obj.serialize(level);
            }
            xml += '</FDSChart>';
            return xml;
        };
        FDSChart.prototype.serializeToJSON = function (level) {
            if (level === void 0) { level = 0 /* GENERATE_FULL */; }
            var root = {};
            if (level !== 0 /* GENERATE_FULL */) {
                root.action = 'snippit';
            }
            if (level === 0 /* GENERATE_FULL */ || level === 2 /* GENERATE_USER */) {
                root.attributes = this._serializeAttributesJSON(this, 'user');
            }
            if (level === 0 /* GENERATE_FULL */ || level === 1 /* GENERATE_APP */) {
                root.appAttributes = this._serializeAttributesJSON(this, 'app');
            }
            if (level === 0 /* GENERATE_FULL */) {
                root.properties = this._serializePropertiesJSON(this);
            }
            root.objects = [];
            for (var childName in this.objects) {
                var child = this.objects[childName];
                if ((isAxis(child)) && child.isBuiltInAxis) {
                    continue;
                } // don't serialize built-in axes
                if (isLegend(child)) {
                    continue;
                } // don't serialize legends
                if (child.isStyleObject) {
                    continue;
                } // These will be handled afterward.
                var childJSON = this._serializeChartObjectJSON(child, level);
                if (childJSON) {
                    root.objects.push(childJSON);
                }
            }
            for (var childName in this._styleObjects) {
                var child = this._styleObjects[childName];
                if ((isAxis(child)) && child.isBuiltInAxis) {
                    continue;
                } // don't serialize built-in axes
                if (isLegend(child)) {
                    continue;
                } // don't serialize legends
                var childJSON = this._serializeChartObjectJSON(child, level);
                if (childJSON) {
                    root.objects.push(childJSON);
                }
            }
            if (this._drawStyleToStyleObjectName) {
                var mapping = {};
                for (var drawStyle in this._drawStyleToStyleObjectName) {
                    var styleName = this._drawStyleToStyleObjectName[drawStyle];
                    if (mapping[styleName] == null) {
                        mapping[styleName] = [];
                    }
                    mapping[styleName].push(Number(drawStyle));
                }
                root.drawStyleMappings = mapping;
            }
            return root;
        };
        FDSChart.prototype._serializeChartObjectJSON = function (object, level) {
            var ret = {
                id: object.id,
                type: object.constructor['selector']
            };
            if (object.isStyleObject) {
                ret.type += 'Style';
            }
            if (level === 0 /* GENERATE_FULL */ || level === 2 /* GENERATE_USER */) {
                ret.attributes = this._serializeAttributesJSON(object, 'user');
            }
            if (level === 0 /* GENERATE_FULL */ || level === 1 /* GENERATE_APP */) {
                ret.appAttributes = this._serializeAttributesJSON(object, 'app');
            }
            if (level === 0 /* GENERATE_FULL */ && !object.isStyleObject) {
                ret.properties = this._serializePropertiesJSON(object);
            }
            // only add this other stuff if you're generating everything
            if (level !== 0 /* GENERATE_FULL */) {
                return ret;
            }
            if (isDataSet(object)) {
                var nan = void 0;
                // figure out how NaNs should be represented
                switch (object.dataType) {
                    case 'DATE':
                    case 'TIME':
                    case 'DATETIME':
                    case 'INT':
                    case 'INTEGER':
                    case 'FLOAT':
                    case 'SINGLE':
                        nan = -1e20;
                        break;
                    default:
                        nan = '@NA';
                }
                if (!object.isStyleObject) {
                    ret.data = [];
                    for (var _i = 0, _a = object.data; _i < _a.length; _i++) {
                        var dataItem = _a[_i];
                        if (IsSomeNAN(dataItem)) {
                            dataItem = nan;
                        }
                        ret.data.push(dataItem);
                    }
                    ret.dataType = object.dataType;
                    ret.dataId = object.dataId;
                }
            }
            if (!object.isStyleObject) {
                ret.children = this._serializeChildrenJSON(object);
            }
            return ret;
        };
        // returns an array of child ids to be added to an existant json object
        FDSChart.prototype._serializeChildrenJSON = function (object) {
            if (isSeries(object)) {
                var ret = [];
                // this copies the same behavior as in the series xml children serialization
                var maxDim = 0;
                for (var _i = 0, _a = Object.keys(object.dimensionalChildren).map(Number); _i < _a.length; _i++) {
                    var num = _a[_i];
                    maxDim = Math.max(maxDim, num);
                }
                for (var dimNum = 0; dimNum < maxDim; dimNum++) {
                    var child = object.dimensionalChildren[dimNum];
                    var childId = '';
                    if (child && object.defined[dimNum]) {
                        childId = child.id == null ? '' : child.id;
                    }
                    ret.push(childId);
                }
                // also add series children
                for (var childId in object.children) {
                    ret.push(childId);
                }
                return ret;
            }
            else if (isPlot(object)) {
                var ret = [];
                var firstChildren = [];
                for (var childId in object.children) {
                    var child = object.children[childId];
                    if (isLegend(child)) {
                        continue;
                    }
                    if (child.serializeFirst) {
                        firstChildren.push(childId);
                    }
                    else {
                        ret.push(childId);
                    }
                }
                ret = firstChildren.concat(ret);
                return ret;
            }
            else if (isDataSet(object)) {
                var ret = [];
                for (var childId in object.children) {
                    var child = object.children[childId];
                    var childObj = { childId: childId };
                    ret.push(childObj);
                }
                return ret;
            }
            return [];
        };
        // returns a map of attributes to be added to an existant json object
        FDSChart.prototype._serializeAttributesJSON = function (object, level) {
            var ret = {};
            var appAttrs = [];
            var userAttrs = [];
            object._getAttributesForSerialization(level === 'app', level === 'user', appAttrs, userAttrs);
            var attrs = level === 'app' ? appAttrs : userAttrs;
            for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
                var _a = attrs_1[_i], name_1 = _a.name, value = _a.value;
                ret[name_1] = value;
            }
            return ret;
        };
        // returns a map of attributes to be added to an existant json object
        FDSChart.prototype._serializePropertiesJSON = function (object) {
            var ret = {};
            for (var key in object.unparsedProperties) {
                ret[key] = object.unparsedProperties[key];
            }
            return ret;
        };
        FDSChart.prototype.addStyleObject = function (object) {
            if ((object == null) || !object.id || object === this || object.hasChild(this)) {
                return false;
            }
            this._styleObjects[object.id] = object;
            if (object.attributeSet != null) {
                object.properties.setParentPropertySet(this.properties);
            }
            return true;
        };
        // Method used to generically add objects.
        //
        // @param name [String] the id of the object to be created
        // @param objType [ObjectType] enum to determine the type of object to be created
        // @param flags [Number] any flags that is determined by the type of object being added
        // @param data [Array] generic array of data used in different ways
        // @param args [Map] generic map of args to be passed to the object being created
        // @return [Array] an array of length 2, the first being wheter add succeeded, second being a string containing an
        // error message
        FDSChart.prototype.addObject = function (name, objType, flags, label, data, wrapper, args) {
            if (wrapper === void 0) { wrapper = null; }
            if (args === void 0) { args = {}; }
            var ret = false;
            var errString = '';
            var reservedType = this._getReservedType(name);
            objType = reservedType !== -1 /* FC_NULL */ ? reservedType : objType;
            if (!this._validateReservedTypeName(name, objType) || this.isReservedAxisType(name)) {
                errString = 'Reserved Object Name:' + name;
            }
            else {
                switch (objType) {
                    case 1 /* FC_DATA */:
                        _a = this._addData(flags, name, label, data, wrapper, args), ret = _a[0], errString = _a[1];
                        break;
                    case 2 /* FC_SERIES */:
                        _b = this._addSeries(name, label, data, wrapper, args), ret = _b[0], errString = _b[1];
                        break;
                    case 4 /* FC_PLOT */:
                        _c = this._addPlot(name, label, data, wrapper, args), ret = _c[0], errString = _c[1];
                        break;
                    case 15 /* FC_AXIS */:
                        _d = this._addAxis(name, label, data, wrapper, args), ret = _d[0], errString = _d[1];
                        break;
                    case 13 /* FC_PLOT_STYLE */:
                    case 11 /* FC_SERIES_STYLE */:
                    case 10 /* FC_DATA_STYLE */:
                    case 16 /* FC_AXIS_STYLE */:
                    case 17 /* FC_CHART_STYLE */:
                        _e = this._addUserStyleObject(name, objType, args), ret = _e[0], errString = _e[1];
                        break;
                    default:
                        errString = "Unknown object type: " + objType;
                }
                this._setStateChanged(true);
            }
            return [ret, errString];
            var _a, _b, _c, _d, _e;
        };
        FDSChart.prototype.addChartObject = function (object) {
            if (!(object instanceof FDSChartObject)) {
                return;
            }
            this.addChild(object);
            object.attributeSet.parentAttrSet = this.attributeSet;
            if (isPlot(object)) {
                if (!object.isStyleObject) {
                    this.chartPlotList.push(object);
                    this.wrapper.setPlotListDirty();
                }
            }
        };
        // Adds a plot to the chart
        //
        // @param name [String] The name of the object
        // @param label [String] The string name of the object that goes into the Label attribute
        // @param data [Array] An array of data containing the max and min x and y value of the plotrect (in factors)
        // @param args [Map] An unused map for now, but any future optional arg additions should be added to here
        FDSChart.prototype._addPlot = function (name, label, data, wrapper, args) {
            var ret = false;
            var errString = '';
            // to default the plotRect to 0,0,1,1 (plot is over the entire chart)
            var layout = [0, 1, 0, 1];
            var num = Math.min(data.length, 4);
            for (var i = 0; i < num; i++) {
                layout[i] = data[i];
            }
            if (!this.getChild(name)) {
                var plot = new FDSPlot(this, name, layout[0], layout[1], layout[2], layout[3], wrapper);
                if (!plot.isStyleObject) {
                    plot.attributeSet.setAt('Label', 'app', label);
                }
                this.addChartObject(plot);
                ret = true;
            }
            else {
                errString = "Object " + name + " already exists!";
            }
            // we added a new plot! we're gonna have to recreate the chart sliders
            this.plotResizeManager.setSlidersDirty();
            return [ret, errString];
        };
        // Adds a data set to the chart
        //
        // @param flags [AddFlags] The type of the data to be added
        // @param name [String] ID of the dataset to be added
        // @param label
        // @param data [Array] array of data
        // @param args [Map] An unused map for now, but any future optional arg additions should be added to here
        FDSChart.prototype._addData = function (flags, name, label, data, wrapper, args) {
            var ret = false;
            var errString = '';
            var object = this.getChild(name);
            var dataSet;
            if (!object) {
                var type = void 0;
                switch (flags) {
                    case 1 /* INT_DATA */:
                        type = 'INT';
                        break;
                    case 5 /* SINGLE_DATA */:
                        type = 'SINGLE';
                        break;
                    case 2 /* FLOAT_DATA */:
                        type = 'FLOAT';
                        break;
                    case 3 /* DATE_DATA */:
                        type = 'DATE';
                        break;
                    case 8 /* DATETIME_DATA */:
                        type = 'DATETIME';
                        break;
                    case 4 /* STRING_DATA */:
                        type = 'STRING';
                        break;
                    case 7 /* TIME_DATA */:
                        type = 'TIME';
                        break;
                    case 9 /* KML_DATA */:
                        type = 'SVG';
                        break;
                    default:
                        return [false, 'invalid datatype specified'];
                }
                dataSet = new FDSDataSet(this, name, wrapper);
                dataSet.dataType = type;
                this.addChartObject(dataSet);
            }
            else {
                if (isDataSet(object)) {
                    dataSet = object;
                }
            }
            if (dataSet) {
                _a = dataSet.add(label, data, wrapper), ret = _a[0], errString = _a[1];
            }
            return [ret, errString];
            var _a;
        };
        // Adds a series to the chart
        //
        // @param name [String] ID of the series to be added
        // @param label [String] label of the series to be displayed on the chart
        // @param data [Array] Array containing strings of IDs of Series objects or Datasets to be set as children
        // @param args [Map] An unused map for now, but any future optional arg additions should be added to here
        FDSChart.prototype._addSeries = function (name, label, data, wrapper, args) {
            var ret = true;
            var errString = '';
            if (this.getChild(name)) {
                return [false, "Object " + name + " already exists!"];
            }
            var series = new FDSSeries(this, name, wrapper);
            if (!series.isStyleObject) {
                series.attributeSet.setAt('Label', 'app', label);
            }
            this.addChartObject(series);
            if (data instanceof Array && data.length > 0) {
                _a = series.setChildren(data), ret = _a[0], errString = _a[1];
            }
            return [ret, errString];
            var _a;
        };
        // Adds an axis to the chart
        //
        // @param flags [null] unused for axes
        // @param name [String] ID of the axis to be added
        // @param label [String] Label of the axis
        // @param data [String] expected to be the name of a plot to parent the axis to
        // @param args [Map] Map containing arguments for axis: (Currently avaliable -> dimension: dimType)
        FDSChart.prototype._addAxis = function (name, label, data, wrapper, args) {
            if (this.getChild(name)) {
                return [false, "Object " + name + " already exists!"];
            }
            var axis = new FDSAxis(this, name, ((args.dimension != null) ? args.dimension : -1 /* NONE */), undefined, undefined, false, 0 /* NONE */, wrapper);
            axis.attributeSet.parentAttrSet = this.attributeSet;
            this.addChartObject(axis);
            if (!axis.isStyleObject) {
                // Data field for axis can contain a specified parent
                if (typeof data === 'string') {
                    var plot = this.getTypedObject(data, isPlot);
                    if (plot) {
                        plot.addChild(axis);
                        plot.axes.push(axis);
                    }
                }
            }
            return [true, ''];
        };
        // Adds a style object to the chart
        //
        // @param styleName [String] the id of the style object being added
        // @param objType [ObjectType] the type of style object being added
        // @param args [Map] An unused map for now, but any future optional arg additions should be added to here
        FDSChart.prototype._addUserStyleObject = function (styleName, objType, args) {
            var ret = false;
            var errString = '';
            var object = this.getChild(styleName);
            if (object == null) {
                switch (objType) {
                    case 13 /* FC_PLOT_STYLE */:
                        object = new FDSPlotStyle(this, styleName);
                        break;
                    case 10 /* FC_DATA_STYLE */:
                        object = new FDSDataStyle(this, styleName);
                        break;
                    case 11 /* FC_SERIES_STYLE */:
                        object = new FDSSeriesStyle(this, styleName);
                        break;
                    case 16 /* FC_AXIS_STYLE */:
                        object = new FDSAxisStyle(this, styleName);
                        break;
                    case 17 /* FC_CHART_STYLE */:
                        object = new FDSChartStyle(this, styleName);
                        break;
                    default:
                        ret = false;
                        errString = "Object type " + objType + " is not a valid style object";
                }
                if (object != null) {
                    this.addStyleObject(object);
                    this._addObject(object.id, object);
                    object.attributeSet.setDirty(false);
                    this.attributeSet.setDirty(true);
                    ret = true;
                }
            }
            return [ret, errString];
        };
        FDSChart.prototype._setStateChanged = function (changed) {
            this._stateChanged = changed;
        };
        // External set children call
        //
        // @param parent [String] the string ID of the parent object desired
        // @param child  [Object] Either a string containing an id of a child, or an array containing strings of children
        FDSChart.prototype.setChildrenExternal = function (parent, child) {
            var ret = false;
            var errString = '';
            if (parent === null) {
                parent = '';
            }
            var childArr = (typeof child === 'string') ? [child] : child;
            var parentObj = this.getChild(parent);
            if (parentObj && !parentObj.isStyleObject) {
                _a = parentObj.setChildren(childArr), ret = _a[0], errString = _a[1];
            }
            else {
                errString = "Unable to set children on " + parent;
            }
            this._setStateChanged(true);
            return [ret, errString];
            var _a;
        };
        // External unset children call
        //
        // @param parent [String] the string ID of the parent object desired
        // @param child  [Object] Either a string containing an id of a child, or an array containing strings of children
        FDSChart.prototype.unsetChildren = function (parent, child) {
            var ret = false;
            var errString = '';
            var childArr = (typeof child === 'string') ? [child] : child;
            var parentObj = this.getChild(parent);
            if (parentObj && childArr.length > 0) {
                _a = parentObj.clearChildren(childArr), ret = _a[0], errString = _a[1];
            }
            else {
                errString = "Unable to clear children from " + parent;
            }
            this._setStateChanged(true);
            return [ret, errString];
            var _a;
        };
        // Clears all of the children and objects (except style objects) from the chart
        FDSChart.prototype.clear = function () {
            this._resetChart();
        };
        FDSChart.prototype.fireNonLocationEvent = function (eventTitle, eventData) {
            if (typeof eventData === 'string') {
                eventData = [eventData];
            }
            this.fireChartEvent(eventTitle, new Point(0, 0), eventData);
        };
        // Fires a chart event to the hosting application on the containing DOM element
        // Chart Events are JavaScript `CustomEvent`s. The detail property of the
        // `CustomEvent` contains the ChartEvent data that is compatible with FDSChart's events
        //
        // @param eventName [String] the name of the specific ChartEvent
        // @param point [Point] Point where the event came from
        // @param data [Array] Generic array containing different information depending on the event
        FDSChart.prototype.fireChartEvent = function (eventName, point, data) {
            // The point provided to this function is in chart-space. Because of MinimumSize,
            // this point doesn't line up with things in browser-space, so we need to scale it.
            var scaledPoint = this.minimumSizeManager.scalePoint(point);
            if (_$1.isArray(data)) {
                this._dispatchEvent('ChartEvent', {
                    event: eventName,
                    point: scaledPoint,
                    data: data,
                    pickObj: data[0],
                    pickSubObj: data[1],
                    pickPath: data[2],
                    eventData: data[3],
                    redirect: data[4],
                    reason: data[5],
                    action: data[7],
                    objectPart: data[8]
                });
            }
            else {
                this._dispatchEvent('ChartEvent', {
                    event: eventName,
                    point: scaledPoint,
                    data: data
                });
            }
        };
        FDSChart.prototype.fireZoomEvent = function (leftPt, rightPt, axis, continueZooming) {
            if (continueZooming === void 0) { continueZooming = false; }
            this._handleZoom(axis.zoomGroup, leftPt, rightPt);
            this.fireChartEvent('ZoomUpdate', { x: 0, y: 0 }, [axis.id, leftPt, rightPt, axis.zoomGroup]);
            if (!continueZooming) {
                this.renderManager.zooming = this.renderManager.zoomPanning = false;
                this._clearActiveSlider();
            }
        };
        FDSChart.prototype._dispatchEvent = function (eventName, detail) {
            var custom = document.createEvent('CustomEvent');
            custom.initCustomEvent(eventName, true, true, detail);
            this.containing_element.dispatchEvent(custom);
        };
        FDSChart.prototype.objectAction = function (action, flags, args) {
            var _this = this;
            var _a = _super.prototype.objectAction.call(this, action, flags, args), handled = _a[0], ret = _a[1], errString = _a[2];
            if (handled) {
                return [handled, ret, errString];
            }
            // set handled to true first, and then set to false if none of the below match.
            handled = true;
            var cursor;
            switch (action) {
                case 'GetSelectedObjectList':
                    var selected = [];
                    for (var id in this.objects) {
                        var obj = this.objects[id];
                        if (obj.isSelected()) {
                            selected.push(obj.id);
                        }
                    }
                    ret = selected;
                    break;
                case 'SYS_TRENDLINE':
                    cursor = this._getCursorFromArgs(args);
                    var numPts = this._getNumPtsFromArgs(args);
                    if (numPts > 0) {
                        this._onPopupTrendline(cursor, numPts);
                    }
                    else {
                        errString = 'SYS_TRENDLINE action requires count greater than 0';
                    }
                    break;
                case 'SYS_PICKPOINT':
                    cursor = this._getCursorFromArgs(args);
                    this._onPopupPickPoint(cursor);
                    break;
                case 'SYS_DRAWBOX':
                    cursor = this._getCursorFromArgs(args);
                    this._onPopupDrawbox(cursor);
                    break;
                case 'SYS_PICK':
                    cursor = this._getCursorFromArgs(args);
                    this._onPopupPick(cursor, flags);
                    break;
                case 'SetXMLString':
                    var xml = (args instanceof Array) ? args[0] : args;
                    this.loadFromXMLString(xml);
                    break;
                case 'GetXMLString':
                case 'InlineXML':
                    ret = this.dumpXML();
                    break;
                case 'GetXMLFromServer':
                    if (args instanceof Array && args.length > 0) {
                        var url = args[0];
                        var xhr_1 = new XMLHttpRequest();
                        xhr_1.onload = function () {
                            if (xhr_1.status === 404) {
                                throw "FDSChart::ObjectAction GetXMLFromServer returned " + xhr_1.status + " : " + xhr_1.statusText;
                            }
                            return _this.loadFromXMLString(xhr_1.responseText);
                        };
                        xhr_1.open('get', url, true);
                        xhr_1.send();
                    }
                    else {
                        errString = 'You must provide a url';
                    }
                    break;
                case 'GetJSONString':
                case 'InlineJSON':
                    ret = this.dumpJSON();
                    break;
                case 'SimpleZoom':
                    this.renderManager.zoomChart(this.pick);
                    break;
                case 'SimpleZoomReset':
                    this.renderManager.unZoomChart(this.pick);
                    break;
                case 'InlinePNG64': {
                    var quality = args[0];
                    ret = this.toImage('image/png', quality);
                    break;
                }
                case 'InlineWebP64': {
                    var quality = args[0];
                    ret = this.toImage('image/webp', quality);
                    break;
                }
                case 'InlinePNG64Async': {
                    var callback = args[0];
                    var quality = args[1];
                    ret = this.toImageAsync(callback, 'image/png', quality);
                    break;
                }
                case 'InlineWebP64Async': {
                    var callback = args[0];
                    var quality = args[1];
                    ret = this.toImageAsync(callback, 'image/webp', quality);
                    break;
                }
                case 'GlobalIgnoreMenuEntries':
                    this.contextMenu.ignoreIDs(args);
                    break;
                case 'GlobalSuppressMenuEntries':
                    this.contextMenu.suppressIDs(args);
                    break;
                case 'GlobalPrependAppMenu':
                    _b = this.contextMenu.globalPrepend(args), ret = _b[0], errString = _b[1];
                    break;
                case 'GlobalAppendAppMenu':
                    _c = this.contextMenu.globalAppend(args), ret = _c[0], errString = _c[1];
                    break;
                case 'GlobalSetAppMenu':
                    _d = this.contextMenu.globalSet(args), ret = _d[0], errString = _d[1];
                    break;
                case 'GlobalClearAppMenu':
                    _e = this.contextMenu.globalClear(args), ret = _e[0], errString = _e[1];
                    break;
                case 'Menu':
                    if (_$1.isString(args)) {
                        ret = this.contextMenu.handleSysMenuId(args);
                        if (!ret) {
                            errString = 'Invalid menu ID';
                        }
                    }
                    else {
                        _f = [false, 'Argument must be a string'], ret = _f[0], errString = _f[1];
                    }
                    break;
                case 'SynchAllMembers':
                case 'SyncAllMembers':
                    this.syncAll();
                    break;
                case 'HideTooltip':
                    this.tooltip.hide();
                    this.tooltip.resetTimeouts();
                    break;
                case 'EnableStateLogging2':
                    if (args[0]) {
                        this._enableStateLogging();
                    }
                    else {
                        this._disableStateLogging();
                    }
                    break;
                case 'StateCheckpoint':
                    ret = this._checkStateLog();
                    break;
                case 'SuppressAllInteraction': {
                    var oldVal = this.suppressAllInteraction;
                    if (args[0]) {
                        this.suppressAllInteraction = true;
                    }
                    else {
                        this.suppressAllInteraction = false;
                    }
                    // syncing is expensive so I only do it when this changes
                    if (oldVal !== this.suppressAllInteraction) {
                        // have to sync here because some things that depend on this flag
                        // only update during sync
                        this.attributeSet.setDirty(true);
                        this.syncAll();
                    }
                    break;
                }
                case 'AddDT_Trendline':
                    this._addDT('Trendline', 1 /* LINE */, args);
                    break;
                case 'AddDT_Fibonacci_Arc':
                    this._addDT('FibArc', 1 /* LINE */, args);
                    break;
                case 'AddDT_Fibonacci_Fan':
                    this._addDT('FibFan', 1 /* LINE */, args);
                    break;
                case 'AddDT_Speed_Resistance_Levels':
                    this._addDT('SpeedResistance', 1 /* LINE */, args);
                    break;
                case 'AddDT_Fibonacci_Retracement':
                    this._addDT('FibRetracements', 1 /* LINE */, args);
                    break;
                case 'AddDT_Fibonacci_Projection':
                    this._addDT('FibProjection', 1 /* LINE */, args, 3);
                    break;
                case 'AddDT_Fibonacci_Time_Zones':
                    this._addDT('FibTimeZones', 1 /* LINE */, args);
                    break;
                case 'AddDT_Gann_Fan':
                    this._addDT('GannFan', 1 /* LINE */, args);
                    break;
                case 'AddDT_Change_Over_Range':
                    this._addDT('PriceChange', 1 /* LINE */, args);
                    break;
                case 'AddDT_Arrow':
                    this._addDT('Arrow', 1 /* LINE */, args);
                    break;
                case 'AddDT_Circle':
                    this._addDT('Circle', 2 /* BOX */, args);
                    break;
                case 'AddDT_Rectangle':
                    this._addDT('Rect', 2 /* BOX */, args);
                    break;
                case 'AddDT_Linear_Regression':
                    this._addDT('LinearRegression', 3 /* PICK */, args);
                    break;
                case 'AddDT_Average':
                    this._addDT('Average', 3 /* PICK */, args);
                    break;
                case 'AddDT_Median':
                    this._addDT('Median', 3 /* PICK */, args);
                    break;
                case 'AddDT_Average_and_Standard_Deviation':
                    this._addDT('AvgStdDev', 3 /* PICK */, args);
                    break;
                case 'AddDT_Quadrant_Lines':
                    this._addDT('QuadrantLines', 3 /* PICK */, args);
                    break;
                case 'AddDT_Tirone_Levels':
                    this._addDT('TironeLevels', 3 /* PICK */, args);
                    break;
                case 'AddDT_Raff_Regression':
                    this._addDT('RaffRegression', 3 /* PICK */, args);
                    break;
                case 'AddDT_Zig_Zag':
                    this._addDT('ZigZag', 3 /* PICK */, args);
                    break;
                case 'AddDT_Marker':
                    this._addDT('Marker', 3 /* PICK */, args);
                    break;
                case 'AddDT_Series_Textbox':
                    this._addDT('SeriesTextbox', 3 /* PICK */, args);
                    break;
                case 'AddDT_Vertical_Reference_Line':
                    this._addDT('Vertical', 4 /* PICKPOINT */, args);
                    break;
                case 'AddDT_Horizontal_Reference_Line':
                    this._addDT('Horizontal', 4 /* PICKPOINT */, args);
                    break;
                case 'AddDT_Textbox':
                    this._addDT('Textbox', 4 /* PICKPOINT */, args);
                    break;
                case 'AddDT_Harmonic_Mean':
                    this._addDT('HarmonicMean', 3 /* PICK */, args);
                    break;
                case 'FetchBGDrawstyles':
                    ret = this._fetchBGDrawstyles();
                    break;
                default:
                    ret = false;
                    handled = false;
                    errString = "Unknown action: " + action;
            }
            return [handled, ret, errString];
            var _b, _c, _d, _e, _f;
        };
        // External objectAction call
        //
        // @param object [String] id of the object to perform the action on
        // @param flags [ActionFlags]
        // @param action [String] string name of the object to be performed
        // @param args [Object] This depends on what type of object is being performed
        FDSChart.prototype.objectActionExternal = function (objectId, flags, action, args) {
            var handled = false;
            var ret = true;
            var errString = '';
            var object = this.getObject(objectId);
            if (object) {
                _a = object.objectAction(action, flags, args), handled = _a[0], ret = _a[1], errString = _a[2];
            }
            else {
                throw "FDSChart::ObjectAction: Invalid object '" + objectId + "'";
            }
            if (handled) {
                this._setStateChanged(true);
            }
            else {
                ret = false;
                errString = 'Unknown action: ' + action;
            }
            if (errString !== '') {
                throw "FDSChart::ObjectAction: " + errString;
            }
            return ret;
            var _a;
        };
        FDSChart.prototype._onPopupTrendline = function (cursor, count) {
            if (count > 1) {
                this.interactionCursor = cursor;
                this.dragMode = 5 /* TREND */;
                this.rubberBandMode = 3 /* LINE */;
                this._pickPointsLength = count;
                this.pickPoints = [];
            }
        };
        FDSChart.prototype._onPopupDrawbox = function (cursor) {
            this.dragMode = 6 /* DRAWBOX */;
            this.rubberBandMode = 2 /* RECT */;
            this.interactionCursor = cursor;
            this._pickPointsLength = 2;
            this.pickPoints = [];
        };
        FDSChart.prototype._onPopupPick = function (cursor, flags) {
            this.dragMode = 1 /* PICK */;
            this.rubberBandMode = 1 /* POINT */;
            this.pickObjectType = flags;
            this._pickMatchCursor = cursor;
        };
        FDSChart.prototype._onPopupPickPoint = function (cursor) {
            this.dragMode = 2 /* PICKPOINT */;
            this.rubberBandMode = 1 /* POINT */;
            this.interactionCursor = cursor;
        };
        FDSChart.prototype._getNumPtsFromArgs = function (args) {
            if (args instanceof Array) {
                if (args.length === 2) {
                    return Number(args[1]);
                }
            }
            return 2;
        };
        FDSChart.prototype._getCursorFromArgs = function (args) {
            if (args instanceof Array) {
                // if args is passed in as an array, assume the cursor is the first thing
                return args[0];
            }
            else {
                // otherwise return noop.
                return args;
            }
        };
        FDSChart.prototype.getLayerManager = function () {
            return this._renderLayerManager;
        };
        FDSChart.prototype.renderRichTextLinks = function () {
            this._renderLayerManager.renderRichTextLinks(this._theme);
        };
        // Used to determine which plot we are over
        //
        // @param point [Point] where the pointer is
        // @return [Boolean] whether or not we are actually over any plots
        FDSChart.prototype.hitTest = function (point, pick$$1, hitShape, mustHitData) {
            if (hitShape === void 0) { hitShape = 0 /* POINT */; }
            if (mustHitData === void 0) { mustHitData = false; }
            var sliderHit = false;
            var sliderRes = this.plotResizeManager.hitTest(point, pick$$1, hitShape);
            var sliderPlot;
            var sliderHS;
            if (sliderRes) {
                sliderPlot = sliderRes[0], sliderHS = sliderRes[1];
                sliderHit = true;
                this.interacting = true;
            }
            var ret = false;
            pick$$1.setAccessObject(this.id);
            pick$$1.setAccessSubObject('Canvas');
            var pickInteractivity = pick$$1.getPickInteractivity();
            if (!mustHitData) {
                if (this._renderLayerManager.linkContainer.hitTest(pick$$1, point)) {
                    return true;
                }
            }
            for (var _i = 0, _a = this.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                if (plot.hitTest(point.x, point.y, pick$$1, hitShape, mustHitData)) {
                    ret = true;
                }
                // In a geographic heatmap, clicks can go through the plot and into the chart directly,
                // so this lets us know what plot object was clicked even when this occurs.
                if (plot.pointInPlot(point)) {
                    this.activePlot = plot.id;
                }
            }
            if (sliderHit && !this.suppressAllInteraction) {
                if (pickInteractivity === 1 /* SELECTING */) {
                    this.pickedObj = sliderHS;
                    this.dragMode = 10 /* PLOT_RESIZE */;
                    this.pickPoints[0] = { point: point, series: '' };
                }
                else {
                    var index = void 0;
                    if (sliderPlot != null) {
                        index = sliderHS.index;
                    }
                    if (index !== this.mousedOverPlotSliderIndex) {
                        this.mousedOverPlotSliderIndex = index;
                        this.renderManager.draw(false); // minimal redraw
                    }
                    var cursor = Cursor.DEFAULT;
                    switch (sliderHS.direction) {
                        case 1 /* ROW */:
                            cursor = Cursor.SIZENS;
                            break;
                        case 0 /* COLUMN */:
                            cursor = Cursor.SIZEWE;
                            break;
                    }
                    pick$$1.cursor = cursor;
                }
                return true;
            }
            else if (!this.suppressAllInteraction) {
                // don't reset the moused-over slider while we're dragging - we want that one to stay selected
                if (this.mousedOverPlotSliderIndex !== -1 && this.dragMode !== 10 /* PLOT_RESIZE */) {
                    this.mousedOverPlotSliderIndex = -1;
                    this.renderManager.draw(false); // minimal redraw
                }
            }
            if (!ret) {
                var tip = '';
                if (this._selectSubObject(point.x, point.y, pick$$1)) {
                    pick$$1.setLevel(2, this.id);
                    pick$$1.setAccessObject(this.id);
                    tip = this.attributeSet.get('TooltipText');
                    if (tip !== '') {
                        pick$$1.setAccessData(tip);
                    }
                    ret = true;
                }
            }
            if ((pickInteractivity === 1 /* SELECTING */) && !this.suppressAllInteraction) {
                if (this._selectedObj) {
                    this._selectedObj.setSelected(false);
                }
                var obj = this.getChild(pick$$1.accessObject());
                if (obj && obj.isSelectable()) {
                    obj.setSelected();
                    this._selectedObj = obj;
                    this.renderManager.draw(false);
                }
            }
            return ret;
        };
        FDSChart.prototype._isFocusedSliderHere = function (point) {
            return false;
        };
        FDSChart.prototype._selectSubObject = function (x, y, pick$$1) {
            for (var i = this._hitShapes.length - 1; i >= 0; i--) {
                var shape = this._hitShapes[i];
                if (shape.onHitTest(x, y)) {
                    var hitName = shape.name;
                    if (hitName === 'RichTextHitRect') {
                        pick$$1.setAccessLClickAction(shape.action);
                        pick$$1.cursor = shape.cursor;
                    }
                    else {
                        pick$$1.setAccessSubObject(hitName);
                    }
                    if (shape.hoverText != null) {
                        pick$$1.hoverText = shape.hoverText; // pass it along
                    }
                    return true;
                }
            }
            return false;
        };
        FDSChart.prototype.setHitList = function () {
            for (var _i = 0, _a = this.storedHeaderRects; _i < _a.length; _i++) {
                var rect = _a[_i];
                this._hitShapes.push(rect);
            }
        };
        FDSChart.prototype.doPick = function (eventStr, point) {
            this.pick.init(eventStr, point);
            return this.hitTest(point, this.pick);
        };
        FDSChart.prototype._pickMatchesObjectType = function () {
            if (this.pickObjectType !== -1 /* FC_NULL */) {
                var pickMatch = false;
                var obj = this.getChild(this.pick.accessObject());
                if (obj) {
                    pickMatch = obj.type === 2 /* FC_SERIES */;
                    if (pickMatch && this.pickObjectType === 2 /* FC_SERIES */) {
                        if (isSeries(obj)) {
                            pickMatch = obj.sysPickable;
                        }
                    }
                }
                return pickMatch;
            }
            else {
                return true;
            }
        };
        FDSChart.prototype.isSelectionEnabled = function () {
            return (1 /* SELECTABLE */ & this.getInteractivityMode());
        };
        FDSChart.prototype._doPrimaryPointerPick = function (eventStr, point, event) {
            this.pick.init(eventStr, point);
            if (this.isSelectionEnabled() || !this._isInteractionListEmpty()) {
                this.pick.setPickInteractivity(1 /* SELECTING */);
            }
            var hit = this.hitTest(point, this.pick);
            this.tooltip.doTooltip(hit, event);
        };
        FDSChart.prototype._setWorldPtEvent = function (plot, pt, pick$$1) {
            var res = '';
            var plotObj = this.getTypedObject(plot, isPlot);
            if (plotObj) {
                if (pick$$1 != null) {
                    pick$$1.setAccessObject(plotObj.id);
                    pick$$1.setAccessData(plotObj.formatAsWorldSinglePt(pt));
                }
                else {
                    res = plotObj.formatAsWorldSinglePt(pt);
                }
            }
            else {
                if (pick$$1 != null) {
                    pick$$1.setAccessObject('');
                    pick$$1.setAccessData('0 0');
                }
                else {
                    res = '0 0';
                }
            }
            return res;
        };
        // Converts the points of a chart interaction into
        // scale data points
        //
        // @param plot [String] the string id of the plot we are interacting with
        // @param pt1 [Point] the first point, in pixels (x,y)
        // @param pt2 [Point] the second point, in pixels (x,y)
        // @param preserveSlope [Boolean] whether or not we should preserve the slope if a point is out of the plotRect
        // @return [Array] Array containing the id of the plot and the data points of the start and end points
        FDSChart.prototype._setWorldRectEvent = function (plot, pt1, pt2, pick$$1, preserveSlope) {
            if (preserveSlope === void 0) { preserveSlope = false; }
            var point1 = { x: pt1.x, y: pt1.y };
            var point2 = { x: pt2.x, y: pt2.y };
            var plotObj = this.getTypedObject(plot, isPlot);
            if (plotObj) {
                pick$$1.setAccessObject(plotObj.id);
                pick$$1.setAccessData(plotObj.formatAsWorld(point1, point2, preserveSlope));
            }
            else {
                pick$$1.setAccessObject('');
                pick$$1.setAccessData('0 0 0 0');
            }
            return true;
        };
        FDSChart.prototype._getWorldEventAxisId = function (plot) {
            var plotObj = this.getTypedObject(plot, isPlot);
            if (plotObj) {
                var axisSpecifier = plotObj.findAGoodAxis();
                var axis = plotObj.getAxis(axisSpecifier);
                if (axis) {
                    return axis.id;
                }
            }
            return '';
        };
        // Determine how our drag was canceled and fire the appropriate event
        FDSChart.prototype._onCancelMode = function () {
            this.renderManager.interactivityMode = 0 /* NONE */;
            var shouldRefresh = false;
            var strCancelModeType = '';
            if (this.rubberBandMode !== 0 /* NONE */ || this.dragMode !== 0 /* NONE */) {
                switch (this.dragMode) {
                    case 5 /* TREND */:
                        strCancelModeType = 'DRAGMODE_TREND';
                        break;
                    case 2 /* PICKPOINT */:
                        strCancelModeType = 'DRAGMODE_PICKPOINT';
                        break;
                    case 1 /* PICK */:
                        strCancelModeType = 'DRAGMODE_PICK';
                        break;
                    case 3 /* ZOOM */:
                        strCancelModeType = 'DRAGMODE_ZOOM';
                        break;
                }
                this.rubberBandMode = 0 /* NONE */;
                this.dragMode = 0 /* NONE */;
                this.pickPoints = [];
                this.interactionCursor = Cursor.DEFAULT;
                shouldRefresh = true;
            }
            if (strCancelModeType !== '') {
                this.fireChartEvent('CancelMode', { x: 0, y: 0 }, strCancelModeType);
            }
            return shouldRefresh;
        };
        // external call for clearing an object's children
        //
        // @param name [String] String ID of the object
        FDSChart.prototype.clearObject = function (name) {
            if (name === null) {
                name = '';
            }
            return this._clearObjectInternal(name);
        };
        // Internal call for clearing an object's children
        //
        // @param name [String] String ID of the object
        FDSChart.prototype._clearObjectInternal = function (name) {
            var ret = false;
            var errString = '';
            var object = this.getChild(name);
            if (object) {
                object.clear();
                ret = true;
            }
            else {
                errString = "Unknown Object: " + name;
            }
            this._setStateChanged(true);
            return [ret, errString];
        };
        // External delete call for deleting an object
        //
        // @param name [String] String ID of the object to be deleted
        // @param flags [DeleteFlags] Flag used to delete with children or not
        FDSChart.prototype.deleteObject = function (name, flags) {
            if (name === null) {
                name = '';
            }
            return this._deleteObjectInternal(name, flags);
        };
        // Internal delete call for deleting an object
        //
        // @param name [String] String ID of the object to be deleted
        // @param flags [DeleteFlags] Flag used to delete with children or not
        FDSChart.prototype._deleteObjectInternal = function (name, flags, fullRemoval) {
            if (fullRemoval === void 0) { fullRemoval = true; }
            var ret = false;
            var errString = '';
            var deleteAxisObjects = false;
            var childList = {};
            var clearStyle = false;
            if (this._getReservedType(name) === -1 /* FC_NULL */) {
                if (this._isBeingInteractedTo(name)) {
                    this.emptyInteractionList();
                }
                var object = this.objects[name];
                if (object) {
                    this.animationManager.removeAnimationsForObject(name);
                    if (fullRemoval) {
                        object.notifyParents();
                    }
                    if (isPlot(object)) {
                        var index = this.chartPlotList.indexOf(object);
                        if (index > -1) {
                            this.chartPlotList.splice(index, 1);
                            this.wrapper.setPlotListDirty();
                        }
                    }
                    // If we are deleting a dataset, we don't delete it if it is bound to
                    // other series
                    if ((isDataSet(object) && object.boundSeries.length === 0) || !(isDataSet(object))) {
                        for (var id in object.children) {
                            var obj = object.children[id];
                            childList[id] = obj;
                        }
                        // Since data children of FDSSeries are not stored in @children,
                        // we will join the dimensionalChildren object with the @children list.
                        // This should be safe because they all require unique ids to be added
                        // to the chart
                        if (isSeries(object) && object.dimensionalChildren != null) {
                            for (var id in object.dimensionalChildren) {
                                var obj = object.dimensionalChildren[id];
                                childList[obj.id] = obj;
                            }
                        }
                        if (object.isStyleObject && isAxis(object)) {
                            clearStyle = true;
                        }
                        object.removeChildren();
                        delete this.objects[name];
                        if (this.children[name] != null) {
                            delete this.children[name];
                        }
                        ret = true;
                    }
                    else {
                        errString = "Unable to fully delete Object: " + name;
                    }
                }
                if (flags === 1 /* DELETE_WITH_CHILD */) {
                    for (var id in childList) {
                        var child = childList[id];
                        _a = this._deleteObjectInternal(id, flags, false), errString = _a[1];
                    }
                }
                else if (deleteAxisObjects) {
                    // here object was an FDSPlot
                    for (var id in childList) {
                        var child = childList[id];
                        if (isLegend(child) || isAxis(child)) {
                            _b = this._deleteObjectInternal(id, flags, false), errString = _b[1];
                        }
                    }
                }
            }
            else {
                errString = "Reserved Object Name: " + name;
            }
            if (clearStyle) {
                this._clearStyleFromAllChildren();
            }
            if (ret === false && errString === '') {
                errString = "Unknown Object: " + name;
            }
            this._setStateChanged(true);
            return [ret, errString];
            var _a, _b;
        };
        FDSChart.prototype.invalidate = function () {
            var _this = this;
            if (this._invalidateHandle == null && !isHeadlessMode) {
                this._invalidateHandle = window.requestAnimationFrame(function () {
                    _this._invalidateHandle = null;
                    _this.draw();
                });
            }
        };
        FDSChart.prototype.hasQueuedInvalidate = function () {
            return this._invalidateHandle != null;
        };
        FDSChart.prototype.cancelQueuedInvalidate = function () {
            window.cancelAnimationFrame(this._invalidateHandle);
            this._invalidateHandle = null;
        };
        FDSChart.prototype.removeStyleSet = function () {
            this._clearStyleFromAllChildren();
            for (var id in this._styleObjects) {
                delete this.children[id];
                delete this.objects[id];
            }
            this._styleObjects = {};
            this.styleChildren = {};
            this.resetAttributeInheritance();
            this.attributeSet.setDirty(true);
            this._drawStyleToStyleObjectName = {};
        };
        FDSChart.prototype._clearStyleFromAllChildren = function () {
            for (var id in this.children) {
                var child = this.children[id];
                this.children[id].styleChildren = {};
                child.resetAttributeInheritance();
                child.attributeSet.setDirty();
            }
        };
        FDSChart.prototype._firePickEventing = function () {
            this.fireChartEvent(this.pick.accessMessage(), this.pick.accessPoint(), this.pick.getPick());
        };
        // Method for simple zooming all of the plots on a chart in the zoom group of
        // the focus plot
        //
        // @param focusPlot [FDSPlot] plot that has focus
        // @param pt1 [Point] The first point of the rectangle to zoom
        // @param pt1 [Point] The second point of the rectangle to zoom
        // @param mode [ZoomAction] The mode of zooming (zooming or unzooming)
        FDSChart.prototype._simpleZoom = function (focusPlotId, pt1, pt2, mode) {
            var ret = false;
            var focusPlot = this.getTypedObject(focusPlotId, isPlot);
            for (var _i = 0, _a = this.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                if ((plot.attributeSet.get('ZoomGrouped')) || plot === focusPlot) {
                    if (plot.simpleZoom(pt1, pt2, mode)) {
                        ret = true;
                    }
                }
            }
            this._setStateChanged(true);
            return ret;
        };
        FDSChart.prototype.handleUnzoom = function () {
            var focusPlot = this.attributeSet.get('FocusPlot');
            if (focusPlot === '') {
                focusPlot = this.activePlot;
            }
            if (this._simpleZoom(focusPlot, new Point(0, 0), new Point(0, 0), 0 /* UNZOOM */)) {
                this.invalidate();
                this.fireChartEvent('UnZoom', { x: 0, y: 0 }, ['', '', '', '', '', '', '', '']);
            }
        };
        FDSChart.prototype.mergeCanvas = function (includeTooltip) {
            if (includeTooltip === void 0) { includeTooltip = true; }
            if (this._renderLayerManager instanceof CanvasLayerManager) {
                return this._renderLayerManager.flattenLayersToCanvas(includeTooltip);
            }
            else {
                throw new Error('Synchronous image fetching is only supported for canvas renderingMode');
            }
        };
        // this function is async, so you need to pass in a callback that will
        // execute when it's done
        FDSChart.prototype._mergeCanvasAsync = function () {
            var _this = this;
            var deferred = $$1.Deferred();
            this._renderLayerManager.flattenLayersToCanvasAsync(true).then(function (canvas) {
                var svgSeries = [];
                // add any geo heatmap svg elements
                for (var id in _this.children) {
                    var s = _this.children[id];
                    if (isSeries(s)) {
                        if (s.drawStyle !== 41 /* KMLMAP */) {
                            continue;
                        }
                        if (s.renderCache && s.renderCache.svg == null) {
                            continue;
                        }
                        svgSeries.push(s);
                    }
                }
                var waitctx = { svgImagesWaitedFor: svgSeries.length, deferred: deferred };
                if (svgSeries.length === 0) {
                    // we're not waiting on any images. call the callback now!
                    deferred.resolve(canvas);
                }
                else {
                    var x = new XMLSerializer();
                    for (var _i = 0, svgSeries_1 = svgSeries; _i < svgSeries_1.length; _i++) {
                        var s = svgSeries_1[_i];
                        // encode svg as base64 and save
                        var svg = x.serializeToString(s.renderCache.svg);
                        var src = 'data:image/svg+xml;base64,' + window.btoa(svg);
                        var img = new Image();
                        img.width = canvas.width;
                        img.height = canvas.height;
                        var drawThisImage = _this._drawLoadedImageToCanvas.bind(_this, img, canvas, s, waitctx);
                        img.onload = drawThisImage;
                        img.src = src;
                    }
                }
            });
            return deferred.promise();
        };
        FDSChart.prototype._drawLoadedImageToCanvas = function (img, canvas, series, waitctx) {
            var plot = series.getPlotParent();
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, plot.plotRect.x1, plot.plotRect.y1);
            waitctx.svgImagesWaitedFor--;
            if (waitctx.svgImagesWaitedFor === 0) {
                waitctx.deferred.resolve(canvas);
            }
        };
        // urlString is undefined for PNG, "image/webp" for WebP
        FDSChart.prototype.toImageAsync = function (callback, mimeType, quality) {
            if (callback == null || typeof callback !== 'function') {
                callback = null;
            }
            if (!mimeType || mimeType === 'image/png') {
                quality = 0;
            }
            var deferred = $$1.Deferred();
            this._mergeCanvasAsync().then(function (canvas) {
                var data = canvas.toDataURL(mimeType, quality);
                if (callback) {
                    callback(data);
                }
                deferred.resolve(data);
            });
            return deferred.promise();
        };
        FDSChart.prototype.toSvg = function () {
            if (this._renderingMode === 'svg') {
                var svgManager = this._renderLayerManager;
                var newSvgRoot = svgManager.cloneSvgRoot();
                // add any geo heatmap svg elements
                for (var _i = 0, _a = this._getObjectsOfType(FDSSeries); _i < _a.length; _i++) {
                    var s = _a[_i];
                    if (s.drawStyle !== 41 /* KMLMAP */ || s.renderCache == null) {
                        continue;
                    }
                    if (s.renderCache && s.renderCache.svg == null) {
                        newSvgRoot.appendChild(s.renderCache.svg.cloneNode(true));
                    }
                }
                return newSvgRoot;
            }
            else {
                throw new Error("Can only get SVG content when renderingMode is set to 'svg'");
            }
        };
        FDSChart.prototype.toImage = function (mimeType, quality) {
            if (this._renderingMode === 'svg') {
                throw new Error('Synchronous image fetching is not available when rendering to SVG');
            }
            if (!mimeType || mimeType === 'image/png') {
                quality = 0;
            }
            return this.mergeCanvas().toDataURL(mimeType, quality);
        };
        FDSChart.prototype.getCrosshairsTooltipSnapPlot = function () {
            var snapPlotId = this._crosshairsTooltipSnapPlot;
            if (snapPlotId === '') {
                snapPlotId = this.activePlot;
            }
            return this.getTypedObject(snapPlotId, isPlot);
        };
        FDSChart.prototype.getImageDS = function (name) {
            if (name.length !== 0) {
                var object = this.getChild(name);
                if (isDataSet(object)) {
                    return object;
                }
            }
            return null;
        };
        FDSChart.prototype.getInteractivityObjectType = function () {
            return 16 /* ROOT */;
        };
        FDSChart.prototype.setInteractionCursor = function (cursor) {
            this.interactionCursor = cursor;
        };
        FDSChart.prototype._setCursor = function (cursor) {
            var oldCursor = this.containing_element.style.cursor;
            if (!this.suppressAllInteraction) {
                this.containing_element.style.cursor = cursor;
            }
            return oldCursor;
        };
        FDSChart.prototype._getCursorName = function (pick$$1) {
            if (this.interactionCursor !== Cursor.DEFAULT) {
                return this._getCursorData(this.interactionCursor);
            }
            if (pick$$1.cursor.length !== 0) {
                return pick$$1.cursor;
            }
            var chartObject = this.getChild(pick$$1.accessObject());
            if (chartObject == null) {
                return Cursor.DEFAULT;
            }
            var subObject = pick$$1.accessSubObject();
            var cursor = chartObject.attributeSet.get('Cursor');
            if (!cursor) {
                return Cursor.DEFAULT;
            }
            else {
                return cursor;
            }
        };
        FDSChart.prototype.getWidth = function () {
            return this.chartRect.getWidth();
        };
        FDSChart.prototype.getHeight = function () {
            return this.chartRect.getHeight();
        };
        FDSChart.prototype._startObjectInteraction = function (objectName, point, event, doRefresh, preferredMessage) {
            if (preferredMessage === void 0) { preferredMessage = 6 /* STARTINTERACTION */; }
            if (this.suppressAllInteraction) {
                this.emptyInteractionList();
                doRefresh.value = true;
                return false;
            }
            var ret = false;
            var chartObject = this.getChild(objectName);
            if (objectName === this.id && (this.interactivityMode & 8 /* TEXTEDITABLE */)) {
                doRefresh.value = true;
                this.emptyInteractionList();
                this._addToInteractionList(chartObject);
                this.interactionSignal.call(chartObject, point, event, preferredMessage);
            }
            else if ((chartObject != null) && chartObject.isInteractive() &&
                this.isPermittedSelectableObject(chartObject.getInteractivityObjectType())) {
                if (this.pick.accessLClickAction().length === 0 ||
                    (this.pick.accessLClickAction().length !== 0 && this._isBeingInteractedTo(chartObject))) {
                    ret = true;
                    // thje following line cannot be moved outside the IF because of the isBeingInteractedTo
                    this.emptyInteractionList();
                    this._addToInteractionList(chartObject);
                    this.interactionSignal.call(chartObject, point, event, preferredMessage);
                    this.interacting = true;
                }
                else {
                    this.emptyInteractionList();
                }
            }
            else {
                if (!this._isInteractionListEmpty()) {
                    this.emptyInteractionList();
                    doRefresh.value = true;
                }
            }
            return ret;
        };
        FDSChart.prototype._isBeingInteractedTo = function (object) {
            var id = (object instanceof FDSChartObject) ? object.id : object;
            return id === this._interactionObject;
        };
        FDSChart.prototype._addToInteractionList = function (object) {
            if (object != null) {
                object.setSelected();
                this._interactionObject = object.id;
                this.interactionSignal = object.interact;
                if (isSeries(object)) {
                    object.syncMembers();
                    this.interactiveDrawStyle = object.getDrawStylePrototype().drawStyle;
                    object.interactiveVisibleOverride = true;
                }
            }
        };
        FDSChart.prototype.emptyInteractionList = function (point, event, message) {
            if (point === void 0) { point = new Point(0, 0); }
            if (event === void 0) { event = null; }
            if (message === void 0) { message = 7 /* ENDINTERACTION */; }
            this.interactiveDrawStyle = null;
            var obj = this.getInteractionObject();
            if (isSeries(obj)) {
                obj.interactiveVisibleOverride = false;
            }
            if (obj != null) {
                this.interactionSignal.call(obj, point, event, message);
            }
            this.interactionSignal = function () {
            };
            this.interactionCursor = Cursor.DEFAULT;
            this._interactionObject = '';
        };
        FDSChart.prototype.getSnappedSeries = function () {
            return this._snappingSeries;
        };
        FDSChart.prototype._isInteractionListEmpty = function () {
            return this._interactionObject === '';
        };
        FDSChart.prototype.getInteractionObject = function () {
            return this.getTypedObject(this._interactionObject, isSeries);
        };
        FDSChart.prototype.removeFromInteractionList = function (object) {
            if (object != null) {
                this._interactionObject = '';
                if (isSeries(object)) {
                    object.interactiveVisibleOverride = false;
                }
            }
        };
        FDSChart.prototype.isPermittedSelectableObject = function (t) {
            return (this._selectabilityMask & t) !== 0;
        };
        FDSChart.prototype.drawSnappedMarker = function () {
            if (this._snappedPoint != null) {
                var ctx = this.getOverlayContext();
                ctx.save();
                var markerPen = new FDSPen({ color: 0 /* BLACK */, width: 1 });
                var markerBrush = new FDSBrush();
                markerBrush.color = 16777215 /* WHITE */;
                markerBrush.style = 0 /* SOLID */;
                var drawFunctor = getMarkerDrawFunctor(this.selectableItemPointMarkerType, this.selectableItemPointMarkerSize);
                var aliasOffset = markerPen.getAliasOffset();
                markerPen.setOnCanvas(ctx);
                markerBrush.setOnCanvas(ctx);
                ctx.beginPath();
                drawFunctor(ctx, ~~this._snappedPoint.x + aliasOffset, ~~this._snappedPoint.y + aliasOffset);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        };
        FDSChart.prototype.snapMouseToSeries = function (point, result, ignoreList, event) {
            if (ignoreList === void 0) { ignoreList = []; }
            var snapSeries = '';
            this._snappedPoint = null;
            var smallestDistanceSquared = Number.POSITIVE_INFINITY;
            var shouldSnap = event.ctrlKey ? !this._bSnapMouseToSeries : this._bSnapMouseToSeries;
            if (shouldSnap) {
                var list = this.getDescendentOfClassList(FDSSeries);
                if (list.length > 0) {
                    var series = list[0];
                    if (series && !_$1.includes(ignoreList, series)) {
                        var index = series.getIndexFromPos(point, true);
                        if (index >= 0 && index < series.size) {
                            var xPt = series.getData(1 /* X */).getAt(index);
                            var yPt = series.getData(2 /* Y */).getAt(index);
                            var plot = series.getPlotParent();
                            // modify result in place so that its returned.
                            (_a = plot.getPixelLocationFromDataXY(xPt, yPt, series), result.x = _a.x, result.y = _a.y);
                            smallestDistanceSquared = Math.pow(point.x - result.x, 2) + Math.pow(point.y - result.y, 2);
                            snapSeries = series.id;
                        }
                    }
                }
                for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                    var series = list_1[_i];
                    if (!series || _$1.includes(ignoreList, series)) {
                        continue;
                    }
                    var index = series.getIndexFromPos(point, true);
                    var n = Math.round((this._snappingThreshold * series.size) / this.getWidth());
                    var j = index - ~~(n / 2);
                    while (j <= index + ~~(n / 2) && 0 <= j && j < series.size) {
                        var dimSize = series.getData(2 /* Y */).getDimension();
                        for (var k = 0; k < dimSize; k++) {
                            var xPt = series.getData(1 /* X */).getAt(j, 0);
                            var yPt = series.getData(2 /* Y */).getAt(j, k);
                            var plot = series.getPlotParent();
                            var _b = plot.getPixelLocationFromDataXY(xPt, yPt, series), x = _b.x, y = _b.y;
                            var distanceSquared = Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2);
                            // if this new one is closer
                            if (distanceSquared < smallestDistanceSquared) {
                                smallestDistanceSquared = distanceSquared;
                                result.x = x;
                                result.y = y;
                                snapSeries = series.id;
                            }
                        }
                        j++;
                    }
                }
            }
            this.drawBandsMarkers = (event.ctrlKey ? !this._bSnapMouseToSeries : this._bSnapMouseToSeries) &&
                smallestDistanceSquared < Math.pow(this._snappingThreshold, 2);
            if (this.drawBandsMarkers) {
                this._snappingSeries = snapSeries;
                this._snappedPoint = result.copy();
            }
            else {
                this._snappingSeries = '';
            }
            return this.drawBandsMarkers;
            var _a;
        };
        FDSChart.prototype.getChildList = function () {
            var list = {};
            for (var _i = 0, _a = this.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                list[plot.id] = plot;
            }
            return list;
        };
        FDSChart.prototype.setTextEditingContent = function (text) {
            text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            text = text.replace(/&lt;FDSBR&gt;/g, '<br>');
            this._textEditDiv.innerHTML = text;
        };
        FDSChart.prototype.getTextEditingContent = function () {
            var text = this._textEditDiv.innerHTML.trim();
            text = text.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');
            text = text.replace(/<br>/g, '<FDSBR>');
            // In internet explorer 11, the innerHTML wraps <p></p> tags around every line of text.
            // Therefore, '</p><p>' indicates a line break. We remove all other instances of <p> and </p>.
            text = text.replace(/<\/p><p>/g, '<FDSBR>');
            text = text.replace(/<\/?p>/g, '');
            text = text.replace(/&nbsp;/g, ' ');
            return text;
        };
        FDSChart.prototype.selectTextEditingContent = function () {
            if (typeof window.getSelection !== 'undefined' && typeof document.createRange !== 'undefined') {
                var range = document.createRange();
                range.selectNodeContents(this._textEditDiv);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
            else if (typeof document['selection'] !== 'undefined' &&
                typeof document.body['createTextRange'] !== 'undefined') {
                var textRange = document.body['createTextRange']();
                textRange.moveToElementText(this._textEditDiv);
                textRange.select();
            }
        };
        FDSChart.prototype.setTextEditingStyle = function (style) {
            for (var key in style) {
                this._textEditDiv.style[key] = style[key];
            }
        };
        FDSChart.prototype.displayTextEditingRectAt = function (rect) {
            if (rect.getWidth() <= 0 || rect.getHeight() <= 0) {
                return;
            }
            this.setTextEditRect(rect);
            this._textEditDivWrapper.style.display = 'table';
            this._textEditDiv.style.display = 'table-cell';
            this._textEditDiv.contentEditable = 'true';
        };
        FDSChart.prototype.setTextEditRect = function (rect) {
            // This div is being set up above the canvas and rect is unscaled, so we need do scaling here.
            var scaledRect = this.minimumSizeManager.scaleRectangle(rect);
            this._textEditDivWrapper.style.position = 'absolute';
            this._textEditDivWrapper.style.left = scaleByDevicePixelRatioInverse(scaledRect.x1) + 'px';
            this._textEditDivWrapper.style.top = scaleByDevicePixelRatioInverse(scaledRect.y1) + 'px';
            this._textEditDivWrapper.style.width = scaleByDevicePixelRatioInverse(scaledRect.getWidth()) + 'px';
            this._textEditDivWrapper.style.height = scaleByDevicePixelRatioInverse(scaledRect.getHeight()) + 'px';
        };
        FDSChart.prototype.hideTextEditingRect = function () {
            this._textEditDivWrapper.style.display = 'none';
            this._textEditDiv.style.display = 'none';
            this._textEditDiv.contentEditable = 'false';
        };
        // Returns the Base64 image string from window.FDSChartJS.cursorImages if it exists, wrapped in a url call
        // If no images are defined, returns the string passed in if it's a system cursor, else returns 'default'
        FDSChart.prototype._getCursorData = function (tool) {
            // Get the cursor image name if it exists
            var imageName = CursorImageNameMap[tool] != null ? CursorImageNameMap[tool] : tool;
            var defaultValue = _$1.includes(SystemCursors, tool) ? tool : 'default';
            return _$1.get(window, ['FDSChartJS', 'cursorImages', imageName], defaultValue);
        };
        FDSChart.prototype.processEventHandling = function (event, pick$$1, point) {
            var args = [point];
            this.wrapper.handleEvent(event, args);
        };
        FDSChart.prototype._enableStateLogging = function () {
            this.stateLog.isEnabled = true;
        };
        FDSChart.prototype._disableStateLogging = function () {
            this.stateLog.isEnabled = false;
        };
        FDSChart.prototype._checkStateLog = function () {
            var json = this.stateLog.toJson();
            var previousEnabledState = this.stateLog.isEnabled;
            // Create a new empty state log after the old one is checked, and preserve the enabled state
            this.stateLog = new FDSStateLog();
            this.stateLog.isEnabled = previousEnabledState;
            return json;
        };
        FDSChart.prototype.getUserAttrs = function () {
            var json = [];
            for (var _i = 0, _a = ['FC_CHART'].concat(Object.keys(this.children)); _i < _a.length; _i++) {
                var id = _a[_i];
                var obj = this.getObject(id);
                var attrs = obj.attributeSet.getValuesAtLevel('user');
                if (!attrs) {
                    continue;
                }
                var attrArr = [];
                for (var _b = 0, attrs_2 = attrs; _b < attrs_2.length; _b++) {
                    var _c = attrs_2[_b], name_2 = _c.name, value = _c.value;
                    attrArr.push({ newValue: value, name: name_2 });
                }
                if (attrArr.length > 0) {
                    json.push({ name: id, SET_NO_FLAGS: attrArr });
                }
            }
            return json;
        };
        FDSChart.prototype.applyUserAttrs = function (json) {
            for (var _i = 0, json_1 = json; _i < json_1.length; _i++) {
                var obj = json_1[_i];
                var chartObj = this.getObject(obj.name);
                if (chartObj == null) {
                    continue;
                }
                if (obj.SET_NO_FLAGS != null) {
                    for (var _a = 0, _b = obj.SET_NO_FLAGS; _a < _b.length; _a++) {
                        var attr = _b[_a];
                        chartObj._setAttributeRedirected(attr.name, 'user', attr.newValue);
                    }
                }
                if (obj.SET_RESET_FLAGS != null) {
                    for (var _c = 0, _d = obj.SET_RESET_FLAGS; _c < _d.length; _c++) {
                        var attr = _d[_c];
                        chartObj._setAttributeRedirected(attr.name, 'user', undefined);
                    }
                }
            }
        };
        FDSChart.prototype._fetchBGDrawstyles = function () {
            return bgDrawstyles;
        };
        FDSChart.prototype.setCanvasToNOP = function () {
            var _this = this;
            var oldRenderLayerManager = this._renderLayerManager;
            var oldMarkerCanvas = this._markerCanvas;
            this._renderLayerManager = new NullLayerManager();
            this._markerCanvas = this._renderLayerManager.createLayer();
            return {
                resetCanvas: function () {
                    _this._renderLayerManager = oldRenderLayerManager;
                    _this._markerCanvas = oldMarkerCanvas;
                }
            };
        };
        FDSChart.prototype._calculateHeaderFooter = function () {
            var headers = [
                this.chartHeader,
                this.chartHeading1,
                this.chartHeading2,
                this.chartHeading3,
                this.chartHeading4
            ];
            var ctx = this.getContext();
            this._cumulativeHeaderHeight = 0;
            var visible = false;
            for (var _i = 0, headers_1 = headers; _i < headers_1.length; _i++) {
                var header = headers_1[_i];
                if (header.visible) {
                    visible = true;
                    var _a = header.computeTextDimensions(ctx), height = _a[1];
                    this._cumulativeHeaderHeight += height;
                }
            }
            if (visible) {
                this._cumulativeHeaderHeight += this.chartHeadersBotOffset + this.chartHeadersTopOffset;
            }
            // also figure out the footer text height
            this._footerHeight = 0;
            if (this.chartFooter.visible) {
                var _b = this.chartFooter.computeTextDimensions(ctx), height = _b[1];
                this._footerHeight = height;
            }
        };
        FDSChart.prototype.calcHeaderOffsets = function () {
            this.headerRect.x1 = 0;
            this.headerRect.y1 = 0;
            this.headerRect.x2 = this.getWidth();
            this.headerRect.y2 = this.headerRect.y1 + this._cumulativeHeaderHeight;
            this.chartSubRect.y1 = this.chartRect.y1 + this._cumulativeHeaderHeight;
            this.footerRect.x1 = 0;
            this.footerRect.y2 = this.getHeight();
            this.footerRect.x2 = this.getWidth();
            this.footerRect.y1 = this.footerRect.y2 - this._footerHeight;
            this.chartSubRect.y2 = this.chartRect.y2 - this._footerHeight;
            var x1 = this.chartRect.x2;
            var x2 = this.chartRect.x1;
            for (var _i = 0, _a = this.chartPlotList; _i < _a.length; _i++) {
                var plot = _a[_i];
                if (plot.plotRect.x1 < x1) {
                    x1 = plot.plotRect.x1;
                }
                if (plot.plotRect.x2 > x2) {
                    x2 = plot.plotRect.x2;
                }
            }
            this.footerRect.x1 = this.headerRect.x1 = x1;
            this.footerRect.x2 = this.headerRect.x2 = x2;
        };
        FDSChart.prototype.containsDrawStyleSpecificStyleObjects = function () {
            return _$1.some(this._drawStyleToStyleObjectName);
        };
        FDSChart.prototype.getStyleObjectName = function () {
            return 'FC_CHART_STYLE';
        };
        FDSChart.prototype.getObjectTypeName = function () {
            return 'FDSChart';
        };
        FDSChart.prototype.getStyleObjectNameForDrawStyle = function (drawStyle) {
            if (!this._drawStyleToStyleObjectName) {
                return undefined;
            }
            return this._drawStyleToStyleObjectName[drawStyle];
        };
        FDSChart.prototype._setDrawStyleToStyleObjectMapping = function (mapping) {
            var invMapping = {};
            for (var styleName in mapping) {
                var drawStyles = mapping[styleName];
                for (var _i = 0, drawStyles_1 = drawStyles; _i < drawStyles_1.length; _i++) {
                    var drawStyle = drawStyles_1[_i];
                    if (ENABLE_DEBUG) {
                        console.assert(invMapping[drawStyle] === undefined, 'Drawstyle is defined multiple times in style object mapping.');
                    }
                    invMapping[drawStyle] = styleName;
                }
            }
            this._drawStyleToStyleObjectName = invMapping;
        };
        FDSChart.prototype.getPropertyUsage = function (usedPropertiesMap) {
            if (this.root.propertyUsageManager.isTrackingProperties()) {
                // Unlike FDSAxis and FDSSeries, this FDSChart.getPropertyUsage is only called once, so we need to update
                // this.usedProperties before calling super.getPropertyUsage.
                this._getPropertyUsageForUnrenderedAttributes();
            }
            _super.prototype.getPropertyUsage.call(this, usedPropertiesMap);
        };
        FDSChart.prototype._setLabelAttribute = function () {
            this.attributeSet.add('Label', String, 'FDSChart');
        };
        FDSChart.prototype._setLabelText = function () {
            var isLabelTextDefault = this.attributeSet.isInheritedDefault('Label');
            this.labelText = this.attributeSet.get('Label');
            if (this.labelText != null) {
                this.compiledLabelText = this.properties.compilePropertyString(this.labelText);
            }
        };
        FDSChart.prototype._getPropertyUsageForUnrenderedAttributes = function () {
            this.properties.compilePropertyString(this.attributeSet.get('CrosshairsTooltipText')).fromValue();
        };
        FDSChart.prototype.shadeHitshapes = function () {
            var ctx = this.root.getUIContext();
            for (var _i = 0, _a = this._hitShapes; _i < _a.length; _i++) {
                var shape = _a[_i];
                shape.shadeShape(ctx);
            }
        };
        FDSChart.prototype.getTheme = function () {
            return this._theme;
        };
        FDSChart.prototype.setTheme = function (theme, styleSet) {
            if (styleSet === void 0) { styleSet = null; }
            this._styleSet = styleSet;
            this._theme = theme;
            if (theme === -1 /* CUSTOM */) {
                this._loadChartFromJSON(styleSet);
            }
            else {
                this._applyTheme();
            }
        };
        FDSChart.prototype.applyStyleSetFromPathAsync = function (audsPath, skipCache) {
            var _this = this;
            this.removeStyleSet();
            this.progressSpinner.show();
            var defaultStyleSets = new DefaultStyleSets();
            return StyleSetCache.getStyleSetAsync(audsPath, skipCache).done(function (data) {
                _this.progressSpinner.hide();
                _this.setTheme(-1 /* CUSTOM */, data.document);
                _this.draw();
            }).fail(function (data) {
                _this._thiefTheme = getThiefTheme();
                var themeStyleSet;
                switch (_this._thiefTheme) {
                    case 4 /* ONYX */:
                    case 2 /* CARBON */:
                        themeStyleSet = defaultStyleSets.getOnyx();
                        break;
                    case 3 /* CRYSTAL */:
                    case 1 /* QUARTZ */:
                    default:
                        themeStyleSet = defaultStyleSets.getCrystal();
                        break;
                }
                _this.progressSpinner.hide();
                _this.setTheme(-1 /* CUSTOM */, themeStyleSet);
                _this.draw();
                console.warn("Failed to load styleset from " + audsPath + ". Loaded default styleset based on Thief theme.");
            });
        };
        FDSChart.prototype.isStateLoggingEnabled = function () {
            return this.stateLog && this.stateLog.isEnabled;
        };
        FDSChart.prototype.updateClickInfoboxes = function (value) {
            this.clickTooltip.setUseExternalInfoboxes(value, this.attributeSet, this.getUIContext());
            this.invalidate();
        };
        FDSChart.selector = 'FDSChart';
        return FDSChart;
    }(FDSChartObject));
    var FDSChartStyle = /** @class */ (function (_super) {
        __extends(FDSChartStyle, _super);
        function FDSChartStyle(root, id) {
            var _this = _super.call(this, root, id, 17 /* FC_CHART_STYLE */) || this;
            _this.wrapper = new FDSChartObjectWrapper(_this);
            return _this;
        }
        FDSChartStyle.prototype.getStyleObjectName = function () {
            return 'FC_CHART_STYLE';
        };
        FDSChartStyle.prototype.getObjectTypeName = function () {
            return 'FDSChart';
        };
        FDSChartStyle.prototype.serialize = function (level) {
            return _super.prototype._serializeObject.call(this, 'Chart', level);
        };
        FDSChartStyle.prototype._init = function () {
            this.isStyleObject = true;
            this._defMapID = 'DEF_CHART';
            _super.prototype._init.call(this);
        };
        FDSChartStyle.selector = 'FDSChart';
        return FDSChartStyle;
    }(FDSChartObject));
    
    var FDSChartJS = /** @class */ (function (_super) {
        __extends(FDSChartJS, _super);
        function FDSChartJS(containingElement, options) {
            var _this = _super.call(this, options) || this;
            _this.loadXMLAsync = _this.loadXMLAsync.bind(_this);
            _this.loadJSONAsync = _this.loadJSONAsync.bind(_this);
            _this.drawAsync = _this.drawAsync.bind(_this);
            _this.triggerResize = _this.triggerResize.bind(_this);
            _this.getUserFormat = _this.getUserFormat.bind(_this);
            _this.applyUserFormat = _this.applyUserFormat.bind(_this);
            _this._sendFakeMouseEventAtPoint = _this._sendFakeMouseEventAtPoint.bind(_this);
            _this._hideTooltipAfterClick = _this._hideTooltipAfterClick.bind(_this);
            _this._clickOnPixel = _this._clickOnPixel.bind(_this);
            _this.leftClickOnPixel = _this.leftClickOnPixel.bind(_this);
            _this.rightClickOnPixel = _this.rightClickOnPixel.bind(_this);
            _this.middleClickOnPixel = _this.middleClickOnPixel.bind(_this);
            _this.doubleClickOnPixel = _this.doubleClickOnPixel.bind(_this);
            _this.doubleRightClickOnPixel = _this.doubleRightClickOnPixel.bind(_this);
            _this.doubleMiddleClickOnPixel = _this.doubleMiddleClickOnPixel.bind(_this);
            _this.hoverOnPixel = _this.hoverOnPixel.bind(_this);
            _this.dragMousePixel = _this.dragMousePixel.bind(_this);
            _this.dragMousePercent = _this.dragMousePercent.bind(_this);
            _this.queryInteractionHandlePixel = _this.queryInteractionHandlePixel.bind(_this);
            _this.queryAxisLabelPixel = _this.queryAxisLabelPixel.bind(_this);
            _this.querySeriesPixel = _this.querySeriesPixel.bind(_this);
            _this.queryPlotSliderPixel = _this.queryPlotSliderPixel.bind(_this);
            _this.queryZoomSliderPixel = _this.queryZoomSliderPixel.bind(_this);
            _this.queryLegendPixel = _this.queryLegendPixel.bind(_this);
            _this.queryAxisTitlePixel = _this.queryAxisTitlePixel.bind(_this);
            _this.queryPlotPixel = _this.queryPlotPixel.bind(_this);
            _this.queryQuicklabelPixel = _this.queryQuicklabelPixel.bind(_this);
            _this.queryHeaderPixel = _this.queryHeaderPixel.bind(_this);
            _this.queryRichTextLinks = _this.queryRichTextLinks.bind(_this);
            _this.querySeriesLabelPixel = _this.querySeriesLabelPixel.bind(_this);
            _this.containingElement = containingElement;
            _this.autoId = {
                PLOT: 0,
                SERIES: 0,
                DATA: 0,
                AXIS: 0
            };
            var fallbackAppName = null;
            if (typeof window !== 'undefined' && window.fdsMetadata) {
                var fdsMetadata = window.fdsMetadata;
                fallbackAppName = fdsMetadata.applicationName.getSync();
            }
            var sanitizedOptions = { appName: '' };
            _$1.assign(sanitizedOptions, options, function (objectValue, sourceValue, key) {
                return _$1.includes(['width', 'height'], key) ? Number(sourceValue) : sourceValue;
            });
            sanitizedOptions.appName = sanitizedOptions.appName || fallbackAppName;
            if (!(typeof (sanitizedOptions['appName']) === 'string') || sanitizedOptions['appName'].length === 0) {
                throw Error('Name of application using the FDSChartJS library is required.  This must be supplied through fds-metadata or through the appName property of the options parameter.');
            }
            _this._chartObject = new FDSChart(containingElement, sanitizedOptions, _this);
            _this.attached = true;
            _this.id = '';
            _this.initHandlers();
            _this.plotList = [];
            _this.plotListDirty = true;
            _this._handlers.Trend = [];
            _this._handlers.Pick = [];
            _this._handlers.PickPoint = [];
            _this.canvasBGBrush = new BrushWrapper(_this, 'CanvasBG');
            _this.chartBGBrush = new BrushWrapper(_this, 'ChartBG');
            _this.plotBG = new BrushWrapper(_this, 'PlotBG');
            _this.legendBrush = new BrushWrapper(_this, 'LegendBG');
            _this.canvasFGPen = new PenWrapper(_this, 'CanvasFG');
            _this.plotFGPen = new PenWrapper(_this, 'PlotFG');
            _this.legendPen = new PenWrapper(_this, 'LegendFG');
            _this.legendFont = new FontWrapper(_this, 'LegendFont');
            _this.xFont = new FontWrapper(_this, 'XFont');
            _this.yFont = new FontWrapper(_this, 'YFont');
            MapFactory.addReference();
            _this.chart = _this;
            _this.version = _this.constructor.version;
            return _this;
        }
        FDSChartJS_1 = FDSChartJS;
        FDSChartJS.setFontFallbackMap = function (map$$1) {
            FDSFont.fontFallbackMap = {};
            _$1.forIn(map$$1, function (value, key) {
                key = key.toLowerCase();
                FDSFont.fontFallbackMap[key] = value.fallbacks;
                if (value.heightMap) {
                    FontHeightMap[FDSFont.addFontFallbackToFamily(key).toLowerCase()] = value.heightMap;
                }
            });
        };
        FDSChartJS.clearTextMetricCache = function () {
            FontHeightMap.clear();
            FontBaselineMap.clear();
        };
        FDSChartJS.prototype.setPlotListDirty = function () {
            this.plotListDirty = true;
        };
        FDSChartJS.prototype.destroy = function () {
            if (this._chartObject != null) {
                this.attached = false;
                this._chartObject.destroy();
                this._chartObject = null;
                MapFactory.releaseReference();
            }
        };
        FDSChartJS.prototype.resetLogsStartAtCurrentChart = function () {
            resetLogsToStartAtCurrentChart(this);
        };
        // Helper to get an id for a particular object type
        FDSChartJS.prototype._getNextId = function (type) {
            // Avoid name collisions
            while (this._chartObject.objects["" + type + this.autoId[type]] != null) {
                this.autoId[type]++;
            }
            return "" + type + this.autoId[type]++;
        };
        // methods to get next Plot/Series/Data IDs
        FDSChartJS.prototype.getNextPlotId = function () {
            return this._getNextId('PLOT');
        };
        FDSChartJS.prototype.getNextSeriesId = function () {
            return this._getNextId('SERIES');
        };
        FDSChartJS.prototype.getNextDataId = function () {
            return this._getNextId('DATA');
        };
        FDSChartJS.prototype.getNextAxisId = function () {
            return this._getNextId('AXIS');
        };
        FDSChartJS.prototype.updatePlotCache = function () {
            this.plotList = this._chartObject.chartPlotList.map(function (o) { return o.wrapper; });
            this.plotListDirty = false;
        };
        FDSChartJS.prototype.on = function (type, cb) {
            if (typeof cb !== 'function') {
                throw new Error('Expected a function');
            }
            switch (type) {
                case 'trend':
                    this._handlers.Trend.push(cb);
                    break;
                case 'pick':
                    this._handlers.Pick.push(cb);
                    break;
                case 'pickpoint':
                    this._handlers.PickPoint.push(cb);
                    break;
                default:
                    _super.prototype.on.call(this, type, cb);
            }
            return this;
        };
        /**
         * Returns a list of the plot wrappers attached to the chart.
         *
         * @returns {FDSPlotWrapper[]} An array of plot wrappers on this chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getPlotChildren = function () {
            if (this.plotListDirty) {
                this.updatePlotCache();
            }
            return this.plotList;
        };
        /**
         * This will return the api wrapper objects of all objects contained on the chart.
         *
         * @returns {FDSChartObjectWrapper[]} An array of wrapper objects.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getAllObjects = function () {
            var objs = this._chartObject.objects;
            return Object.keys(objs).map(function (key) { return objs[key].wrapper; });
        };
        /**
         * This will return the id's for all objects contained on the chart.
         *
         * @returns {string[]} An array of object id's.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getAllObjectIds = function () {
            return Object.keys(this._chartObject.objects);
        };
        /**
         * Adds a plot to the chart.
         *
         * @param {FDSPlotWrapper} plot - The FDSPlotWrapper to add to the chart.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.addPlot = function (plot) {
            plot.addToChart(this);
            return this;
        };
        /**
         * Adds a dateset to the chart.
         *
         * @param {FDSDataWrapper} data - the FDSDataWrapper to add to the chart.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.addDataset = function (data) {
            data.addToChart(this);
            return this;
        };
        /**
         * Adds a series to the chart. It does not make it appear on any plot though.
         *
         * @param {FDSSeriesWrapper} series - An FDSSeriesWrapper object.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.addSeries = function (series) {
            series.addToChart(this);
            return this;
        };
        FDSChartJS.prototype.addAxis = function (axis) {
            axis.addToChart(this);
            return this;
        };
        /**
         * Deletes a chart object from the chart.
         *
         * @param {FDSChartObjectWrapper} object - The FDSChartObjectWrapper to delete.
         * @param {boolean} [deleteChildren=false] - Whether or not the children should be deleted.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.deleteObject = function (object, deleteChildren) {
            if (deleteChildren === void 0) { deleteChildren = false; }
            if (typeof object['removeFromChart'] === 'function') {
                object['removeFromChart'](this, deleteChildren);
            }
            return this;
        };
        /**
         * Removes a plot from the chart.
         *
         * @param {FDSPlotWrapper} plot - The FDSPlotWrapper to remove.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.removePlot = function (plot) {
            plot.removeFromChart(this);
            return this;
        };
        FDSChartJS.prototype.enableStateLogging = function () {
            this._chartObject.objectActionExternal('', 0 /* NONE */, 'EnableStateLogging2', [true]);
            return this;
        };
        FDSChartJS.prototype.disableStateLogging = function () {
            this._chartObject.objectActionExternal('', 0 /* NONE */, 'EnableStateLogging2', [false]);
            return this;
        };
        FDSChartJS.prototype.checkStateLog = function () {
            return this._chartObject.objectActionExternal('', 0 /* NONE */, 'StateCheckpoint', []);
        };
        /**
         * Starts trendline drawing mode on the chart. After clicking and dragging a line/multiline, it will fire the trend
         * event.
         *
         * @param {number} [numPts=2] - The number of points to draw.
         * @param {string} [cursor='CROSS'] - The name of the cursor to use.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.startTrendline = function (numPts, cursor) {
            if (numPts === void 0) { numPts = 2; }
            if (cursor === void 0) { cursor = 'CROSS'; }
            this._chartObject.objectActionExternal('', 0 /* NONE */, 'SYS_TRENDLINE', [cursor, numPts]);
            return this;
        };
        /**
         * Starts a pick point mode on the chart. After clicking, it will fire the pickpoint event.
         *
         * @param {string} [cursor='CROSS'] - The name of the cursor to use.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.startPickPoint = function (cursor) {
            if (cursor === void 0) { cursor = 'CROSS'; }
            this._chartObject.objectActionExternal('', 0 /* NONE */, 'SYS_PICKPOINT', [cursor]);
            return this;
        };
        /**
         * Similar to FDSChartJS.startTrendline() but only allows two points and draws a box while dragging instead.
         *
         * @param {String} [cursor='CROSS'] - The name of the cursor to use.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.startDrawBox = function (cursor) {
            if (cursor === void 0) { cursor = 'CROSS'; }
            this._chartObject.objectActionExternal('', 0 /* NONE */, 'SYS_DRAWBOX', [cursor]);
            return this;
        };
        /**
         * Starts a pick interaction. After clicking on an object of the type specified in the parameter, the chart will
         * fire a pick event with info about the picked object.
         *
         * @param {('FC_SERIES'|'FC_PLOT'|'FC_AXIS'|'FC_LEGEND'|'FC_ROOT')} objectType - The type of object to pick.
         * @param {string} [cursor='CROSS'] - The name of the cursor to use.
         * @returns {FDSChartJS} The instance of the chart, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.startPick = function (objectType, cursor) {
            if (cursor === void 0) { cursor = 'CROSS'; }
            this._chartObject.objectActionExternal('', ObjectTypeExported[objectType], 'SYS_PICK', [cursor]);
            return this;
        };
        /**
         * Serializes the chart state to json.
         *
         * @returns {string} Returns a json string of the state of the chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.serializeChart = function () {
            return this._chartObject.dumpJSON();
        };
        /**
         * Creates a chart json snippit with only attributes at the provided level, and no data
         *
         * @param {('user'|'app')} [level='user']
         * @returns the serialized chart snippit
         * @memberof FDSChartJS
         */
        FDSChartJS.prototype.serializeChartSnippit = function (level) {
            if (level === void 0) { level = 'user'; }
            if (level !== 'user' && level !== 'app') {
                throw new Error("The provided level must be 'user' or 'app'");
            }
            return this._chartObject.dumpJSON(level === 'user' ? 2 /* GENERATE_USER */ : 1 /* GENERATE_APP */);
        };
        /**
         * Serializes the chart state to xml.
         *
         * @returns {string} Returns an xml string of the state of the chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.serializeChartToXML = function () {
            return this._chartObject.dumpXML();
        };
        /**
         * Creates a chart xml snippit with only attributes at the provided level, and no data
         *
         * @param {('user'|'app')} [level='user']
         * @returns the serialized chart snippit
         * @memberof FDSChartJS
         */
        FDSChartJS.prototype.serializeChartToXMLSnippit = function (level) {
            if (level === void 0) { level = 'user'; }
            if (level !== 'user' && level !== 'app') {
                throw new Error("The provided level must be 'user' or 'app'");
            }
            return this._chartObject.dumpXML(level === 'user' ? 2 /* GENERATE_USER */ : 1 /* GENERATE_APP */);
        };
        /**
         * Fetches a base64 string representing the chart as a PNG.
         *
         * @returns {string} Returns a base64 encoded image of the current state of the chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getPNG = function (quality) {
            if (this._chartObject.hasQueuedInvalidate()) {
                this._chartObject.cancelQueuedInvalidate();
                this.draw();
            }
            return this._chartObject.toImage('image/png', quality);
        };
        /**
         * Fetches a copy of the chart's svg representation. This is currently only valid when `renderMode` is set to 'svg'.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getSVG = function () {
            return this._chartObject.toSvg();
        };
        /**
         * Asynchronously fetches a base64 string representing the chart as a PNG. When fetched, it passes the string into
         * the provided function callback.
         *
         * @param {(result: string) => void} callback - a function to call when the image is fetched. The function will be
         *   passed the image data as a base64 string.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getPNGAsync = function (callback, quality) {
            return this._chartObject.toImageAsync(callback, 'image/png', quality);
        };
        FDSChartJS.prototype.objectAction = function (action, params) {
            return this._chartObject.objectActionExternal('', 0 /* NONE */, action, params);
        };
        /**
         * Fetches the wrapper for an object with the given id. If no such object exists, it returns undefined.
         *
         * @param {string} id - The id of the object to fetch.
         * @returns {FDSChartObjectWrapper} The FDSChartObjectWrapper of the object if it exists, undefined otherwise.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getObjectById = function (id) {
            if (!id || id === 'FC_CHART') {
                return this;
            }
            var object = this._chartObject.getObject(id);
            if (object) {
                return object.wrapper;
            }
            else {
                return undefined;
            }
        };
        /**
         * Shades all hitshapes in the chart hitshape list for easier debugging
         */
        FDSChartJS.prototype.shadeHitShapes = function () {
            this._chartObject.shadeHitshapes();
        };
        /**
         * Shades all series hitshapes in the chart for easier debugging
         */
        FDSChartJS.prototype.shadeAllSeriesHitShapes = function () {
            for (var _i = 0, _a = this.getPlotChildren(); _i < _a.length; _i++) {
                var plot = _a[_i];
                for (var _b = 0, _c = plot.getSeriesChildren(); _b < _c.length; _b++) {
                    var series = _c[_b];
                    series.shadeHitShapes();
                }
            }
        };
        /**
         * Calculates histogram bins and frequencies for an array of values.
         *
         * @param {values} - A list of numbers, whose distribution is to be counted.histogramOptions
         * @param {histogramOptions} - An optional object that contains options for the histogram calculation.
         * @returns {histogramBins} An object that contains the start and end of each histogram bin as well as the frequency of values in the bin range.
         */
        FDSChartJS.prototype.calculateHistogramBins = function (values$$1, histogramOptions) {
            var binsCreator = new HistogramBinsCreator(histogramOptions);
            return binsCreator.createHistogramBins(values$$1);
        };
        FDSChartJS.prototype.getTheme = function () {
            return { type: this._chartObject.getTheme() };
        };
        FDSChartJS.prototype.setRenderingMode = function (mode) {
            if (!_$1.isString(mode) || !_$1.includes(ValidRenderingModes, mode)) {
                console.error("An invalid rendering mode was provided. Valid values are " + JSON.stringify(ValidRenderingModes) + ".");
                return false;
            }
            else {
                return this._chartObject.setRenderingMode(mode);
            }
        };
        FDSChartJS.prototype.setTheme = function (theme, styleset) {
            var themeVal;
            if (typeof theme === 'string') {
                switch (theme.toLowerCase()) {
                    case 'quartz':
                        themeVal = 1 /* QUARTZ */;
                        break;
                    case 'carbon':
                        themeVal = 2 /* CARBON */;
                        break;
                    case 'custom':
                        themeVal = -1 /* CUSTOM */;
                        break;
                    case 'none':
                    default:
                        themeVal = 0 /* NONE */;
                        break;
                }
            }
            else {
                if (theme === 1 /* QUARTZ */ || theme === 2 /* CARBON */ || theme === -1 /* CUSTOM */) {
                    themeVal = theme;
                }
                else {
                    themeVal = 0 /* NONE */;
                }
            }
            if (themeVal === -1 /* CUSTOM */ && styleset && !this.areAllCustomThemeFeaturesSupportedInThisVersion(styleset)) {
                console.warn('This style set is not compatible with this version of FDSChartJS and may appear incorrectly.' +
                    ' Please update to a later version of FDSChartJS');
            }
            // If the existing theme is custom, remove the styleset
            if (this._chartObject.getTheme() === -1 /* CUSTOM */) {
                this._chartObject.removeStyleSet();
            }
            this._chartObject.setTheme(themeVal, styleset);
            return this;
        };
        FDSChartJS.prototype.areAllCustomThemeFeaturesSupportedInThisVersion = function (styleset) {
            return styleset.styleSetObjectVersion <= FDSChartJS_1.supportedStyleSetObjectVersion;
        };
        /**
         * Applies a styleset from an AUDS file location using the styleset-document-service.
         *
         * @param {string} audsPath - The filepath for the styleset document. Should begin with a '/'.
         * @param {boolean} [skipCache=false] - OPTIONAL - If true, function will always make a new request instead of using cached result.
         * @returns {Promise} The promise containing the response from the styleset request.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.applyStyleSetFromPathAsync = function (audsPath, skipCache) {
            return this._chartObject.applyStyleSetFromPathAsync(audsPath, skipCache);
        };
        /**
         * Clears chart and shows a progress spinner
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.showProgressSpinner = function () {
            this._chartObject.progressSpinner.show();
        };
        /**
         * Hides the progress spinner if shown and draws the chart
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.hideProgressSpinner = function () {
            this._chartObject.progressSpinner.hide();
        };
        // This is a nonstandard API convenience call to clear the chart and load an
        // entirely new set of objects from an XML string. The same functionality
        // would be achieved PC-side via an object action.
        FDSChartJS.prototype.loadFromXMLString = function (xmlString) {
            this._chartObject.loadFromXMLString(xmlString);
            this._chartObject.draw();
        };
        // ditto for JSON
        FDSChartJS.prototype.loadFromJSONString = function (jsonString) {
            this._chartObject.loadFromJSONString(jsonString);
            this._chartObject.draw();
        };
        /**
         * Loads the chart from an XML string, then reapplies the current theme.
         *
         * @param {string} xmlString - The string of xml to load into the chart.
         * @returns {boolean} Returns true if the chart was successfully loaded and false otherwise.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.loadXML = function (xmlString) {
            return this._chartObject.loadFromXMLString(xmlString);
        };
        FDSChartJS.prototype.loadXMLAsync = function (xmlString, callback) {
            var _this = this;
            return setTimeout((function () {
                _this._chartObject.loadFromXMLString(xmlString);
                if (_$1.isFunction(callback)) {
                    callback();
                }
            }), 0);
        };
        /**
         * Loads the chart from JSON, then reapplies the current theme.
         *
         * @param {(string|Object)} json - The javascript object or json string of a serialized chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.loadJSON = function (json) {
            this._chartObject.loadFromJSONString(json);
        };
        FDSChartJS.prototype.loadJSONAsync = function (json, callback) {
            var _this = this;
            return setTimeout((function () {
                _this._chartObject.loadFromJSONString(json);
                if (_$1.isFunction(callback)) {
                    callback();
                }
            }), 0);
        };
        FDSChartJS.prototype.invalidate = function (callback) {
            if (_$1.isFunction(callback)) {
                this._chartObject.postDrawHooks.push(callback);
            }
            this._chartObject.invalidate();
        };
        /**
         * Draws the chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.draw = function () {
            this._chartObject.draw();
        };
        FDSChartJS.prototype.drawAsync = function (callback) {
            var _this = this;
            return setTimeout((function () {
                _this._chartObject.draw();
                if (_$1.isFunction(callback)) {
                    callback();
                }
            }));
        };
        /**
         * Clears a specific chart object.
         *
         * @param {string} name - The name of the chart object to be cleared.
         * @returns {[boolean, string]} Returns True if the object was successfully cleared, and False with an error
         *   statement otherwise.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.clearObject = function (name) {
            return this._chartObject.clearObject(name);
        };
        /**
         * Clears all objects on the chart.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.clearAll = function () {
            this._chartObject.clear();
        };
        /**
         * Resizes to new dimensions.
         *
         * @param {Event} [event] - Resize event (currently unused).
         * @param {Object} [options] - Object with properties that define resize options.
         * @param {boolean} [options.redraw] - Defaults to true if unspecified. Specifies whether or not to redraw on
         *   resize.
         * @param {number} [options.useWidth] - Will attempt to resize the container and canvas objects to the user
         *   specified width.
         * @param {number} [options.useHeight] - Will attempt to resize the container and canvas objects to the user
         *   specified height.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.triggerResize = function (event, options) {
            this._chartObject.didTriggerResize(options);
        };
        /**
         * Returns a JSON object containing all the changes made to the chart on the user level. This can be saved and
         * reapplied later to save user formatting between sessions.
         *
         * @returns {Object} A JSON object representing user formatting.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getUserFormat = function () {
            return this._chartObject.getUserAttrs();
        };
        /**
         * Applies the given format to the chart. The chart state is updated to contain all the user formatting in the
         * format.
         *
         * @param {FDSChart.UserAttrFormat} format - A JSON object representing user formatting. Usually obtained from
         *   FDSChartJS.getUserFormat().
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.applyUserFormat = function (format) {
            this._chartObject.applyUserAttrs(format);
        };
        FDSChartJS.prototype.resetSimpleZoom = function () {
            this.objectAction('SimpleZoomReset');
        };
        /*
           Interaction mimicking events
        */
        FDSChartJS.prototype._sendFakeMouseEventAtPoint = function (name, x, y, which) {
            // figure out the client x and y (same for all)
            var offsets = this._chartObject.containing_element.getBoundingClientRect();
            if (ENABLE_DEBUG) {
                if (offsets.width === 0 && offsets.height === 0 && offsets.left === 0 && offsets.top === 0) {
                    throw Error('Chart container has no size. Is it on the DOM?');
                }
            }
            x = Math.round(scaleByDevicePixelRatioInverse(x) + offsets.left);
            y = Math.round(scaleByDevicePixelRatioInverse(y) + offsets.top);
            for (var i = this._chartObject.interactionElements.length - 1; i >= 0; i--) {
                // check if it's under the mouse
                var div = this._chartObject.interactionElements[i];
                var rect = div.getBoundingClientRect();
                if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                    continue;
                }
                // if we're here, we found the div that's hit
                // it'll either be a zoom slider div, or the chart rect if none of those hit
                var options = {
                    screenX: x,
                    screenY: y,
                    clientX: x,
                    clientY: y,
                    button: which - 1,
                };
                var e = document.createEvent('MouseEvents');
                e.initMouseEvent(name, true, // bubble
                true, // cancelable
                window, 0, // detail
                options.screenX, options.screenY, options.clientX, options.clientY, false, // ctrl
                false, // alt
                false, // shift
                false, // meta
                options.button, null // related target
                );
                div.dispatchEvent(e);
            }
        };
        // helper function to prevent tooltips showing up on clicks
        // apparently thief tooltips show up when you have a click event. presumably they assume the
        // mouse is at that point anyway. so this 'moves' the mouse away again after the click
        FDSChartJS.prototype._hideTooltipAfterClick = function (which) {
            this._sendFakeMouseEventAtPoint('mousemove', -100, -100, which);
        };
        FDSChartJS.prototype._clickOnPixel = function (x, y, which) {
            this._sendFakeMouseEventAtPoint('mousedown', x, y, which);
            this._sendFakeMouseEventAtPoint('mouseup', x, y, which);
            this._sendFakeMouseEventAtPoint('click', x, y, which);
            this._hideTooltipAfterClick(which);
        };
        /**
         * Mimics a left click on the chart at the pixel specified.
         *
         * @param {number} x - The pixel to click on in the x dimension.
         * @param {number} y = The pixel to click on in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.leftClickOnPixel = function (x, y) {
            this._clickOnPixel(x, y, 1 /* LEFT */);
            return this;
        };
        /**
         * Mimics the right click on the chart at the pixel specified.
         *
         * @param {number} x - The pixel to click on in the x dimension.
         * @param {number} y - The pixel to click on in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.rightClickOnPixel = function (x, y) {
            this._clickOnPixel(x, y, 3 /* RIGHT */);
            this._sendFakeMouseEventAtPoint('contextmenu', x, y, 3 /* RIGHT */);
            return this;
        };
        /** Mimics the middle click on the chart at the pixel specified.
         *
         * @param {number} x - The pixel to click on in the x dimension.
         * @param {number} y - The pixel to click on in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.middleClickOnPixel = function (x, y) {
            this._clickOnPixel(x, y, 2 /* MIDDLE */);
            return this;
        };
        /** Mimics the double left click on the chart at the pixel specified.
         *
         * @param {number} x - The pixel to click on in the x dimension.
         * @param {number} y - The pixel to click on in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.doubleClickOnPixel = function (x, y) {
            // send the two mouse down/up events, and then the double click event
            this._clickOnPixel(x, y, 1 /* LEFT */);
            this._clickOnPixel(x, y, 1 /* LEFT */);
            this._sendFakeMouseEventAtPoint('dblclick', x, y, 1 /* LEFT */);
            return this;
        };
        /** Mimics the double right click on the chart at the pixel specified.
         *
         * @param {number} x - The pixel to click on in the x dimension.
         * @param {number} y - The pixel to click on in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.doubleRightClickOnPixel = function (x, y) {
            this._clickOnPixel(x, y, 3 /* RIGHT */);
            this._clickOnPixel(x, y, 3 /* RIGHT */);
            this._sendFakeMouseEventAtPoint('dblclick', x, y, 3 /* RIGHT */);
            return this;
        };
        /** Mimics the double middle click on the chart at the pixel specified.
         *
         * @param {number} x - The pixel to click on in the x dimension.
         * @param {number} y - The pixel to click on in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.doubleMiddleClickOnPixel = function (x, y) {
            this._clickOnPixel(x, y, 2 /* MIDDLE */);
            this._clickOnPixel(x, y, 2 /* MIDDLE */);
            this._sendFakeMouseEventAtPoint('dblclick', x, y, 2 /* MIDDLE */);
            return this;
        };
        /**
         * Mimics a mouse hovering over the chart at the pixel specified.
         *
         * @param {number} x - The pixel to hover over in the x dimension.
         * @param {number} y - The pixel to hover over in the y dimension.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.hoverOnPixel = function (x, y) {
            this._sendFakeMouseEventAtPoint('mousemove', x, y, 1 /* LEFT */);
            return this;
        };
        /**
         * Mimics the mouse clicking and dragging between the two pixel points specified.
         *
         * @param {number} x1
         * @param {number} y1
         * @param {number} x2
         * @param {number} y2
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.dragMousePixel = function (x1, y1, x2, y2) {
            this._sendFakeMouseEventAtPoint('mousedown', x1, y1, 1 /* LEFT */);
            this._sendFakeMouseEventAtPoint('mousemove', x1, y1, 1 /* LEFT */);
            this._sendFakeMouseEventAtPoint('mousemove', x2, y2, 1 /* LEFT */);
            this._sendFakeMouseEventAtPoint('mouseup', x2, y2, 1 /* LEFT */);
            return this;
        };
        /**
         * Mimics a mouse clicking and dragging, starting at the specified point and dragging the percentage of the plot or
         * chart area specified.
         *
         * @param {number} x1 - The x pixel to start dragging from.
         * @param {number} y1 - The y pixel to start dragging from.
         * @param {number} xPct - Factor, between 0 and 1, of the chart or plot rect to drag horizontally, e.g., 0.5 would
         *   mean drag 1/2 the plot/chart width in the x direction.
         * @param {number} yPct - Factor, between 0 and 1, of the chart or plot rect to drag vertically, e.g., 0.5 would
         *   mean drag 1/2 the plot/chart height in the y direction.
         * @param {string} plotID - When defined, the factors are treated as percentages of the plot rect. Otherwise, the
         *   factors are considered percentages of the chart rect.
         * @returns {FDSChartJS} The chart instance, for chainability.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.dragMousePercent = function (x1, y1, xPct, yPct, plotID) {
            var rect = this._chartObject.chartRect;
            if (plotID != null) {
                var plot = this._chartObject.getTypedObject(plotID, isPlot);
                if (plot != null) {
                    rect = plot.plotRect;
                }
            }
            var x2 = Math.round(x1 + (rect.getWidth() * xPct));
            var y2 = Math.round(y1 + (rect.getHeight() * yPct));
            this.dragMousePixel(x1, y1, x2, y2);
            return this;
        };
        FDSChartJS.prototype.queryInteractionHandlePixel = function (seriesId, handlePos) {
            var obj = this._chartObject.interactionHandlePixelPoints[seriesId];
            if (!obj) {
                return undefined;
            }
            if (handlePos != null && obj instanceof Array) {
                return obj[handlePos];
            }
            return obj;
        };
        /**
         * @typedef {Object} IActiveAxisMap
         * @property {FDSAxisWrapper[]} x - An array of x axis objects
         * @property {FDSAxisWrapper[]} y - An array of y axis objects
         */
        /**
         * Retrieves two lists of axis wrappers (x and y) containing only the axes that are bound to one or more series.
         * If a `plotId` is specified, it will return only axes belonging to that plot, otherwise all plots.
         * @param {string=} plotId - the plot who's axes to return
         * @returns {IActiveAxisMap}
         */
        FDSChartJS.prototype.queryActiveAxisObjects = function (plotId) {
            var axisMap = { x: [], y: [] };
            var addAxesToMap = function (plot) {
                if (!plot || FDSChartObjectWrapper.unwrap(plot).isFullPlotDrawStyle()) {
                    return;
                }
                var boundAxes = plot.getAxisChildren().filter(function (axis) { return axis.isBoundToSeries(); });
                axisMap.x = axisMap.x.concat(boundAxes.filter(function (axis) { return axis.getDimension() === 1 /* X */; }));
                axisMap.y = axisMap.y.concat(boundAxes.filter(function (axis) { return axis.getDimension() === 2 /* Y */; }));
            };
            var plots = plotId ? [this.getObjectById(plotId)] : this.getPlotChildren();
            _$1.forEach(plots, addAxesToMap);
            return axisMap;
        };
        /**
         * @typedef {Object} IPlot2D
         * @property {number} x - The x coordinate of the point.
         * @property {number} y - The y coordinate of the point.
         */
        /**
         * Returns the pixel coordinates of the center of the axis label specified.
         *
         * @param {string} axisId - The id of the axis in question
         * @param {number} [index=0] - The index of the axis label to get pixels for.
         * @param {number} [level=0] - The level of the axis label to get pixels for.
         * @returns {IPlot2D} The pixel coordinates of the label point.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryAxisLabelPixel = function (axisId, index, level) {
            if (index === void 0) { index = 0; }
            if (level === void 0) { level = 0; }
            var pixelsByLabelIndex = this._chartObject.pixelPoints[axisId];
            if (pixelsByLabelIndex == null) {
                return undefined;
            }
            var pixelsByLevel;
            if (pixelsByLabelIndex instanceof Object) {
                pixelsByLevel = pixelsByLabelIndex[index];
            }
            if (pixelsByLevel instanceof Array) {
                return pixelsByLevel[level];
            }
            return undefined;
        };
        /**
         * Returns the pixel coordinates of the series point specified.
         *
         * @param {string} seriesId - The id of the series in question.
         * @param {number} [index=0] - The index of the series to get pixels for.
         * @returns {IPlot2D} The pixel coordinates of the center of the series label.
         */
        FDSChartJS.prototype.querySeriesPixel = function (seriesId, index) {
            if (index === void 0) { index = 0; }
            var pixelsByIndex = this._chartObject.pixelPoints[seriesId];
            if (pixelsByIndex instanceof Object) {
                return pixelsByIndex[index];
            }
            else {
                return undefined;
            }
        };
        /**
         * Returns the pixel coordinates of the center of a plot slider.
         *
         * @param {string} plot1ID - The id of one of the plots that the slider is between.
         * @param {string} plot2ID - The id of the other plot that the slider is touching.
         * @returns {IPlot2D} The pixel coordinates of the slider point.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryPlotSliderPixel = function (plot1ID, plot2ID) {
            return this._chartObject.plotSliderPixelPoints[plot1ID + "_" + plot2ID];
        };
        /**
         * Returns the pixel coordinates of the center of a plot grabber.
         *
         * @param {string} plotID - The id of the plot that the grabber is in.
         * @returns {IPlot2D} The pixel coordinates of the plot grabber point.
         */
        FDSChartJS.prototype.queryPlotGrabberPixel = function (plotID) {
            return this._chartObject.plotGrabberPixelPoints[plotID];
        };
        /**
         * Returns the labels drawn for the heatmap legend.
         *
         * @param {string} plotID - The id of the plot that the heatmap legend is in.
         * @return {LabelsInfo} Contains text and rect information about all drawn labels.
         */
        FDSChartJS.prototype.queryHeatmapLegendLabels = function (plotID) {
            return this._chartObject.heatmapLegendLabels[plotID];
        };
        /**
         * Returns the pixel coordinates of the center of a zoom slider rect, or of its handles.
         *
         * @param {string} plotID - The id of the plot which the zoom slider is on.
         * @param {number} [pos=2] - Whether to fetch pixels for the rect itself or one of its handles. 0 = left slider handle, 1 = right
         *   slider handle, 2 = rect.
         * @returns {IPlot2D} The pixel coordinates of the slider point.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryZoomSliderPixel = function (plotID, pos) {
            if (pos === void 0) { pos = 2; }
            var obj = this._chartObject.zoomSliderPixelPoints[plotID];
            if (obj != null) {
                return obj[pos];
            }
            return undefined;
        };
        /**
         * Returns the pixel coordinates of the center of the plot's legend if it's visible.
         *
         * @param {string} plotID - The id of the plot containing the legend in question.
         * @returns {IPlot2D} The pixel of the legend center.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryLegendPixel = function (plotID) {
            return this._chartObject.legendPixelPoints[plotID];
        };
        /**
         * Returns the pixel coordinates of the center of the axis label specified.
         *
         * @param {string} axisID - The id of the axis in question
         * @returns {IPlot2D} The pixel coordinates of the label point.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryAxisTitlePixel = function (axisID) {
            return this._chartObject.axisTitlePixelPoints[axisID];
        };
        /**
         * Returns the pixel coordinates of one of five positions in a plot: upper left corner, upper right corner, lower
         * left corner, lower right corner, or center. This is to make it easier for the user to get a plot pixel that
         * doesn't have a series or a legend blocking it.
         *
         * @param {string} plotID - The id of the plot in question.
         * @param {number} [pos=4] - The quadrant of the plot to return a pixel from. 0 = upper left, 1 = upper right, 2 =
         *   lower left, 4 = center.
         * @returns {IPoint2D} The pixel coordinates of the plot point.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryPlotPixel = function (plotID, pos) {
            if (pos === void 0) { pos = 4; }
            var obj = this._chartObject.pixelPoints[plotID];
            if (obj != null) {
                return obj[pos];
            }
            return undefined;
        };
        /**
         * Returns the pixel coordinates of a series quicklabel. If the series has only one quicklabel showing, that label's
         * coordinates will be returned. If both its left and right labels are showing, the coordinates of the left label
         * will be returned.
         *
         * @param {string} seriesID - The id of the series with the quicklabel in question.
         * @returns {IPoint2D} The pixel coordinates of the quicklabel center.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryQuicklabelPixel = function (seriesID) {
            return this._chartObject.quicklabelPixelPoints[seriesID];
        };
        /**
         * Returns the pixel coordinates of the center of a plot header or footer.
         *
         * @param {string} plotID - The id of the plot with the header or footer in question. For chart-level headers, pass
         *   'FC_CHART'.
         * @param {number} headerNum - The index of the header whose coordinates are being fetched. 0 = Header, 1 =
         *   Heading1, 2 = Heading2, 3 = Heading3, 4 = Heading4, 5 = Footer, etc. As an additional note, only the visible
         *   headings are counted, so if Header = false, 0 = Heading1, etc.
         * @returns {IPoint2D} The pixel coordinates of the header center.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryHeaderPixel = function (plotID, headerNum) {
            // header order: Header, Heading1, Heading2, Heading3, Heading4, Footer
            var obj = this._chartObject.headerPixelPoints[plotID];
            if ((obj != null) && (headerNum != null)) {
                return obj[headerNum];
            }
            return undefined;
        };
        /**
         * Returns information about all rich-text links drawn on the chart.
         *
         * @returns Array<{textBlocks: {rect: Rectangle, text: string}[], type: 'href'|'action'|'event', data: string}>
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.queryRichTextLinks = function () {
            var linkContainer = this._chartObject.getLayerManager().linkContainer;
            if (linkContainer) {
                return linkContainer.getLinkInfoAsJson();
            }
            else {
                return [];
            }
        };
        /**
         * Returns the pixel coordinates of a series label.
         *
         * @param {string} sereisId - The id of the series in question.
         * @param {number} [index=0] - The index of the series label to get pixels for.
         * @returns {IPoint2D} The pixel coordinates of the center of the series label.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.querySeriesLabelPixel = function (seriesID, index) {
            if (index === void 0) { index = 0; }
            var obj = this._chartObject.seriesLabelPixelPoints[seriesID];
            if (obj != null) {
                return obj[index];
            }
            return undefined;
        };
        /**
         * Returns all user-defined properties that are used on the chart, sorted by the chart object that they are used on.
         * This includes undefined properties.
         *
         * @param {{[chartObjectId: string]: string}} [propertiesMap] - An onject that contains a key for each chart object
         *   with user-defined properties used on it. The value of each key is a list of properties used on the
         *   corresponding chart object. If this parameter is null, this function will perform a full draw of the chart to
         *   determine all user-defined properties that are used. Otherwise, this function will resolve every property in
         *   the parameter to find all used user-defined properties related to those in the input map.
         * @returns {{[chartObjectId: string]: string}} An object that contains a key for each chart object with
         *   user-defined properties used on it. The value of each key is a list of properties used on the corresponding
         *   chart object.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getUsedProperties = function (propertiesMap) {
            if (propertiesMap) {
                return this._chartObject.propertyUsageManager.getUsedPropertiesFromPropertiesMap(propertiesMap);
            }
            else {
                return this._chartObject.propertyUsageManager.getUsedProperties();
            }
        };
        /**
         * This function can be used to register for property tracking during the next draw call. After the chart is done
         * drawing, propertiesUsageMap will be forwarded to the provided callback function.
         *
         * @param {(usedProperties: {[chartObjectId: string]: string}) => void} callback - The callback function that the
         *   usedProperties map will be forwarded to the next time a draw occurs.
         *
         * @memberOf FDSChartJS
         */
        FDSChartJS.prototype.getUsedPropertiesAsync = function (callback) {
            this._chartObject.propertyUsageManager.getUsedPropertiesAsync(callback);
        };
        // helper functions for dealing with FDSChartJS dates
        // converts from m/d/y format to julian (things like 27363)
        FDSChartJS.prototype.getDateNumber = function (y, m, d) {
            return FDSDate.getJulian(y, m, d);
        };
        // converts from hours, mins, and secs to fraction of a day
        FDSChartJS.prototype.getTimeNumber = function (h, m, s) {
            return FDSTime.makeTimeStd(h, m, s);
        };
        // converts from month day year hour min sec to julian + fraction of day
        FDSChartJS.prototype.getDateTimeNumber = function (y, mo, d, h, mi, s) {
            return FDSTime.makeDateTime(y, mo, d, h, mi, s);
        };
        // converts from julian format (things like 34545) to m/d/y
        FDSChartJS.prototype.getDateTimeArray = function (num) {
            return FDSTime.getDateTimeArray(num);
        };
        /*
           LEGACY FDSChartJS API
        */
        FDSChartJS.prototype.AddObject = function (name, objType, flags, label, data) {
            // if the objType is passed in as string, lookup the int value in the `enum`
            // object
            if (_$1.isString(objType)) {
                objType = ObjectTypeExported[objType.toUpperCase()];
                if (objType == null) {
                    return [false, "Unknown object type: " + objType];
                }
            }
            return this._chartObject.addObject(name, objType, flags, label, data);
        };
        FDSChartJS.prototype.DeleteObject = function (name, flags) {
            return this._chartObject.deleteObject(name, flags);
        };
        FDSChartJS.prototype.SetChild = function (parent, child) {
            return this._chartObject.setChildrenExternal(parent, child);
        };
        FDSChartJS.prototype.UnsetChild = function (parent, child) {
            return this._chartObject.unsetChildren(parent, child);
        };
        FDSChartJS.prototype.ClearObject = function (name, flags) {
            return this.clearObject(name);
        };
        FDSChartJS.prototype.SetAttribute = function (id, flags, attribute, value) {
            return this._chartObject.setAttributeExternal(id, flags, attribute, value);
        };
        FDSChartJS.prototype.GetAttribute = function (id, flags, attribute) {
            switch (flags) {
                case 0 /* NONE */:
                case 1 /* DEFAULT */:
                case 2 /* IF_DEFAULT */:
                    return this._chartObject.getAttribute(id, attribute, flags);
                case 3 /* ROOT */:
                case 4 /* IF_ROOT */:
                    console.warn('Root level attributes are not supported in FDSChartJS through this API');
                    return undefined;
                case 5 /* PROPERTY */:
                    return this._chartObject.fetchProperty(id, attribute);
            }
            return false;
        };
        FDSChartJS.prototype.ObjectAction = function (id, flags, action, args) {
            return this._chartObject.objectActionExternal(id, flags, action, args);
        };
        FDSChartJS.prototype.ClearAll = function () {
            this.clearAll();
        };
        FDSChartJS.prototype.Refresh = function () {
            this.draw();
        };
        FDSChartJS.prototype.subscribeToExternalInfoboxForClickTooltips = function (callback) {
            this._chartObject.clickTooltip.externalInfoboxSubscription.subscribeToInfobox(callback);
        };
        FDSChartJS.prototype.unsubscribeFromExternalInfoboxForClickTooltips = function (callback) {
            this._chartObject.clickTooltip.externalInfoboxSubscription.unsubscribeFromInfobox(callback);
        };
        FDSChartJS.prototype.setUseExternalInfoboxesForClickTooltips = function (value) {
            this._chartObject.updateClickInfoboxes(value);
        };
        FDSChartJS.selector = 'FDSChartWrapper';
        FDSChartJS.supportedStyleSetObjectVersion = 1;
        FDSChartJS._chartRefCount = 0;
        FDSChartJS._clearDefaultMapTimer = undefined;
        FDSChartJS.constants = {
            AddFlags: AddFlagsExported,
            SetFlags: SetFlagsExported,
            GetFlags: GetFlagsExported,
            DeleteFlags: DeleteFlagsExported,
            ObjectType: ObjectTypeExported,
            DrawStyle: DrawStyleExported,
        };
        FDSChartJS = FDSChartJS_1 = __decorate([
            FDSChartObjectWrapperLogDecorator
        ], FDSChartJS);
        return FDSChartJS;
        var FDSChartJS_1;
    }(FDSChartObjectWrapper));
    
    var TemplateUtils;
    (function (TemplateUtils) {
        function insert(dim, val, data, valid) {
            if (val != null) {
                data[dim].push(dim === 'color' ? HEXtoCOLORREF(val) : val);
                valid[dim] = true;
            }
            else {
                data[dim].push(NAN);
            }
        }
        TemplateUtils.insert = insert;
        function extractData(data, keys$$1) {
            var out = {};
            if (data instanceof Array) {
                var valid_1 = {};
                for (var _i = 0, keys_1 = keys$$1; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    out[key] = [];
                    valid_1[key] = false;
                }
                data.map(function (vals) {
                    for (var _i = 0, keys_2 = keys$$1; _i < keys_2.length; _i++) {
                        var key = keys_2[_i];
                        insert(key, vals[key], out, valid_1);
                    }
                    return;
                });
                for (var key in valid_1) {
                    if (!valid_1.hasOwnProperty(key)) {
                        continue;
                    }
                    var val = valid_1[key];
                    if (!valid_1[key]) {
                        delete out[key];
                    }
                }
            }
            else {
                for (var _a = 0, keys_3 = keys$$1; _a < keys_3.length; _a++) {
                    var key = keys_3[_a];
                    if (!data[key]) {
                        continue;
                    }
                    if (key === 'color') {
                        out[key] = data[key].map(function (c) { return _$1.isString(c) ? HEXtoCOLORREF(c) : c; });
                    }
                    else {
                        out[key] = data[key];
                    }
                }
            }
            return out;
        }
        TemplateUtils.extractData = extractData;
        // Zips up an array of arrays into a single array. Elements that share an index
        // go together. Borrowed from underscore
        function zipData(array) {
            if (array == null) {
                return [];
            }
            var length = 0;
            array.forEach(function (arr) {
                if (arr.length > length) {
                    length = arr.length;
                }
            });
            var results = Array(length);
            while (length-- > 0) {
                results[length] = array.map(function (val) { return val[length]; });
            }
            return results;
        }
        TemplateUtils.zipData = zipData;
        function getDisableLoggingFromOpts(opts) {
            if (opts.disableLogging == null || typeof (opts.disableLogging) !== 'boolean') {
                return false;
            }
            else {
                return opts.disableLogging;
            }
        }
        TemplateUtils.getDisableLoggingFromOpts = getDisableLoggingFromOpts;
        function getThemeFromOpts(opts) {
            if (opts.theme == null) {
                return 1 /* QUARTZ */;
            }
            else {
                switch (opts.theme.toLowerCase()) {
                    case 'none':
                        return 0 /* NONE */;
                    case 'carbon':
                        return 2 /* CARBON */;
                    default:
                        return 1 /* QUARTZ */;
                }
            }
        }
        TemplateUtils.getThemeFromOpts = getThemeFromOpts;
        function getWidthFromOpts(opts) {
            // The following regex matches 0 or 1 instances of 1 or more digits followed by 0 or 1 instances of 'px'
            // It is valid to have no width, or a width of one of the following formats: #, #px
            // Width might be specified using CSS, which is why it is acceptable to have empty width.
            var widthReg = /^((\d+)(px)?)?$/;
            if (opts.width != null) {
                if (widthReg.test(opts.width)) {
                    return opts.width.match(widthReg)[2];
                }
                else {
                    throw new Error("TemplateUtils.getWidthFromOpts(): unexpected width = " + opts.width);
                }
            }
            return opts.width;
        }
        TemplateUtils.getWidthFromOpts = getWidthFromOpts;
        function getHeightFromOpts(opts) {
            // The following regex matches 0 or 1 instances of 1 or more digits followed by 0 or 1 instances of 'px'
            // It is valid to have no height, or a height of one of the following formats: #, #px
            // Height might be specified using CSS, which is why it is acceptable to have empty height.
            var heightReg = /^((\d+)(px)?)?$/;
            if (opts.height != null) {
                if (heightReg.test(opts.height)) {
                    return opts.height.match(heightReg)[2];
                }
                else {
                    throw new Error("TemplateUtils.getHeightFromOpts(): unexpected height = " + opts.height);
                }
            }
            return opts.height;
        }
        TemplateUtils.getHeightFromOpts = getHeightFromOpts;
        function createData(arr, dataType) {
            var dataset;
            if (arr != null) {
                dataset = new models.data({
                    dataType: dataType,
                    data: arr
                });
            }
            return dataset;
        }
        TemplateUtils.createData = createData;
        function getDataTypes(entry, opts) {
            var dt = entry.dataType;
            var xDataType = opts.dataType && opts.dataType.X;
            var yDataType = opts.dataType && opts.dataType.Y;
            if (dt != null) {
                if (dt.X != null) {
                    xDataType = dt.X;
                }
                if (dt.Y != null) {
                    yDataType = dt.Y;
                }
            }
            return { xDataType: xDataType, yDataType: yDataType };
        }
        TemplateUtils.getDataTypes = getDataTypes;
        function getDataFrequencies(entry, opts) {
            var df = entry.frequency;
            var xDataFrequency = opts.frequency && opts.frequency.X;
            var yDataFrequency = opts.frequency && opts.frequency.Y;
            if (df != null) {
                if (df.X != null) {
                    xDataFrequency = df.X;
                }
                if (df.Y != null) {
                    yDataFrequency = df.Y;
                }
            }
            return { xDataFrequency: xDataFrequency, yDataFrequency: yDataFrequency };
        }
        TemplateUtils.getDataFrequencies = getDataFrequencies;
        function getTreatAsIndex(entry) {
            var xTreatAsIndex;
            var yTreatAsIndex;
            if (entry.treatAsIndex) {
                xTreatAsIndex = entry.treatAsIndex.X;
                yTreatAsIndex = entry.treatAsIndex.Y;
            }
            return { xTreatAsIndex: xTreatAsIndex, yTreatAsIndex: yTreatAsIndex };
        }
        TemplateUtils.getTreatAsIndex = getTreatAsIndex;
        function addChartObjects(seriesInfoList, opts, setAttributes) {
            var plot = opts.plot, container = opts.container;
            console.assert(!(plot != null && container != null), 'Found both plot and container in the options. Only one should be specified!');
            if (plot != null) {
                // If we were passed a plot, just add this series we created to it
                for (var _i = 0, seriesInfoList_1 = seriesInfoList; _i < seriesInfoList_1.length; _i++) {
                    var _a = seriesInfoList_1[_i], series = _a.series, seriesOptions = _a.seriesOptions;
                    plot.addSeries(series);
                    setAttributes(series, seriesOptions);
                }
                plot.chart.invalidate();
                return plot.chart;
            }
            else {
                // otherwise we must create a chart
                var chart = new FDSChartJS(container, {
                    appName: opts.appName,
                    disableLogging: TemplateUtils.getDisableLoggingFromOpts(opts),
                    commonDebug: opts.commonDebug,
                    theme: getThemeFromOpts(opts),
                    width: getWidthFromOpts(opts),
                    height: getHeightFromOpts(opts)
                });
                var newPlot = new models.plot({
                    label: opts.plotLabel
                });
                chart.addPlot(newPlot);
                for (var _b = 0, seriesInfoList_2 = seriesInfoList; _b < seriesInfoList_2.length; _b++) {
                    var _c = seriesInfoList_2[_b], series = _c.series, seriesOptions = _c.seriesOptions;
                    newPlot.addSeries(series);
                    setAttributes(series, seriesOptions);
                }
                for (var axisDim in opts.axisTitles) {
                    var title = opts.axisTitles[axisDim];
                    newPlot.setAttribute(axisDim + "Title", 'app', true);
                    newPlot.setAttribute(axisDim + "TitleText", 'app', title);
                }
                chart.invalidate();
                return chart;
            }
        }
        TemplateUtils.addChartObjects = addChartObjects;
    })(TemplateUtils || (TemplateUtils = {}));
    
    var BaseBarTemplate = function (drawStyle, options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('TooltipLabelMask', 'app', 0);
            series.setAttribute('TooltipSublabelMask', 'app', 0);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */);
            if (opts.stacked) {
                series.setAttribute('IsStacked', 'app', true);
            }
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        if (drawStyle === 12 /* BARS */) {
            if (options.is3D) {
                drawStyle = 11 /* BARS3D */;
            }
        }
        if (drawStyle === 6 /* COLUMNS */) {
            if (options.is3D) {
                drawStyle = 5 /* COLUMNS3D */;
            }
        }
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'y', 'color', 'value']), x = _b.x, y = _b.y, color = _b.color, value = _b.value;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            var xdata = new models.data({
                dataType: xDataType,
                data: x,
                frequency: xDataFrequency,
                treatAsIndex: xTreatAsIndex
            });
            var ydata = new models.data({
                dataType: yDataType,
                data: y,
                frequency: yDataFrequency,
                treatAsIndex: yTreatAsIndex
            });
            var cdata = TemplateUtils.createData(color, 'int');
            var vdata = TemplateUtils.createData(value, 'string');
            var series = new models.series({
                id: entry.id,
                x: xdata,
                y: ydata,
                color: cdata,
                value: vdata,
                drawStyle: drawStyle,
                label: entry.label,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    stacked: entry.stacked,
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    var BarTemplate = BaseBarTemplate.bind(null, 12 /* BARS */);
    var ColumnTemplate = BaseBarTemplate.bind(null, 6 /* COLUMNS */);
    
    var BoxAndWhiskerTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('SeriesFGWidth', 'app', 2);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */);
            if (opts.wickStyle) {
                series.setAttribute('WickStyle', 'app', opts.wickStyle);
            }
            else {
                series.setAttribute('WickStyle', 'app', 1 /* T */);
            }
            if (opts.calculatePercentiles) {
                series.setAttribute('SeriesValueLabelMask', 'app', 5);
                series.setAttribute('TooltipText', 'app', '<FDSDataLabel>');
                var yData50 = series.getData().y;
                yData50.setId(series.id + "::Percentile50");
                yData50.setAttribute('Label', 'app', '50th Percentile');
                var yDataMin = yData50.getChildDataByIndex(0);
                yDataMin.setId(series.id + "::Minimum");
                yDataMin.setAttribute('Label', 'app', 'Minimum');
                var yData25 = yData50.getChildDataByIndex(1);
                yData25.setId(series.id + "::Percentile25");
                yData25.setAttribute('Label', 'app', '25th Percentile');
                var yData75 = yData50.getChildDataByIndex(2);
                yData75.setId(series.id + "::Percentile75");
                yData75.setAttribute('Label', 'app', '75th Percentile');
                var yData100 = yData50.getChildDataByIndex(3);
                yData100.setId(series.id + "::Maximum");
                yData100.setAttribute('Label', 'app', 'Maximum');
            }
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'y', 'color', 'value']), x = _b.x, y = _b.y, color = _b.color, value = _b.value;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            var yData = void 0;
            var yDataChildren = void 0;
            if (entry.calculatePercentiles || (entry.calculatePercentiles === undefined)) {
                var boxAndWhiskerData = getBoxAndWhiskerPercentiles(y);
                yData = boxAndWhiskerData.percentile50;
                yDataChildren = [
                    boxAndWhiskerData.minimum,
                    boxAndWhiskerData.percentile25,
                    boxAndWhiskerData.percentile75,
                    boxAndWhiskerData.maximum
                ];
            }
            else {
                yDataChildren = TemplateUtils.zipData(y);
                yData = yDataChildren.shift();
            }
            var xdata = new models.data({
                dataType: xDataType,
                data: x,
                frequency: xDataFrequency,
                treatAsIndex: xTreatAsIndex
            });
            var ydata = new models.data({
                dataType: yDataType,
                data: yData,
                frequency: yDataFrequency,
                treatAsIndex: yTreatAsIndex,
                children: yDataChildren
            });
            var cdata = TemplateUtils.createData(color, 'int');
            var vdata = TemplateUtils.createData(value, 'string');
            var series = new models.series({
                id: entry.id,
                x: xdata,
                y: ydata,
                color: cdata,
                value: vdata,
                drawStyle: 61 /* RANGECANDLE */,
                label: entry.label,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText,
                    calculatePercentiles: entry.calculatePercentiles,
                    wickStyle: entry.wickStyle
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    var getBoxAndWhiskerPercentiles = function (dataArrays) {
        var minimum = [];
        var percentile25 = [];
        var percentile50 = [];
        var percentile75 = [];
        var maximum = [];
        for (var _i = 0, dataArrays_1 = dataArrays; _i < dataArrays_1.length; _i++) {
            var data = dataArrays_1[_i];
            minimum.push(_$1.min(data));
            percentile25.push(percentile(data, 0.25));
            percentile50.push(percentile(data, 0.5));
            percentile75.push(percentile(data, 0.75));
            maximum.push(_$1.max(data));
        }
        function percentile(array, percent) {
            if (array.length === 0) {
                return 0;
            }
            if (percent <= 0) {
                return array[0];
            }
            if (percent >= 1) {
                return array[array.length - 1];
            }
            array = _$1.sortBy(array);
            var index = ((array.length - 1) * percent);
            var weight = index % 1;
            if (weight === 0) {
                return array[index];
            }
            else {
                var lower = Math.floor(index);
                var upper = Math.ceil(index);
                return (array[lower] * (1 - weight)) + (array[upper] * weight);
            }
        }
        return { minimum: minimum, percentile25: percentile25, percentile50: percentile50, percentile75: percentile75, maximum: maximum };
    };
    
    var BubbleTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('SeriesFGWidth', 'app', 2);
            series.setAttribute('SeriesBGAlpha', 'app', 90);
            series.setAttribute('TooltipLabelMask', 'app', 0);
            series.setAttribute('TooltipSublabelMask', 'app', 0);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */ | 32 /* SIZE */);
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'y', 'size', 'color', 'value']), x = _b.x, y = _b.y, size = _b.size, color = _b.color, value = _b.value;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            var xdata = new models.data({
                dataType: xDataType,
                data: x,
                frequency: xDataFrequency,
                treatAsIndex: xTreatAsIndex
            });
            var ydata = new models.data({
                dataType: yDataType,
                data: y,
                frequency: yDataFrequency,
                treatAsIndex: yTreatAsIndex
            });
            var cdata = TemplateUtils.createData(color, 'int');
            var vdata = TemplateUtils.createData(value, 'string');
            var sdata = TemplateUtils.createData(size, 'float');
            var series = new models.series({
                id: entry.id,
                label: entry.label,
                x: xdata,
                y: ydata,
                color: cdata,
                value: vdata,
                size: sdata,
                drawStyle: 31 /* BUBBLE */,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    
    var LineTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('SeriesFGWidth', 'app', 2);
            series.setAttribute('SeriesBGAlpha', 'app', 90);
            series.setAttribute('TooltipLabelMask', 'app', 0);
            series.setAttribute('TooltipSublabelMask', 'app', 0);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */);
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'y', 'color', 'value']), x = _b.x, y = _b.y, color = _b.color, value = _b.value;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            var xdata = new models.data({
                dataType: xDataType,
                data: x,
                frequency: xDataFrequency,
                treatAsIndex: xTreatAsIndex
            });
            var ydata = new models.data({
                dataType: yDataType,
                data: y,
                frequency: yDataFrequency,
                treatAsIndex: yTreatAsIndex
            });
            var cdata = TemplateUtils.createData(color, 'int');
            var vdata = TemplateUtils.createData(value, 'string');
            var drawStyle = 0;
            if (typeof entry.lineType === 'string' && entry.lineType != null) {
                var lt$$1 = entry.lineType.toLowerCase();
                if (lt$$1 === 'step') {
                    drawStyle = 14 /* STEP */;
                }
                else if (lt$$1 === 'area') {
                    drawStyle = 9 /* AREA */;
                }
                else if (lt$$1 === 'areastep') {
                    drawStyle = 18 /* AREASTEP */;
                }
            }
            var series = new models.series({
                id: entry.id,
                x: xdata,
                y: ydata,
                color: cdata,
                value: vdata,
                drawStyle: drawStyle,
                label: entry.label,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    
    var OHLCTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('SeriesFGWidth', 'app', 2);
            series.setAttribute('TooltipLabelMask', 'app', 1);
            series.setAttribute('TooltipSublabelMask', 'app', 1);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */);
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'o', 'h', 'l', 'c', 'color']), x = _b.x, o = _b.o, h = _b.h, l = _b.l, c = _b.c, color = _b.color;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            var xdata = new models.data({
                dataType: xDataType,
                data: x,
                frequency: xDataFrequency,
                treatAsIndex: xTreatAsIndex
            });
            var closeData = new models.data({
                dataType: yDataType,
                data: c,
                frequency: yDataFrequency,
                treatAsIndex: yTreatAsIndex,
                children: [h, l, o]
            });
            var colorData = TemplateUtils.createData(color, 'string');
            var drawStyle = 22;
            if (entry.ohlcType != null) {
                var map$$1 = {
                    hlc: 2 /* HLC */,
                    hlcross: 37 /* HLCROSS */,
                    candle: 23 /* CANDLE */,
                    ohlc: 22 /* OHLC */,
                };
                var olhcDS = map$$1[entry.ohlcType.toLowerCase()];
                if (olhcDS != null) {
                    drawStyle = olhcDS;
                }
            }
            var series = new models.series({
                id: entry.id,
                x: xdata,
                y: closeData,
                label: entry.label,
                color: colorData,
                drawStyle: drawStyle,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    
    var PieTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.seriesFGPen.setHexColor('#FFFFFF');
            series.plot.plotFGPen.setStyle(5 /* NULL */);
            series.plot.setAttributes({
                DrawStyle: 19 /* PIE */,
                LegendAxisPosition: 3 /* MIDDLE */,
                LegendBasePosition: 1 /* RIGHT */,
                LegendPosition: 1 /* RIGHT */,
                LegendVPosition: 2 /* CENTER */,
                LegendSublabelMask: 0,
            });
            var dataMask = opts.whichDataMask == null ? 1 /* VALUE */ | 2 /* X */ : opts.whichDataMask;
            var seriesAttributes = {
                SeriesValueDataMask: dataMask,
                TooltipLabelMask: 0,
                TooltipSublabelMask: 0,
                TooltipShowLabel: false,
            };
            if (opts.useColorDataset) {
                seriesAttributes.CycleColorIndex = false;
            }
            if (opts.donut) {
                seriesAttributes.PieDonutRadius = 0.5;
            }
            if (opts.seriesValue != null) {
                seriesAttributes.SeriesValue = opts.seriesValue;
                if (opts.seriesValue) {
                    seriesAttributes.SeriesValueSublabelMask = 0;
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    seriesAttributes.SeriesValue = true;
                }
                seriesAttributes.SeriesValueText = opts.seriesValueText;
            }
            series.setAttributes(seriesAttributes);
        };
        var _a = TemplateUtils.extractData(options.data, ['x', 'y', 'color', 'value']), x = _a.x, y = _a.y, color = _a.color, value = _a.value;
        var xdata = new models.data({
            dataType: 'string',
            data: x
        });
        var ydata = new models.data({
            dataType: 'float',
            data: y
        });
        var drawStyle = 19;
        if (options.is3D) {
            drawStyle = 36 /* PIE3D */;
        }
        var cdata = TemplateUtils.createData(color, 'int');
        var vdata = TemplateUtils.createData(value, 'string');
        // If we add a color dataset, we need to turn CycleColorIndex off in order to use the color data
        options.useColorDataset = (cdata != null);
        options.whichDataMask = (vdata != null) ? 1 /* VALUE */ : (2 /* X */ | 4 /* Y */);
        var series = new models.series({
            id: options.id,
            x: xdata,
            y: ydata,
            color: cdata,
            value: vdata,
            drawStyle: drawStyle
        });
        // We treat the pie differently because more than likely you will not
        // want more than one pie on the same chart.
        var chart = new FDSChartJS(options.container, {
            appName: options.appName,
            disableLogging: TemplateUtils.getDisableLoggingFromOpts(options),
            theme: TemplateUtils.getThemeFromOpts(options),
            width: TemplateUtils.getWidthFromOpts(options),
            height: TemplateUtils.getHeightFromOpts(options)
        });
        var plot = new models.plot({
            label: options.plotLabel
        });
        chart.addPlot(plot);
        plot.addSeries(series);
        setAttributes(series, options);
        chart.draw();
        return chart;
    };
    
    var RangeBarTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('TooltipLabelMask', 'app', 1);
            series.setAttribute('TooltipSublabelMask', 'app', 1);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */);
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'y', 'color', 'value']), x = _b.x, y = _b.y, color = _b.color, value = _b.value;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            var xdata = getFDSDataWrapper(x, xDataType, xDataFrequency, xTreatAsIndex);
            var ydata = getFDSDataWrapper(y, yDataType, yDataFrequency, yTreatAsIndex);
            var cdata = TemplateUtils.createData(color, 'int');
            var vdata = TemplateUtils.createData(value, 'string');
            var series = new models.series({
                id: entry.id,
                x: xdata,
                y: ydata,
                color: cdata,
                value: vdata,
                drawStyle: 4 /* RANGEBAR */,
                label: entry.label,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    function getFDSDataWrapper(data, dataType, dataFrequency, treatAsIndex) {
        if (data.length > 0 && Array.isArray(data[0])) {
            // Values are an array of arrays, we need to rotate this
            var dataArrays = TemplateUtils.zipData(data);
            var firstDatum = dataArrays.shift();
            return new models.data({
                dataType: dataType,
                data: firstDatum,
                frequency: dataFrequency,
                treatAsIndex: treatAsIndex,
                children: dataArrays
            });
        }
        else {
            return new models.data({
                dataType: dataType,
                data: data,
                frequency: dataFrequency,
                treatAsIndex: treatAsIndex
            });
        }
    }
    
    var RangeCandleTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttribute('SeriesFGWidth', 'app', 2);
            series.setAttribute('TooltipLabelMask', 'app', 1);
            series.setAttribute('TooltipSublabelMask', 'app', 1);
            series.setAttribute('TooltipDataMask', 'app', 1 /* VALUE */ | 2 /* X */ | 4 /* Y */);
            if (opts.wickStyle) {
                series.setAttribute('WickStyle', 'app', opts.wickStyle);
            }
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var seriesInfoList = [];
        for (var _i = 0, _a = options.datasets; _i < _a.length; _i++) {
            var entry = _a[_i];
            var _b = TemplateUtils.extractData(entry.data, ['x', 'y', 'color', 'value']), x = _b.x, y = _b.y, color = _b.color, value = _b.value;
            var _c = TemplateUtils.getDataTypes(entry, options), xDataType = _c.xDataType, yDataType = _c.yDataType;
            var _d = TemplateUtils.getDataFrequencies(entry, options), xDataFrequency = _d.xDataFrequency, yDataFrequency = _d.yDataFrequency;
            var _e = TemplateUtils.getTreatAsIndex(entry), xTreatAsIndex = _e.xTreatAsIndex, yTreatAsIndex = _e.yTreatAsIndex;
            // Y values are an array of arrays, we need to rotate this
            var yDataArrays = TemplateUtils.zipData(y);
            var firstY = yDataArrays.shift();
            var xdata = new models.data({
                dataType: xDataType,
                data: x,
                frequency: xDataFrequency,
                treatAsIndex: xTreatAsIndex
            });
            var ydata = new models.data({
                dataType: yDataType,
                data: firstY,
                frequency: yDataFrequency,
                treatAsIndex: yTreatAsIndex,
                children: yDataArrays
            });
            var cdata = TemplateUtils.createData(color, 'int');
            var vdata = TemplateUtils.createData(value, 'string');
            var series = new models.series({
                id: entry.id,
                x: xdata,
                y: ydata,
                color: cdata,
                value: vdata,
                drawStyle: 61 /* RANGECANDLE */,
                label: entry.label,
                onYAxis: entry.onYAxis,
                onXAxis: entry.onXAxis
            });
            seriesInfoList.push({
                series: series,
                seriesOptions: {
                    markers: entry.markers,
                    seriesValue: entry.seriesValue,
                    seriesValueText: entry.seriesValueText,
                    wickStyle: entry.wickStyle
                }
            });
        }
        return TemplateUtils.addChartObjects(seriesInfoList, options, setAttributes);
    };
    
    var HistogramTemplate = function (options) {
        var setAttributes = function (series, opts) {
            series.setAttributes({
                TooltipLabelMask: 0,
                TooltipSublabelMask: 0,
                TooltipDataMask: 1 /* VALUE */ | 2 /* X */ | 4 /* Y */
            });
            if (opts.markers) {
                series.setAttribute('SeriesMarker', 'app', true);
            }
            if (opts.seriesValue != null) {
                series.setAttribute('SeriesValue', 'app', opts.seriesValue);
                if (opts.seriesValue) {
                    series.setAttribute('SeriesValueSublabelMask', 'app', 0);
                }
            }
            if (opts.seriesValueText != null) {
                if (opts.seriesValue == null) {
                    series.setAttribute('SeriesValue', 'app', true);
                }
                series.setAttribute('SeriesValueText', 'app', opts.seriesValueText);
            }
        };
        var chart = new FDSChartJS(options.container, {
            appName: options.appName,
            disableLogging: TemplateUtils.getDisableLoggingFromOpts(options),
            theme: TemplateUtils.getThemeFromOpts(options),
            width: TemplateUtils.getWidthFromOpts(options),
            height: TemplateUtils.getHeightFromOpts(options)
        });
        var plot = new models.plot({
            label: options.plotLabel
        });
        chart.addPlot(plot);
        var x = options.data;
        var series = plot.addHistogramSeries(options.seriesId, x, options.histogramOptions);
        setAttributes(series, options);
        var yAxis = series.getAxis(2 /* Y */);
        yAxis.setAttribute('ThreshMin', 'app', 0);
        if (options.histogramOptions && options.histogramOptions.countAsPercents) {
            yAxis.setAttribute('LabelPostfix', 'app', '%');
        }
        chart.draw();
        return chart;
    };
    
    function getBinAttributes(numberOfSeries, direction) {
        var specSpaceBetweenSeries = 2;
        var specBarWidth = 20;
        var totalSpaceBetweenBars = Math.max(0, numberOfSeries - 1) * specSpaceBetweenSeries;
        var idealBinFactor = totalSpaceBetweenBars + numberOfSeries * specBarWidth;
        var binPrefix = direction === 'horizontal' ? 'Y' : 'X';
        var valuePrefix = direction === 'horizontal' ? 'X' : 'Y';
        return _a = {},
            _a[binPrefix + "BinFactor"] = idealBinFactor,
            _a[binPrefix + "InnerBinPadding"] = specSpaceBetweenSeries,
            _a[valuePrefix + "Reference"] = 0,
            _a[valuePrefix + "ThreshConsider"] = true,
            _a[valuePrefix + "ThreshConsiderValue"] = 0,
            _a[valuePrefix + "TickMode"] = 0 /* FLOATING */,
            _a;
        var _a;
    }
    function getMaxValueSize(objects) {
        if (_.isUndefined(objects)) {
            return 0;
        }
        return _.max(_.map(objects, function (obj) { return _.size(obj.values); }));
    }
    var BarInfographicTemplate = function (options) {
        if (_.isUndefined(options.direction)) {
            options.direction = 'horizontal';
        }
        if (options.direction !== 'horizontal' && options.direction !== 'vertical') {
            throw new Error("direction must be 'horizontal' or 'vertical'");
        }
        if (_.isUndefined(options.data)) {
            throw new Error("The 'data' parameter was undefined");
        }
        var barDrawStyle = options.direction === 'vertical' ? 6 /* COLUMNS */ : 12;
        var _a = options.data, series = _a.series, indicators = _a.indicators;
        var indicatorInfo = _.get(options, ['data', 'indicators']);
        var maxSeriesSize = getMaxValueSize(series);
        var maxIndicatorSize = getMaxValueSize(indicators);
        var theme = TemplateUtils.getThemeFromOpts(options);
        var needsStyleAttributes = _.contains([1 /* QUARTZ */, 2 /* CARBON */, 0 /* NONE */], theme);
        var chart = new FDSChartJS(options.container, {
            appName: options.appName,
            disableLogging: TemplateUtils.getDisableLoggingFromOpts(options),
            commonDebug: options.commonDebug,
            theme: theme,
            width: TemplateUtils.getWidthFromOpts(options),
            height: TemplateUtils.getHeightFromOpts(options)
        });
        var newPlot = new models.plot({
            label: options.plotLabel
        });
        chart.addPlot(newPlot);
        newPlot.setAttributes({
            PlotFGStyle: 5,
            Heading1: false,
            Heading2: false,
            Legend: false,
            YBin: options.direction === 'horizontal',
            YLabel: false,
            YTicks: false,
            YAxis: false,
            YGrid: false,
            YReference: 0,
            XBin: options.direction === 'vertical',
            XLabel: false,
            XTicks: false,
            XAxis: false,
            XGrid: false,
            XReference: 0,
        });
        newPlot.setAttributes(getBinAttributes(series.length, options.direction));
        var binData = new models.data({
            id: 'BinData',
            label: '',
            dataType: 'string',
            data: _.times(Math.max(maxSeriesSize, maxIndicatorSize)),
            treatAsIndex: true,
        });
        if (options.axisTitles) {
            for (var axisDim in options.axisTitles) {
                var title = options.axisTitles[axisDim];
                newPlot.setAttribute(axisDim + "Title", 'app', true);
                newPlot.setAttribute(axisDim + "TitleText", 'app', title);
            }
        }
        for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
            var seriesInfo = series_1[_i];
            var id = (seriesInfo.id || seriesInfo.label);
            var label = seriesInfo.label || '';
            var valueData = new models.data({
                id: !_.isUndefined(id) ? (id + 'Data') : undefined,
                dataType: 'float',
                label: label,
                data: seriesInfo.values
            });
            var barSeries = new models.series({
                id: id,
                x: options.direction === 'vertical' ? binData : valueData,
                y: options.direction === 'vertical' ? valueData : binData,
                drawStyle: barDrawStyle,
                label: label,
            });
            newPlot.addSeries(barSeries);
            barSeries.setAttributes({
                TooltipShowLabel: false,
                TooltipLabelMask: 0,
            });
            if (_.isNumber(seriesInfo.color)) {
                barSeries.setAttributes({
                    SeriesBGColor: seriesInfo.color
                });
            }
            if (needsStyleAttributes) {
                barSeries.setAttributes({
                    SeriesOutlineStyle: 5 /* NULL */,
                });
            }
        }
        if (indicators) {
            for (var i = 0; i < indicators.length; i++) {
                var indicator = indicators[i];
                var id = indicator.id || indicator.label;
                var label = indicator.label || '';
                var indicatorData = new models.data({
                    id: !_.isUndefined(id) ? (id + 'Data') : undefined,
                    dataType: 'float',
                    label: label,
                    data: indicator.values,
                });
                var indicatorSeries = new models.series({
                    id: id,
                    x: options.direction === 'vertical' ? binData : indicatorData,
                    y: options.direction === 'vertical' ? indicatorData : binData,
                    drawStyle: 63 /* BARINDICATOR */,
                    label: label,
                });
                newPlot.addSeries(indicatorSeries);
                indicatorSeries.setAttributes({
                    TooltipShowLabel: false,
                    TooltipLabelMask: 0,
                    SeriesNumber: _.get(indicator, ['seriesNumber'], i),
                });
                if (_.isNumber(indicator.color)) {
                    indicatorSeries.setAttributes({
                        SeriesOutlineColor: indicator.color
                    });
                }
                if (needsStyleAttributes) {
                    indicatorSeries.setAttributes({
                        SeriesOutlineWidth: 1,
                        SeriesMarkerSize: 9,
                    });
                }
            }
        }
        // Hide the tooltips on the generated bin dataset
        if (binData.attached) {
            binData.setAttributes({ InTips: false });
        }
        chart.invalidate();
        return chart;
    };
    
    var templates = {
        line: LineTemplate,
        ohlc: OHLCTemplate,
        pie: PieTemplate,
        bar: BarTemplate,
        column: ColumnTemplate,
        bubble: BubbleTemplate,
        rangebar: RangeBarTemplate,
        rangecandle: RangeCandleTemplate,
        boxandwhisker: BoxAndWhiskerTemplate,
        histogram: HistogramTemplate,
        barinfographic: BarInfographicTemplate,
    };
    var templateUtilities = {
        calcBoxAndWhisker: getBoxAndWhiskerPercentiles
    };
    
    var API = FDSChartJS;
    Object.defineProperty(API, 'inhouse', {
        get: function () { return Inhouse.isEnabled; },
        set: function (newValue) { Inhouse.isEnabled = newValue; },
    });
    Object.defineProperty(API, 'interactionLogs', {
        get: function () { return Inhouse.interactionLogs; }
    });
    API.version = new Version();
    API.models = models;
    API.templates = templates;
    API.templateUtilities = templateUtilities;
    API.enableUsageLogging = LoggingStatus.enableUsageLogging;
    API.disableUsageLogging = LoggingStatus.disableUsageLogging;
    API.isUsageLoggingEnabled = LoggingStatus.isUsageLoggingEnabled;
    API.defaultStyleSets = new DefaultStyleSets();
    API.prefetchStyleSetFromPathAsync = StyleSetCache.getStyleSetAsync;
    
    return API;
    
    }(_,jQuery));
    //# sourceMappingURL=FDSChartJS.js.map
    